# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'LifecyclePolicyPolicyDetails',
    'LifecyclePolicyPolicyDetailsAction',
    'LifecyclePolicyPolicyDetailsActionCrossRegionCopy',
    'LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration',
    'LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule',
    'LifecyclePolicyPolicyDetailsEventSource',
    'LifecyclePolicyPolicyDetailsEventSourceParameters',
    'LifecyclePolicyPolicyDetailsParameters',
    'LifecyclePolicyPolicyDetailsSchedule',
    'LifecyclePolicyPolicyDetailsScheduleCreateRule',
    'LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule',
    'LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule',
    'LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule',
    'LifecyclePolicyPolicyDetailsScheduleDeprecateRule',
    'LifecyclePolicyPolicyDetailsScheduleFastRestoreRule',
    'LifecyclePolicyPolicyDetailsScheduleRetainRule',
    'LifecyclePolicyPolicyDetailsScheduleShareRule',
]

@pulumi.output_type
class LifecyclePolicyPolicyDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSource":
            suggest = "event_source"
        elif key == "policyType":
            suggest = "policy_type"
        elif key == "resourceLocations":
            suggest = "resource_locations"
        elif key == "resourceTypes":
            suggest = "resource_types"
        elif key == "targetTags":
            suggest = "target_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional['outputs.LifecyclePolicyPolicyDetailsAction'] = None,
                 event_source: Optional['outputs.LifecyclePolicyPolicyDetailsEventSource'] = None,
                 parameters: Optional['outputs.LifecyclePolicyPolicyDetailsParameters'] = None,
                 policy_type: Optional[builtins.str] = None,
                 resource_locations: Optional[builtins.str] = None,
                 resource_types: Optional[Sequence[builtins.str]] = None,
                 schedules: Optional[Sequence['outputs.LifecyclePolicyPolicyDetailsSchedule']] = None,
                 target_tags: Optional[Mapping[str, builtins.str]] = None):
        """
        :param 'LifecyclePolicyPolicyDetailsActionArgs' action: The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `action` configuration block.
        :param 'LifecyclePolicyPolicyDetailsEventSourceArgs' event_source: The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `event_source` configuration block.
        :param builtins.str policy_type: The valid target resource types and actions a policy can manage. Specify `EBS_SNAPSHOT_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify `IMAGE_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify `EVENT_BASED_POLICY` to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is `EBS_SNAPSHOT_MANAGEMENT`.
        :param builtins.str resource_locations: The location of the resources to backup. If the source resources are located in an AWS Region, specify `CLOUD`. If the source resources are located on an Outpost in your account, specify `OUTPOST`. If you specify `OUTPOST`, Amazon Data Lifecycle Manager backs up all resources of the specified type with matching target tags across all of the Outposts in your account. Valid values are `CLOUD` and `OUTPOST`.
        :param Sequence[builtins.str] resource_types: A list of resource types that should be targeted by the lifecycle policy. Valid values are `VOLUME` and `INSTANCE`.
        :param Sequence['LifecyclePolicyPolicyDetailsScheduleArgs'] schedules: See the `schedule` configuration block.
        :param Mapping[str, builtins.str] target_tags: A map of tag keys and their values. Any resources that match the `resource_types` and are tagged with _any_ of these tags will be targeted.
               
               > Note: You cannot have overlapping lifecycle policies that share the same `target_tags`. Pulumi is unable to detect this at plan time but it will fail during apply.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)
        if resource_locations is not None:
            pulumi.set(__self__, "resource_locations", resource_locations)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if target_tags is not None:
            pulumi.set(__self__, "target_tags", target_tags)

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsAction']:
        """
        The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `action` configuration block.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsEventSource']:
        """
        The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the `event_source` configuration block.
        """
        return pulumi.get(self, "event_source")

    @property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsParameters']:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[builtins.str]:
        """
        The valid target resource types and actions a policy can manage. Specify `EBS_SNAPSHOT_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify `IMAGE_MANAGEMENT` to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify `EVENT_BASED_POLICY` to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is `EBS_SNAPSHOT_MANAGEMENT`.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="resourceLocations")
    def resource_locations(self) -> Optional[builtins.str]:
        """
        The location of the resources to backup. If the source resources are located in an AWS Region, specify `CLOUD`. If the source resources are located on an Outpost in your account, specify `OUTPOST`. If you specify `OUTPOST`, Amazon Data Lifecycle Manager backs up all resources of the specified type with matching target tags across all of the Outposts in your account. Valid values are `CLOUD` and `OUTPOST`.
        """
        return pulumi.get(self, "resource_locations")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of resource types that should be targeted by the lifecycle policy. Valid values are `VOLUME` and `INSTANCE`.
        """
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter
    def schedules(self) -> Optional[Sequence['outputs.LifecyclePolicyPolicyDetailsSchedule']]:
        """
        See the `schedule` configuration block.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="targetTags")
    def target_tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of tag keys and their values. Any resources that match the `resource_types` and are tagged with _any_ of these tags will be targeted.

        > Note: You cannot have overlapping lifecycle policies that share the same `target_tags`. Pulumi is unable to detect this at plan time but it will fail during apply.
        """
        return pulumi.get(self, "target_tags")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossRegionCopies":
            suggest = "cross_region_copies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_region_copies: Sequence['outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopy'],
                 name: builtins.str):
        """
        :param Sequence['LifecyclePolicyPolicyDetailsActionCrossRegionCopyArgs'] cross_region_copies: The rule for copying shared snapshots across Regions. See the `cross_region_copy` configuration block.
        """
        pulumi.set(__self__, "cross_region_copies", cross_region_copies)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="crossRegionCopies")
    def cross_region_copies(self) -> Sequence['outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopy']:
        """
        The rule for copying shared snapshots across Regions. See the `cross_region_copy` configuration block.
        """
        return pulumi.get(self, "cross_region_copies")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsActionCrossRegionCopy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionConfiguration":
            suggest = "encryption_configuration"
        elif key == "retainRule":
            suggest = "retain_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsActionCrossRegionCopy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_configuration: 'outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration',
                 target: builtins.str,
                 retain_rule: Optional['outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule'] = None):
        """
        :param 'LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfigurationArgs' encryption_configuration: The encryption settings for the copied snapshot. See the `encryption_configuration` block. Max of 1 per action.
        """
        pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        pulumi.set(__self__, "target", target)
        if retain_rule is not None:
            pulumi.set(__self__, "retain_rule", retain_rule)

    @property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> 'outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration':
        """
        The encryption settings for the copied snapshot. See the `encryption_configuration` block. Max of 1 per action.
        """
        return pulumi.get(self, "encryption_configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="retainRule")
    def retain_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule']:
        return pulumi.get(self, "retain_rule")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cmkArn":
            suggest = "cmk_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopyEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cmk_arn: Optional[builtins.str] = None,
                 encrypted: Optional[builtins.bool] = None):
        if cmk_arn is not None:
            pulumi.set(__self__, "cmk_arn", cmk_arn)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)

    @property
    @pulumi.getter(name="cmkArn")
    def cmk_arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cmk_arn")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "encrypted")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsActionCrossRegionCopyRetainRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: builtins.int,
                 interval_unit: builtins.str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> builtins.str:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsEventSource(dict):
    def __init__(__self__, *,
                 parameters: 'outputs.LifecyclePolicyPolicyDetailsEventSourceParameters',
                 type: builtins.str):
        """
        :param builtins.str type: The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are `MANAGED_CWE`.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.LifecyclePolicyPolicyDetailsEventSourceParameters':
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are `MANAGED_CWE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsEventSourceParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "descriptionRegex":
            suggest = "description_regex"
        elif key == "eventType":
            suggest = "event_type"
        elif key == "snapshotOwners":
            suggest = "snapshot_owners"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsEventSourceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsEventSourceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsEventSourceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description_regex: builtins.str,
                 event_type: builtins.str,
                 snapshot_owners: Sequence[builtins.str]):
        """
        :param builtins.str description_regex: The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account.
        :param builtins.str event_type: The type of event. Currently, only `shareSnapshot` events are supported.
        :param Sequence[builtins.str] snapshot_owners: The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account.
        """
        pulumi.set(__self__, "description_regex", description_regex)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "snapshot_owners", snapshot_owners)

    @property
    @pulumi.getter(name="descriptionRegex")
    def description_regex(self) -> builtins.str:
        """
        The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account.
        """
        return pulumi.get(self, "description_regex")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> builtins.str:
        """
        The type of event. Currently, only `shareSnapshot` events are supported.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="snapshotOwners")
    def snapshot_owners(self) -> Sequence[builtins.str]:
        """
        The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account.
        """
        return pulumi.get(self, "snapshot_owners")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeBootVolume":
            suggest = "exclude_boot_volume"
        elif key == "noReboot":
            suggest = "no_reboot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_boot_volume: Optional[builtins.bool] = None,
                 no_reboot: Optional[builtins.bool] = None):
        """
        :param builtins.bool exclude_boot_volume: Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is `false`.
        :param builtins.bool no_reboot: Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. `true` indicates that targeted instances are not rebooted when the policy runs. `false` indicates that target instances are rebooted when the policy runs. The default is `true` (instances are not rebooted).
        """
        if exclude_boot_volume is not None:
            pulumi.set(__self__, "exclude_boot_volume", exclude_boot_volume)
        if no_reboot is not None:
            pulumi.set(__self__, "no_reboot", no_reboot)

    @property
    @pulumi.getter(name="excludeBootVolume")
    def exclude_boot_volume(self) -> Optional[builtins.bool]:
        """
        Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is `false`.
        """
        return pulumi.get(self, "exclude_boot_volume")

    @property
    @pulumi.getter(name="noReboot")
    def no_reboot(self) -> Optional[builtins.bool]:
        """
        Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. `true` indicates that targeted instances are not rebooted when the policy runs. `false` indicates that target instances are rebooted when the policy runs. The default is `true` (instances are not rebooted).
        """
        return pulumi.get(self, "no_reboot")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createRule":
            suggest = "create_rule"
        elif key == "retainRule":
            suggest = "retain_rule"
        elif key == "copyTags":
            suggest = "copy_tags"
        elif key == "crossRegionCopyRules":
            suggest = "cross_region_copy_rules"
        elif key == "deprecateRule":
            suggest = "deprecate_rule"
        elif key == "fastRestoreRule":
            suggest = "fast_restore_rule"
        elif key == "shareRule":
            suggest = "share_rule"
        elif key == "tagsToAdd":
            suggest = "tags_to_add"
        elif key == "variableTags":
            suggest = "variable_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_rule: 'outputs.LifecyclePolicyPolicyDetailsScheduleCreateRule',
                 name: builtins.str,
                 retain_rule: 'outputs.LifecyclePolicyPolicyDetailsScheduleRetainRule',
                 copy_tags: Optional[builtins.bool] = None,
                 cross_region_copy_rules: Optional[Sequence['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule']] = None,
                 deprecate_rule: Optional['outputs.LifecyclePolicyPolicyDetailsScheduleDeprecateRule'] = None,
                 fast_restore_rule: Optional['outputs.LifecyclePolicyPolicyDetailsScheduleFastRestoreRule'] = None,
                 share_rule: Optional['outputs.LifecyclePolicyPolicyDetailsScheduleShareRule'] = None,
                 tags_to_add: Optional[Mapping[str, builtins.str]] = None,
                 variable_tags: Optional[Mapping[str, builtins.str]] = None):
        """
        :param 'LifecyclePolicyPolicyDetailsScheduleCreateRuleArgs' create_rule: See the `create_rule` block. Max of 1 per schedule.
        :param Sequence['LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleArgs'] cross_region_copy_rules: See the `cross_region_copy_rule` block. Max of 3 per schedule.
        :param 'LifecyclePolicyPolicyDetailsScheduleFastRestoreRuleArgs' fast_restore_rule: See the `fast_restore_rule` block. Max of 1 per schedule.
        :param 'LifecyclePolicyPolicyDetailsScheduleShareRuleArgs' share_rule: See the `share_rule` block. Max of 1 per schedule.
        :param Mapping[str, builtins.str] tags_to_add: A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these.
        :param Mapping[str, builtins.str] variable_tags: A map of tag keys and variable values, where the values are determined when the policy is executed. Only `$(instance-id)` or `$(timestamp)` are valid values. Can only be used when `resource_types` is `INSTANCE`.
        """
        pulumi.set(__self__, "create_rule", create_rule)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retain_rule", retain_rule)
        if copy_tags is not None:
            pulumi.set(__self__, "copy_tags", copy_tags)
        if cross_region_copy_rules is not None:
            pulumi.set(__self__, "cross_region_copy_rules", cross_region_copy_rules)
        if deprecate_rule is not None:
            pulumi.set(__self__, "deprecate_rule", deprecate_rule)
        if fast_restore_rule is not None:
            pulumi.set(__self__, "fast_restore_rule", fast_restore_rule)
        if share_rule is not None:
            pulumi.set(__self__, "share_rule", share_rule)
        if tags_to_add is not None:
            pulumi.set(__self__, "tags_to_add", tags_to_add)
        if variable_tags is not None:
            pulumi.set(__self__, "variable_tags", variable_tags)

    @property
    @pulumi.getter(name="createRule")
    def create_rule(self) -> 'outputs.LifecyclePolicyPolicyDetailsScheduleCreateRule':
        """
        See the `create_rule` block. Max of 1 per schedule.
        """
        return pulumi.get(self, "create_rule")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retainRule")
    def retain_rule(self) -> 'outputs.LifecyclePolicyPolicyDetailsScheduleRetainRule':
        return pulumi.get(self, "retain_rule")

    @property
    @pulumi.getter(name="copyTags")
    def copy_tags(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "copy_tags")

    @property
    @pulumi.getter(name="crossRegionCopyRules")
    def cross_region_copy_rules(self) -> Optional[Sequence['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule']]:
        """
        See the `cross_region_copy_rule` block. Max of 3 per schedule.
        """
        return pulumi.get(self, "cross_region_copy_rules")

    @property
    @pulumi.getter(name="deprecateRule")
    def deprecate_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsScheduleDeprecateRule']:
        return pulumi.get(self, "deprecate_rule")

    @property
    @pulumi.getter(name="fastRestoreRule")
    def fast_restore_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsScheduleFastRestoreRule']:
        """
        See the `fast_restore_rule` block. Max of 1 per schedule.
        """
        return pulumi.get(self, "fast_restore_rule")

    @property
    @pulumi.getter(name="shareRule")
    def share_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsScheduleShareRule']:
        """
        See the `share_rule` block. Max of 1 per schedule.
        """
        return pulumi.get(self, "share_rule")

    @property
    @pulumi.getter(name="tagsToAdd")
    def tags_to_add(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these.
        """
        return pulumi.get(self, "tags_to_add")

    @property
    @pulumi.getter(name="variableTags")
    def variable_tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map of tag keys and variable values, where the values are determined when the policy is executed. Only `$(instance-id)` or `$(timestamp)` are valid values. Can only be used when `resource_types` is `INSTANCE`.
        """
        return pulumi.get(self, "variable_tags")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleCreateRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleCreateRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCreateRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCreateRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: Optional[builtins.str] = None,
                 interval: Optional[builtins.int] = None,
                 interval_unit: Optional[builtins.str] = None,
                 location: Optional[builtins.str] = None,
                 times: Optional[builtins.str] = None):
        """
        :param builtins.str cron_expression: The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year. Conflicts with `interval`, `interval_unit`, and `times`.
        :param builtins.str location: Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify `CLOUD`. To create snapshots on the same Outpost as the source resource, specify `OUTPOST_LOCAL`. If you omit this parameter, `CLOUD` is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are `CLOUD` and `OUTPOST_LOCAL`.
        :param builtins.str times: A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with `cron_expression`. Must be set if `interval` is set.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if interval_unit is not None:
            pulumi.set(__self__, "interval_unit", interval_unit)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if times is not None:
            pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[builtins.str]:
        """
        The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year. Conflicts with `interval`, `interval_unit`, and `times`.
        """
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> Optional[builtins.str]:
        return pulumi.get(self, "interval_unit")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify `CLOUD`. To create snapshots on the same Outpost as the source resource, specify `OUTPOST_LOCAL`. If you omit this parameter, `CLOUD` is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are `CLOUD` and `OUTPOST_LOCAL`.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def times(self) -> Optional[builtins.str]:
        """
        A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with `cron_expression`. Must be set if `interval` is set.
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cmkArn":
            suggest = "cmk_arn"
        elif key == "copyTags":
            suggest = "copy_tags"
        elif key == "deprecateRule":
            suggest = "deprecate_rule"
        elif key == "retainRule":
            suggest = "retain_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted: builtins.bool,
                 target: builtins.str,
                 cmk_arn: Optional[builtins.str] = None,
                 copy_tags: Optional[builtins.bool] = None,
                 deprecate_rule: Optional['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule'] = None,
                 retain_rule: Optional['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule'] = None):
        pulumi.set(__self__, "encrypted", encrypted)
        pulumi.set(__self__, "target", target)
        if cmk_arn is not None:
            pulumi.set(__self__, "cmk_arn", cmk_arn)
        if copy_tags is not None:
            pulumi.set(__self__, "copy_tags", copy_tags)
        if deprecate_rule is not None:
            pulumi.set(__self__, "deprecate_rule", deprecate_rule)
        if retain_rule is not None:
            pulumi.set(__self__, "retain_rule", retain_rule)

    @property
    @pulumi.getter
    def encrypted(self) -> builtins.bool:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="cmkArn")
    def cmk_arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cmk_arn")

    @property
    @pulumi.getter(name="copyTags")
    def copy_tags(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "copy_tags")

    @property
    @pulumi.getter(name="deprecateRule")
    def deprecate_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule']:
        return pulumi.get(self, "deprecate_rule")

    @property
    @pulumi.getter(name="retainRule")
    def retain_rule(self) -> Optional['outputs.LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule']:
        return pulumi.get(self, "retain_rule")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: builtins.int,
                 interval_unit: builtins.str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> builtins.str:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleCrossRegionCopyRuleRetainRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: builtins.int,
                 interval_unit: builtins.str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> builtins.str:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleDeprecateRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleDeprecateRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleDeprecateRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleDeprecateRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 interval: Optional[builtins.int] = None,
                 interval_unit: Optional[builtins.str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if interval_unit is not None:
            pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> Optional[builtins.str]:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleFastRestoreRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleFastRestoreRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleFastRestoreRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleFastRestoreRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zones: Sequence[builtins.str],
                 count: Optional[builtins.int] = None,
                 interval: Optional[builtins.int] = None,
                 interval_unit: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] availability_zones: The Availability Zones in which to enable fast snapshot restore.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if interval_unit is not None:
            pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[builtins.str]:
        """
        The Availability Zones in which to enable fast snapshot restore.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> Optional[builtins.str]:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleRetainRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalUnit":
            suggest = "interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleRetainRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleRetainRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleRetainRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 interval: Optional[builtins.int] = None,
                 interval_unit: Optional[builtins.str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if interval_unit is not None:
            pulumi.set(__self__, "interval_unit", interval_unit)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="intervalUnit")
    def interval_unit(self) -> Optional[builtins.str]:
        return pulumi.get(self, "interval_unit")


@pulumi.output_type
class LifecyclePolicyPolicyDetailsScheduleShareRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetAccounts":
            suggest = "target_accounts"
        elif key == "unshareInterval":
            suggest = "unshare_interval"
        elif key == "unshareIntervalUnit":
            suggest = "unshare_interval_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyPolicyDetailsScheduleShareRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyPolicyDetailsScheduleShareRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyPolicyDetailsScheduleShareRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_accounts: Sequence[builtins.str],
                 unshare_interval: Optional[builtins.int] = None,
                 unshare_interval_unit: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] target_accounts: The IDs of the AWS accounts with which to share the snapshots.
        :param builtins.int unshare_interval: The period after which snapshots that are shared with other AWS accounts are automatically unshared.
        :param builtins.str unshare_interval_unit: The unit of time for the automatic unsharing interval. Valid values are `DAYS`, `WEEKS`, `MONTHS`, `YEARS`.
        """
        pulumi.set(__self__, "target_accounts", target_accounts)
        if unshare_interval is not None:
            pulumi.set(__self__, "unshare_interval", unshare_interval)
        if unshare_interval_unit is not None:
            pulumi.set(__self__, "unshare_interval_unit", unshare_interval_unit)

    @property
    @pulumi.getter(name="targetAccounts")
    def target_accounts(self) -> Sequence[builtins.str]:
        """
        The IDs of the AWS accounts with which to share the snapshots.
        """
        return pulumi.get(self, "target_accounts")

    @property
    @pulumi.getter(name="unshareInterval")
    def unshare_interval(self) -> Optional[builtins.int]:
        """
        The period after which snapshots that are shared with other AWS accounts are automatically unshared.
        """
        return pulumi.get(self, "unshare_interval")

    @property
    @pulumi.getter(name="unshareIntervalUnit")
    def unshare_interval_unit(self) -> Optional[builtins.str]:
        """
        The unit of time for the automatic unsharing interval. Valid values are `DAYS`, `WEEKS`, `MONTHS`, `YEARS`.
        """
        return pulumi.get(self, "unshare_interval_unit")


