# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterBrokerNodeGroupInfoArgs',
    'ClusterBrokerNodeGroupInfoArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict',
    'ClusterClientAuthenticationArgs',
    'ClusterClientAuthenticationArgsDict',
    'ClusterClientAuthenticationSaslArgs',
    'ClusterClientAuthenticationSaslArgsDict',
    'ClusterClientAuthenticationTlsArgs',
    'ClusterClientAuthenticationTlsArgsDict',
    'ClusterConfigurationInfoArgs',
    'ClusterConfigurationInfoArgsDict',
    'ClusterEncryptionInfoArgs',
    'ClusterEncryptionInfoArgsDict',
    'ClusterEncryptionInfoEncryptionInTransitArgs',
    'ClusterEncryptionInfoEncryptionInTransitArgsDict',
    'ClusterLoggingInfoArgs',
    'ClusterLoggingInfoArgsDict',
    'ClusterLoggingInfoBrokerLogsArgs',
    'ClusterLoggingInfoBrokerLogsArgsDict',
    'ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs',
    'ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict',
    'ClusterLoggingInfoBrokerLogsFirehoseArgs',
    'ClusterLoggingInfoBrokerLogsFirehoseArgsDict',
    'ClusterLoggingInfoBrokerLogsS3Args',
    'ClusterLoggingInfoBrokerLogsS3ArgsDict',
    'ClusterOpenMonitoringArgs',
    'ClusterOpenMonitoringArgsDict',
    'ClusterOpenMonitoringPrometheusArgs',
    'ClusterOpenMonitoringPrometheusArgsDict',
    'ClusterOpenMonitoringPrometheusJmxExporterArgs',
    'ClusterOpenMonitoringPrometheusJmxExporterArgsDict',
    'ClusterOpenMonitoringPrometheusNodeExporterArgs',
    'ClusterOpenMonitoringPrometheusNodeExporterArgsDict',
    'ClusterRebalancingArgs',
    'ClusterRebalancingArgsDict',
    'ReplicatorKafkaClusterArgs',
    'ReplicatorKafkaClusterArgsDict',
    'ReplicatorKafkaClusterAmazonMskClusterArgs',
    'ReplicatorKafkaClusterAmazonMskClusterArgsDict',
    'ReplicatorKafkaClusterVpcConfigArgs',
    'ReplicatorKafkaClusterVpcConfigArgsDict',
    'ReplicatorReplicationInfoListArgs',
    'ReplicatorReplicationInfoListArgsDict',
    'ReplicatorReplicationInfoListConsumerGroupReplicationArgs',
    'ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationArgs',
    'ReplicatorReplicationInfoListTopicReplicationArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs',
    'ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs',
    'ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict',
    'ServerlessClusterClientAuthenticationArgs',
    'ServerlessClusterClientAuthenticationArgsDict',
    'ServerlessClusterClientAuthenticationSaslArgs',
    'ServerlessClusterClientAuthenticationSaslArgsDict',
    'ServerlessClusterClientAuthenticationSaslIamArgs',
    'ServerlessClusterClientAuthenticationSaslIamArgsDict',
    'ServerlessClusterVpcConfigArgs',
    'ServerlessClusterVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterBrokerNodeGroupInfoArgsDict(TypedDict):
        client_subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        instance_type: pulumi.Input[_builtins.str]
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        az_distribution: NotRequired[pulumi.Input[_builtins.str]]
        connectivity_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict']]
        storage_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgsDict']]
elif False:
    ClusterBrokerNodeGroupInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoArgs:
    def __init__(__self__, *,
                 client_subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 instance_type: pulumi.Input[_builtins.str],
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 az_distribution: Optional[pulumi.Input[_builtins.str]] = None,
                 connectivity_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']] = None,
                 storage_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']] = None):
        pulumi.set(__self__, "client_subnets", client_subnets)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "security_groups", security_groups)
        if az_distribution is not None:
            pulumi.set(__self__, "az_distribution", az_distribution)
        if connectivity_info is not None:
            pulumi.set(__self__, "connectivity_info", connectivity_info)
        if storage_info is not None:
            pulumi.set(__self__, "storage_info", storage_info)

    @_builtins.property
    @pulumi.getter(name="clientSubnets")
    def client_subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "client_subnets")

    @client_subnets.setter
    def client_subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "client_subnets", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter(name="azDistribution")
    def az_distribution(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "az_distribution")

    @az_distribution.setter
    def az_distribution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "az_distribution", value)

    @_builtins.property
    @pulumi.getter(name="connectivityInfo")
    def connectivity_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']]:
        return pulumi.get(self, "connectivity_info")

    @connectivity_info.setter
    def connectivity_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']]):
        pulumi.set(self, "connectivity_info", value)

    @_builtins.property
    @pulumi.getter(name="storageInfo")
    def storage_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']]:
        return pulumi.get(self, "storage_info")

    @storage_info.setter
    def storage_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']]):
        pulumi.set(self, "storage_info", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict(TypedDict):
        public_access: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict']]
        vpc_connectivity: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict']]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoArgs:
    def __init__(__self__, *,
                 public_access: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']] = None,
                 vpc_connectivity: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']] = None):
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if vpc_connectivity is not None:
            pulumi.set(__self__, "vpc_connectivity", vpc_connectivity)

    @_builtins.property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']]:
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']]):
        pulumi.set(self, "public_access", value)

    @_builtins.property
    @pulumi.getter(name="vpcConnectivity")
    def vpc_connectivity(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']]:
        return pulumi.get(self, "vpc_connectivity")

    @vpc_connectivity.setter
    def vpc_connectivity(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']]):
        pulumi.set(self, "vpc_connectivity", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict(TypedDict):
        client_authentication: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict']]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs:
    def __init__(__self__, *,
                 client_authentication: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']] = None):
        if client_authentication is not None:
            pulumi.set(__self__, "client_authentication", client_authentication)

    @_builtins.property
    @pulumi.getter(name="clientAuthentication")
    def client_authentication(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']]:
        return pulumi.get(self, "client_authentication")

    @client_authentication.setter
    def client_authentication(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']]):
        pulumi.set(self, "client_authentication", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict(TypedDict):
        sasl: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict']]
        tls: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']] = None,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None):
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']]:
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict(TypedDict):
        iam: NotRequired[pulumi.Input[_builtins.bool]]
        scram: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input[_builtins.bool]] = None,
                 scram: Optional[pulumi.Input[_builtins.bool]] = None):
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @_builtins.property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "iam", value)

    @_builtins.property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "scram", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoArgsDict(TypedDict):
        ebs_storage_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict']]
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoArgs:
    def __init__(__self__, *,
                 ebs_storage_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']] = None):
        if ebs_storage_info is not None:
            pulumi.set(__self__, "ebs_storage_info", ebs_storage_info)

    @_builtins.property
    @pulumi.getter(name="ebsStorageInfo")
    def ebs_storage_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']]:
        return pulumi.get(self, "ebs_storage_info")

    @ebs_storage_info.setter
    def ebs_storage_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']]):
        pulumi.set(self, "ebs_storage_info", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict(TypedDict):
        provisioned_throughput: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict']]
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs:
    def __init__(__self__, *,
                 provisioned_throughput: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None):
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']]:
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']]):
        pulumi.set(self, "provisioned_throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        volume_throughput: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_throughput: Optional[pulumi.Input[_builtins.int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if volume_throughput is not None:
            pulumi.set(__self__, "volume_throughput", volume_throughput)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volume_throughput")

    @volume_throughput.setter
    def volume_throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_throughput", value)


if not MYPY:
    class ClusterClientAuthenticationArgsDict(TypedDict):
        sasl: NotRequired[pulumi.Input['ClusterClientAuthenticationSaslArgsDict']]
        tls: NotRequired[pulumi.Input['ClusterClientAuthenticationTlsArgsDict']]
        unauthenticated: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']] = None,
                 tls: Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']] = None,
                 unauthenticated: Optional[pulumi.Input[_builtins.bool]] = None):
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if unauthenticated is not None:
            pulumi.set(__self__, "unauthenticated", unauthenticated)

    @_builtins.property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']]:
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter
    def unauthenticated(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "unauthenticated")

    @unauthenticated.setter
    def unauthenticated(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unauthenticated", value)


if not MYPY:
    class ClusterClientAuthenticationSaslArgsDict(TypedDict):
        iam: NotRequired[pulumi.Input[_builtins.bool]]
        scram: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input[_builtins.bool]] = None,
                 scram: Optional[pulumi.Input[_builtins.bool]] = None):
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @_builtins.property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "iam", value)

    @_builtins.property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "scram", value)


if not MYPY:
    class ClusterClientAuthenticationTlsArgsDict(TypedDict):
        certificate_authority_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterClientAuthenticationTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationTlsArgs:
    def __init__(__self__, *,
                 certificate_authority_arns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if certificate_authority_arns is not None:
            pulumi.set(__self__, "certificate_authority_arns", certificate_authority_arns)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "certificate_authority_arns")

    @certificate_authority_arns.setter
    def certificate_authority_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "certificate_authority_arns", value)


if not MYPY:
    class ClusterConfigurationInfoArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        revision: pulumi.Input[_builtins.int]
elif False:
    ClusterConfigurationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationInfoArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 revision: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter
    def revision(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "revision", value)


if not MYPY:
    class ClusterEncryptionInfoArgsDict(TypedDict):
        encryption_at_rest_kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        encryption_in_transit: NotRequired[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgsDict']]
elif False:
    ClusterEncryptionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_at_rest_kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_in_transit: Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']] = None):
        if encryption_at_rest_kms_key_arn is not None:
            pulumi.set(__self__, "encryption_at_rest_kms_key_arn", encryption_at_rest_kms_key_arn)
        if encryption_in_transit is not None:
            pulumi.set(__self__, "encryption_in_transit", encryption_in_transit)

    @_builtins.property
    @pulumi.getter(name="encryptionAtRestKmsKeyArn")
    def encryption_at_rest_kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_at_rest_kms_key_arn")

    @encryption_at_rest_kms_key_arn.setter
    def encryption_at_rest_kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_at_rest_kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="encryptionInTransit")
    def encryption_in_transit(self) -> Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']]:
        return pulumi.get(self, "encryption_in_transit")

    @encryption_in_transit.setter
    def encryption_in_transit(self, value: Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']]):
        pulumi.set(self, "encryption_in_transit", value)


if not MYPY:
    class ClusterEncryptionInfoEncryptionInTransitArgsDict(TypedDict):
        client_broker: NotRequired[pulumi.Input[_builtins.str]]
        in_cluster: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ClusterEncryptionInfoEncryptionInTransitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionInfoEncryptionInTransitArgs:
    def __init__(__self__, *,
                 client_broker: Optional[pulumi.Input[_builtins.str]] = None,
                 in_cluster: Optional[pulumi.Input[_builtins.bool]] = None):
        if client_broker is not None:
            pulumi.set(__self__, "client_broker", client_broker)
        if in_cluster is not None:
            pulumi.set(__self__, "in_cluster", in_cluster)

    @_builtins.property
    @pulumi.getter(name="clientBroker")
    def client_broker(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_broker")

    @client_broker.setter
    def client_broker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_broker", value)

    @_builtins.property
    @pulumi.getter(name="inCluster")
    def in_cluster(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "in_cluster")

    @in_cluster.setter
    def in_cluster(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "in_cluster", value)


if not MYPY:
    class ClusterLoggingInfoArgsDict(TypedDict):
        broker_logs: pulumi.Input['ClusterLoggingInfoBrokerLogsArgsDict']
elif False:
    ClusterLoggingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoArgs:
    def __init__(__self__, *,
                 broker_logs: pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']):
        pulumi.set(__self__, "broker_logs", broker_logs)

    @_builtins.property
    @pulumi.getter(name="brokerLogs")
    def broker_logs(self) -> pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']:
        return pulumi.get(self, "broker_logs")

    @broker_logs.setter
    def broker_logs(self, value: pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']):
        pulumi.set(self, "broker_logs", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict']]
        firehose: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgsDict']]
        s3: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsS3ArgsDict']]
elif False:
    ClusterLoggingInfoBrokerLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']] = None,
                 firehose: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']]:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        log_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 log_group: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsFirehoseArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        delivery_stream: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterLoggingInfoBrokerLogsFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsFirehoseArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 delivery_stream: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delivery_stream", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsS3ArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterLoggingInfoBrokerLogsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsS3Args:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ClusterOpenMonitoringArgsDict(TypedDict):
        prometheus: pulumi.Input['ClusterOpenMonitoringPrometheusArgsDict']
elif False:
    ClusterOpenMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringArgs:
    def __init__(__self__, *,
                 prometheus: pulumi.Input['ClusterOpenMonitoringPrometheusArgs']):
        pulumi.set(__self__, "prometheus", prometheus)

    @_builtins.property
    @pulumi.getter
    def prometheus(self) -> pulumi.Input['ClusterOpenMonitoringPrometheusArgs']:
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: pulumi.Input['ClusterOpenMonitoringPrometheusArgs']):
        pulumi.set(self, "prometheus", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusArgsDict(TypedDict):
        jmx_exporter: NotRequired[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgsDict']]
        node_exporter: NotRequired[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgsDict']]
elif False:
    ClusterOpenMonitoringPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusArgs:
    def __init__(__self__, *,
                 jmx_exporter: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']] = None,
                 node_exporter: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']] = None):
        if jmx_exporter is not None:
            pulumi.set(__self__, "jmx_exporter", jmx_exporter)
        if node_exporter is not None:
            pulumi.set(__self__, "node_exporter", node_exporter)

    @_builtins.property
    @pulumi.getter(name="jmxExporter")
    def jmx_exporter(self) -> Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']]:
        return pulumi.get(self, "jmx_exporter")

    @jmx_exporter.setter
    def jmx_exporter(self, value: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']]):
        pulumi.set(self, "jmx_exporter", value)

    @_builtins.property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']]:
        return pulumi.get(self, "node_exporter")

    @node_exporter.setter
    def node_exporter(self, value: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']]):
        pulumi.set(self, "node_exporter", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusJmxExporterArgsDict(TypedDict):
        enabled_in_broker: pulumi.Input[_builtins.bool]
elif False:
    ClusterOpenMonitoringPrometheusJmxExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusJmxExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @_builtins.property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled_in_broker", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusNodeExporterArgsDict(TypedDict):
        enabled_in_broker: pulumi.Input[_builtins.bool]
elif False:
    ClusterOpenMonitoringPrometheusNodeExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusNodeExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @_builtins.property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled_in_broker", value)


if not MYPY:
    class ClusterRebalancingArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
elif False:
    ClusterRebalancingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRebalancingArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ReplicatorKafkaClusterArgsDict(TypedDict):
        amazon_msk_cluster: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgsDict']
        vpc_config: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgsDict']
elif False:
    ReplicatorKafkaClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterArgs:
    def __init__(__self__, *,
                 amazon_msk_cluster: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs'],
                 vpc_config: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']):
        pulumi.set(__self__, "amazon_msk_cluster", amazon_msk_cluster)
        pulumi.set(__self__, "vpc_config", vpc_config)

    @_builtins.property
    @pulumi.getter(name="amazonMskCluster")
    def amazon_msk_cluster(self) -> pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs']:
        return pulumi.get(self, "amazon_msk_cluster")

    @amazon_msk_cluster.setter
    def amazon_msk_cluster(self, value: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs']):
        pulumi.set(self, "amazon_msk_cluster", value)

    @_builtins.property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']:
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class ReplicatorKafkaClusterAmazonMskClusterArgsDict(TypedDict):
        msk_cluster_arn: pulumi.Input[_builtins.str]
elif False:
    ReplicatorKafkaClusterAmazonMskClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterAmazonMskClusterArgs:
    def __init__(__self__, *,
                 msk_cluster_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "msk_cluster_arn", msk_cluster_arn)

    @_builtins.property
    @pulumi.getter(name="mskClusterArn")
    def msk_cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "msk_cluster_arn")

    @msk_cluster_arn.setter
    def msk_cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "msk_cluster_arn", value)


if not MYPY:
    class ReplicatorKafkaClusterVpcConfigArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        security_groups_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ReplicatorKafkaClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 security_groups_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups_ids")

    @security_groups_ids.setter
    def security_groups_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups_ids", value)


if not MYPY:
    class ReplicatorReplicationInfoListArgsDict(TypedDict):
        consumer_group_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict']]]
        source_kafka_cluster_arn: pulumi.Input[_builtins.str]
        target_compression_type: pulumi.Input[_builtins.str]
        target_kafka_cluster_arn: pulumi.Input[_builtins.str]
        topic_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgsDict']]]
        source_kafka_cluster_alias: NotRequired[pulumi.Input[_builtins.str]]
        target_kafka_cluster_alias: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReplicatorReplicationInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListArgs:
    def __init__(__self__, *,
                 consumer_group_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]],
                 source_kafka_cluster_arn: pulumi.Input[_builtins.str],
                 target_compression_type: pulumi.Input[_builtins.str],
                 target_kafka_cluster_arn: pulumi.Input[_builtins.str],
                 topic_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]],
                 source_kafka_cluster_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 target_kafka_cluster_alias: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "consumer_group_replications", consumer_group_replications)
        pulumi.set(__self__, "source_kafka_cluster_arn", source_kafka_cluster_arn)
        pulumi.set(__self__, "target_compression_type", target_compression_type)
        pulumi.set(__self__, "target_kafka_cluster_arn", target_kafka_cluster_arn)
        pulumi.set(__self__, "topic_replications", topic_replications)
        if source_kafka_cluster_alias is not None:
            pulumi.set(__self__, "source_kafka_cluster_alias", source_kafka_cluster_alias)
        if target_kafka_cluster_alias is not None:
            pulumi.set(__self__, "target_kafka_cluster_alias", target_kafka_cluster_alias)

    @_builtins.property
    @pulumi.getter(name="consumerGroupReplications")
    def consumer_group_replications(self) -> pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]]:
        return pulumi.get(self, "consumer_group_replications")

    @consumer_group_replications.setter
    def consumer_group_replications(self, value: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]]):
        pulumi.set(self, "consumer_group_replications", value)

    @_builtins.property
    @pulumi.getter(name="sourceKafkaClusterArn")
    def source_kafka_cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_kafka_cluster_arn")

    @source_kafka_cluster_arn.setter
    def source_kafka_cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_kafka_cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetCompressionType")
    def target_compression_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_compression_type")

    @target_compression_type.setter
    def target_compression_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_compression_type", value)

    @_builtins.property
    @pulumi.getter(name="targetKafkaClusterArn")
    def target_kafka_cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_kafka_cluster_arn")

    @target_kafka_cluster_arn.setter
    def target_kafka_cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_kafka_cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="topicReplications")
    def topic_replications(self) -> pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]]:
        return pulumi.get(self, "topic_replications")

    @topic_replications.setter
    def topic_replications(self, value: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]]):
        pulumi.set(self, "topic_replications", value)

    @_builtins.property
    @pulumi.getter(name="sourceKafkaClusterAlias")
    def source_kafka_cluster_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_kafka_cluster_alias")

    @source_kafka_cluster_alias.setter
    def source_kafka_cluster_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_kafka_cluster_alias", value)

    @_builtins.property
    @pulumi.getter(name="targetKafkaClusterAlias")
    def target_kafka_cluster_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_kafka_cluster_alias")

    @target_kafka_cluster_alias.setter
    def target_kafka_cluster_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_kafka_cluster_alias", value)


if not MYPY:
    class ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict(TypedDict):
        consumer_groups_to_replicates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        consumer_groups_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        detect_and_copy_new_consumer_groups: NotRequired[pulumi.Input[_builtins.bool]]
        synchronise_consumer_group_offsets: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListConsumerGroupReplicationArgs:
    def __init__(__self__, *,
                 consumer_groups_to_replicates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 consumer_groups_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 detect_and_copy_new_consumer_groups: Optional[pulumi.Input[_builtins.bool]] = None,
                 synchronise_consumer_group_offsets: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "consumer_groups_to_replicates", consumer_groups_to_replicates)
        if consumer_groups_to_excludes is not None:
            pulumi.set(__self__, "consumer_groups_to_excludes", consumer_groups_to_excludes)
        if detect_and_copy_new_consumer_groups is not None:
            pulumi.set(__self__, "detect_and_copy_new_consumer_groups", detect_and_copy_new_consumer_groups)
        if synchronise_consumer_group_offsets is not None:
            pulumi.set(__self__, "synchronise_consumer_group_offsets", synchronise_consumer_group_offsets)

    @_builtins.property
    @pulumi.getter(name="consumerGroupsToReplicates")
    def consumer_groups_to_replicates(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "consumer_groups_to_replicates")

    @consumer_groups_to_replicates.setter
    def consumer_groups_to_replicates(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "consumer_groups_to_replicates", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroupsToExcludes")
    def consumer_groups_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "consumer_groups_to_excludes")

    @consumer_groups_to_excludes.setter
    def consumer_groups_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "consumer_groups_to_excludes", value)

    @_builtins.property
    @pulumi.getter(name="detectAndCopyNewConsumerGroups")
    def detect_and_copy_new_consumer_groups(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "detect_and_copy_new_consumer_groups")

    @detect_and_copy_new_consumer_groups.setter
    def detect_and_copy_new_consumer_groups(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "detect_and_copy_new_consumer_groups", value)

    @_builtins.property
    @pulumi.getter(name="synchroniseConsumerGroupOffsets")
    def synchronise_consumer_group_offsets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "synchronise_consumer_group_offsets")

    @synchronise_consumer_group_offsets.setter
    def synchronise_consumer_group_offsets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "synchronise_consumer_group_offsets", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationArgsDict(TypedDict):
        topics_to_replicates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        copy_access_control_lists_for_topics: NotRequired[pulumi.Input[_builtins.bool]]
        copy_topic_configurations: NotRequired[pulumi.Input[_builtins.bool]]
        detect_and_copy_new_topics: NotRequired[pulumi.Input[_builtins.bool]]
        starting_position: NotRequired[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict']]
        topic_name_configuration: NotRequired[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict']]
        topics_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ReplicatorReplicationInfoListTopicReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationArgs:
    def __init__(__self__, *,
                 topics_to_replicates: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 copy_access_control_lists_for_topics: Optional[pulumi.Input[_builtins.bool]] = None,
                 copy_topic_configurations: Optional[pulumi.Input[_builtins.bool]] = None,
                 detect_and_copy_new_topics: Optional[pulumi.Input[_builtins.bool]] = None,
                 starting_position: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']] = None,
                 topic_name_configuration: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']] = None,
                 topics_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "topics_to_replicates", topics_to_replicates)
        if copy_access_control_lists_for_topics is not None:
            pulumi.set(__self__, "copy_access_control_lists_for_topics", copy_access_control_lists_for_topics)
        if copy_topic_configurations is not None:
            pulumi.set(__self__, "copy_topic_configurations", copy_topic_configurations)
        if detect_and_copy_new_topics is not None:
            pulumi.set(__self__, "detect_and_copy_new_topics", detect_and_copy_new_topics)
        if starting_position is not None:
            pulumi.set(__self__, "starting_position", starting_position)
        if topic_name_configuration is not None:
            pulumi.set(__self__, "topic_name_configuration", topic_name_configuration)
        if topics_to_excludes is not None:
            pulumi.set(__self__, "topics_to_excludes", topics_to_excludes)

    @_builtins.property
    @pulumi.getter(name="topicsToReplicates")
    def topics_to_replicates(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "topics_to_replicates")

    @topics_to_replicates.setter
    def topics_to_replicates(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "topics_to_replicates", value)

    @_builtins.property
    @pulumi.getter(name="copyAccessControlListsForTopics")
    def copy_access_control_lists_for_topics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "copy_access_control_lists_for_topics")

    @copy_access_control_lists_for_topics.setter
    def copy_access_control_lists_for_topics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "copy_access_control_lists_for_topics", value)

    @_builtins.property
    @pulumi.getter(name="copyTopicConfigurations")
    def copy_topic_configurations(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "copy_topic_configurations")

    @copy_topic_configurations.setter
    def copy_topic_configurations(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "copy_topic_configurations", value)

    @_builtins.property
    @pulumi.getter(name="detectAndCopyNewTopics")
    def detect_and_copy_new_topics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "detect_and_copy_new_topics")

    @detect_and_copy_new_topics.setter
    def detect_and_copy_new_topics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "detect_and_copy_new_topics", value)

    @_builtins.property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']]:
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']]):
        pulumi.set(self, "starting_position", value)

    @_builtins.property
    @pulumi.getter(name="topicNameConfiguration")
    def topic_name_configuration(self) -> Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']]:
        return pulumi.get(self, "topic_name_configuration")

    @topic_name_configuration.setter
    def topic_name_configuration(self, value: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']]):
        pulumi.set(self, "topic_name_configuration", value)

    @_builtins.property
    @pulumi.getter(name="topicsToExcludes")
    def topics_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "topics_to_excludes")

    @topics_to_excludes.setter
    def topics_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "topics_to_excludes", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationArgsDict(TypedDict):
        sasl: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgsDict']
elif False:
    ServerlessClusterClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']):
        pulumi.set(__self__, "sasl", sasl)

    @_builtins.property
    @pulumi.getter
    def sasl(self) -> pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']:
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']):
        pulumi.set(self, "sasl", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationSaslArgsDict(TypedDict):
        iam: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgsDict']
elif False:
    ServerlessClusterClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']):
        pulumi.set(__self__, "iam", iam)

    @_builtins.property
    @pulumi.getter
    def iam(self) -> pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']):
        pulumi.set(self, "iam", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationSaslIamArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
elif False:
    ServerlessClusterClientAuthenticationSaslIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationSaslIamArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ServerlessClusterVpcConfigArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ServerlessClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)


