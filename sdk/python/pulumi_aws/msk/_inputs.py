# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterBrokerNodeGroupInfoArgs',
    'ClusterBrokerNodeGroupInfoArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs',
    'ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs',
    'ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict',
    'ClusterClientAuthenticationArgs',
    'ClusterClientAuthenticationArgsDict',
    'ClusterClientAuthenticationSaslArgs',
    'ClusterClientAuthenticationSaslArgsDict',
    'ClusterClientAuthenticationTlsArgs',
    'ClusterClientAuthenticationTlsArgsDict',
    'ClusterConfigurationInfoArgs',
    'ClusterConfigurationInfoArgsDict',
    'ClusterEncryptionInfoArgs',
    'ClusterEncryptionInfoArgsDict',
    'ClusterEncryptionInfoEncryptionInTransitArgs',
    'ClusterEncryptionInfoEncryptionInTransitArgsDict',
    'ClusterLoggingInfoArgs',
    'ClusterLoggingInfoArgsDict',
    'ClusterLoggingInfoBrokerLogsArgs',
    'ClusterLoggingInfoBrokerLogsArgsDict',
    'ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs',
    'ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict',
    'ClusterLoggingInfoBrokerLogsFirehoseArgs',
    'ClusterLoggingInfoBrokerLogsFirehoseArgsDict',
    'ClusterLoggingInfoBrokerLogsS3Args',
    'ClusterLoggingInfoBrokerLogsS3ArgsDict',
    'ClusterOpenMonitoringArgs',
    'ClusterOpenMonitoringArgsDict',
    'ClusterOpenMonitoringPrometheusArgs',
    'ClusterOpenMonitoringPrometheusArgsDict',
    'ClusterOpenMonitoringPrometheusJmxExporterArgs',
    'ClusterOpenMonitoringPrometheusJmxExporterArgsDict',
    'ClusterOpenMonitoringPrometheusNodeExporterArgs',
    'ClusterOpenMonitoringPrometheusNodeExporterArgsDict',
    'ReplicatorKafkaClusterArgs',
    'ReplicatorKafkaClusterArgsDict',
    'ReplicatorKafkaClusterAmazonMskClusterArgs',
    'ReplicatorKafkaClusterAmazonMskClusterArgsDict',
    'ReplicatorKafkaClusterVpcConfigArgs',
    'ReplicatorKafkaClusterVpcConfigArgsDict',
    'ReplicatorReplicationInfoListArgs',
    'ReplicatorReplicationInfoListArgsDict',
    'ReplicatorReplicationInfoListConsumerGroupReplicationArgs',
    'ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationArgs',
    'ReplicatorReplicationInfoListTopicReplicationArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs',
    'ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict',
    'ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs',
    'ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict',
    'ServerlessClusterClientAuthenticationArgs',
    'ServerlessClusterClientAuthenticationArgsDict',
    'ServerlessClusterClientAuthenticationSaslArgs',
    'ServerlessClusterClientAuthenticationSaslArgsDict',
    'ServerlessClusterClientAuthenticationSaslIamArgs',
    'ServerlessClusterClientAuthenticationSaslIamArgsDict',
    'ServerlessClusterVpcConfigArgs',
    'ServerlessClusterVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterBrokerNodeGroupInfoArgsDict(TypedDict):
        client_subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of subnets to connect to in client VPC ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-prop-brokernodegroupinfo-clientsubnets)).
        """
        instance_type: pulumi.Input[str]
        """
        Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. ([Pricing info](https://aws.amazon.com/msk/pricing/))
        """
        security_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
        """
        az_distribution: NotRequired[pulumi.Input[str]]
        """
        The distribution of broker nodes across availability zones ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-model-brokerazdistribution)). Currently the only valid value is `DEFAULT`.
        """
        connectivity_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict']]
        """
        Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible ([documentation](https://docs.aws.amazon.com/msk/latest/developerguide/public-access.html)).
        """
        storage_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgsDict']]
        """
        A block that contains information about storage volumes attached to MSK broker nodes. See below.
        """
elif False:
    ClusterBrokerNodeGroupInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoArgs:
    def __init__(__self__, *,
                 client_subnets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 instance_type: pulumi.Input[str],
                 security_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 az_distribution: Optional[pulumi.Input[str]] = None,
                 connectivity_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']] = None,
                 storage_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] client_subnets: A list of subnets to connect to in client VPC ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-prop-brokernodegroupinfo-clientsubnets)).
        :param pulumi.Input[str] instance_type: Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. ([Pricing info](https://aws.amazon.com/msk/pricing/))
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
        :param pulumi.Input[str] az_distribution: The distribution of broker nodes across availability zones ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-model-brokerazdistribution)). Currently the only valid value is `DEFAULT`.
        :param pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs'] connectivity_info: Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible ([documentation](https://docs.aws.amazon.com/msk/latest/developerguide/public-access.html)).
        :param pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs'] storage_info: A block that contains information about storage volumes attached to MSK broker nodes. See below.
        """
        pulumi.set(__self__, "client_subnets", client_subnets)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "security_groups", security_groups)
        if az_distribution is not None:
            pulumi.set(__self__, "az_distribution", az_distribution)
        if connectivity_info is not None:
            pulumi.set(__self__, "connectivity_info", connectivity_info)
        if storage_info is not None:
            pulumi.set(__self__, "storage_info", storage_info)

    @property
    @pulumi.getter(name="clientSubnets")
    def client_subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of subnets to connect to in client VPC ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-prop-brokernodegroupinfo-clientsubnets)).
        """
        return pulumi.get(self, "client_subnets")

    @client_subnets.setter
    def client_subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "client_subnets", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        Specify the instance type to use for the kafka brokersE.g., kafka.m5.large. ([Pricing info](https://aws.amazon.com/msk/pricing/))
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of the security groups to associate with the elastic network interfaces to control who can communicate with the cluster.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="azDistribution")
    def az_distribution(self) -> Optional[pulumi.Input[str]]:
        """
        The distribution of broker nodes across availability zones ([documentation](https://docs.aws.amazon.com/msk/1.0/apireference/clusters.html#clusters-model-brokerazdistribution)). Currently the only valid value is `DEFAULT`.
        """
        return pulumi.get(self, "az_distribution")

    @az_distribution.setter
    def az_distribution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "az_distribution", value)

    @property
    @pulumi.getter(name="connectivityInfo")
    def connectivity_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']]:
        """
        Information about the cluster access configuration. See below. For security reasons, you can't turn on public access while creating an MSK cluster. However, you can update an existing cluster to make it publicly accessible. You can also create a new cluster and then update it to make it publicly accessible ([documentation](https://docs.aws.amazon.com/msk/latest/developerguide/public-access.html)).
        """
        return pulumi.get(self, "connectivity_info")

    @connectivity_info.setter
    def connectivity_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoArgs']]):
        pulumi.set(self, "connectivity_info", value)

    @property
    @pulumi.getter(name="storageInfo")
    def storage_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']]:
        """
        A block that contains information about storage volumes attached to MSK broker nodes. See below.
        """
        return pulumi.get(self, "storage_info")

    @storage_info.setter
    def storage_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoArgs']]):
        pulumi.set(self, "storage_info", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict(TypedDict):
        public_access: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict']]
        """
        Access control settings for brokers. See below.
        """
        vpc_connectivity: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict']]
        """
        VPC connectivity access control for brokers. See below.
        """
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoArgs:
    def __init__(__self__, *,
                 public_access: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']] = None,
                 vpc_connectivity: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']] = None):
        """
        :param pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs'] public_access: Access control settings for brokers. See below.
        :param pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs'] vpc_connectivity: VPC connectivity access control for brokers. See below.
        """
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if vpc_connectivity is not None:
            pulumi.set(__self__, "vpc_connectivity", vpc_connectivity)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']]:
        """
        Access control settings for brokers. See below.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs']]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="vpcConnectivity")
    def vpc_connectivity(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']]:
        """
        VPC connectivity access control for brokers. See below.
        """
        return pulumi.get(self, "vpc_connectivity")

    @vpc_connectivity.setter
    def vpc_connectivity(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs']]):
        pulumi.set(self, "vpc_connectivity", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Public access type. Valid values: `DISABLED`, `SERVICE_PROVIDED_EIPS`.
        """
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoPublicAccessArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Public access type. Valid values: `DISABLED`, `SERVICE_PROVIDED_EIPS`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Public access type. Valid values: `DISABLED`, `SERVICE_PROVIDED_EIPS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict(TypedDict):
        client_authentication: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict']]
        """
        Configuration block for specifying a client authentication. See below.
        """
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityArgs:
    def __init__(__self__, *,
                 client_authentication: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']] = None):
        """
        :param pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs'] client_authentication: Configuration block for specifying a client authentication. See below.
        """
        if client_authentication is not None:
            pulumi.set(__self__, "client_authentication", client_authentication)

    @property
    @pulumi.getter(name="clientAuthentication")
    def client_authentication(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']]:
        """
        Configuration block for specifying a client authentication. See below.
        """
        return pulumi.get(self, "client_authentication")

    @client_authentication.setter
    def client_authentication(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs']]):
        pulumi.set(self, "client_authentication", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict(TypedDict):
        sasl: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict']]
        """
        Configuration block for specifying SASL client authentication. See below.
        """
        tls: NotRequired[pulumi.Input[bool]]
        """
        Configuration block for specifying TLS client authentication. See below.
        """
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']] = None,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs'] sasl: Configuration block for specifying SASL client authentication. See below.
        :param pulumi.Input[bool] tls: Configuration block for specifying TLS client authentication. See below.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']]:
        """
        Configuration block for specifying SASL client authentication. See below.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration block for specifying TLS client authentication. See below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict(TypedDict):
        iam: NotRequired[pulumi.Input[bool]]
        scram: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoConnectivityInfoVpcConnectivityClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input[bool]] = None,
                 scram: Optional[pulumi.Input[bool]] = None):
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scram", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoArgsDict(TypedDict):
        ebs_storage_info: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict']]
        """
        A block that contains EBS volume information. See below.
        """
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoArgs:
    def __init__(__self__, *,
                 ebs_storage_info: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']] = None):
        """
        :param pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs'] ebs_storage_info: A block that contains EBS volume information. See below.
        """
        if ebs_storage_info is not None:
            pulumi.set(__self__, "ebs_storage_info", ebs_storage_info)

    @property
    @pulumi.getter(name="ebsStorageInfo")
    def ebs_storage_info(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']]:
        """
        A block that contains EBS volume information. See below.
        """
        return pulumi.get(self, "ebs_storage_info")

    @ebs_storage_info.setter
    def ebs_storage_info(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs']]):
        pulumi.set(self, "ebs_storage_info", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict(TypedDict):
        provisioned_throughput: NotRequired[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict']]
        """
        A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of `1` and maximum value of `16384`.
        """
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoArgs:
    def __init__(__self__, *,
                 provisioned_throughput: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']] = None,
                 volume_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs'] provisioned_throughput: A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
        :param pulumi.Input[int] volume_size: The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of `1` and maximum value of `16384`.
        """
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']]:
        """
        A block that contains EBS volume provisioned throughput information. To provision storage throughput, you must choose broker type kafka.m5.4xlarge or larger. See below.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: Optional[pulumi.Input['ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs']]):
        pulumi.set(self, "provisioned_throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size in GiB of the EBS volume for the data drive on each broker node. Minimum value of `1` and maximum value of `16384`.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)


if not MYPY:
    class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        volume_throughput: NotRequired[pulumi.Input[int]]
        """
        Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is `250`. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following [documentation on throughput bottlenecks](https://docs.aws.amazon.com/msk/latest/developerguide/msk-provision-throughput.html#throughput-bottlenecks)
        """
elif False:
    ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBrokerNodeGroupInfoStorageInfoEbsStorageInfoProvisionedThroughputArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 volume_throughput: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] volume_throughput: Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is `250`. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following [documentation on throughput bottlenecks](https://docs.aws.amazon.com/msk/latest/developerguide/msk-provision-throughput.html#throughput-bottlenecks)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if volume_throughput is not None:
            pulumi.set(__self__, "volume_throughput", volume_throughput)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second. The minimum value is `250`. The maximum value varies between broker type. You can refer to the valid values for the maximum volume throughput at the following [documentation on throughput bottlenecks](https://docs.aws.amazon.com/msk/latest/developerguide/msk-provision-throughput.html#throughput-bottlenecks)
        """
        return pulumi.get(self, "volume_throughput")

    @volume_throughput.setter
    def volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_throughput", value)


if not MYPY:
    class ClusterClientAuthenticationArgsDict(TypedDict):
        sasl: NotRequired[pulumi.Input['ClusterClientAuthenticationSaslArgsDict']]
        """
        Configuration block for specifying SASL client authentication. See below.
        """
        tls: NotRequired[pulumi.Input['ClusterClientAuthenticationTlsArgsDict']]
        """
        Configuration block for specifying TLS client authentication. See below.
        """
        unauthenticated: NotRequired[pulumi.Input[bool]]
        """
        Enables unauthenticated access.
        """
elif False:
    ClusterClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']] = None,
                 tls: Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']] = None,
                 unauthenticated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterClientAuthenticationSaslArgs'] sasl: Configuration block for specifying SASL client authentication. See below.
        :param pulumi.Input['ClusterClientAuthenticationTlsArgs'] tls: Configuration block for specifying TLS client authentication. See below.
        :param pulumi.Input[bool] unauthenticated: Enables unauthenticated access.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if unauthenticated is not None:
            pulumi.set(__self__, "unauthenticated", unauthenticated)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']]:
        """
        Configuration block for specifying SASL client authentication. See below.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterClientAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']]:
        """
        Configuration block for specifying TLS client authentication. See below.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ClusterClientAuthenticationTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def unauthenticated(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables unauthenticated access.
        """
        return pulumi.get(self, "unauthenticated")

    @unauthenticated.setter
    def unauthenticated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unauthenticated", value)


if not MYPY:
    class ClusterClientAuthenticationSaslArgsDict(TypedDict):
        iam: NotRequired[pulumi.Input[bool]]
        scram: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input[bool]] = None,
                 scram: Optional[pulumi.Input[bool]] = None):
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scram", value)


if not MYPY:
    class ClusterClientAuthenticationTlsArgsDict(TypedDict):
        certificate_authority_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ACM Certificate Authority Amazon Resource Names (ARNs).
        """
elif False:
    ClusterClientAuthenticationTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientAuthenticationTlsArgs:
    def __init__(__self__, *,
                 certificate_authority_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_authority_arns: List of ACM Certificate Authority Amazon Resource Names (ARNs).
        """
        if certificate_authority_arns is not None:
            pulumi.set(__self__, "certificate_authority_arns", certificate_authority_arns)

    @property
    @pulumi.getter(name="certificateAuthorityArns")
    def certificate_authority_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ACM Certificate Authority Amazon Resource Names (ARNs).
        """
        return pulumi.get(self, "certificate_authority_arns")

    @certificate_authority_arns.setter
    def certificate_authority_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate_authority_arns", value)


if not MYPY:
    class ClusterConfigurationInfoArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
        """
        revision: pulumi.Input[int]
        """
        Revision of the MSK Configuration to use in the cluster.
        """
elif False:
    ClusterConfigurationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationInfoArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 revision: pulumi.Input[int]):
        """
        :param pulumi.Input[str] arn: Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
        :param pulumi.Input[int] revision: Revision of the MSK Configuration to use in the cluster.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the MSK Configuration to use in the cluster.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def revision(self) -> pulumi.Input[int]:
        """
        Revision of the MSK Configuration to use in the cluster.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[int]):
        pulumi.set(self, "revision", value)


if not MYPY:
    class ClusterEncryptionInfoArgsDict(TypedDict):
        encryption_at_rest_kms_key_arn: NotRequired[pulumi.Input[str]]
        """
        You may specify a KMS key short ID or ARN (it will always output an ARN) to use for encrypting your data at rest.  If no key is specified, an AWS managed KMS ('aws/msk' managed service) key will be used for encrypting the data at rest.
        """
        encryption_in_transit: NotRequired[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgsDict']]
        """
        Configuration block to specify encryption in transit. See below.
        """
elif False:
    ClusterEncryptionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_at_rest_kms_key_arn: Optional[pulumi.Input[str]] = None,
                 encryption_in_transit: Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']] = None):
        """
        :param pulumi.Input[str] encryption_at_rest_kms_key_arn: You may specify a KMS key short ID or ARN (it will always output an ARN) to use for encrypting your data at rest.  If no key is specified, an AWS managed KMS ('aws/msk' managed service) key will be used for encrypting the data at rest.
        :param pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs'] encryption_in_transit: Configuration block to specify encryption in transit. See below.
        """
        if encryption_at_rest_kms_key_arn is not None:
            pulumi.set(__self__, "encryption_at_rest_kms_key_arn", encryption_at_rest_kms_key_arn)
        if encryption_in_transit is not None:
            pulumi.set(__self__, "encryption_in_transit", encryption_in_transit)

    @property
    @pulumi.getter(name="encryptionAtRestKmsKeyArn")
    def encryption_at_rest_kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        You may specify a KMS key short ID or ARN (it will always output an ARN) to use for encrypting your data at rest.  If no key is specified, an AWS managed KMS ('aws/msk' managed service) key will be used for encrypting the data at rest.
        """
        return pulumi.get(self, "encryption_at_rest_kms_key_arn")

    @encryption_at_rest_kms_key_arn.setter
    def encryption_at_rest_kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_at_rest_kms_key_arn", value)

    @property
    @pulumi.getter(name="encryptionInTransit")
    def encryption_in_transit(self) -> Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']]:
        """
        Configuration block to specify encryption in transit. See below.
        """
        return pulumi.get(self, "encryption_in_transit")

    @encryption_in_transit.setter
    def encryption_in_transit(self, value: Optional[pulumi.Input['ClusterEncryptionInfoEncryptionInTransitArgs']]):
        pulumi.set(self, "encryption_in_transit", value)


if not MYPY:
    class ClusterEncryptionInfoEncryptionInTransitArgsDict(TypedDict):
        client_broker: NotRequired[pulumi.Input[str]]
        """
        Encryption setting for data in transit between clients and brokers. Valid values: `TLS`, `TLS_PLAINTEXT`, and `PLAINTEXT`. Default value is `TLS`.
        """
        in_cluster: NotRequired[pulumi.Input[bool]]
        """
        Whether data communication among broker nodes is encrypted. Default value: `true`.
        """
elif False:
    ClusterEncryptionInfoEncryptionInTransitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionInfoEncryptionInTransitArgs:
    def __init__(__self__, *,
                 client_broker: Optional[pulumi.Input[str]] = None,
                 in_cluster: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] client_broker: Encryption setting for data in transit between clients and brokers. Valid values: `TLS`, `TLS_PLAINTEXT`, and `PLAINTEXT`. Default value is `TLS`.
        :param pulumi.Input[bool] in_cluster: Whether data communication among broker nodes is encrypted. Default value: `true`.
        """
        if client_broker is not None:
            pulumi.set(__self__, "client_broker", client_broker)
        if in_cluster is not None:
            pulumi.set(__self__, "in_cluster", in_cluster)

    @property
    @pulumi.getter(name="clientBroker")
    def client_broker(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption setting for data in transit between clients and brokers. Valid values: `TLS`, `TLS_PLAINTEXT`, and `PLAINTEXT`. Default value is `TLS`.
        """
        return pulumi.get(self, "client_broker")

    @client_broker.setter
    def client_broker(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_broker", value)

    @property
    @pulumi.getter(name="inCluster")
    def in_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether data communication among broker nodes is encrypted. Default value: `true`.
        """
        return pulumi.get(self, "in_cluster")

    @in_cluster.setter
    def in_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "in_cluster", value)


if not MYPY:
    class ClusterLoggingInfoArgsDict(TypedDict):
        broker_logs: pulumi.Input['ClusterLoggingInfoBrokerLogsArgsDict']
        """
        Configuration block for Broker Logs settings for logging info. See below.
        """
elif False:
    ClusterLoggingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoArgs:
    def __init__(__self__, *,
                 broker_logs: pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']):
        """
        :param pulumi.Input['ClusterLoggingInfoBrokerLogsArgs'] broker_logs: Configuration block for Broker Logs settings for logging info. See below.
        """
        pulumi.set(__self__, "broker_logs", broker_logs)

    @property
    @pulumi.getter(name="brokerLogs")
    def broker_logs(self) -> pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']:
        """
        Configuration block for Broker Logs settings for logging info. See below.
        """
        return pulumi.get(self, "broker_logs")

    @broker_logs.setter
    def broker_logs(self, value: pulumi.Input['ClusterLoggingInfoBrokerLogsArgs']):
        pulumi.set(self, "broker_logs", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict']]
        firehose: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgsDict']]
        s3: NotRequired[pulumi.Input['ClusterLoggingInfoBrokerLogsS3ArgsDict']]
elif False:
    ClusterLoggingInfoBrokerLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']] = None,
                 firehose: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']]:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterLoggingInfoBrokerLogsS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        log_group: NotRequired[pulumi.Input[str]]
        """
        Name of the Cloudwatch Log Group to deliver logs to.
        """
elif False:
    ClusterLoggingInfoBrokerLogsCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsCloudwatchLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 log_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_group: Name of the Cloudwatch Log Group to deliver logs to.
        """
        pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Cloudwatch Log Group to deliver logs to.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsFirehoseArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        delivery_stream: NotRequired[pulumi.Input[str]]
        """
        Name of the Kinesis Data Firehose delivery stream to deliver logs to.
        """
elif False:
    ClusterLoggingInfoBrokerLogsFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsFirehoseArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 delivery_stream: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delivery_stream: Name of the Kinesis Data Firehose delivery stream to deliver logs to.
        """
        pulumi.set(__self__, "enabled", enabled)
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Kinesis Data Firehose delivery stream to deliver logs to.
        """
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delivery_stream", value)


if not MYPY:
    class ClusterLoggingInfoBrokerLogsS3ArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        bucket: NotRequired[pulumi.Input[str]]
        """
        Name of the S3 bucket to deliver logs to.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix to append to the folder name.
        """
elif False:
    ClusterLoggingInfoBrokerLogsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLoggingInfoBrokerLogsS3Args:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 bucket: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the S3 bucket to deliver logs to.
        :param pulumi.Input[str] prefix: Prefix to append to the folder name.
        """
        pulumi.set(__self__, "enabled", enabled)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the S3 bucket to deliver logs to.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix to append to the folder name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ClusterOpenMonitoringArgsDict(TypedDict):
        prometheus: pulumi.Input['ClusterOpenMonitoringPrometheusArgsDict']
        """
        Configuration block for Prometheus settings for open monitoring. See below.
        """
elif False:
    ClusterOpenMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringArgs:
    def __init__(__self__, *,
                 prometheus: pulumi.Input['ClusterOpenMonitoringPrometheusArgs']):
        """
        :param pulumi.Input['ClusterOpenMonitoringPrometheusArgs'] prometheus: Configuration block for Prometheus settings for open monitoring. See below.
        """
        pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> pulumi.Input['ClusterOpenMonitoringPrometheusArgs']:
        """
        Configuration block for Prometheus settings for open monitoring. See below.
        """
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: pulumi.Input['ClusterOpenMonitoringPrometheusArgs']):
        pulumi.set(self, "prometheus", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusArgsDict(TypedDict):
        jmx_exporter: NotRequired[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgsDict']]
        """
        Configuration block for JMX Exporter. See below.
        """
        node_exporter: NotRequired[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgsDict']]
        """
        Configuration block for Node Exporter. See below.
        """
elif False:
    ClusterOpenMonitoringPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusArgs:
    def __init__(__self__, *,
                 jmx_exporter: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']] = None,
                 node_exporter: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']] = None):
        """
        :param pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs'] jmx_exporter: Configuration block for JMX Exporter. See below.
        :param pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs'] node_exporter: Configuration block for Node Exporter. See below.
        """
        if jmx_exporter is not None:
            pulumi.set(__self__, "jmx_exporter", jmx_exporter)
        if node_exporter is not None:
            pulumi.set(__self__, "node_exporter", node_exporter)

    @property
    @pulumi.getter(name="jmxExporter")
    def jmx_exporter(self) -> Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']]:
        """
        Configuration block for JMX Exporter. See below.
        """
        return pulumi.get(self, "jmx_exporter")

    @jmx_exporter.setter
    def jmx_exporter(self, value: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusJmxExporterArgs']]):
        pulumi.set(self, "jmx_exporter", value)

    @property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']]:
        """
        Configuration block for Node Exporter. See below.
        """
        return pulumi.get(self, "node_exporter")

    @node_exporter.setter
    def node_exporter(self, value: Optional[pulumi.Input['ClusterOpenMonitoringPrometheusNodeExporterArgs']]):
        pulumi.set(self, "node_exporter", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusJmxExporterArgsDict(TypedDict):
        enabled_in_broker: pulumi.Input[bool]
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
elif False:
    ClusterOpenMonitoringPrometheusJmxExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusJmxExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled_in_broker: Indicates whether you want to enable or disable the Node Exporter.
        """
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[bool]:
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_in_broker", value)


if not MYPY:
    class ClusterOpenMonitoringPrometheusNodeExporterArgsDict(TypedDict):
        enabled_in_broker: pulumi.Input[bool]
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
elif False:
    ClusterOpenMonitoringPrometheusNodeExporterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOpenMonitoringPrometheusNodeExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled_in_broker: Indicates whether you want to enable or disable the Node Exporter.
        """
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[bool]:
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_in_broker", value)


if not MYPY:
    class ReplicatorKafkaClusterArgsDict(TypedDict):
        amazon_msk_cluster: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgsDict']
        """
        Details of an Amazon MSK cluster.
        """
        vpc_config: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgsDict']
        """
        Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        """
elif False:
    ReplicatorKafkaClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterArgs:
    def __init__(__self__, *,
                 amazon_msk_cluster: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs'],
                 vpc_config: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']):
        """
        :param pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs'] amazon_msk_cluster: Details of an Amazon MSK cluster.
        :param pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs'] vpc_config: Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        """
        pulumi.set(__self__, "amazon_msk_cluster", amazon_msk_cluster)
        pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="amazonMskCluster")
    def amazon_msk_cluster(self) -> pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs']:
        """
        Details of an Amazon MSK cluster.
        """
        return pulumi.get(self, "amazon_msk_cluster")

    @amazon_msk_cluster.setter
    def amazon_msk_cluster(self, value: pulumi.Input['ReplicatorKafkaClusterAmazonMskClusterArgs']):
        pulumi.set(self, "amazon_msk_cluster", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']:
        """
        Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: pulumi.Input['ReplicatorKafkaClusterVpcConfigArgs']):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class ReplicatorKafkaClusterAmazonMskClusterArgsDict(TypedDict):
        msk_cluster_arn: pulumi.Input[str]
        """
        The ARN of an Amazon MSK cluster.
        """
elif False:
    ReplicatorKafkaClusterAmazonMskClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterAmazonMskClusterArgs:
    def __init__(__self__, *,
                 msk_cluster_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] msk_cluster_arn: The ARN of an Amazon MSK cluster.
        """
        pulumi.set(__self__, "msk_cluster_arn", msk_cluster_arn)

    @property
    @pulumi.getter(name="mskClusterArn")
    def msk_cluster_arn(self) -> pulumi.Input[str]:
        """
        The ARN of an Amazon MSK cluster.
        """
        return pulumi.get(self, "msk_cluster_arn")

    @msk_cluster_arn.setter
    def msk_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "msk_cluster_arn", value)


if not MYPY:
    class ReplicatorKafkaClusterVpcConfigArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
        """
        security_groups_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
        """
elif False:
    ReplicatorKafkaClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorKafkaClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 security_groups_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups_ids: The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_groups_ids is not None:
            pulumi.set(__self__, "security_groups_ids", security_groups_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets to allow communication between your Kafka Cluster and the replicator.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroupsIds")
    def security_groups_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AWS security groups to associate with the ENIs used by the replicator. If a security group is not specified, the default security group associated with the VPC is used.
        """
        return pulumi.get(self, "security_groups_ids")

    @security_groups_ids.setter
    def security_groups_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups_ids", value)


if not MYPY:
    class ReplicatorReplicationInfoListArgsDict(TypedDict):
        consumer_group_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict']]]
        """
        Configuration relating to consumer group replication.
        """
        source_kafka_cluster_arn: pulumi.Input[str]
        """
        The ARN of the source Kafka cluster.
        """
        target_compression_type: pulumi.Input[str]
        """
        The type of compression to use writing records to target Kafka cluster.
        """
        target_kafka_cluster_arn: pulumi.Input[str]
        """
        The ARN of the target Kafka cluster.
        """
        topic_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgsDict']]]
        """
        Configuration relating to topic replication.
        """
        source_kafka_cluster_alias: NotRequired[pulumi.Input[str]]
        target_kafka_cluster_alias: NotRequired[pulumi.Input[str]]
elif False:
    ReplicatorReplicationInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListArgs:
    def __init__(__self__, *,
                 consumer_group_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]],
                 source_kafka_cluster_arn: pulumi.Input[str],
                 target_compression_type: pulumi.Input[str],
                 target_kafka_cluster_arn: pulumi.Input[str],
                 topic_replications: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]],
                 source_kafka_cluster_alias: Optional[pulumi.Input[str]] = None,
                 target_kafka_cluster_alias: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]] consumer_group_replications: Configuration relating to consumer group replication.
        :param pulumi.Input[str] source_kafka_cluster_arn: The ARN of the source Kafka cluster.
        :param pulumi.Input[str] target_compression_type: The type of compression to use writing records to target Kafka cluster.
        :param pulumi.Input[str] target_kafka_cluster_arn: The ARN of the target Kafka cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]] topic_replications: Configuration relating to topic replication.
        """
        pulumi.set(__self__, "consumer_group_replications", consumer_group_replications)
        pulumi.set(__self__, "source_kafka_cluster_arn", source_kafka_cluster_arn)
        pulumi.set(__self__, "target_compression_type", target_compression_type)
        pulumi.set(__self__, "target_kafka_cluster_arn", target_kafka_cluster_arn)
        pulumi.set(__self__, "topic_replications", topic_replications)
        if source_kafka_cluster_alias is not None:
            pulumi.set(__self__, "source_kafka_cluster_alias", source_kafka_cluster_alias)
        if target_kafka_cluster_alias is not None:
            pulumi.set(__self__, "target_kafka_cluster_alias", target_kafka_cluster_alias)

    @property
    @pulumi.getter(name="consumerGroupReplications")
    def consumer_group_replications(self) -> pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]]:
        """
        Configuration relating to consumer group replication.
        """
        return pulumi.get(self, "consumer_group_replications")

    @consumer_group_replications.setter
    def consumer_group_replications(self, value: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListConsumerGroupReplicationArgs']]]):
        pulumi.set(self, "consumer_group_replications", value)

    @property
    @pulumi.getter(name="sourceKafkaClusterArn")
    def source_kafka_cluster_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the source Kafka cluster.
        """
        return pulumi.get(self, "source_kafka_cluster_arn")

    @source_kafka_cluster_arn.setter
    def source_kafka_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_kafka_cluster_arn", value)

    @property
    @pulumi.getter(name="targetCompressionType")
    def target_compression_type(self) -> pulumi.Input[str]:
        """
        The type of compression to use writing records to target Kafka cluster.
        """
        return pulumi.get(self, "target_compression_type")

    @target_compression_type.setter
    def target_compression_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_compression_type", value)

    @property
    @pulumi.getter(name="targetKafkaClusterArn")
    def target_kafka_cluster_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the target Kafka cluster.
        """
        return pulumi.get(self, "target_kafka_cluster_arn")

    @target_kafka_cluster_arn.setter
    def target_kafka_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_kafka_cluster_arn", value)

    @property
    @pulumi.getter(name="topicReplications")
    def topic_replications(self) -> pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]]:
        """
        Configuration relating to topic replication.
        """
        return pulumi.get(self, "topic_replications")

    @topic_replications.setter
    def topic_replications(self, value: pulumi.Input[Sequence[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationArgs']]]):
        pulumi.set(self, "topic_replications", value)

    @property
    @pulumi.getter(name="sourceKafkaClusterAlias")
    def source_kafka_cluster_alias(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_kafka_cluster_alias")

    @source_kafka_cluster_alias.setter
    def source_kafka_cluster_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_kafka_cluster_alias", value)

    @property
    @pulumi.getter(name="targetKafkaClusterAlias")
    def target_kafka_cluster_alias(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_kafka_cluster_alias")

    @target_kafka_cluster_alias.setter
    def target_kafka_cluster_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_kafka_cluster_alias", value)


if not MYPY:
    class ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict(TypedDict):
        consumer_groups_to_replicates: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of regular expression patterns indicating the consumer groups to copy.
        """
        consumer_groups_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regular expression patterns indicating the consumer groups that should not be replicated.
        """
        detect_and_copy_new_consumer_groups: NotRequired[pulumi.Input[bool]]
        """
        Whether to periodically check for new consumer groups.
        """
        synchronise_consumer_group_offsets: NotRequired[pulumi.Input[bool]]
        """
        Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
        """
elif False:
    ReplicatorReplicationInfoListConsumerGroupReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListConsumerGroupReplicationArgs:
    def __init__(__self__, *,
                 consumer_groups_to_replicates: pulumi.Input[Sequence[pulumi.Input[str]]],
                 consumer_groups_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detect_and_copy_new_consumer_groups: Optional[pulumi.Input[bool]] = None,
                 synchronise_consumer_group_offsets: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] consumer_groups_to_replicates: List of regular expression patterns indicating the consumer groups to copy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] consumer_groups_to_excludes: List of regular expression patterns indicating the consumer groups that should not be replicated.
        :param pulumi.Input[bool] detect_and_copy_new_consumer_groups: Whether to periodically check for new consumer groups.
        :param pulumi.Input[bool] synchronise_consumer_group_offsets: Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
        """
        pulumi.set(__self__, "consumer_groups_to_replicates", consumer_groups_to_replicates)
        if consumer_groups_to_excludes is not None:
            pulumi.set(__self__, "consumer_groups_to_excludes", consumer_groups_to_excludes)
        if detect_and_copy_new_consumer_groups is not None:
            pulumi.set(__self__, "detect_and_copy_new_consumer_groups", detect_and_copy_new_consumer_groups)
        if synchronise_consumer_group_offsets is not None:
            pulumi.set(__self__, "synchronise_consumer_group_offsets", synchronise_consumer_group_offsets)

    @property
    @pulumi.getter(name="consumerGroupsToReplicates")
    def consumer_groups_to_replicates(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of regular expression patterns indicating the consumer groups to copy.
        """
        return pulumi.get(self, "consumer_groups_to_replicates")

    @consumer_groups_to_replicates.setter
    def consumer_groups_to_replicates(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "consumer_groups_to_replicates", value)

    @property
    @pulumi.getter(name="consumerGroupsToExcludes")
    def consumer_groups_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression patterns indicating the consumer groups that should not be replicated.
        """
        return pulumi.get(self, "consumer_groups_to_excludes")

    @consumer_groups_to_excludes.setter
    def consumer_groups_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "consumer_groups_to_excludes", value)

    @property
    @pulumi.getter(name="detectAndCopyNewConsumerGroups")
    def detect_and_copy_new_consumer_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically check for new consumer groups.
        """
        return pulumi.get(self, "detect_and_copy_new_consumer_groups")

    @detect_and_copy_new_consumer_groups.setter
    def detect_and_copy_new_consumer_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detect_and_copy_new_consumer_groups", value)

    @property
    @pulumi.getter(name="synchroniseConsumerGroupOffsets")
    def synchronise_consumer_group_offsets(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
        """
        return pulumi.get(self, "synchronise_consumer_group_offsets")

    @synchronise_consumer_group_offsets.setter
    def synchronise_consumer_group_offsets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "synchronise_consumer_group_offsets", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationArgsDict(TypedDict):
        topics_to_replicates: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of regular expression patterns indicating the topics to copy.
        """
        copy_access_control_lists_for_topics: NotRequired[pulumi.Input[bool]]
        """
        Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        """
        copy_topic_configurations: NotRequired[pulumi.Input[bool]]
        """
        Whether to periodically configure remote topics to match their corresponding upstream topics.
        """
        detect_and_copy_new_topics: NotRequired[pulumi.Input[bool]]
        """
        Whether to periodically check for new topics and partitions.
        """
        starting_position: NotRequired[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict']]
        """
        Configuration for specifying the position in the topics to start replicating from.
        """
        topic_name_configuration: NotRequired[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict']]
        topics_to_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regular expression patterns indicating the topics that should not be replica.
        """
elif False:
    ReplicatorReplicationInfoListTopicReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationArgs:
    def __init__(__self__, *,
                 topics_to_replicates: pulumi.Input[Sequence[pulumi.Input[str]]],
                 copy_access_control_lists_for_topics: Optional[pulumi.Input[bool]] = None,
                 copy_topic_configurations: Optional[pulumi.Input[bool]] = None,
                 detect_and_copy_new_topics: Optional[pulumi.Input[bool]] = None,
                 starting_position: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']] = None,
                 topic_name_configuration: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']] = None,
                 topics_to_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics_to_replicates: List of regular expression patterns indicating the topics to copy.
        :param pulumi.Input[bool] copy_access_control_lists_for_topics: Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        :param pulumi.Input[bool] copy_topic_configurations: Whether to periodically configure remote topics to match their corresponding upstream topics.
        :param pulumi.Input[bool] detect_and_copy_new_topics: Whether to periodically check for new topics and partitions.
        :param pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs'] starting_position: Configuration for specifying the position in the topics to start replicating from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics_to_excludes: List of regular expression patterns indicating the topics that should not be replica.
        """
        pulumi.set(__self__, "topics_to_replicates", topics_to_replicates)
        if copy_access_control_lists_for_topics is not None:
            pulumi.set(__self__, "copy_access_control_lists_for_topics", copy_access_control_lists_for_topics)
        if copy_topic_configurations is not None:
            pulumi.set(__self__, "copy_topic_configurations", copy_topic_configurations)
        if detect_and_copy_new_topics is not None:
            pulumi.set(__self__, "detect_and_copy_new_topics", detect_and_copy_new_topics)
        if starting_position is not None:
            pulumi.set(__self__, "starting_position", starting_position)
        if topic_name_configuration is not None:
            pulumi.set(__self__, "topic_name_configuration", topic_name_configuration)
        if topics_to_excludes is not None:
            pulumi.set(__self__, "topics_to_excludes", topics_to_excludes)

    @property
    @pulumi.getter(name="topicsToReplicates")
    def topics_to_replicates(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of regular expression patterns indicating the topics to copy.
        """
        return pulumi.get(self, "topics_to_replicates")

    @topics_to_replicates.setter
    def topics_to_replicates(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "topics_to_replicates", value)

    @property
    @pulumi.getter(name="copyAccessControlListsForTopics")
    def copy_access_control_lists_for_topics(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        """
        return pulumi.get(self, "copy_access_control_lists_for_topics")

    @copy_access_control_lists_for_topics.setter
    def copy_access_control_lists_for_topics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "copy_access_control_lists_for_topics", value)

    @property
    @pulumi.getter(name="copyTopicConfigurations")
    def copy_topic_configurations(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically configure remote topics to match their corresponding upstream topics.
        """
        return pulumi.get(self, "copy_topic_configurations")

    @copy_topic_configurations.setter
    def copy_topic_configurations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "copy_topic_configurations", value)

    @property
    @pulumi.getter(name="detectAndCopyNewTopics")
    def detect_and_copy_new_topics(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically check for new topics and partitions.
        """
        return pulumi.get(self, "detect_and_copy_new_topics")

    @detect_and_copy_new_topics.setter
    def detect_and_copy_new_topics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detect_and_copy_new_topics", value)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']]:
        """
        Configuration for specifying the position in the topics to start replicating from.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs']]):
        pulumi.set(self, "starting_position", value)

    @property
    @pulumi.getter(name="topicNameConfiguration")
    def topic_name_configuration(self) -> Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']]:
        return pulumi.get(self, "topic_name_configuration")

    @topic_name_configuration.setter
    def topic_name_configuration(self, value: Optional[pulumi.Input['ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs']]):
        pulumi.set(self, "topic_name_configuration", value)

    @property
    @pulumi.getter(name="topicsToExcludes")
    def topics_to_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression patterns indicating the topics that should not be replica.
        """
        return pulumi.get(self, "topics_to_excludes")

    @topics_to_excludes.setter
    def topics_to_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics_to_excludes", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of replication starting position. Supports `LATEST` and `EARLIEST`.
        """
elif False:
    ReplicatorReplicationInfoListTopicReplicationStartingPositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationStartingPositionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of replication starting position. Supports `LATEST` and `EARLIEST`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of replication starting position. Supports `LATEST` and `EARLIEST`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
elif False:
    ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicatorReplicationInfoListTopicReplicationTopicNameConfigurationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationArgsDict(TypedDict):
        sasl: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgsDict']
        """
        Details for client authentication using SASL. See below.
        """
elif False:
    ServerlessClusterClientAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']):
        """
        :param pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs'] sasl: Details for client authentication using SASL. See below.
        """
        pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def sasl(self) -> pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']:
        """
        Details for client authentication using SASL. See below.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: pulumi.Input['ServerlessClusterClientAuthenticationSaslArgs']):
        pulumi.set(self, "sasl", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationSaslArgsDict(TypedDict):
        iam: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgsDict']
        """
        Details for client authentication using IAM. See below.
        """
elif False:
    ServerlessClusterClientAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationSaslArgs:
    def __init__(__self__, *,
                 iam: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']):
        """
        :param pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs'] iam: Details for client authentication using IAM. See below.
        """
        pulumi.set(__self__, "iam", iam)

    @property
    @pulumi.getter
    def iam(self) -> pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']:
        """
        Details for client authentication using IAM. See below.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: pulumi.Input['ServerlessClusterClientAuthenticationSaslIamArgs']):
        pulumi.set(self, "iam", value)


if not MYPY:
    class ServerlessClusterClientAuthenticationSaslIamArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether SASL/IAM authentication is enabled or not.
        """
elif False:
    ServerlessClusterClientAuthenticationSaslIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterClientAuthenticationSaslIamArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether SASL/IAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether SASL/IAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ServerlessClusterVpcConfigArgsDict(TypedDict):
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of subnets in at least two different Availability Zones that host your client applications.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies up to five security groups that control inbound and outbound traffic for the serverless cluster.
        """
elif False:
    ServerlessClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: A list of subnets in at least two different Availability Zones that host your client applications.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Specifies up to five security groups that control inbound and outbound traffic for the serverless cluster.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of subnets in at least two different Availability Zones that host your client applications.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies up to five security groups that control inbound and outbound traffic for the serverless cluster.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


