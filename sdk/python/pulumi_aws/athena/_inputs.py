# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CapacityReservationTimeoutsArgs',
    'CapacityReservationTimeoutsArgsDict',
    'DatabaseAclConfigurationArgs',
    'DatabaseAclConfigurationArgsDict',
    'DatabaseEncryptionConfigurationArgs',
    'DatabaseEncryptionConfigurationArgsDict',
    'WorkgroupConfigurationArgs',
    'WorkgroupConfigurationArgsDict',
    'WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs',
    'WorkgroupConfigurationCustomerContentEncryptionConfigurationArgsDict',
    'WorkgroupConfigurationEngineVersionArgs',
    'WorkgroupConfigurationEngineVersionArgsDict',
    'WorkgroupConfigurationIdentityCenterConfigurationArgs',
    'WorkgroupConfigurationIdentityCenterConfigurationArgsDict',
    'WorkgroupConfigurationManagedQueryResultsConfigurationArgs',
    'WorkgroupConfigurationManagedQueryResultsConfigurationArgsDict',
    'WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs',
    'WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgsDict',
    'WorkgroupConfigurationMonitoringConfigurationArgs',
    'WorkgroupConfigurationMonitoringConfigurationArgsDict',
    'WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs',
    'WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgsDict',
    'WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs',
    'WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgsDict',
    'WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs',
    'WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgsDict',
    'WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs',
    'WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgsDict',
    'WorkgroupConfigurationResultConfigurationArgs',
    'WorkgroupConfigurationResultConfigurationArgsDict',
    'WorkgroupConfigurationResultConfigurationAclConfigurationArgs',
    'WorkgroupConfigurationResultConfigurationAclConfigurationArgsDict',
    'WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs',
    'WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class CapacityReservationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CapacityReservationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DatabaseAclConfigurationArgsDict(TypedDict):
        s3_acl_option: pulumi.Input[_builtins.str]
        """
        Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.

        > **NOTE:** When Athena queries are executed, result files may be created in the specified bucket. Consider using `force_destroy` on the bucket too in order to avoid any problems when destroying the bucket.
        """
elif False:
    DatabaseAclConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseAclConfigurationArgs:
    def __init__(__self__, *,
                 s3_acl_option: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_acl_option: Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
               
               > **NOTE:** When Athena queries are executed, result files may be created in the specified bucket. Consider using `force_destroy` on the bucket too in order to avoid any problems when destroying the bucket.
        """
        pulumi.set(__self__, "s3_acl_option", s3_acl_option)

    @_builtins.property
    @pulumi.getter(name="s3AclOption")
    def s3_acl_option(self) -> pulumi.Input[_builtins.str]:
        """
        Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.

        > **NOTE:** When Athena queries are executed, result files may be created in the specified bucket. Consider using `force_destroy` on the bucket too in order to avoid any problems when destroying the bucket.
        """
        return pulumi.get(self, "s3_acl_option")

    @s3_acl_option.setter
    def s3_acl_option(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_acl_option", value)


if not MYPY:
    class DatabaseEncryptionConfigurationArgsDict(TypedDict):
        encryption_option: pulumi.Input[_builtins.str]
        """
        Type of key; one of `SSE_S3`, `SSE_KMS`, `CSE_KMS`
        """
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN or ID; required for key types `SSE_KMS` and `CSE_KMS`.
        """
elif False:
    DatabaseEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_option: pulumi.Input[_builtins.str],
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encryption_option: Type of key; one of `SSE_S3`, `SSE_KMS`, `CSE_KMS`
        :param pulumi.Input[_builtins.str] kms_key: KMS key ARN or ID; required for key types `SSE_KMS` and `CSE_KMS`.
        """
        pulumi.set(__self__, "encryption_option", encryption_option)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> pulumi.Input[_builtins.str]:
        """
        Type of key; one of `SSE_S3`, `SSE_KMS`, `CSE_KMS`
        """
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "encryption_option", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN or ID; required for key types `SSE_KMS` and `CSE_KMS`.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class WorkgroupConfigurationArgsDict(TypedDict):
        bytes_scanned_cutoff_per_query: NotRequired[pulumi.Input[_builtins.int]]
        """
        Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least `10485760`.
        """
        customer_content_encryption_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationCustomerContentEncryptionConfigurationArgsDict']]
        """
        Configuration block to specify the KMS key that is used to encrypt the user's data stores in Athena. This setting applies to the PySpark engine for Athena notebooks. See Customer Content Encryption Configuration below.
        """
        enable_minimum_encryption_configuration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean indicating whether a minimum level of encryption is enforced for the workgroup for query and calculation results written to Amazon S3.
        """
        enforce_workgroup_configuration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean whether the settings for the workgroup override client-side settings. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html). Defaults to `true`.
        """
        engine_version: NotRequired[pulumi.Input['WorkgroupConfigurationEngineVersionArgsDict']]
        """
        Configuration block for the Athena Engine Versioning. For more information, see [Athena Engine Versioning](https://docs.aws.amazon.com/athena/latest/ug/engine-versions.html). See Engine Version below.
        """
        execution_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role used to access user resources in notebook sessions and IAM Identity Center enabled workgroups. The property is required for IAM Identity Center enabled workgroups.
        """
        identity_center_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationIdentityCenterConfigurationArgsDict']]
        """
        Configuration block to set up an IAM Identity Center enabled workgroup. See Identity Center Configuration below.
        """
        managed_query_results_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationArgsDict']]
        """
        Configuration block for storing results in Athena owned storage. See Managed Query Results Configuration below.
        """
        monitoring_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationArgsDict']]
        """
        Configuration block for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc. Only applicable to Apache Spark engine. See Monitoring Configuration below.
        """
        publish_cloudwatch_metrics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to `true`.
        """
        requester_pays_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        """
        result_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationResultConfigurationArgsDict']]
        """
        Configuration block with result settings. See Result Configuration below.
        """
elif False:
    WorkgroupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationArgs:
    def __init__(__self__, *,
                 bytes_scanned_cutoff_per_query: Optional[pulumi.Input[_builtins.int]] = None,
                 customer_content_encryption_configuration: Optional[pulumi.Input['WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs']] = None,
                 enable_minimum_encryption_configuration: Optional[pulumi.Input[_builtins.bool]] = None,
                 enforce_workgroup_configuration: Optional[pulumi.Input[_builtins.bool]] = None,
                 engine_version: Optional[pulumi.Input['WorkgroupConfigurationEngineVersionArgs']] = None,
                 execution_role: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_center_configuration: Optional[pulumi.Input['WorkgroupConfigurationIdentityCenterConfigurationArgs']] = None,
                 managed_query_results_configuration: Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationArgs']] = None,
                 monitoring_configuration: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationArgs']] = None,
                 publish_cloudwatch_metrics_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 requester_pays_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 result_configuration: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] bytes_scanned_cutoff_per_query: Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least `10485760`.
        :param pulumi.Input['WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs'] customer_content_encryption_configuration: Configuration block to specify the KMS key that is used to encrypt the user's data stores in Athena. This setting applies to the PySpark engine for Athena notebooks. See Customer Content Encryption Configuration below.
        :param pulumi.Input[_builtins.bool] enable_minimum_encryption_configuration: Boolean indicating whether a minimum level of encryption is enforced for the workgroup for query and calculation results written to Amazon S3.
        :param pulumi.Input[_builtins.bool] enforce_workgroup_configuration: Boolean whether the settings for the workgroup override client-side settings. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html). Defaults to `true`.
        :param pulumi.Input['WorkgroupConfigurationEngineVersionArgs'] engine_version: Configuration block for the Athena Engine Versioning. For more information, see [Athena Engine Versioning](https://docs.aws.amazon.com/athena/latest/ug/engine-versions.html). See Engine Version below.
        :param pulumi.Input[_builtins.str] execution_role: Role used to access user resources in notebook sessions and IAM Identity Center enabled workgroups. The property is required for IAM Identity Center enabled workgroups.
        :param pulumi.Input['WorkgroupConfigurationIdentityCenterConfigurationArgs'] identity_center_configuration: Configuration block to set up an IAM Identity Center enabled workgroup. See Identity Center Configuration below.
        :param pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationArgs'] managed_query_results_configuration: Configuration block for storing results in Athena owned storage. See Managed Query Results Configuration below.
        :param pulumi.Input['WorkgroupConfigurationMonitoringConfigurationArgs'] monitoring_configuration: Configuration block for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc. Only applicable to Apache Spark engine. See Monitoring Configuration below.
        :param pulumi.Input[_builtins.bool] publish_cloudwatch_metrics_enabled: Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to `true`.
        :param pulumi.Input[_builtins.bool] requester_pays_enabled: If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        :param pulumi.Input['WorkgroupConfigurationResultConfigurationArgs'] result_configuration: Configuration block with result settings. See Result Configuration below.
        """
        if bytes_scanned_cutoff_per_query is not None:
            pulumi.set(__self__, "bytes_scanned_cutoff_per_query", bytes_scanned_cutoff_per_query)
        if customer_content_encryption_configuration is not None:
            pulumi.set(__self__, "customer_content_encryption_configuration", customer_content_encryption_configuration)
        if enable_minimum_encryption_configuration is not None:
            pulumi.set(__self__, "enable_minimum_encryption_configuration", enable_minimum_encryption_configuration)
        if enforce_workgroup_configuration is not None:
            pulumi.set(__self__, "enforce_workgroup_configuration", enforce_workgroup_configuration)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if execution_role is not None:
            pulumi.set(__self__, "execution_role", execution_role)
        if identity_center_configuration is not None:
            pulumi.set(__self__, "identity_center_configuration", identity_center_configuration)
        if managed_query_results_configuration is not None:
            pulumi.set(__self__, "managed_query_results_configuration", managed_query_results_configuration)
        if monitoring_configuration is not None:
            pulumi.set(__self__, "monitoring_configuration", monitoring_configuration)
        if publish_cloudwatch_metrics_enabled is not None:
            pulumi.set(__self__, "publish_cloudwatch_metrics_enabled", publish_cloudwatch_metrics_enabled)
        if requester_pays_enabled is not None:
            pulumi.set(__self__, "requester_pays_enabled", requester_pays_enabled)
        if result_configuration is not None:
            pulumi.set(__self__, "result_configuration", result_configuration)

    @_builtins.property
    @pulumi.getter(name="bytesScannedCutoffPerQuery")
    def bytes_scanned_cutoff_per_query(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Integer for the upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan. Must be at least `10485760`.
        """
        return pulumi.get(self, "bytes_scanned_cutoff_per_query")

    @bytes_scanned_cutoff_per_query.setter
    def bytes_scanned_cutoff_per_query(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bytes_scanned_cutoff_per_query", value)

    @_builtins.property
    @pulumi.getter(name="customerContentEncryptionConfiguration")
    def customer_content_encryption_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs']]:
        """
        Configuration block to specify the KMS key that is used to encrypt the user's data stores in Athena. This setting applies to the PySpark engine for Athena notebooks. See Customer Content Encryption Configuration below.
        """
        return pulumi.get(self, "customer_content_encryption_configuration")

    @customer_content_encryption_configuration.setter
    def customer_content_encryption_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs']]):
        pulumi.set(self, "customer_content_encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="enableMinimumEncryptionConfiguration")
    def enable_minimum_encryption_configuration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean indicating whether a minimum level of encryption is enforced for the workgroup for query and calculation results written to Amazon S3.
        """
        return pulumi.get(self, "enable_minimum_encryption_configuration")

    @enable_minimum_encryption_configuration.setter
    def enable_minimum_encryption_configuration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_minimum_encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="enforceWorkgroupConfiguration")
    def enforce_workgroup_configuration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean whether the settings for the workgroup override client-side settings. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html). Defaults to `true`.
        """
        return pulumi.get(self, "enforce_workgroup_configuration")

    @enforce_workgroup_configuration.setter
    def enforce_workgroup_configuration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_workgroup_configuration", value)

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[pulumi.Input['WorkgroupConfigurationEngineVersionArgs']]:
        """
        Configuration block for the Athena Engine Versioning. For more information, see [Athena Engine Versioning](https://docs.aws.amazon.com/athena/latest/ug/engine-versions.html). See Engine Version below.
        """
        return pulumi.get(self, "engine_version")

    @engine_version.setter
    def engine_version(self, value: Optional[pulumi.Input['WorkgroupConfigurationEngineVersionArgs']]):
        pulumi.set(self, "engine_version", value)

    @_builtins.property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role used to access user resources in notebook sessions and IAM Identity Center enabled workgroups. The property is required for IAM Identity Center enabled workgroups.
        """
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_role", value)

    @_builtins.property
    @pulumi.getter(name="identityCenterConfiguration")
    def identity_center_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationIdentityCenterConfigurationArgs']]:
        """
        Configuration block to set up an IAM Identity Center enabled workgroup. See Identity Center Configuration below.
        """
        return pulumi.get(self, "identity_center_configuration")

    @identity_center_configuration.setter
    def identity_center_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationIdentityCenterConfigurationArgs']]):
        pulumi.set(self, "identity_center_configuration", value)

    @_builtins.property
    @pulumi.getter(name="managedQueryResultsConfiguration")
    def managed_query_results_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationArgs']]:
        """
        Configuration block for storing results in Athena owned storage. See Managed Query Results Configuration below.
        """
        return pulumi.get(self, "managed_query_results_configuration")

    @managed_query_results_configuration.setter
    def managed_query_results_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationArgs']]):
        pulumi.set(self, "managed_query_results_configuration", value)

    @_builtins.property
    @pulumi.getter(name="monitoringConfiguration")
    def monitoring_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationArgs']]:
        """
        Configuration block for managed log persistence, delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc. Only applicable to Apache Spark engine. See Monitoring Configuration below.
        """
        return pulumi.get(self, "monitoring_configuration")

    @monitoring_configuration.setter
    def monitoring_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationArgs']]):
        pulumi.set(self, "monitoring_configuration", value)

    @_builtins.property
    @pulumi.getter(name="publishCloudwatchMetricsEnabled")
    def publish_cloudwatch_metrics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean whether Amazon CloudWatch metrics are enabled for the workgroup. Defaults to `true`.
        """
        return pulumi.get(self, "publish_cloudwatch_metrics_enabled")

    @publish_cloudwatch_metrics_enabled.setter
    def publish_cloudwatch_metrics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "publish_cloudwatch_metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="requesterPaysEnabled")
    def requester_pays_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true , allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false , workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false . For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        """
        return pulumi.get(self, "requester_pays_enabled")

    @requester_pays_enabled.setter
    def requester_pays_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "requester_pays_enabled", value)

    @_builtins.property
    @pulumi.getter(name="resultConfiguration")
    def result_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationArgs']]:
        """
        Configuration block with result settings. See Result Configuration below.
        """
        return pulumi.get(self, "result_configuration")

    @result_configuration.setter
    def result_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationArgs']]):
        pulumi.set(self, "result_configuration", value)


if not MYPY:
    class WorkgroupConfigurationCustomerContentEncryptionConfigurationArgsDict(TypedDict):
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkgroupConfigurationCustomerContentEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationCustomerContentEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class WorkgroupConfigurationEngineVersionArgsDict(TypedDict):
        effective_engine_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The engine version on which the query runs. If `selected_engine_version` is set to `AUTO`, the effective engine version is chosen by Athena.
        """
        selected_engine_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Requested engine version. Defaults to `AUTO`.
        """
elif False:
    WorkgroupConfigurationEngineVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationEngineVersionArgs:
    def __init__(__self__, *,
                 effective_engine_version: Optional[pulumi.Input[_builtins.str]] = None,
                 selected_engine_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective_engine_version: The engine version on which the query runs. If `selected_engine_version` is set to `AUTO`, the effective engine version is chosen by Athena.
        :param pulumi.Input[_builtins.str] selected_engine_version: Requested engine version. Defaults to `AUTO`.
        """
        if effective_engine_version is not None:
            pulumi.set(__self__, "effective_engine_version", effective_engine_version)
        if selected_engine_version is not None:
            pulumi.set(__self__, "selected_engine_version", selected_engine_version)

    @_builtins.property
    @pulumi.getter(name="effectiveEngineVersion")
    def effective_engine_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The engine version on which the query runs. If `selected_engine_version` is set to `AUTO`, the effective engine version is chosen by Athena.
        """
        return pulumi.get(self, "effective_engine_version")

    @effective_engine_version.setter
    def effective_engine_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_engine_version", value)

    @_builtins.property
    @pulumi.getter(name="selectedEngineVersion")
    def selected_engine_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Requested engine version. Defaults to `AUTO`.
        """
        return pulumi.get(self, "selected_engine_version")

    @selected_engine_version.setter
    def selected_engine_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selected_engine_version", value)


if not MYPY:
    class WorkgroupConfigurationIdentityCenterConfigurationArgsDict(TypedDict):
        enable_identity_center: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the workgroup is IAM Identity Center supported.
        """
        identity_center_instance_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IAM Identity Center instance ARN that the workgroup associates to.
        """
elif False:
    WorkgroupConfigurationIdentityCenterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationIdentityCenterConfigurationArgs:
    def __init__(__self__, *,
                 enable_identity_center: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_center_instance_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_identity_center: Specifies whether the workgroup is IAM Identity Center supported.
        :param pulumi.Input[_builtins.str] identity_center_instance_arn: The IAM Identity Center instance ARN that the workgroup associates to.
        """
        if enable_identity_center is not None:
            pulumi.set(__self__, "enable_identity_center", enable_identity_center)
        if identity_center_instance_arn is not None:
            pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)

    @_builtins.property
    @pulumi.getter(name="enableIdentityCenter")
    def enable_identity_center(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the workgroup is IAM Identity Center supported.
        """
        return pulumi.get(self, "enable_identity_center")

    @enable_identity_center.setter
    def enable_identity_center(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_identity_center", value)

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IAM Identity Center instance ARN that the workgroup associates to.
        """
        return pulumi.get(self, "identity_center_instance_arn")

    @identity_center_instance_arn.setter
    def identity_center_instance_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_center_instance_arn", value)


if not MYPY:
    class WorkgroupConfigurationManagedQueryResultsConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to `true`, allows you to store query results in Athena owned storage. If set to `false`, workgroup member stores query results in the location specified under `result_configuration.output_location`. The default is `false`. A workgroup cannot have the `result_configuration.output_location` set when this is `true`.
        """
        encryption_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgsDict']]
        """
        Configuration block for the encryption configuration. See Managed Query Results Encryption Configuration below.
        """
elif False:
    WorkgroupConfigurationManagedQueryResultsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationManagedQueryResultsConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 encryption_configuration: Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set to `true`, allows you to store query results in Athena owned storage. If set to `false`, workgroup member stores query results in the location specified under `result_configuration.output_location`. The default is `false`. A workgroup cannot have the `result_configuration.output_location` set when this is `true`.
        :param pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs'] encryption_configuration: Configuration block for the encryption configuration. See Managed Query Results Encryption Configuration below.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to `true`, allows you to store query results in Athena owned storage. If set to `false`, workgroup member stores query results in the location specified under `result_configuration.output_location`. The default is `false`. A workgroup cannot have the `result_configuration.output_location` set when this is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs']]:
        """
        Configuration block for the encryption configuration. See Managed Query Results Encryption Configuration below.
        """
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)


if not MYPY:
    class WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgsDict(TypedDict):
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationManagedQueryResultsConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class WorkgroupConfigurationMonitoringConfigurationArgsDict(TypedDict):
        cloud_watch_logging_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgsDict']]
        """
        Configuration block for delivering logs to Amazon CloudWatch log groups. See CloudWatch Logging Configuration below.
        """
        managed_logging_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgsDict']]
        """
        Configuration block for managed log persistence. See Managed Logging Configuration below.
        """
        s3_logging_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgsDict']]
        """
        Configuration block for delivering logs to Amazon S3 buckets. See S3 Logging Configuration below.
        """
elif False:
    WorkgroupConfigurationMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 cloud_watch_logging_configuration: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs']] = None,
                 managed_logging_configuration: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs']] = None,
                 s3_logging_configuration: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs']] = None):
        """
        :param pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs'] cloud_watch_logging_configuration: Configuration block for delivering logs to Amazon CloudWatch log groups. See CloudWatch Logging Configuration below.
        :param pulumi.Input['WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs'] managed_logging_configuration: Configuration block for managed log persistence. See Managed Logging Configuration below.
        :param pulumi.Input['WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs'] s3_logging_configuration: Configuration block for delivering logs to Amazon S3 buckets. See S3 Logging Configuration below.
        """
        if cloud_watch_logging_configuration is not None:
            pulumi.set(__self__, "cloud_watch_logging_configuration", cloud_watch_logging_configuration)
        if managed_logging_configuration is not None:
            pulumi.set(__self__, "managed_logging_configuration", managed_logging_configuration)
        if s3_logging_configuration is not None:
            pulumi.set(__self__, "s3_logging_configuration", s3_logging_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLoggingConfiguration")
    def cloud_watch_logging_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs']]:
        """
        Configuration block for delivering logs to Amazon CloudWatch log groups. See CloudWatch Logging Configuration below.
        """
        return pulumi.get(self, "cloud_watch_logging_configuration")

    @cloud_watch_logging_configuration.setter
    def cloud_watch_logging_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs']]):
        pulumi.set(self, "cloud_watch_logging_configuration", value)

    @_builtins.property
    @pulumi.getter(name="managedLoggingConfiguration")
    def managed_logging_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs']]:
        """
        Configuration block for managed log persistence. See Managed Logging Configuration below.
        """
        return pulumi.get(self, "managed_logging_configuration")

    @managed_logging_configuration.setter
    def managed_logging_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs']]):
        pulumi.set(self, "managed_logging_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3LoggingConfiguration")
    def s3_logging_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs']]:
        """
        Configuration block for delivering logs to Amazon S3 buckets. See S3 Logging Configuration below.
        """
        return pulumi.get(self, "s3_logging_configuration")

    @s3_logging_configuration.setter
    def s3_logging_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs']]):
        pulumi.set(self, "s3_logging_configuration", value)


if not MYPY:
    class WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        """
        log_stream_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix for the CloudWatch log stream name.
        """
        log_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgsDict']]]]
        """
        Repeatable block defining log types to be delivered to CloudWatch.
        """
elif False:
    WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 log_group: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_name_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_types: Optional[pulumi.Input[Sequence[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] log_group: Name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        :param pulumi.Input[_builtins.str] log_stream_name_prefix: Prefix for the CloudWatch log stream name.
        :param pulumi.Input[Sequence[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs']]] log_types: Repeatable block defining log types to be delivered to CloudWatch.
        """
        pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix for the CloudWatch log stream name.
        """
        return pulumi.get(self, "log_stream_name_prefix")

    @log_stream_name_prefix.setter
    def log_stream_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs']]]]:
        """
        Repeatable block defining log types to be delivered to CloudWatch.
        """
        return pulumi.get(self, "log_types")

    @log_types.setter
    def log_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs']]]]):
        pulumi.set(self, "log_types", value)


if not MYPY:
    class WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Type of worker to deliver logs to CloudWatch (for example, `SPARK_DRIVER` and `SPARK_EXECUTOR`).
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of log types to be delivered to CloudWatch (for example, `STDOUT` and `STDERR`).
        """
elif False:
    WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationMonitoringConfigurationCloudWatchLoggingConfigurationLogTypeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: Type of worker to deliver logs to CloudWatch (for example, `SPARK_DRIVER` and `SPARK_EXECUTOR`).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of log types to be delivered to CloudWatch (for example, `STDOUT` and `STDERR`).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Type of worker to deliver logs to CloudWatch (for example, `SPARK_DRIVER` and `SPARK_EXECUTOR`).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of log types to be delivered to CloudWatch (for example, `STDOUT` and `STDERR`).
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean whether managed log persistence is enabled for the workgroup.
        """
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationMonitoringConfigurationManagedLoggingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean whether managed log persistence is enabled for the workgroup.
        """
        pulumi.set(__self__, "enabled", enabled)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean whether managed log persistence is enabled for the workgroup.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean whether Amazon S3 logging is enabled for the workgroup.
        """
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        """
        log_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Amazon S3 destination URI (`s3://bucket/prefix`) for log publishing.
        """
elif False:
    WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationMonitoringConfigurationS3LoggingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None,
                 log_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean whether Amazon S3 logging is enabled for the workgroup.
        :param pulumi.Input[_builtins.str] kms_key: KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        :param pulumi.Input[_builtins.str] log_location: Amazon S3 destination URI (`s3://bucket/prefix`) for log publishing.
        """
        pulumi.set(__self__, "enabled", enabled)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if log_location is not None:
            pulumi.set(__self__, "log_location", log_location)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean whether Amazon S3 logging is enabled for the workgroup.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)

    @_builtins.property
    @pulumi.getter(name="logLocation")
    def log_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Amazon S3 destination URI (`s3://bucket/prefix`) for log publishing.
        """
        return pulumi.get(self, "log_location")

    @log_location.setter
    def log_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_location", value)


if not MYPY:
    class WorkgroupConfigurationResultConfigurationArgsDict(TypedDict):
        acl_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationResultConfigurationAclConfigurationArgsDict']]
        """
        That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
        """
        encryption_configuration: NotRequired[pulumi.Input['WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgsDict']]
        """
        Configuration block with encryption settings. See Encryption Configuration below.
        """
        expected_bucket_owner: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS account ID that you expect to be the owner of the Amazon S3 bucket.
        """
        output_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location in Amazon S3 where your query results are stored, such as `s3://path/to/query/bucket/`. For more information, see [Queries and Query Result Files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        """
elif False:
    WorkgroupConfigurationResultConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationResultConfigurationArgs:
    def __init__(__self__, *,
                 acl_configuration: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationAclConfigurationArgs']] = None,
                 encryption_configuration: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs']] = None,
                 expected_bucket_owner: Optional[pulumi.Input[_builtins.str]] = None,
                 output_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkgroupConfigurationResultConfigurationAclConfigurationArgs'] acl_configuration: That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
        :param pulumi.Input['WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs'] encryption_configuration: Configuration block with encryption settings. See Encryption Configuration below.
        :param pulumi.Input[_builtins.str] expected_bucket_owner: AWS account ID that you expect to be the owner of the Amazon S3 bucket.
        :param pulumi.Input[_builtins.str] output_location: Location in Amazon S3 where your query results are stored, such as `s3://path/to/query/bucket/`. For more information, see [Queries and Query Result Files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        """
        if acl_configuration is not None:
            pulumi.set(__self__, "acl_configuration", acl_configuration)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if expected_bucket_owner is not None:
            pulumi.set(__self__, "expected_bucket_owner", expected_bucket_owner)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)

    @_builtins.property
    @pulumi.getter(name="aclConfiguration")
    def acl_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationAclConfigurationArgs']]:
        """
        That an Amazon S3 canned ACL should be set to control ownership of stored query results. See ACL Configuration below.
        """
        return pulumi.get(self, "acl_configuration")

    @acl_configuration.setter
    def acl_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationAclConfigurationArgs']]):
        pulumi.set(self, "acl_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs']]:
        """
        Configuration block with encryption settings. See Encryption Configuration below.
        """
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="expectedBucketOwner")
    def expected_bucket_owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS account ID that you expect to be the owner of the Amazon S3 bucket.
        """
        return pulumi.get(self, "expected_bucket_owner")

    @expected_bucket_owner.setter
    def expected_bucket_owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_bucket_owner", value)

    @_builtins.property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location in Amazon S3 where your query results are stored, such as `s3://path/to/query/bucket/`. For more information, see [Queries and Query Result Files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        """
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_location", value)


if not MYPY:
    class WorkgroupConfigurationResultConfigurationAclConfigurationArgsDict(TypedDict):
        s3_acl_option: pulumi.Input[_builtins.str]
        """
        Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
        """
elif False:
    WorkgroupConfigurationResultConfigurationAclConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationResultConfigurationAclConfigurationArgs:
    def __init__(__self__, *,
                 s3_acl_option: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_acl_option: Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
        """
        pulumi.set(__self__, "s3_acl_option", s3_acl_option)

    @_builtins.property
    @pulumi.getter(name="s3AclOption")
    def s3_acl_option(self) -> pulumi.Input[_builtins.str]:
        """
        Amazon S3 canned ACL that Athena should specify when storing query results. Valid value is `BUCKET_OWNER_FULL_CONTROL`.
        """
        return pulumi.get(self, "s3_acl_option")

    @s3_acl_option.setter
    def s3_acl_option(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_acl_option", value)


if not MYPY:
    class WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgsDict(TypedDict):
        encryption_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether Amazon S3 server-side encryption with Amazon S3-managed keys (`SSE_S3`), server-side encryption with KMS-managed keys (`SSE_KMS`), or client-side encryption with KMS-managed keys (`CSE_KMS`) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        For `SSE_KMS` and `CSE_KMS`, this is the KMS key ARN.
        """
elif False:
    WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkgroupConfigurationResultConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_option: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encryption_option: Whether Amazon S3 server-side encryption with Amazon S3-managed keys (`SSE_S3`), server-side encryption with KMS-managed keys (`SSE_KMS`), or client-side encryption with KMS-managed keys (`CSE_KMS`) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        :param pulumi.Input[_builtins.str] kms_key_arn: For `SSE_KMS` and `CSE_KMS`, this is the KMS key ARN.
        """
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether Amazon S3 server-side encryption with Amazon S3-managed keys (`SSE_S3`), server-side encryption with KMS-managed keys (`SSE_KMS`), or client-side encryption with KMS-managed keys (`CSE_KMS`) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        """
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_option", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For `SSE_KMS` and `CSE_KMS`, this is the KMS key ARN.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


