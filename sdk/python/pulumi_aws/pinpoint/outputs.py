# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AppCampaignHook',
    'AppLimits',
    'AppQuietTime',
    'EmailTemplateEmailTemplate',
    'EmailTemplateEmailTemplateHeader',
    'Smsvoicev2PhoneNumberTimeouts',
]

@pulumi.output_type
class AppCampaignHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaFunctionName":
            suggest = "lambda_function_name"
        elif key == "webUrl":
            suggest = "web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppCampaignHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppCampaignHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppCampaignHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_function_name: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 web_url: Optional[_builtins.str] = None):
        if lambda_function_name is not None:
            pulumi.set(__self__, "lambda_function_name", lambda_function_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionName")
    def lambda_function_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lambda_function_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "web_url")


@pulumi.output_type
class AppLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumDuration":
            suggest = "maximum_duration"
        elif key == "messagesPerSecond":
            suggest = "messages_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 daily: Optional[_builtins.int] = None,
                 maximum_duration: Optional[_builtins.int] = None,
                 messages_per_second: Optional[_builtins.int] = None,
                 total: Optional[_builtins.int] = None):
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if messages_per_second is not None:
            pulumi.set(__self__, "messages_per_second", messages_per_second)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "daily")

    @_builtins.property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_duration")

    @_builtins.property
    @pulumi.getter(name="messagesPerSecond")
    def messages_per_second(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "messages_per_second")

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total")


@pulumi.output_type
class AppQuietTime(dict):
    def __init__(__self__, *,
                 end: Optional[_builtins.str] = None,
                 start: Optional[_builtins.str] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start")


@pulumi.output_type
class EmailTemplateEmailTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSubstitutions":
            suggest = "default_substitutions"
        elif key == "htmlPart":
            suggest = "html_part"
        elif key == "recommenderId":
            suggest = "recommender_id"
        elif key == "textPart":
            suggest = "text_part"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailTemplateEmailTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailTemplateEmailTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailTemplateEmailTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_substitutions: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.EmailTemplateEmailTemplateHeader']] = None,
                 html_part: Optional[_builtins.str] = None,
                 recommender_id: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 text_part: Optional[_builtins.str] = None):
        if default_substitutions is not None:
            pulumi.set(__self__, "default_substitutions", default_substitutions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_part is not None:
            pulumi.set(__self__, "html_part", html_part)
        if recommender_id is not None:
            pulumi.set(__self__, "recommender_id", recommender_id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if text_part is not None:
            pulumi.set(__self__, "text_part", text_part)

    @_builtins.property
    @pulumi.getter(name="defaultSubstitutions")
    def default_substitutions(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_substitutions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EmailTemplateEmailTemplateHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="htmlPart")
    def html_part(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "html_part")

    @_builtins.property
    @pulumi.getter(name="recommenderId")
    def recommender_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "recommender_id")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="textPart")
    def text_part(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "text_part")


@pulumi.output_type
class EmailTemplateEmailTemplateHeader(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Smsvoicev2PhoneNumberTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


