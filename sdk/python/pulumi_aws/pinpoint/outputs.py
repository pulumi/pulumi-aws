# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AppCampaignHook',
    'AppLimits',
    'AppQuietTime',
    'EmailTemplateEmailTemplate',
    'EmailTemplateEmailTemplateHeader',
    'Smsvoicev2PhoneNumberTimeouts',
]

@pulumi.output_type
class AppCampaignHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaFunctionName":
            suggest = "lambda_function_name"
        elif key == "webUrl":
            suggest = "web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppCampaignHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppCampaignHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppCampaignHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_function_name: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 web_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str lambda_function_name: Lambda function name or ARN to be called for delivery. Conflicts with `web_url`
        :param _builtins.str mode: What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
        :param _builtins.str web_url: Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambda_function_name`
        """
        if lambda_function_name is not None:
            pulumi.set(__self__, "lambda_function_name", lambda_function_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionName")
    def lambda_function_name(self) -> Optional[_builtins.str]:
        """
        Lambda function name or ARN to be called for delivery. Conflicts with `web_url`
        """
        return pulumi.get(self, "lambda_function_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[_builtins.str]:
        """
        Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambda_function_name`
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class AppLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumDuration":
            suggest = "maximum_duration"
        elif key == "messagesPerSecond":
            suggest = "messages_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 daily: Optional[_builtins.int] = None,
                 maximum_duration: Optional[_builtins.int] = None,
                 messages_per_second: Optional[_builtins.int] = None,
                 total: Optional[_builtins.int] = None):
        """
        :param _builtins.int daily: The maximum number of messages that the campaign can send daily.
        :param _builtins.int maximum_duration: The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        :param _builtins.int messages_per_second: The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        :param _builtins.int total: The maximum total number of messages that the campaign can send.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if messages_per_second is not None:
            pulumi.set(__self__, "messages_per_second", messages_per_second)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[_builtins.int]:
        """
        The maximum number of messages that the campaign can send daily.
        """
        return pulumi.get(self, "daily")

    @_builtins.property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[_builtins.int]:
        """
        The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        """
        return pulumi.get(self, "maximum_duration")

    @_builtins.property
    @pulumi.getter(name="messagesPerSecond")
    def messages_per_second(self) -> Optional[_builtins.int]:
        """
        The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        """
        return pulumi.get(self, "messages_per_second")

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[_builtins.int]:
        """
        The maximum total number of messages that the campaign can send.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class AppQuietTime(dict):
    def __init__(__self__, *,
                 end: Optional[_builtins.str] = None,
                 start: Optional[_builtins.str] = None):
        """
        :param _builtins.str end: The default end time for quiet time in ISO 8601 format. Required if `start` is set
        :param _builtins.str start: The default start time for quiet time in ISO 8601 format. Required if `end` is set
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        The default end time for quiet time in ISO 8601 format. Required if `start` is set
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        """
        The default start time for quiet time in ISO 8601 format. Required if `end` is set
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class EmailTemplateEmailTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSubstitutions":
            suggest = "default_substitutions"
        elif key == "htmlPart":
            suggest = "html_part"
        elif key == "recommenderId":
            suggest = "recommender_id"
        elif key == "textPart":
            suggest = "text_part"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmailTemplateEmailTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmailTemplateEmailTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmailTemplateEmailTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_substitutions: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.EmailTemplateEmailTemplateHeader']] = None,
                 html_part: Optional[_builtins.str] = None,
                 recommender_id: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 text_part: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_substitutions: JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        :param _builtins.str html_part: The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        :param _builtins.str recommender_id: The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        :param _builtins.str subject: Subject line, or title, to use in email messages that are based on the message template.
        :param _builtins.str text_part: Message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        if default_substitutions is not None:
            pulumi.set(__self__, "default_substitutions", default_substitutions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_part is not None:
            pulumi.set(__self__, "html_part", html_part)
        if recommender_id is not None:
            pulumi.set(__self__, "recommender_id", recommender_id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if text_part is not None:
            pulumi.set(__self__, "text_part", text_part)

    @_builtins.property
    @pulumi.getter(name="defaultSubstitutions")
    def default_substitutions(self) -> Optional[_builtins.str]:
        """
        JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        """
        return pulumi.get(self, "default_substitutions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EmailTemplateEmailTemplateHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="htmlPart")
    def html_part(self) -> Optional[_builtins.str]:
        """
        The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        """
        return pulumi.get(self, "html_part")

    @_builtins.property
    @pulumi.getter(name="recommenderId")
    def recommender_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        """
        return pulumi.get(self, "recommender_id")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        Subject line, or title, to use in email messages that are based on the message template.
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="textPart")
    def text_part(self) -> Optional[_builtins.str]:
        """
        Message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        return pulumi.get(self, "text_part")


@pulumi.output_type
class EmailTemplateEmailTemplateHeader(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the message header. The header name can contain up to 126 characters.
        :param _builtins.str value: Value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the message header. The header name can contain up to 126 characters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Smsvoicev2PhoneNumberTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


