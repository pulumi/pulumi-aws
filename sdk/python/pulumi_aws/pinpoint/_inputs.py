# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppCampaignHookArgs',
    'AppCampaignHookArgsDict',
    'AppLimitsArgs',
    'AppLimitsArgsDict',
    'AppQuietTimeArgs',
    'AppQuietTimeArgsDict',
    'EmailTemplateEmailTemplateArgs',
    'EmailTemplateEmailTemplateArgsDict',
    'EmailTemplateEmailTemplateHeaderArgs',
    'EmailTemplateEmailTemplateHeaderArgsDict',
    'Smsvoicev2PhoneNumberTimeoutsArgs',
    'Smsvoicev2PhoneNumberTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class AppCampaignHookArgsDict(TypedDict):
        lambda_function_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Lambda function name or ARN to be called for delivery. Conflicts with `web_url`
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
        """
        web_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambda_function_name`
        """
elif False:
    AppCampaignHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppCampaignHookArgs:
    def __init__(__self__, *,
                 lambda_function_name: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 web_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] lambda_function_name: Lambda function name or ARN to be called for delivery. Conflicts with `web_url`
        :param pulumi.Input[builtins.str] mode: What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
        :param pulumi.Input[builtins.str] web_url: Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambda_function_name`
        """
        if lambda_function_name is not None:
            pulumi.set(__self__, "lambda_function_name", lambda_function_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @property
    @pulumi.getter(name="lambdaFunctionName")
    def lambda_function_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Lambda function name or ARN to be called for delivery. Conflicts with `web_url`
        """
        return pulumi.get(self, "lambda_function_name")

    @lambda_function_name.setter
    def lambda_function_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lambda_function_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        What mode Lambda should be invoked in. Valid values for this parameter are `DELIVERY`, `FILTER`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request. Conflicts with `lambda_function_name`
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class AppLimitsArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of messages that the campaign can send daily.
        """
        maximum_duration: NotRequired[pulumi.Input[builtins.int]]
        """
        The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        """
        messages_per_second: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        """
        total: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum total number of messages that the campaign can send.
        """
elif False:
    AppLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLimitsArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input[builtins.int]] = None,
                 maximum_duration: Optional[pulumi.Input[builtins.int]] = None,
                 messages_per_second: Optional[pulumi.Input[builtins.int]] = None,
                 total: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] daily: The maximum number of messages that the campaign can send daily.
        :param pulumi.Input[builtins.int] maximum_duration: The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        :param pulumi.Input[builtins.int] messages_per_second: The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        :param pulumi.Input[builtins.int] total: The maximum total number of messages that the campaign can send.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if messages_per_second is not None:
            pulumi.set(__self__, "messages_per_second", messages_per_second)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of messages that the campaign can send daily.
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "daily", value)

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        """
        return pulumi.get(self, "maximum_duration")

    @maximum_duration.setter
    def maximum_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_duration", value)

    @property
    @pulumi.getter(name="messagesPerSecond")
    def messages_per_second(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        """
        return pulumi.get(self, "messages_per_second")

    @messages_per_second.setter
    def messages_per_second(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "messages_per_second", value)

    @property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum total number of messages that the campaign can send.
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "total", value)


if not MYPY:
    class AppQuietTimeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[builtins.str]]
        """
        The default end time for quiet time in ISO 8601 format. Required if `start` is set
        """
        start: NotRequired[pulumi.Input[builtins.str]]
        """
        The default start time for quiet time in ISO 8601 format. Required if `end` is set
        """
elif False:
    AppQuietTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppQuietTimeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[builtins.str]] = None,
                 start: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] end: The default end time for quiet time in ISO 8601 format. Required if `start` is set
        :param pulumi.Input[builtins.str] start: The default start time for quiet time in ISO 8601 format. Required if `end` is set
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default end time for quiet time in ISO 8601 format. Required if `start` is set
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default start time for quiet time in ISO 8601 format. Required if `end` is set
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class EmailTemplateEmailTemplateArgsDict(TypedDict):
        default_substitutions: NotRequired[pulumi.Input[builtins.str]]
        """
        JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgsDict']]]]
        html_part: NotRequired[pulumi.Input[builtins.str]]
        """
        The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        """
        recommender_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        """
        subject: NotRequired[pulumi.Input[builtins.str]]
        """
        Subject line, or title, to use in email messages that are based on the message template.
        """
        text_part: NotRequired[pulumi.Input[builtins.str]]
        """
        Message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
elif False:
    EmailTemplateEmailTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailTemplateEmailTemplateArgs:
    def __init__(__self__, *,
                 default_substitutions: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]] = None,
                 html_part: Optional[pulumi.Input[builtins.str]] = None,
                 recommender_id: Optional[pulumi.Input[builtins.str]] = None,
                 subject: Optional[pulumi.Input[builtins.str]] = None,
                 text_part: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] default_substitutions: JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        :param pulumi.Input[builtins.str] html_part: The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        :param pulumi.Input[builtins.str] recommender_id: The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        :param pulumi.Input[builtins.str] subject: Subject line, or title, to use in email messages that are based on the message template.
        :param pulumi.Input[builtins.str] text_part: Message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        if default_substitutions is not None:
            pulumi.set(__self__, "default_substitutions", default_substitutions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_part is not None:
            pulumi.set(__self__, "html_part", html_part)
        if recommender_id is not None:
            pulumi.set(__self__, "recommender_id", recommender_id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if text_part is not None:
            pulumi.set(__self__, "text_part", text_part)

    @property
    @pulumi.getter(name="defaultSubstitutions")
    def default_substitutions(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        """
        return pulumi.get(self, "default_substitutions")

    @default_substitutions.setter
    def default_substitutions(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_substitutions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="htmlPart")
    def html_part(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        """
        return pulumi.get(self, "html_part")

    @html_part.setter
    def html_part(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "html_part", value)

    @property
    @pulumi.getter(name="recommenderId")
    def recommender_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        """
        return pulumi.get(self, "recommender_id")

    @recommender_id.setter
    def recommender_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recommender_id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subject line, or title, to use in email messages that are based on the message template.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="textPart")
    def text_part(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        return pulumi.get(self, "text_part")

    @text_part.setter
    def text_part(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text_part", value)


if not MYPY:
    class EmailTemplateEmailTemplateHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the message header. The header name can contain up to 126 characters.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        """
elif False:
    EmailTemplateEmailTemplateHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailTemplateEmailTemplateHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the message header. The header name can contain up to 126 characters.
        :param pulumi.Input[builtins.str] value: Value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the message header. The header name can contain up to 126 characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Smsvoicev2PhoneNumberTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    Smsvoicev2PhoneNumberTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Smsvoicev2PhoneNumberTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


