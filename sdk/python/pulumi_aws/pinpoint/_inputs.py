# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppCampaignHookArgs',
    'AppCampaignHookArgsDict',
    'AppLimitsArgs',
    'AppLimitsArgsDict',
    'AppQuietTimeArgs',
    'AppQuietTimeArgsDict',
    'EmailTemplateEmailTemplateArgs',
    'EmailTemplateEmailTemplateArgsDict',
    'EmailTemplateEmailTemplateHeaderArgs',
    'EmailTemplateEmailTemplateHeaderArgsDict',
    'Smsvoicev2PhoneNumberTimeoutsArgs',
    'Smsvoicev2PhoneNumberTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class AppCampaignHookArgsDict(TypedDict):
        lambda_function_name: NotRequired[pulumi.Input[_builtins.str]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
        web_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AppCampaignHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppCampaignHookArgs:
    def __init__(__self__, *,
                 lambda_function_name: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 web_url: Optional[pulumi.Input[_builtins.str]] = None):
        if lambda_function_name is not None:
            pulumi.set(__self__, "lambda_function_name", lambda_function_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionName")
    def lambda_function_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lambda_function_name")

    @lambda_function_name.setter
    def lambda_function_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_function_name", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class AppLimitsArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input[_builtins.int]]
        maximum_duration: NotRequired[pulumi.Input[_builtins.int]]
        messages_per_second: NotRequired[pulumi.Input[_builtins.int]]
        total: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AppLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLimitsArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 messages_per_second: Optional[pulumi.Input[_builtins.int]] = None,
                 total: Optional[pulumi.Input[_builtins.int]] = None):
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if messages_per_second is not None:
            pulumi.set(__self__, "messages_per_second", messages_per_second)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_duration")

    @maximum_duration.setter
    def maximum_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_duration", value)

    @_builtins.property
    @pulumi.getter(name="messagesPerSecond")
    def messages_per_second(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "messages_per_second")

    @messages_per_second.setter
    def messages_per_second(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "messages_per_second", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total", value)


if not MYPY:
    class AppQuietTimeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input[_builtins.str]]
        start: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AppQuietTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppQuietTimeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[_builtins.str]] = None,
                 start: Optional[pulumi.Input[_builtins.str]] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start", value)


if not MYPY:
    class EmailTemplateEmailTemplateArgsDict(TypedDict):
        default_substitutions: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgsDict']]]]
        html_part: NotRequired[pulumi.Input[_builtins.str]]
        recommender_id: NotRequired[pulumi.Input[_builtins.str]]
        subject: NotRequired[pulumi.Input[_builtins.str]]
        text_part: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EmailTemplateEmailTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailTemplateEmailTemplateArgs:
    def __init__(__self__, *,
                 default_substitutions: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]] = None,
                 html_part: Optional[pulumi.Input[_builtins.str]] = None,
                 recommender_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 text_part: Optional[pulumi.Input[_builtins.str]] = None):
        if default_substitutions is not None:
            pulumi.set(__self__, "default_substitutions", default_substitutions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_part is not None:
            pulumi.set(__self__, "html_part", html_part)
        if recommender_id is not None:
            pulumi.set(__self__, "recommender_id", recommender_id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if text_part is not None:
            pulumi.set(__self__, "text_part", text_part)

    @_builtins.property
    @pulumi.getter(name="defaultSubstitutions")
    def default_substitutions(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_substitutions")

    @default_substitutions.setter
    def default_substitutions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_substitutions", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailTemplateEmailTemplateHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="htmlPart")
    def html_part(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "html_part")

    @html_part.setter
    def html_part(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_part", value)

    @_builtins.property
    @pulumi.getter(name="recommenderId")
    def recommender_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recommender_id")

    @recommender_id.setter
    def recommender_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommender_id", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="textPart")
    def text_part(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text_part")

    @text_part.setter
    def text_part(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_part", value)


if not MYPY:
    class EmailTemplateEmailTemplateHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EmailTemplateEmailTemplateHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailTemplateEmailTemplateHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Smsvoicev2PhoneNumberTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    Smsvoicev2PhoneNumberTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Smsvoicev2PhoneNumberTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


