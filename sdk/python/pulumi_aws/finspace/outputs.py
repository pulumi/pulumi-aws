# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'KxClusterAutoScalingConfiguration',
    'KxClusterCacheStorageConfiguration',
    'KxClusterCapacityConfiguration',
    'KxClusterCode',
    'KxClusterDatabase',
    'KxClusterDatabaseCacheConfiguration',
    'KxClusterSavedownStorageConfiguration',
    'KxClusterScalingGroupConfiguration',
    'KxClusterTickerplantLogConfiguration',
    'KxClusterVpcConfiguration',
    'KxDataviewSegmentConfiguration',
    'KxEnvironmentCustomDnsConfiguration',
    'KxEnvironmentTransitGatewayConfiguration',
    'KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration',
    'KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode',
    'KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange',
    'KxVolumeAttachedCluster',
    'KxVolumeNas1Configuration',
]

@pulumi.output_type
class KxClusterAutoScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScalingMetric":
            suggest = "auto_scaling_metric"
        elif key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "metricTarget":
            suggest = "metric_target"
        elif key == "minNodeCount":
            suggest = "min_node_count"
        elif key == "scaleInCooldownSeconds":
            suggest = "scale_in_cooldown_seconds"
        elif key == "scaleOutCooldownSeconds":
            suggest = "scale_out_cooldown_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterAutoScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterAutoScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterAutoScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scaling_metric: _builtins.str,
                 max_node_count: _builtins.int,
                 metric_target: _builtins.float,
                 min_node_count: _builtins.int,
                 scale_in_cooldown_seconds: _builtins.float,
                 scale_out_cooldown_seconds: _builtins.float):
        pulumi.set(__self__, "auto_scaling_metric", auto_scaling_metric)
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "metric_target", metric_target)
        pulumi.set(__self__, "min_node_count", min_node_count)
        pulumi.set(__self__, "scale_in_cooldown_seconds", scale_in_cooldown_seconds)
        pulumi.set(__self__, "scale_out_cooldown_seconds", scale_out_cooldown_seconds)

    @_builtins.property
    @pulumi.getter(name="autoScalingMetric")
    def auto_scaling_metric(self) -> _builtins.str:
        return pulumi.get(self, "auto_scaling_metric")

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> _builtins.int:
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter(name="metricTarget")
    def metric_target(self) -> _builtins.float:
        return pulumi.get(self, "metric_target")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> _builtins.int:
        return pulumi.get(self, "min_node_count")

    @_builtins.property
    @pulumi.getter(name="scaleInCooldownSeconds")
    def scale_in_cooldown_seconds(self) -> _builtins.float:
        return pulumi.get(self, "scale_in_cooldown_seconds")

    @_builtins.property
    @pulumi.getter(name="scaleOutCooldownSeconds")
    def scale_out_cooldown_seconds(self) -> _builtins.float:
        return pulumi.get(self, "scale_out_cooldown_seconds")


@pulumi.output_type
class KxClusterCacheStorageConfiguration(dict):
    def __init__(__self__, *,
                 size: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class KxClusterCapacityConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterCapacityConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterCapacityConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterCapacityConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: _builtins.int,
                 node_type: _builtins.str):
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        return pulumi.get(self, "node_type")


@pulumi.output_type
class KxClusterCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Key":
            suggest = "s3_key"
        elif key == "s3ObjectVersion":
            suggest = "s3_object_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket: _builtins.str,
                 s3_key: _builtins.str,
                 s3_object_version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> _builtins.str:
        return pulumi.get(self, "s3_bucket")

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> _builtins.str:
        return pulumi.get(self, "s3_key")

    @_builtins.property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "s3_object_version")


@pulumi.output_type
class KxClusterDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "cacheConfigurations":
            suggest = "cache_configurations"
        elif key == "changesetId":
            suggest = "changeset_id"
        elif key == "dataviewName":
            suggest = "dataview_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 cache_configurations: Optional[Sequence['outputs.KxClusterDatabaseCacheConfiguration']] = None,
                 changeset_id: Optional[_builtins.str] = None,
                 dataview_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        if cache_configurations is not None:
            pulumi.set(__self__, "cache_configurations", cache_configurations)
        if changeset_id is not None:
            pulumi.set(__self__, "changeset_id", changeset_id)
        if dataview_name is not None:
            pulumi.set(__self__, "dataview_name", dataview_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="cacheConfigurations")
    def cache_configurations(self) -> Optional[Sequence['outputs.KxClusterDatabaseCacheConfiguration']]:
        return pulumi.get(self, "cache_configurations")

    @_builtins.property
    @pulumi.getter(name="changesetId")
    def changeset_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "changeset_id")

    @_builtins.property
    @pulumi.getter(name="dataviewName")
    def dataview_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dataview_name")


@pulumi.output_type
class KxClusterDatabaseCacheConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheType":
            suggest = "cache_type"
        elif key == "dbPaths":
            suggest = "db_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterDatabaseCacheConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterDatabaseCacheConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterDatabaseCacheConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_type: _builtins.str,
                 db_paths: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "cache_type", cache_type)
        if db_paths is not None:
            pulumi.set(__self__, "db_paths", db_paths)

    @_builtins.property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> _builtins.str:
        return pulumi.get(self, "cache_type")

    @_builtins.property
    @pulumi.getter(name="dbPaths")
    def db_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "db_paths")


@pulumi.output_type
class KxClusterSavedownStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterSavedownStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterSavedownStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterSavedownStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 volume_name: Optional[_builtins.str] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class KxClusterScalingGroupConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryReservation":
            suggest = "memory_reservation"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "scalingGroupName":
            suggest = "scaling_group_name"
        elif key == "memoryLimit":
            suggest = "memory_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterScalingGroupConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterScalingGroupConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterScalingGroupConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_reservation: _builtins.int,
                 node_count: _builtins.int,
                 scaling_group_name: _builtins.str,
                 cpu: Optional[_builtins.float] = None,
                 memory_limit: Optional[_builtins.int] = None):
        pulumi.set(__self__, "memory_reservation", memory_reservation)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "scaling_group_name", scaling_group_name)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)

    @_builtins.property
    @pulumi.getter(name="memoryReservation")
    def memory_reservation(self) -> _builtins.int:
        return pulumi.get(self, "memory_reservation")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="scalingGroupName")
    def scaling_group_name(self) -> _builtins.str:
        return pulumi.get(self, "scaling_group_name")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory_limit")


@pulumi.output_type
class KxClusterTickerplantLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tickerplantLogVolumes":
            suggest = "tickerplant_log_volumes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterTickerplantLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterTickerplantLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterTickerplantLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tickerplant_log_volumes: Sequence[_builtins.str]):
        pulumi.set(__self__, "tickerplant_log_volumes", tickerplant_log_volumes)

    @_builtins.property
    @pulumi.getter(name="tickerplantLogVolumes")
    def tickerplant_log_volumes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tickerplant_log_volumes")


@pulumi.output_type
class KxClusterVpcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxClusterVpcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxClusterVpcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxClusterVpcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_type: _builtins.str,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "ip_address_type", ip_address_type)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> _builtins.str:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class KxDataviewSegmentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPaths":
            suggest = "db_paths"
        elif key == "volumeName":
            suggest = "volume_name"
        elif key == "onDemand":
            suggest = "on_demand"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxDataviewSegmentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxDataviewSegmentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxDataviewSegmentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_paths: Sequence[_builtins.str],
                 volume_name: _builtins.str,
                 on_demand: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "db_paths", db_paths)
        pulumi.set(__self__, "volume_name", volume_name)
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)

    @_builtins.property
    @pulumi.getter(name="dbPaths")
    def db_paths(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "db_paths")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> _builtins.str:
        return pulumi.get(self, "volume_name")

    @_builtins.property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "on_demand")


@pulumi.output_type
class KxEnvironmentCustomDnsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDnsServerIp":
            suggest = "custom_dns_server_ip"
        elif key == "customDnsServerName":
            suggest = "custom_dns_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxEnvironmentCustomDnsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxEnvironmentCustomDnsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxEnvironmentCustomDnsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_dns_server_ip: _builtins.str,
                 custom_dns_server_name: _builtins.str):
        pulumi.set(__self__, "custom_dns_server_ip", custom_dns_server_ip)
        pulumi.set(__self__, "custom_dns_server_name", custom_dns_server_name)

    @_builtins.property
    @pulumi.getter(name="customDnsServerIp")
    def custom_dns_server_ip(self) -> _builtins.str:
        return pulumi.get(self, "custom_dns_server_ip")

    @_builtins.property
    @pulumi.getter(name="customDnsServerName")
    def custom_dns_server_name(self) -> _builtins.str:
        return pulumi.get(self, "custom_dns_server_name")


@pulumi.output_type
class KxEnvironmentTransitGatewayConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routableCidrSpace":
            suggest = "routable_cidr_space"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "attachmentNetworkAclConfigurations":
            suggest = "attachment_network_acl_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxEnvironmentTransitGatewayConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxEnvironmentTransitGatewayConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxEnvironmentTransitGatewayConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routable_cidr_space: _builtins.str,
                 transit_gateway_id: _builtins.str,
                 attachment_network_acl_configurations: Optional[Sequence['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration']] = None):
        pulumi.set(__self__, "routable_cidr_space", routable_cidr_space)
        pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if attachment_network_acl_configurations is not None:
            pulumi.set(__self__, "attachment_network_acl_configurations", attachment_network_acl_configurations)

    @_builtins.property
    @pulumi.getter(name="routableCidrSpace")
    def routable_cidr_space(self) -> _builtins.str:
        return pulumi.get(self, "routable_cidr_space")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> _builtins.str:
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="attachmentNetworkAclConfigurations")
    def attachment_network_acl_configurations(self) -> Optional[Sequence['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration']]:
        return pulumi.get(self, "attachment_network_acl_configurations")


@pulumi.output_type
class KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"
        elif key == "icmpTypeCode":
            suggest = "icmp_type_code"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 protocol: _builtins.str,
                 rule_action: _builtins.str,
                 rule_number: _builtins.int,
                 icmp_type_code: Optional['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode'] = None,
                 port_range: Optional['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange'] = None):
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rule_action", rule_action)
        pulumi.set(__self__, "rule_number", rule_number)
        if icmp_type_code is not None:
            pulumi.set(__self__, "icmp_type_code", icmp_type_code)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> _builtins.str:
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> _builtins.int:
        return pulumi.get(self, "rule_number")

    @_builtins.property
    @pulumi.getter(name="icmpTypeCode")
    def icmp_type_code(self) -> Optional['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode']:
        return pulumi.get(self, "icmp_type_code")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange']:
        return pulumi.get(self, "port_range")


@pulumi.output_type
class KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationIcmpTypeCode(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 type: _builtins.int):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.int:
        return pulumi.get(self, "type")


@pulumi.output_type
class KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxEnvironmentTransitGatewayConfigurationAttachmentNetworkAclConfigurationPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: _builtins.int,
                 to: _builtins.int):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.int:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.int:
        return pulumi.get(self, "to")


@pulumi.output_type
class KxVolumeAttachedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "clusterStatus":
            suggest = "cluster_status"
        elif key == "clusterType":
            suggest = "cluster_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KxVolumeAttachedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KxVolumeAttachedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KxVolumeAttachedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 cluster_status: _builtins.str,
                 cluster_type: _builtins.str):
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_status", cluster_status)
        pulumi.set(__self__, "cluster_type", cluster_type)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterStatus")
    def cluster_status(self) -> _builtins.str:
        return pulumi.get(self, "cluster_status")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        return pulumi.get(self, "cluster_type")


@pulumi.output_type
class KxVolumeNas1Configuration(dict):
    def __init__(__self__, *,
                 size: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


