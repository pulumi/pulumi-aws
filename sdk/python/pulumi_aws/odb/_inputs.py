# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CloudAutonomousVmClusterMaintenanceWindowArgs',
    'CloudAutonomousVmClusterMaintenanceWindowArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowMonthArgs',
    'CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict',
    'CloudAutonomousVmClusterTimeoutsArgs',
    'CloudAutonomousVmClusterTimeoutsArgsDict',
    'CloudExadataInfrastructureCustomerContactsToSendToOciArgs',
    'CloudExadataInfrastructureCustomerContactsToSendToOciArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowArgs',
    'CloudExadataInfrastructureMaintenanceWindowArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowMonthArgs',
    'CloudExadataInfrastructureMaintenanceWindowMonthArgsDict',
    'CloudExadataInfrastructureTimeoutsArgs',
    'CloudExadataInfrastructureTimeoutsArgsDict',
    'CloudVmClusterDataCollectionOptionsArgs',
    'CloudVmClusterDataCollectionOptionsArgsDict',
    'CloudVmClusterIormConfigCacheArgs',
    'CloudVmClusterIormConfigCacheArgsDict',
    'CloudVmClusterIormConfigCacheDbPlanArgs',
    'CloudVmClusterIormConfigCacheDbPlanArgsDict',
    'CloudVmClusterTimeoutsArgs',
    'CloudVmClusterTimeoutsArgsDict',
    'NetworkManagedServiceArgs',
    'NetworkManagedServiceArgsDict',
    'NetworkManagedServiceManagedS3BackupAccessArgs',
    'NetworkManagedServiceManagedS3BackupAccessArgsDict',
    'NetworkManagedServiceS3AccessArgs',
    'NetworkManagedServiceS3AccessArgsDict',
    'NetworkManagedServiceServiceNetworkEndpointArgs',
    'NetworkManagedServiceServiceNetworkEndpointArgsDict',
    'NetworkManagedServiceZeroEtlAccessArgs',
    'NetworkManagedServiceZeroEtlAccessArgsDict',
    'NetworkOciDnsForwardingConfigArgs',
    'NetworkOciDnsForwardingConfigArgsDict',
    'NetworkPeeringConnectionTimeoutsArgs',
    'NetworkPeeringConnectionTimeoutsArgsDict',
    'NetworkTimeoutsArgs',
    'NetworkTimeoutsArgsDict',
    'GetNetworkPeeringConnectionsOdbPeeringConnectionArgs',
    'GetNetworkPeeringConnectionsOdbPeeringConnectionArgsDict',
]

MYPY = False

if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowArgsDict(TypedDict):
        preference: pulumi.Input[_builtins.str]
        """
        The preference for the maintenance window scheduling.
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        The days of the week when maintenance can be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The hours of the day when maintenance can be performed.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lead time in weeks before the maintenance window.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict']]]]
        """
        The months when maintenance can be performed.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Indicates whether to skip release updates during maintenance.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[_builtins.str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[_builtins.int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] preference: The preference for the maintenance window scheduling.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: The days of the week when maintenance can be performed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] hours_of_days: The hours of the day when maintenance can be performed.
        :param pulumi.Input[_builtins.int] lead_time_in_weeks: The lead time in weeks before the maintenance window.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]] months: The months when maintenance can be performed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] weeks_of_months: Indicates whether to skip release updates during maintenance.
        """
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> pulumi.Input[_builtins.str]:
        """
        The preference for the maintenance window scheduling.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "preference", value)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        The days of the week when maintenance can be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The hours of the day when maintenance can be performed.
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lead time in weeks before the maintenance window.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]:
        """
        The months when maintenance can be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Indicates whether to skip release updates during maintenance.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAutonomousVmClusterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CloudAutonomousVmClusterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CloudExadataInfrastructureCustomerContactsToSendToOciArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
elif False:
    CloudExadataInfrastructureCustomerContactsToSendToOciArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureCustomerContactsToSendToOciArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: pulumi.Input[_builtins.int]
        """
        The custom action timeout in minutes for the maintenance window.
        """
        is_custom_action_timeout_enabled: pulumi.Input[_builtins.bool]
        """
        ndicates whether custom action timeout is enabled for the maintenance window.
        """
        patching_mode: pulumi.Input[_builtins.str]
        """
        The patching mode for the maintenance window.
        """
        preference: pulumi.Input[_builtins.str]
        """
        The preference for the maintenance window scheduling.
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        The days of the week when maintenance can be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The hours of the day when maintenance can be performed.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lead time in weeks before the maintenance window.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgsDict']]]]
        """
        The months when maintenance can be performed.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        The weeks of the month when maintenance can be performed.
        """
elif False:
    CloudExadataInfrastructureMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: pulumi.Input[_builtins.int],
                 is_custom_action_timeout_enabled: pulumi.Input[_builtins.bool],
                 patching_mode: pulumi.Input[_builtins.str],
                 preference: pulumi.Input[_builtins.str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[_builtins.int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] custom_action_timeout_in_mins: The custom action timeout in minutes for the maintenance window.
        :param pulumi.Input[_builtins.bool] is_custom_action_timeout_enabled: ndicates whether custom action timeout is enabled for the maintenance window.
        :param pulumi.Input[_builtins.str] patching_mode: The patching mode for the maintenance window.
        :param pulumi.Input[_builtins.str] preference: The preference for the maintenance window scheduling.
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: The days of the week when maintenance can be performed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] hours_of_days: The hours of the day when maintenance can be performed.
        :param pulumi.Input[_builtins.int] lead_time_in_weeks: The lead time in weeks before the maintenance window.
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]] months: The months when maintenance can be performed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] weeks_of_months: The weeks of the month when maintenance can be performed.
        """
        pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        pulumi.set(__self__, "patching_mode", patching_mode)
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @_builtins.property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> pulumi.Input[_builtins.int]:
        """
        The custom action timeout in minutes for the maintenance window.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @_builtins.property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        ndicates whether custom action timeout is enabled for the maintenance window.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> pulumi.Input[_builtins.str]:
        """
        The patching mode for the maintenance window.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "patching_mode", value)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> pulumi.Input[_builtins.str]:
        """
        The preference for the maintenance window scheduling.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "preference", value)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        The days of the week when maintenance can be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @_builtins.property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The hours of the day when maintenance can be performed.
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @_builtins.property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lead time in weeks before the maintenance window.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        The months when maintenance can be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @_builtins.property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        The weeks of the month when maintenance can be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowMonthArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    CloudExadataInfrastructureMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudExadataInfrastructureTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CloudExadataInfrastructureTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CloudVmClusterDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: pulumi.Input[_builtins.bool]
        is_health_monitoring_enabled: pulumi.Input[_builtins.bool]
        is_incident_logs_enabled: pulumi.Input[_builtins.bool]
elif False:
    CloudVmClusterDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: pulumi.Input[_builtins.bool],
                 is_health_monitoring_enabled: pulumi.Input[_builtins.bool],
                 is_incident_logs_enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @_builtins.property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class CloudVmClusterIormConfigCacheArgsDict(TypedDict):
        db_plans: pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCacheDbPlanArgsDict']]]
        lifecycle_details: pulumi.Input[_builtins.str]
        lifecycle_state: pulumi.Input[_builtins.str]
        objective: pulumi.Input[_builtins.str]
elif False:
    CloudVmClusterIormConfigCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterIormConfigCacheArgs:
    def __init__(__self__, *,
                 db_plans: pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCacheDbPlanArgs']]],
                 lifecycle_details: pulumi.Input[_builtins.str],
                 lifecycle_state: pulumi.Input[_builtins.str],
                 objective: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "db_plans", db_plans)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "lifecycle_state", lifecycle_state)
        pulumi.set(__self__, "objective", objective)

    @_builtins.property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCacheDbPlanArgs']]]:
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCacheDbPlanArgs']]]):
        pulumi.set(self, "db_plans", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lifecycle_details", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lifecycle_state")

    @lifecycle_state.setter
    def lifecycle_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lifecycle_state", value)

    @_builtins.property
    @pulumi.getter
    def objective(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "objective", value)


if not MYPY:
    class CloudVmClusterIormConfigCacheDbPlanArgsDict(TypedDict):
        db_name: pulumi.Input[_builtins.str]
        flash_cache_limit: pulumi.Input[_builtins.str]
        share: pulumi.Input[_builtins.int]
elif False:
    CloudVmClusterIormConfigCacheDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterIormConfigCacheDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[_builtins.str],
                 flash_cache_limit: pulumi.Input[_builtins.str],
                 share: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        pulumi.set(__self__, "share", share)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "db_name", value)

    @_builtins.property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flash_cache_limit", value)

    @_builtins.property
    @pulumi.getter
    def share(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "share", value)


if not MYPY:
    class CloudVmClusterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CloudVmClusterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetworkManagedServiceArgsDict(TypedDict):
        managed_s3_backup_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceManagedS3BackupAccessArgsDict']]]
        managed_service_ipv4_cidrs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        resource_gateway_arn: pulumi.Input[_builtins.str]
        s3_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceS3AccessArgsDict']]]
        """
        Specifies the configuration for Amazon S3 access from the ODB network.
        """
        service_network_arn: pulumi.Input[_builtins.str]
        service_network_endpoints: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceServiceNetworkEndpointArgsDict']]]
        zero_etl_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceZeroEtlAccessArgsDict']]]
        """
        Specifies the configuration for Zero-ETL access from the ODB network.

        The following arguments are optional:
        """
elif False:
    NetworkManagedServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkManagedServiceArgs:
    def __init__(__self__, *,
                 managed_s3_backup_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceManagedS3BackupAccessArgs']]],
                 managed_service_ipv4_cidrs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 resource_gateway_arn: pulumi.Input[_builtins.str],
                 s3_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceS3AccessArgs']]],
                 service_network_arn: pulumi.Input[_builtins.str],
                 service_network_endpoints: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceServiceNetworkEndpointArgs']]],
                 zero_etl_accesses: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceZeroEtlAccessArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceS3AccessArgs']]] s3_accesses: Specifies the configuration for Amazon S3 access from the ODB network.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceZeroEtlAccessArgs']]] zero_etl_accesses: Specifies the configuration for Zero-ETL access from the ODB network.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "managed_s3_backup_accesses", managed_s3_backup_accesses)
        pulumi.set(__self__, "managed_service_ipv4_cidrs", managed_service_ipv4_cidrs)
        pulumi.set(__self__, "resource_gateway_arn", resource_gateway_arn)
        pulumi.set(__self__, "s3_accesses", s3_accesses)
        pulumi.set(__self__, "service_network_arn", service_network_arn)
        pulumi.set(__self__, "service_network_endpoints", service_network_endpoints)
        pulumi.set(__self__, "zero_etl_accesses", zero_etl_accesses)

    @_builtins.property
    @pulumi.getter(name="managedS3BackupAccesses")
    def managed_s3_backup_accesses(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceManagedS3BackupAccessArgs']]]:
        return pulumi.get(self, "managed_s3_backup_accesses")

    @managed_s3_backup_accesses.setter
    def managed_s3_backup_accesses(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceManagedS3BackupAccessArgs']]]):
        pulumi.set(self, "managed_s3_backup_accesses", value)

    @_builtins.property
    @pulumi.getter(name="managedServiceIpv4Cidrs")
    def managed_service_ipv4_cidrs(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "managed_service_ipv4_cidrs")

    @managed_service_ipv4_cidrs.setter
    def managed_service_ipv4_cidrs(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "managed_service_ipv4_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="resourceGatewayArn")
    def resource_gateway_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_gateway_arn")

    @resource_gateway_arn.setter
    def resource_gateway_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_gateway_arn", value)

    @_builtins.property
    @pulumi.getter(name="s3Accesses")
    def s3_accesses(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceS3AccessArgs']]]:
        """
        Specifies the configuration for Amazon S3 access from the ODB network.
        """
        return pulumi.get(self, "s3_accesses")

    @s3_accesses.setter
    def s3_accesses(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceS3AccessArgs']]]):
        pulumi.set(self, "s3_accesses", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetworkArn")
    def service_network_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "service_network_arn")

    @service_network_arn.setter
    def service_network_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_network_arn", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetworkEndpoints")
    def service_network_endpoints(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceServiceNetworkEndpointArgs']]]:
        return pulumi.get(self, "service_network_endpoints")

    @service_network_endpoints.setter
    def service_network_endpoints(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceServiceNetworkEndpointArgs']]]):
        pulumi.set(self, "service_network_endpoints", value)

    @_builtins.property
    @pulumi.getter(name="zeroEtlAccesses")
    def zero_etl_accesses(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceZeroEtlAccessArgs']]]:
        """
        Specifies the configuration for Zero-ETL access from the ODB network.

        The following arguments are optional:
        """
        return pulumi.get(self, "zero_etl_accesses")

    @zero_etl_accesses.setter
    def zero_etl_accesses(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkManagedServiceZeroEtlAccessArgs']]]):
        pulumi.set(self, "zero_etl_accesses", value)


if not MYPY:
    class NetworkManagedServiceManagedS3BackupAccessArgsDict(TypedDict):
        ipv4_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        status: pulumi.Input[_builtins.str]
        """
        The status of the network resource.
        """
elif False:
    NetworkManagedServiceManagedS3BackupAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkManagedServiceManagedS3BackupAccessArgs:
    def __init__(__self__, *,
                 ipv4_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: The status of the network resource.
        """
        pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "ipv4_addresses")

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ipv4_addresses", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        The status of the network resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NetworkManagedServiceS3AccessArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        ipv4_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        s3_policy_document: pulumi.Input[_builtins.str]
        """
        Specifies the endpoint policy for Amazon S3 access from the ODB network.
        """
        status: pulumi.Input[_builtins.str]
        """
        The status of the network resource.
        """
elif False:
    NetworkManagedServiceS3AccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkManagedServiceS3AccessArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 ipv4_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 s3_policy_document: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_policy_document: Specifies the endpoint policy for Amazon S3 access from the ODB network.
        :param pulumi.Input[_builtins.str] status: The status of the network resource.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        pulumi.set(__self__, "s3_policy_document", s3_policy_document)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "ipv4_addresses")

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ipv4_addresses", value)

    @_builtins.property
    @pulumi.getter(name="s3PolicyDocument")
    def s3_policy_document(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the endpoint policy for Amazon S3 access from the ODB network.
        """
        return pulumi.get(self, "s3_policy_document")

    @s3_policy_document.setter
    def s3_policy_document(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_policy_document", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        The status of the network resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NetworkManagedServiceServiceNetworkEndpointArgsDict(TypedDict):
        vpc_endpoint_id: pulumi.Input[_builtins.str]
        vpc_endpoint_type: pulumi.Input[_builtins.str]
elif False:
    NetworkManagedServiceServiceNetworkEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkManagedServiceServiceNetworkEndpointArgs:
    def __init__(__self__, *,
                 vpc_endpoint_id: pulumi.Input[_builtins.str],
                 vpc_endpoint_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)
        pulumi.set(__self__, "vpc_endpoint_type", vpc_endpoint_type)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_id")

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointType")
    def vpc_endpoint_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_type")

    @vpc_endpoint_type.setter
    def vpc_endpoint_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_endpoint_type", value)


if not MYPY:
    class NetworkManagedServiceZeroEtlAccessArgsDict(TypedDict):
        cidr: pulumi.Input[_builtins.str]
        status: pulumi.Input[_builtins.str]
        """
        The status of the network resource.
        """
elif False:
    NetworkManagedServiceZeroEtlAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkManagedServiceZeroEtlAccessArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: The status of the network resource.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        The status of the network resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NetworkOciDnsForwardingConfigArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        oci_dns_listener_ip: pulumi.Input[_builtins.str]
elif False:
    NetworkOciDnsForwardingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkOciDnsForwardingConfigArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 oci_dns_listener_ip: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "oci_dns_listener_ip", oci_dns_listener_ip)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="ociDnsListenerIp")
    def oci_dns_listener_ip(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oci_dns_listener_ip")

    @oci_dns_listener_ip.setter
    def oci_dns_listener_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oci_dns_listener_ip", value)


if not MYPY:
    class NetworkPeeringConnectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetworkPeeringConnectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeeringConnectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NetworkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    NetworkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GetNetworkPeeringConnectionsOdbPeeringConnectionArgsDict(TypedDict):
        arn: _builtins.str
        """
        The Amazon Resource Name (ARN) for the  ODB network peering connection.
        """
        display_name: _builtins.str
        """
        Display name of the ODB network peering connection.
        """
        id: _builtins.str
        """
        The unique identifier of the  ODB network peering connection.
        """
        odb_network_arn: _builtins.str
        """
        ARN of the ODB network peering connection.
        """
        peer_network_arn: _builtins.str
        """
        ARN of the peer network peering connection.
        """
elif False:
    GetNetworkPeeringConnectionsOdbPeeringConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkPeeringConnectionsOdbPeeringConnectionArgs:
    def __init__(__self__, *,
                 arn: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 odb_network_arn: _builtins.str,
                 peer_network_arn: _builtins.str):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) for the  ODB network peering connection.
        :param _builtins.str display_name: Display name of the ODB network peering connection.
        :param _builtins.str id: The unique identifier of the  ODB network peering connection.
        :param _builtins.str odb_network_arn: ARN of the ODB network peering connection.
        :param _builtins.str peer_network_arn: ARN of the peer network peering connection.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "odb_network_arn", odb_network_arn)
        pulumi.set(__self__, "peer_network_arn", peer_network_arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) for the  ODB network peering connection.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: _builtins.str):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Display name of the ODB network peering connection.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: _builtins.str):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier of the  ODB network peering connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="odbNetworkArn")
    def odb_network_arn(self) -> _builtins.str:
        """
        ARN of the ODB network peering connection.
        """
        return pulumi.get(self, "odb_network_arn")

    @odb_network_arn.setter
    def odb_network_arn(self, value: _builtins.str):
        pulumi.set(self, "odb_network_arn", value)

    @_builtins.property
    @pulumi.getter(name="peerNetworkArn")
    def peer_network_arn(self) -> _builtins.str:
        """
        ARN of the peer network peering connection.
        """
        return pulumi.get(self, "peer_network_arn")

    @peer_network_arn.setter
    def peer_network_arn(self, value: _builtins.str):
        pulumi.set(self, "peer_network_arn", value)


