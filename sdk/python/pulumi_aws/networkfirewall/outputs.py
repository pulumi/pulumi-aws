# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'FirewallEncryptionConfiguration',
    'FirewallFirewallStatus',
    'FirewallFirewallStatusSyncState',
    'FirewallFirewallStatusSyncStateAttachment',
    'FirewallPolicyEncryptionConfiguration',
    'FirewallPolicyFirewallPolicy',
    'FirewallPolicyFirewallPolicyPolicyVariables',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet',
    'FirewallPolicyFirewallPolicyStatefulEngineOptions',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReference',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride',
    'FirewallPolicyFirewallPolicyStatelessCustomAction',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReference',
    'FirewallSubnetMapping',
    'LoggingConfigurationLoggingConfiguration',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfig',
    'RuleGroupEncryptionConfiguration',
    'RuleGroupRuleGroup',
    'RuleGroupRuleGroupReferenceSets',
    'RuleGroupRuleGroupReferenceSetsIpSetReference',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference',
    'RuleGroupRuleGroupRuleVariables',
    'RuleGroupRuleGroupRuleVariablesIpSet',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSet',
    'RuleGroupRuleGroupRuleVariablesPortSet',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSet',
    'RuleGroupRuleGroupRulesSource',
    'RuleGroupRuleGroupRulesSourceRulesSourceList',
    'RuleGroupRuleGroupRulesSourceStatefulRule',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeader',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag',
    'RuleGroupRuleGroupStatefulRuleOptions',
    'GetFirewallEncryptionConfigurationResult',
    'GetFirewallFirewallStatusResult',
    'GetFirewallFirewallStatusCapacityUsageSummaryResult',
    'GetFirewallFirewallStatusCapacityUsageSummaryCidrResult',
    'GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult',
    'GetFirewallFirewallStatusSyncStateResult',
    'GetFirewallFirewallStatusSyncStateAttachmentResult',
    'GetFirewallPolicyFirewallPolicyResult',
    'GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult',
    'GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult',
    'GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult',
    'GetFirewallPolicyFirewallPolicyStatelessCustomActionResult',
    'GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult',
    'GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult',
    'GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult',
    'GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult',
    'GetFirewallSubnetMappingResult',
]

@pulumi.output_type
class FirewallEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 key_id: Optional[str] = None):
        """
        :param str type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param str key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        FirewallEncryptionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class FirewallFirewallStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "syncStates":
            suggest = "sync_states"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallFirewallStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallFirewallStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallFirewallStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sync_states: Optional[Sequence['outputs.FirewallFirewallStatusSyncState']] = None):
        """
        :param Sequence['FirewallFirewallStatusSyncStateArgs'] sync_states: Set of subnets configured for use by the firewall.
        """
        FirewallFirewallStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sync_states=sync_states,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sync_states: Optional[Sequence['outputs.FirewallFirewallStatusSyncState']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sync_states is None and 'syncStates' in kwargs:
            sync_states = kwargs['syncStates']

        if sync_states is not None:
            _setter("sync_states", sync_states)

    @property
    @pulumi.getter(name="syncStates")
    def sync_states(self) -> Optional[Sequence['outputs.FirewallFirewallStatusSyncState']]:
        """
        Set of subnets configured for use by the firewall.
        """
        return pulumi.get(self, "sync_states")


@pulumi.output_type
class FirewallFirewallStatusSyncState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallFirewallStatusSyncState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallFirewallStatusSyncState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallFirewallStatusSyncState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachments: Optional[Sequence['outputs.FirewallFirewallStatusSyncStateAttachment']] = None,
                 availability_zone: Optional[str] = None):
        """
        :param Sequence['FirewallFirewallStatusSyncStateAttachmentArgs'] attachments: Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        :param str availability_zone: The Availability Zone where the subnet is configured.
        """
        FirewallFirewallStatusSyncState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachments=attachments,
            availability_zone=availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachments: Optional[Sequence['outputs.FirewallFirewallStatusSyncStateAttachment']] = None,
             availability_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']

        if attachments is not None:
            _setter("attachments", attachments)
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)

    @property
    @pulumi.getter
    def attachments(self) -> Optional[Sequence['outputs.FirewallFirewallStatusSyncStateAttachment']]:
        """
        Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        """
        return pulumi.get(self, "attachments")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone where the subnet is configured.
        """
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class FirewallFirewallStatusSyncStateAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallFirewallStatusSyncStateAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallFirewallStatusSyncStateAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallFirewallStatusSyncStateAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str endpoint_id: The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        :param str subnet_id: The unique identifier for the subnet.
        """
        FirewallFirewallStatusSyncStateAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_id is None and 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class FirewallPolicyEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 key_id: Optional[str] = None):
        """
        :param str type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param str key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        FirewallPolicyEncryptionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class FirewallPolicyFirewallPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statelessDefaultActions":
            suggest = "stateless_default_actions"
        elif key == "statelessFragmentDefaultActions":
            suggest = "stateless_fragment_default_actions"
        elif key == "policyVariables":
            suggest = "policy_variables"
        elif key == "statefulDefaultActions":
            suggest = "stateful_default_actions"
        elif key == "statefulEngineOptions":
            suggest = "stateful_engine_options"
        elif key == "statefulRuleGroupReferences":
            suggest = "stateful_rule_group_references"
        elif key == "statelessCustomActions":
            suggest = "stateless_custom_actions"
        elif key == "statelessRuleGroupReferences":
            suggest = "stateless_rule_group_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stateless_default_actions: Sequence[str],
                 stateless_fragment_default_actions: Sequence[str],
                 policy_variables: Optional['outputs.FirewallPolicyFirewallPolicyPolicyVariables'] = None,
                 stateful_default_actions: Optional[Sequence[str]] = None,
                 stateful_engine_options: Optional['outputs.FirewallPolicyFirewallPolicyStatefulEngineOptions'] = None,
                 stateful_rule_group_references: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReference']] = None,
                 stateless_custom_actions: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomAction']] = None,
                 stateless_rule_group_references: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessRuleGroupReference']] = None):
        """
        :param Sequence[str] stateless_default_actions: Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param Sequence[str] stateless_fragment_default_actions: Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param 'FirewallPolicyFirewallPolicyPolicyVariablesArgs' policy_variables: . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        :param Sequence[str] stateful_default_actions: Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        :param 'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs' stateful_engine_options: A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        :param Sequence['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs'] stateful_rule_group_references: Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        :param Sequence['FirewallPolicyFirewallPolicyStatelessCustomActionArgs'] stateless_custom_actions: Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        :param Sequence['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs'] stateless_rule_group_references: Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        FirewallPolicyFirewallPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stateless_default_actions=stateless_default_actions,
            stateless_fragment_default_actions=stateless_fragment_default_actions,
            policy_variables=policy_variables,
            stateful_default_actions=stateful_default_actions,
            stateful_engine_options=stateful_engine_options,
            stateful_rule_group_references=stateful_rule_group_references,
            stateless_custom_actions=stateless_custom_actions,
            stateless_rule_group_references=stateless_rule_group_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stateless_default_actions: Optional[Sequence[str]] = None,
             stateless_fragment_default_actions: Optional[Sequence[str]] = None,
             policy_variables: Optional['outputs.FirewallPolicyFirewallPolicyPolicyVariables'] = None,
             stateful_default_actions: Optional[Sequence[str]] = None,
             stateful_engine_options: Optional['outputs.FirewallPolicyFirewallPolicyStatefulEngineOptions'] = None,
             stateful_rule_group_references: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReference']] = None,
             stateless_custom_actions: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomAction']] = None,
             stateless_rule_group_references: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessRuleGroupReference']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stateless_default_actions is None and 'statelessDefaultActions' in kwargs:
            stateless_default_actions = kwargs['statelessDefaultActions']
        if stateless_default_actions is None:
            raise TypeError("Missing 'stateless_default_actions' argument")
        if stateless_fragment_default_actions is None and 'statelessFragmentDefaultActions' in kwargs:
            stateless_fragment_default_actions = kwargs['statelessFragmentDefaultActions']
        if stateless_fragment_default_actions is None:
            raise TypeError("Missing 'stateless_fragment_default_actions' argument")
        if policy_variables is None and 'policyVariables' in kwargs:
            policy_variables = kwargs['policyVariables']
        if stateful_default_actions is None and 'statefulDefaultActions' in kwargs:
            stateful_default_actions = kwargs['statefulDefaultActions']
        if stateful_engine_options is None and 'statefulEngineOptions' in kwargs:
            stateful_engine_options = kwargs['statefulEngineOptions']
        if stateful_rule_group_references is None and 'statefulRuleGroupReferences' in kwargs:
            stateful_rule_group_references = kwargs['statefulRuleGroupReferences']
        if stateless_custom_actions is None and 'statelessCustomActions' in kwargs:
            stateless_custom_actions = kwargs['statelessCustomActions']
        if stateless_rule_group_references is None and 'statelessRuleGroupReferences' in kwargs:
            stateless_rule_group_references = kwargs['statelessRuleGroupReferences']

        _setter("stateless_default_actions", stateless_default_actions)
        _setter("stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            _setter("policy_variables", policy_variables)
        if stateful_default_actions is not None:
            _setter("stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            _setter("stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            _setter("stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            _setter("stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            _setter("stateless_rule_group_references", stateless_rule_group_references)

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> Sequence[str]:
        """
        Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_default_actions")

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> Sequence[str]:
        """
        Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional['outputs.FirewallPolicyFirewallPolicyPolicyVariables']:
        """
        . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        """
        return pulumi.get(self, "policy_variables")

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[Sequence[str]]:
        """
        Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        """
        return pulumi.get(self, "stateful_default_actions")

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional['outputs.FirewallPolicyFirewallPolicyStatefulEngineOptions']:
        """
        A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        """
        return pulumi.get(self, "stateful_engine_options")

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReference']]:
        """
        Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomAction']]:
        """
        Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        """
        return pulumi.get(self, "stateless_custom_actions")

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessRuleGroupReference']]:
        """
        Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateless_rule_group_references")


@pulumi.output_type
class FirewallPolicyFirewallPolicyPolicyVariables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleVariables":
            suggest = "rule_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyPolicyVariables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyPolicyVariables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyPolicyVariables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_variables: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable']] = None):
        FirewallPolicyFirewallPolicyPolicyVariables._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_variables=rule_variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_variables: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_variables is None and 'ruleVariables' in kwargs:
            rule_variables = kwargs['ruleVariables']

        if rule_variables is not None:
            _setter("rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[Sequence['outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable']]:
        return pulumi.get(self, "rule_variables")


@pulumi.output_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSet":
            suggest = "ip_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_set: 'outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet',
                 key: str):
        """
        :param 'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs' ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param str key: An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set=ip_set,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set: Optional['outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet'] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set is None and 'ipSet' in kwargs:
            ip_set = kwargs['ipSet']
        if ip_set is None:
            raise TypeError("Missing 'ip_set' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set", ip_set)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> 'outputs.FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet':
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet(dict):
    def __init__(__self__, *,
                 definitions: Sequence[str]):
        """
        :param Sequence[str] definitions: Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> Sequence[str]:
        """
        Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        return pulumi.get(self, "definitions")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatefulEngineOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOrder":
            suggest = "rule_order"
        elif key == "streamExceptionPolicy":
            suggest = "stream_exception_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyStatefulEngineOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyStatefulEngineOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyStatefulEngineOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_order: Optional[str] = None,
                 stream_exception_policy: Optional[str] = None):
        """
        :param str rule_order: Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        :param str stream_exception_policy: Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        FirewallPolicyFirewallPolicyStatefulEngineOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_order=rule_order,
            stream_exception_policy=stream_exception_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_order: Optional[str] = None,
             stream_exception_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_order is None and 'ruleOrder' in kwargs:
            rule_order = kwargs['ruleOrder']
        if stream_exception_policy is None and 'streamExceptionPolicy' in kwargs:
            stream_exception_policy = kwargs['streamExceptionPolicy']

        if rule_order is not None:
            _setter("rule_order", rule_order)
        if stream_exception_policy is not None:
            _setter("stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[str]:
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[str]:
        """
        Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        return pulumi.get(self, "stream_exception_policy")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyStatefulRuleGroupReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyStatefulRuleGroupReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyStatefulRuleGroupReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_arn: str,
                 override: Optional['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride'] = None,
                 priority: Optional[int] = None):
        """
        :param str resource_arn: The Amazon Resource Name (ARN) of the stateful rule group.
        :param 'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs' override: Configuration block for override values
        :param int priority: An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        FirewallPolicyFirewallPolicyStatefulRuleGroupReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
            override=override,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[str] = None,
             override: Optional['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride'] = None,
             priority: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)
        if override is not None:
            _setter("override", override)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        return pulumi.get(self, "resource_arn")

    @property
    @pulumi.getter
    def override(self) -> Optional['outputs.FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride']:
        """
        Configuration block for override values
        """
        return pulumi.get(self, "override")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None):
        """
        :param str action: The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if action is not None:
            _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatelessCustomAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionDefinition":
            suggest = "action_definition"
        elif key == "actionName":
            suggest = "action_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyStatelessCustomAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyStatelessCustomAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyStatelessCustomAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_definition: 'outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition',
                 action_name: str):
        """
        :param 'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs' action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param str action_name: A friendly name of the custom action.
        """
        FirewallPolicyFirewallPolicyStatelessCustomAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_definition=action_definition,
            action_name=action_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_definition: Optional['outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition'] = None,
             action_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_definition is None and 'actionDefinition' in kwargs:
            action_definition = kwargs['actionDefinition']
        if action_definition is None:
            raise TypeError("Missing 'action_definition' argument")
        if action_name is None and 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if action_name is None:
            raise TypeError("Missing 'action_name' argument")

        _setter("action_definition", action_definition)
        _setter("action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> 'outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition':
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> str:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publishMetricAction":
            suggest = "publish_metric_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publish_metric_action: 'outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction'):
        """
        :param 'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs' publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish_metric_action=publish_metric_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish_metric_action: Optional['outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publish_metric_action is None and 'publishMetricAction' in kwargs:
            publish_metric_action = kwargs['publishMetricAction']
        if publish_metric_action is None:
            raise TypeError("Missing 'publish_metric_action' argument")

        _setter("publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> 'outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction':
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension']):
        """
        :param Sequence['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs'] dimensions: Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension']:
        """
        Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: The string value to use in the custom metric dimension.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The string value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FirewallPolicyFirewallPolicyStatelessRuleGroupReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFirewallPolicyStatelessRuleGroupReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFirewallPolicyStatelessRuleGroupReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFirewallPolicyStatelessRuleGroupReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: int,
                 resource_arn: str):
        """
        :param int priority: An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        :param str resource_arn: The Amazon Resource Name (ARN) of the stateless rule group.
        """
        FirewallPolicyFirewallPolicyStatelessRuleGroupReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("priority", priority)
        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class FirewallSubnetMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipAddressType":
            suggest = "ip_address_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallSubnetMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallSubnetMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallSubnetMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 ip_address_type: Optional[str] = None):
        """
        :param str subnet_id: The unique identifier for the subnet.
        :param str ip_address_type: The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        FirewallSubnetMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            ip_address_type=ip_address_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: Optional[str] = None,
             ip_address_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if ip_address_type is None and 'ipAddressType' in kwargs:
            ip_address_type = kwargs['ipAddressType']

        _setter("subnet_id", subnet_id)
        if ip_address_type is not None:
            _setter("ip_address_type", ip_address_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        return pulumi.get(self, "ip_address_type")


@pulumi.output_type
class LoggingConfigurationLoggingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDestinationConfigs":
            suggest = "log_destination_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_destination_configs: Sequence['outputs.LoggingConfigurationLoggingConfigurationLogDestinationConfig']):
        """
        :param Sequence['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs'] log_destination_configs: Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        LoggingConfigurationLoggingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_destination_configs=log_destination_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_destination_configs: Optional[Sequence['outputs.LoggingConfigurationLoggingConfigurationLogDestinationConfig']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_destination_configs is None and 'logDestinationConfigs' in kwargs:
            log_destination_configs = kwargs['logDestinationConfigs']
        if log_destination_configs is None:
            raise TypeError("Missing 'log_destination_configs' argument")

        _setter("log_destination_configs", log_destination_configs)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> Sequence['outputs.LoggingConfigurationLoggingConfigurationLogDestinationConfig']:
        """
        Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        return pulumi.get(self, "log_destination_configs")


@pulumi.output_type
class LoggingConfigurationLoggingConfigurationLogDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDestination":
            suggest = "log_destination"
        elif key == "logDestinationType":
            suggest = "log_destination_type"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationLoggingConfigurationLogDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationLoggingConfigurationLogDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationLoggingConfigurationLogDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_destination: Mapping[str, str],
                 log_destination_type: str,
                 log_type: str):
        """
        :param Mapping[str, str] log_destination: A map describing the logging destination for the chosen `log_destination_type`.
               * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
               * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
               * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        :param str log_destination_type: The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        :param str log_type: The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        LoggingConfigurationLoggingConfigurationLogDestinationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_destination=log_destination,
            log_destination_type=log_destination_type,
            log_type=log_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_destination: Optional[Mapping[str, str]] = None,
             log_destination_type: Optional[str] = None,
             log_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_destination is None and 'logDestination' in kwargs:
            log_destination = kwargs['logDestination']
        if log_destination is None:
            raise TypeError("Missing 'log_destination' argument")
        if log_destination_type is None and 'logDestinationType' in kwargs:
            log_destination_type = kwargs['logDestinationType']
        if log_destination_type is None:
            raise TypeError("Missing 'log_destination_type' argument")
        if log_type is None and 'logType' in kwargs:
            log_type = kwargs['logType']
        if log_type is None:
            raise TypeError("Missing 'log_type' argument")

        _setter("log_destination", log_destination)
        _setter("log_destination_type", log_destination_type)
        _setter("log_type", log_type)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Mapping[str, str]:
        """
        A map describing the logging destination for the chosen `log_destination_type`.
        * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
        * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
        * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        """
        return pulumi.get(self, "log_destination")

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> str:
        """
        The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        """
        return pulumi.get(self, "log_destination_type")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class RuleGroupEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 key_id: Optional[str] = None):
        """
        :param str type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param str key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        RuleGroupEncryptionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class RuleGroupRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rulesSource":
            suggest = "rules_source"
        elif key == "referenceSets":
            suggest = "reference_sets"
        elif key == "ruleVariables":
            suggest = "rule_variables"
        elif key == "statefulRuleOptions":
            suggest = "stateful_rule_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rules_source: 'outputs.RuleGroupRuleGroupRulesSource',
                 reference_sets: Optional['outputs.RuleGroupRuleGroupReferenceSets'] = None,
                 rule_variables: Optional['outputs.RuleGroupRuleGroupRuleVariables'] = None,
                 stateful_rule_options: Optional['outputs.RuleGroupRuleGroupStatefulRuleOptions'] = None):
        """
        :param 'RuleGroupRuleGroupRulesSourceArgs' rules_source: A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        :param 'RuleGroupRuleGroupReferenceSetsArgs' reference_sets: A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        :param 'RuleGroupRuleGroupRuleVariablesArgs' rule_variables: A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        :param 'RuleGroupRuleGroupStatefulRuleOptionsArgs' stateful_rule_options: A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        RuleGroupRuleGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules_source=rules_source,
            reference_sets=reference_sets,
            rule_variables=rule_variables,
            stateful_rule_options=stateful_rule_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules_source: Optional['outputs.RuleGroupRuleGroupRulesSource'] = None,
             reference_sets: Optional['outputs.RuleGroupRuleGroupReferenceSets'] = None,
             rule_variables: Optional['outputs.RuleGroupRuleGroupRuleVariables'] = None,
             stateful_rule_options: Optional['outputs.RuleGroupRuleGroupStatefulRuleOptions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules_source is None and 'rulesSource' in kwargs:
            rules_source = kwargs['rulesSource']
        if rules_source is None:
            raise TypeError("Missing 'rules_source' argument")
        if reference_sets is None and 'referenceSets' in kwargs:
            reference_sets = kwargs['referenceSets']
        if rule_variables is None and 'ruleVariables' in kwargs:
            rule_variables = kwargs['ruleVariables']
        if stateful_rule_options is None and 'statefulRuleOptions' in kwargs:
            stateful_rule_options = kwargs['statefulRuleOptions']

        _setter("rules_source", rules_source)
        if reference_sets is not None:
            _setter("reference_sets", reference_sets)
        if rule_variables is not None:
            _setter("rule_variables", rule_variables)
        if stateful_rule_options is not None:
            _setter("stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> 'outputs.RuleGroupRuleGroupRulesSource':
        """
        A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        """
        return pulumi.get(self, "rules_source")

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional['outputs.RuleGroupRuleGroupReferenceSets']:
        """
        A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        """
        return pulumi.get(self, "reference_sets")

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional['outputs.RuleGroupRuleGroupRuleVariables']:
        """
        A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        """
        return pulumi.get(self, "rule_variables")

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional['outputs.RuleGroupRuleGroupStatefulRuleOptions']:
        """
        A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        return pulumi.get(self, "stateful_rule_options")


@pulumi.output_type
class RuleGroupRuleGroupReferenceSets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetReferences":
            suggest = "ip_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupReferenceSets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupReferenceSets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupReferenceSets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_set_references: Optional[Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReference']] = None):
        RuleGroupRuleGroupReferenceSets._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set_references=ip_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set_references: Optional[Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReference']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set_references is None and 'ipSetReferences' in kwargs:
            ip_set_references = kwargs['ipSetReferences']

        if ip_set_references is not None:
            _setter("ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReference']]:
        return pulumi.get(self, "ip_set_references")


@pulumi.output_type
class RuleGroupRuleGroupReferenceSetsIpSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetReferences":
            suggest = "ip_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupReferenceSetsIpSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupReferenceSetsIpSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupReferenceSetsIpSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_set_references: Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference'],
                 key: str):
        """
        :param Sequence['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs'] ip_set_references: Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
        :param str key: A unique alphanumeric string to identify the `ip_set`.
        """
        RuleGroupRuleGroupReferenceSetsIpSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set_references=ip_set_references,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set_references: Optional[Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference']] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set_references is None and 'ipSetReferences' in kwargs:
            ip_set_references = kwargs['ipSetReferences']
        if ip_set_references is None:
            raise TypeError("Missing 'ip_set_references' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set_references", ip_set_references)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Sequence['outputs.RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference']:
        """
        Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
        """
        return pulumi.get(self, "ip_set_references")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceArn":
            suggest = "reference_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_arn: str):
        """
        :param str reference_arn: Set of Managed Prefix IP ARN(s)
        """
        RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_arn=reference_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_arn is None and 'referenceArn' in kwargs:
            reference_arn = kwargs['referenceArn']
        if reference_arn is None:
            raise TypeError("Missing 'reference_arn' argument")

        _setter("reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> str:
        """
        Set of Managed Prefix IP ARN(s)
        """
        return pulumi.get(self, "reference_arn")


@pulumi.output_type
class RuleGroupRuleGroupRuleVariables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSets":
            suggest = "ip_sets"
        elif key == "portSets":
            suggest = "port_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRuleVariables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRuleVariables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRuleVariables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_sets: Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesIpSet']] = None,
                 port_sets: Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesPortSet']] = None):
        """
        :param Sequence['RuleGroupRuleGroupRuleVariablesIpSetArgs'] ip_sets: Set of configuration blocks that define IP address information. See IP Sets below for details.
        :param Sequence['RuleGroupRuleGroupRuleVariablesPortSetArgs'] port_sets: Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        RuleGroupRuleGroupRuleVariables._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_sets=ip_sets,
            port_sets=port_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_sets: Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesIpSet']] = None,
             port_sets: Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesPortSet']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_sets is None and 'ipSets' in kwargs:
            ip_sets = kwargs['ipSets']
        if port_sets is None and 'portSets' in kwargs:
            port_sets = kwargs['portSets']

        if ip_sets is not None:
            _setter("ip_sets", ip_sets)
        if port_sets is not None:
            _setter("port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesIpSet']]:
        """
        Set of configuration blocks that define IP address information. See IP Sets below for details.
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRuleVariablesPortSet']]:
        """
        Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        return pulumi.get(self, "port_sets")


@pulumi.output_type
class RuleGroupRuleGroupRuleVariablesIpSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSet":
            suggest = "ip_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRuleVariablesIpSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRuleVariablesIpSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRuleVariablesIpSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_set: 'outputs.RuleGroupRuleGroupRuleVariablesIpSetIpSet',
                 key: str):
        """
        :param 'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs' ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param str key: A unique alphanumeric string to identify the `ip_set`.
        """
        RuleGroupRuleGroupRuleVariablesIpSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set=ip_set,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set: Optional['outputs.RuleGroupRuleGroupRuleVariablesIpSetIpSet'] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set is None and 'ipSet' in kwargs:
            ip_set = kwargs['ipSet']
        if ip_set is None:
            raise TypeError("Missing 'ip_set' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set", ip_set)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> 'outputs.RuleGroupRuleGroupRuleVariablesIpSetIpSet':
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class RuleGroupRuleGroupRuleVariablesIpSetIpSet(dict):
    def __init__(__self__, *,
                 definitions: Sequence[str]):
        """
        :param Sequence[str] definitions: Set of IP addresses and address ranges, in CIDR notation.
        """
        RuleGroupRuleGroupRuleVariablesIpSetIpSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> Sequence[str]:
        """
        Set of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "definitions")


@pulumi.output_type
class RuleGroupRuleGroupRuleVariablesPortSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portSet":
            suggest = "port_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRuleVariablesPortSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRuleVariablesPortSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRuleVariablesPortSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 port_set: 'outputs.RuleGroupRuleGroupRuleVariablesPortSetPortSet'):
        """
        :param str key: An unique alphanumeric string to identify the `port_set`.
        :param 'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs' port_set: A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        RuleGroupRuleGroupRuleVariablesPortSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            port_set=port_set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             port_set: Optional['outputs.RuleGroupRuleGroupRuleVariablesPortSetPortSet'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if port_set is None and 'portSet' in kwargs:
            port_set = kwargs['portSet']
        if port_set is None:
            raise TypeError("Missing 'port_set' argument")

        _setter("key", key)
        _setter("port_set", port_set)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        An unique alphanumeric string to identify the `port_set`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="portSet")
    def port_set(self) -> 'outputs.RuleGroupRuleGroupRuleVariablesPortSetPortSet':
        """
        A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        return pulumi.get(self, "port_set")


@pulumi.output_type
class RuleGroupRuleGroupRuleVariablesPortSetPortSet(dict):
    def __init__(__self__, *,
                 definitions: Sequence[str]):
        """
        :param Sequence[str] definitions: Set of port ranges.
        """
        RuleGroupRuleGroupRuleVariablesPortSetPortSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> Sequence[str]:
        """
        Set of port ranges.
        """
        return pulumi.get(self, "definitions")


@pulumi.output_type
class RuleGroupRuleGroupRulesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rulesSourceList":
            suggest = "rules_source_list"
        elif key == "rulesString":
            suggest = "rules_string"
        elif key == "statefulRules":
            suggest = "stateful_rules"
        elif key == "statelessRulesAndCustomActions":
            suggest = "stateless_rules_and_custom_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rules_source_list: Optional['outputs.RuleGroupRuleGroupRulesSourceRulesSourceList'] = None,
                 rules_string: Optional[str] = None,
                 stateful_rules: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRule']] = None,
                 stateless_rules_and_custom_actions: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions'] = None):
        """
        :param 'RuleGroupRuleGroupRulesSourceRulesSourceListArgs' rules_source_list: A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        :param str rules_string: The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatefulRuleArgs'] stateful_rules: Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        :param 'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs' stateless_rules_and_custom_actions: A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        RuleGroupRuleGroupRulesSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules_source_list=rules_source_list,
            rules_string=rules_string,
            stateful_rules=stateful_rules,
            stateless_rules_and_custom_actions=stateless_rules_and_custom_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules_source_list: Optional['outputs.RuleGroupRuleGroupRulesSourceRulesSourceList'] = None,
             rules_string: Optional[str] = None,
             stateful_rules: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRule']] = None,
             stateless_rules_and_custom_actions: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules_source_list is None and 'rulesSourceList' in kwargs:
            rules_source_list = kwargs['rulesSourceList']
        if rules_string is None and 'rulesString' in kwargs:
            rules_string = kwargs['rulesString']
        if stateful_rules is None and 'statefulRules' in kwargs:
            stateful_rules = kwargs['statefulRules']
        if stateless_rules_and_custom_actions is None and 'statelessRulesAndCustomActions' in kwargs:
            stateless_rules_and_custom_actions = kwargs['statelessRulesAndCustomActions']

        if rules_source_list is not None:
            _setter("rules_source_list", rules_source_list)
        if rules_string is not None:
            _setter("rules_string", rules_string)
        if stateful_rules is not None:
            _setter("stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            _setter("stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional['outputs.RuleGroupRuleGroupRulesSourceRulesSourceList']:
        """
        A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        """
        return pulumi.get(self, "rules_source_list")

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[str]:
        """
        The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        """
        return pulumi.get(self, "rules_string")

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRule']]:
        """
        Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        """
        return pulumi.get(self, "stateful_rules")

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions']:
        """
        A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceRulesSourceList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generatedRulesType":
            suggest = "generated_rules_type"
        elif key == "targetTypes":
            suggest = "target_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceRulesSourceList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceRulesSourceList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceRulesSourceList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generated_rules_type: str,
                 target_types: Sequence[str],
                 targets: Sequence[str]):
        """
        :param str generated_rules_type: String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        :param Sequence[str] target_types: Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        :param Sequence[str] targets: Set of domains that you want to inspect for in your traffic flows.
        """
        RuleGroupRuleGroupRulesSourceRulesSourceList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            generated_rules_type=generated_rules_type,
            target_types=target_types,
            targets=targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             generated_rules_type: Optional[str] = None,
             target_types: Optional[Sequence[str]] = None,
             targets: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if generated_rules_type is None and 'generatedRulesType' in kwargs:
            generated_rules_type = kwargs['generatedRulesType']
        if generated_rules_type is None:
            raise TypeError("Missing 'generated_rules_type' argument")
        if target_types is None and 'targetTypes' in kwargs:
            target_types = kwargs['targetTypes']
        if target_types is None:
            raise TypeError("Missing 'target_types' argument")
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("generated_rules_type", generated_rules_type)
        _setter("target_types", target_types)
        _setter("targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> str:
        """
        String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        """
        return pulumi.get(self, "generated_rules_type")

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> Sequence[str]:
        """
        Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        """
        return pulumi.get(self, "target_types")

    @property
    @pulumi.getter
    def targets(self) -> Sequence[str]:
        """
        Set of domains that you want to inspect for in your traffic flows.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatefulRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOptions":
            suggest = "rule_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatefulRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatefulRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatefulRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 header: 'outputs.RuleGroupRuleGroupRulesSourceStatefulRuleHeader',
                 rule_options: Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption']):
        """
        :param str action: Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        :param 'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs' header: A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs'] rule_options: Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        RuleGroupRuleGroupRulesSourceStatefulRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            header=header,
            rule_options=rule_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             header: Optional['outputs.RuleGroupRuleGroupRulesSourceStatefulRuleHeader'] = None,
             rule_options: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if header is None:
            raise TypeError("Missing 'header' argument")
        if rule_options is None and 'ruleOptions' in kwargs:
            rule_options = kwargs['ruleOptions']
        if rule_options is None:
            raise TypeError("Missing 'rule_options' argument")

        _setter("action", action)
        _setter("header", header)
        _setter("rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def header(self) -> 'outputs.RuleGroupRuleGroupRulesSourceStatefulRuleHeader':
        """
        A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> Sequence['outputs.RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption']:
        """
        Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        return pulumi.get(self, "rule_options")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatefulRuleHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatefulRuleHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatefulRuleHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatefulRuleHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 destination_port: str,
                 direction: str,
                 protocol: str,
                 source: str,
                 source_port: str):
        """
        :param str destination: The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        :param str destination_port: The destination port to inspect for. To match with any address, specify `ANY`.
        :param str direction: The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        :param str protocol: The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        :param str source: The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        :param str source_port: The source port to inspect for. To match with any address, specify `ANY`.
        """
        RuleGroupRuleGroupRulesSourceStatefulRuleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            destination_port=destination_port,
            direction=direction,
            protocol=protocol,
            source=source,
            source_port=source_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             destination_port: Optional[str] = None,
             direction: Optional[str] = None,
             protocol: Optional[str] = None,
             source: Optional[str] = None,
             source_port: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if destination_port is None and 'destinationPort' in kwargs:
            destination_port = kwargs['destinationPort']
        if destination_port is None:
            raise TypeError("Missing 'destination_port' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_port is None and 'sourcePort' in kwargs:
            source_port = kwargs['sourcePort']
        if source_port is None:
            raise TypeError("Missing 'source_port' argument")

        _setter("destination", destination)
        _setter("destination_port", destination_port)
        _setter("direction", direction)
        _setter("protocol", protocol)
        _setter("source", source)
        _setter("source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> str:
        """
        The destination port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        """
        The source port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption(dict):
    def __init__(__self__, *,
                 keyword: str,
                 settings: Optional[Sequence[str]] = None):
        """
        :param str keyword: Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
               See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        :param Sequence[str] settings: Set of strings for additional settings to use in stateful rule inspection.
        """
        RuleGroupRuleGroupRulesSourceStatefulRuleRuleOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keyword=keyword,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keyword: Optional[str] = None,
             settings: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if keyword is None:
            raise TypeError("Missing 'keyword' argument")

        _setter("keyword", keyword)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> str:
        """
        Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
        See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        """
        return pulumi.get(self, "keyword")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence[str]]:
        """
        Set of strings for additional settings to use in stateful rule inspection.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statelessRules":
            suggest = "stateless_rules"
        elif key == "customActions":
            suggest = "custom_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stateless_rules: Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule'],
                 custom_actions: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction']] = None):
        """
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs'] stateless_rules: Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs'] custom_actions: Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stateless_rules=stateless_rules,
            custom_actions=custom_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stateless_rules: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule']] = None,
             custom_actions: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stateless_rules is None and 'statelessRules' in kwargs:
            stateless_rules = kwargs['statelessRules']
        if stateless_rules is None:
            raise TypeError("Missing 'stateless_rules' argument")
        if custom_actions is None and 'customActions' in kwargs:
            custom_actions = kwargs['customActions']

        _setter("stateless_rules", stateless_rules)
        if custom_actions is not None:
            _setter("custom_actions", custom_actions)

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule']:
        """
        Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        """
        return pulumi.get(self, "stateless_rules")

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction']]:
        """
        Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        return pulumi.get(self, "custom_actions")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionDefinition":
            suggest = "action_definition"
        elif key == "actionName":
            suggest = "action_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_definition: 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition',
                 action_name: str):
        """
        :param 'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs' action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param str action_name: A friendly name of the custom action.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_definition=action_definition,
            action_name=action_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_definition: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition'] = None,
             action_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_definition is None and 'actionDefinition' in kwargs:
            action_definition = kwargs['actionDefinition']
        if action_definition is None:
            raise TypeError("Missing 'action_definition' argument")
        if action_name is None and 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if action_name is None:
            raise TypeError("Missing 'action_name' argument")

        _setter("action_definition", action_definition)
        _setter("action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition':
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> str:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publishMetricAction":
            suggest = "publish_metric_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publish_metric_action: 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction'):
        """
        :param 'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs' publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish_metric_action=publish_metric_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish_metric_action: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publish_metric_action is None and 'publishMetricAction' in kwargs:
            publish_metric_action = kwargs['publishMetricAction']
        if publish_metric_action is None:
            raise TypeError("Missing 'publish_metric_action' argument")

        _setter("publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction':
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension']):
        """
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs'] dimensions: Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension']:
        """
        Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension(dict):
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: The value to use in the custom metric dimension.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleDefinition":
            suggest = "rule_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: int,
                 rule_definition: 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition'):
        """
        :param int priority: A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        :param 'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs' rule_definition: A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            rule_definition=rule_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             rule_definition: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if rule_definition is None and 'ruleDefinition' in kwargs:
            rule_definition = kwargs['ruleDefinition']
        if rule_definition is None:
            raise TypeError("Missing 'rule_definition' argument")

        _setter("priority", priority)
        _setter("rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition':
        """
        A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        return pulumi.get(self, "rule_definition")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchAttributes":
            suggest = "match_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence[str],
                 match_attributes: 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes'):
        """
        :param Sequence[str] actions: Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        :param 'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs' match_attributes: A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            match_attributes=match_attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             match_attributes: Optional['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if match_attributes is None and 'matchAttributes' in kwargs:
            match_attributes = kwargs['matchAttributes']
        if match_attributes is None:
            raise TypeError("Missing 'match_attributes' argument")

        _setter("actions", actions)
        _setter("match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> 'outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes':
        """
        A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        return pulumi.get(self, "match_attributes")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourcePorts":
            suggest = "source_ports"
        elif key == "tcpFlags":
            suggest = "tcp_flags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort']] = None,
                 destinations: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination']] = None,
                 protocols: Optional[Sequence[int]] = None,
                 source_ports: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort']] = None,
                 sources: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource']] = None,
                 tcp_flags: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag']] = None):
        """
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs'] destination_ports: Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs'] destinations: Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        :param Sequence[int] protocols: Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs'] source_ports: Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs'] sources: Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        :param Sequence['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs'] tcp_flags: Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ports=destination_ports,
            destinations=destinations,
            protocols=protocols,
            source_ports=source_ports,
            sources=sources,
            tcp_flags=tcp_flags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ports: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort']] = None,
             destinations: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination']] = None,
             protocols: Optional[Sequence[int]] = None,
             source_ports: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort']] = None,
             sources: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource']] = None,
             tcp_flags: Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ports is None and 'destinationPorts' in kwargs:
            destination_ports = kwargs['destinationPorts']
        if source_ports is None and 'sourcePorts' in kwargs:
            source_ports = kwargs['sourcePorts']
        if tcp_flags is None and 'tcpFlags' in kwargs:
            tcp_flags = kwargs['tcpFlags']

        if destination_ports is not None:
            _setter("destination_ports", destination_ports)
        if destinations is not None:
            _setter("destinations", destinations)
        if protocols is not None:
            _setter("protocols", protocols)
        if source_ports is not None:
            _setter("source_ports", source_ports)
        if sources is not None:
            _setter("sources", sources)
        if tcp_flags is not None:
            _setter("tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort']]:
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination']]:
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[int]]:
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort']]:
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        """
        return pulumi.get(self, "source_ports")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource']]:
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[Sequence['outputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag']]:
        """
        Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        return pulumi.get(self, "tcp_flags")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressDefinition":
            suggest = "address_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_definition: str):
        """
        :param str address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_definition=address_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_definition: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_definition is None and 'addressDefinition' in kwargs:
            address_definition = kwargs['addressDefinition']
        if address_definition is None:
            raise TypeError("Missing 'address_definition' argument")

        _setter("address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> str:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 to_port: Optional[int] = None):
        """
        :param int from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param int to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             to_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressDefinition":
            suggest = "address_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_definition: str):
        """
        :param str address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_definition=address_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_definition: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_definition is None and 'addressDefinition' in kwargs:
            address_definition = kwargs['addressDefinition']
        if address_definition is None:
            raise TypeError("Missing 'address_definition' argument")

        _setter("address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> str:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 to_port: Optional[int] = None):
        """
        :param int from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param int to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             to_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag(dict):
    def __init__(__self__, *,
                 flags: Sequence[str],
                 masks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] flags: Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        :param Sequence[str] masks: Set of flags to consider in the inspection. To inspect all flags, leave this empty.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flags=flags,
            masks=masks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flags: Optional[Sequence[str]] = None,
             masks: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if flags is None:
            raise TypeError("Missing 'flags' argument")

        _setter("flags", flags)
        if masks is not None:
            _setter("masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> Sequence[str]:
        """
        Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def masks(self) -> Optional[Sequence[str]]:
        """
        Set of flags to consider in the inspection. To inspect all flags, leave this empty.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "masks")


@pulumi.output_type
class RuleGroupRuleGroupStatefulRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOrder":
            suggest = "rule_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleGroupStatefulRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleGroupStatefulRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleGroupStatefulRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_order: str):
        """
        :param str rule_order: Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        RuleGroupRuleGroupStatefulRuleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_order=rule_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_order is None and 'ruleOrder' in kwargs:
            rule_order = kwargs['ruleOrder']
        if rule_order is None:
            raise TypeError("Missing 'rule_order' argument")

        _setter("rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> str:
        """
        Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")


@pulumi.output_type
class GetFirewallEncryptionConfigurationResult(dict):
    def __init__(__self__, *,
                 key_id: str,
                 type: str):
        """
        :param str key_id: The ID of the AWS Key Management Service (AWS KMS) customer managed key.
        :param str type: The type of the AWS Key Management Service (AWS KMS) key use by the firewall.
        """
        GetFirewallEncryptionConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_id=key_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']
        if key_id is None:
            raise TypeError("Missing 'key_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("key_id", key_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        The ID of the AWS Key Management Service (AWS KMS) customer managed key.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the AWS Key Management Service (AWS KMS) key use by the firewall.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFirewallFirewallStatusResult(dict):
    def __init__(__self__, *,
                 capacity_usage_summaries: Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryResult'],
                 configuration_sync_state_summary: str,
                 status: str,
                 sync_states: Sequence['outputs.GetFirewallFirewallStatusSyncStateResult']):
        """
        :param Sequence['GetFirewallFirewallStatusCapacityUsageSummaryArgs'] capacity_usage_summaries: Aggregated count of all resources used by reference sets in a firewall.
        :param str configuration_sync_state_summary: Summary of sync states for all availability zones in which the firewall is configured.
        :param Sequence['GetFirewallFirewallStatusSyncStateArgs'] sync_states: Set of subnets configured for use by the firewall.
        """
        GetFirewallFirewallStatusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity_usage_summaries=capacity_usage_summaries,
            configuration_sync_state_summary=configuration_sync_state_summary,
            status=status,
            sync_states=sync_states,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity_usage_summaries: Optional[Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryResult']] = None,
             configuration_sync_state_summary: Optional[str] = None,
             status: Optional[str] = None,
             sync_states: Optional[Sequence['outputs.GetFirewallFirewallStatusSyncStateResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capacity_usage_summaries is None and 'capacityUsageSummaries' in kwargs:
            capacity_usage_summaries = kwargs['capacityUsageSummaries']
        if capacity_usage_summaries is None:
            raise TypeError("Missing 'capacity_usage_summaries' argument")
        if configuration_sync_state_summary is None and 'configurationSyncStateSummary' in kwargs:
            configuration_sync_state_summary = kwargs['configurationSyncStateSummary']
        if configuration_sync_state_summary is None:
            raise TypeError("Missing 'configuration_sync_state_summary' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if sync_states is None and 'syncStates' in kwargs:
            sync_states = kwargs['syncStates']
        if sync_states is None:
            raise TypeError("Missing 'sync_states' argument")

        _setter("capacity_usage_summaries", capacity_usage_summaries)
        _setter("configuration_sync_state_summary", configuration_sync_state_summary)
        _setter("status", status)
        _setter("sync_states", sync_states)

    @property
    @pulumi.getter(name="capacityUsageSummaries")
    def capacity_usage_summaries(self) -> Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryResult']:
        """
        Aggregated count of all resources used by reference sets in a firewall.
        """
        return pulumi.get(self, "capacity_usage_summaries")

    @property
    @pulumi.getter(name="configurationSyncStateSummary")
    def configuration_sync_state_summary(self) -> str:
        """
        Summary of sync states for all availability zones in which the firewall is configured.
        """
        return pulumi.get(self, "configuration_sync_state_summary")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="syncStates")
    def sync_states(self) -> Sequence['outputs.GetFirewallFirewallStatusSyncStateResult']:
        """
        Set of subnets configured for use by the firewall.
        """
        return pulumi.get(self, "sync_states")


@pulumi.output_type
class GetFirewallFirewallStatusCapacityUsageSummaryResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrResult']):
        """
        :param Sequence['GetFirewallFirewallStatusCapacityUsageSummaryCidrArgs'] cidrs: Capacity usage of CIDR blocks used by IP set references in a firewall.
        """
        GetFirewallFirewallStatusCapacityUsageSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidrs=cidrs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidrs: Optional[Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cidrs is None:
            raise TypeError("Missing 'cidrs' argument")

        _setter("cidrs", cidrs)

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrResult']:
        """
        Capacity usage of CIDR blocks used by IP set references in a firewall.
        """
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class GetFirewallFirewallStatusCapacityUsageSummaryCidrResult(dict):
    def __init__(__self__, *,
                 available_cidr_count: int,
                 ip_set_references: Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult'],
                 utilized_cidr_count: int):
        """
        :param int available_cidr_count: Available number of CIDR blocks available for use by the IP set references in a firewall.
        :param Sequence['GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceArgs'] ip_set_references: The list of IP set references used by a firewall.
        :param int utilized_cidr_count: Number of CIDR blocks used by the IP set references in a firewall.
        """
        GetFirewallFirewallStatusCapacityUsageSummaryCidrResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_cidr_count=available_cidr_count,
            ip_set_references=ip_set_references,
            utilized_cidr_count=utilized_cidr_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_cidr_count: Optional[int] = None,
             ip_set_references: Optional[Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult']] = None,
             utilized_cidr_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if available_cidr_count is None and 'availableCidrCount' in kwargs:
            available_cidr_count = kwargs['availableCidrCount']
        if available_cidr_count is None:
            raise TypeError("Missing 'available_cidr_count' argument")
        if ip_set_references is None and 'ipSetReferences' in kwargs:
            ip_set_references = kwargs['ipSetReferences']
        if ip_set_references is None:
            raise TypeError("Missing 'ip_set_references' argument")
        if utilized_cidr_count is None and 'utilizedCidrCount' in kwargs:
            utilized_cidr_count = kwargs['utilizedCidrCount']
        if utilized_cidr_count is None:
            raise TypeError("Missing 'utilized_cidr_count' argument")

        _setter("available_cidr_count", available_cidr_count)
        _setter("ip_set_references", ip_set_references)
        _setter("utilized_cidr_count", utilized_cidr_count)

    @property
    @pulumi.getter(name="availableCidrCount")
    def available_cidr_count(self) -> int:
        """
        Available number of CIDR blocks available for use by the IP set references in a firewall.
        """
        return pulumi.get(self, "available_cidr_count")

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Sequence['outputs.GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult']:
        """
        The list of IP set references used by a firewall.
        """
        return pulumi.get(self, "ip_set_references")

    @property
    @pulumi.getter(name="utilizedCidrCount")
    def utilized_cidr_count(self) -> int:
        """
        Number of CIDR blocks used by the IP set references in a firewall.
        """
        return pulumi.get(self, "utilized_cidr_count")


@pulumi.output_type
class GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult(dict):
    def __init__(__self__, *,
                 resolved_cidr_count: int):
        """
        :param int resolved_cidr_count: Total number of CIDR blocks used by the IP set references in a firewall.
        """
        GetFirewallFirewallStatusCapacityUsageSummaryCidrIpSetReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolved_cidr_count=resolved_cidr_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolved_cidr_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resolved_cidr_count is None and 'resolvedCidrCount' in kwargs:
            resolved_cidr_count = kwargs['resolvedCidrCount']
        if resolved_cidr_count is None:
            raise TypeError("Missing 'resolved_cidr_count' argument")

        _setter("resolved_cidr_count", resolved_cidr_count)

    @property
    @pulumi.getter(name="resolvedCidrCount")
    def resolved_cidr_count(self) -> int:
        """
        Total number of CIDR blocks used by the IP set references in a firewall.
        """
        return pulumi.get(self, "resolved_cidr_count")


@pulumi.output_type
class GetFirewallFirewallStatusSyncStateResult(dict):
    def __init__(__self__, *,
                 attachments: Sequence['outputs.GetFirewallFirewallStatusSyncStateAttachmentResult'],
                 availability_zone: str):
        """
        :param Sequence['GetFirewallFirewallStatusSyncStateAttachmentArgs'] attachments: Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        :param str availability_zone: The Availability Zone where the subnet is configured.
        """
        GetFirewallFirewallStatusSyncStateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachments=attachments,
            availability_zone=availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachments: Optional[Sequence['outputs.GetFirewallFirewallStatusSyncStateAttachmentResult']] = None,
             availability_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attachments is None:
            raise TypeError("Missing 'attachments' argument")
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")

        _setter("attachments", attachments)
        _setter("availability_zone", availability_zone)

    @property
    @pulumi.getter
    def attachments(self) -> Sequence['outputs.GetFirewallFirewallStatusSyncStateAttachmentResult']:
        """
        Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        """
        return pulumi.get(self, "attachments")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        """
        The Availability Zone where the subnet is configured.
        """
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class GetFirewallFirewallStatusSyncStateAttachmentResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 status: str,
                 subnet_id: str):
        """
        :param str endpoint_id: The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        :param str subnet_id: The unique identifier for the subnet.
        """
        GetFirewallFirewallStatusSyncStateAttachmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            status=status,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             status: Optional[str] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_id is None and 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if endpoint_id is None:
            raise TypeError("Missing 'endpoint_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("endpoint_id", endpoint_id)
        _setter("status", status)
        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyResult(dict):
    def __init__(__self__, *,
                 stateful_default_actions: Sequence[str],
                 stateful_engine_options: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult'],
                 stateful_rule_group_references: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult'],
                 stateless_custom_actions: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionResult'],
                 stateless_default_actions: Sequence[str],
                 stateless_fragment_default_actions: Sequence[str],
                 stateless_rule_group_references: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult']):
        GetFirewallPolicyFirewallPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stateful_default_actions=stateful_default_actions,
            stateful_engine_options=stateful_engine_options,
            stateful_rule_group_references=stateful_rule_group_references,
            stateless_custom_actions=stateless_custom_actions,
            stateless_default_actions=stateless_default_actions,
            stateless_fragment_default_actions=stateless_fragment_default_actions,
            stateless_rule_group_references=stateless_rule_group_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stateful_default_actions: Optional[Sequence[str]] = None,
             stateful_engine_options: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult']] = None,
             stateful_rule_group_references: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult']] = None,
             stateless_custom_actions: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionResult']] = None,
             stateless_default_actions: Optional[Sequence[str]] = None,
             stateless_fragment_default_actions: Optional[Sequence[str]] = None,
             stateless_rule_group_references: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stateful_default_actions is None and 'statefulDefaultActions' in kwargs:
            stateful_default_actions = kwargs['statefulDefaultActions']
        if stateful_default_actions is None:
            raise TypeError("Missing 'stateful_default_actions' argument")
        if stateful_engine_options is None and 'statefulEngineOptions' in kwargs:
            stateful_engine_options = kwargs['statefulEngineOptions']
        if stateful_engine_options is None:
            raise TypeError("Missing 'stateful_engine_options' argument")
        if stateful_rule_group_references is None and 'statefulRuleGroupReferences' in kwargs:
            stateful_rule_group_references = kwargs['statefulRuleGroupReferences']
        if stateful_rule_group_references is None:
            raise TypeError("Missing 'stateful_rule_group_references' argument")
        if stateless_custom_actions is None and 'statelessCustomActions' in kwargs:
            stateless_custom_actions = kwargs['statelessCustomActions']
        if stateless_custom_actions is None:
            raise TypeError("Missing 'stateless_custom_actions' argument")
        if stateless_default_actions is None and 'statelessDefaultActions' in kwargs:
            stateless_default_actions = kwargs['statelessDefaultActions']
        if stateless_default_actions is None:
            raise TypeError("Missing 'stateless_default_actions' argument")
        if stateless_fragment_default_actions is None and 'statelessFragmentDefaultActions' in kwargs:
            stateless_fragment_default_actions = kwargs['statelessFragmentDefaultActions']
        if stateless_fragment_default_actions is None:
            raise TypeError("Missing 'stateless_fragment_default_actions' argument")
        if stateless_rule_group_references is None and 'statelessRuleGroupReferences' in kwargs:
            stateless_rule_group_references = kwargs['statelessRuleGroupReferences']
        if stateless_rule_group_references is None:
            raise TypeError("Missing 'stateless_rule_group_references' argument")

        _setter("stateful_default_actions", stateful_default_actions)
        _setter("stateful_engine_options", stateful_engine_options)
        _setter("stateful_rule_group_references", stateful_rule_group_references)
        _setter("stateless_custom_actions", stateless_custom_actions)
        _setter("stateless_default_actions", stateless_default_actions)
        _setter("stateless_fragment_default_actions", stateless_fragment_default_actions)
        _setter("stateless_rule_group_references", stateless_rule_group_references)

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Sequence[str]:
        return pulumi.get(self, "stateful_default_actions")

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult']:
        return pulumi.get(self, "stateful_engine_options")

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult']:
        return pulumi.get(self, "stateful_rule_group_references")

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionResult']:
        return pulumi.get(self, "stateless_custom_actions")

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> Sequence[str]:
        return pulumi.get(self, "stateless_default_actions")

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> Sequence[str]:
        return pulumi.get(self, "stateless_fragment_default_actions")

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult']:
        return pulumi.get(self, "stateless_rule_group_references")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult(dict):
    def __init__(__self__, *,
                 rule_order: str,
                 stream_exception_policy: str):
        GetFirewallPolicyFirewallPolicyStatefulEngineOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_order=rule_order,
            stream_exception_policy=stream_exception_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_order: Optional[str] = None,
             stream_exception_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_order is None and 'ruleOrder' in kwargs:
            rule_order = kwargs['ruleOrder']
        if rule_order is None:
            raise TypeError("Missing 'rule_order' argument")
        if stream_exception_policy is None and 'streamExceptionPolicy' in kwargs:
            stream_exception_policy = kwargs['streamExceptionPolicy']
        if stream_exception_policy is None:
            raise TypeError("Missing 'stream_exception_policy' argument")

        _setter("rule_order", rule_order)
        _setter("stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> str:
        return pulumi.get(self, "rule_order")

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> str:
        return pulumi.get(self, "stream_exception_policy")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult(dict):
    def __init__(__self__, *,
                 priority: int,
                 resource_arn: str,
                 overrides: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult']] = None):
        GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            resource_arn=resource_arn,
            overrides=overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             resource_arn: Optional[str] = None,
             overrides: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("priority", priority)
        _setter("resource_arn", resource_arn)
        if overrides is not None:
            _setter("overrides", overrides)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        return pulumi.get(self, "resource_arn")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None):
        GetFirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if action is not None:
            _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatelessCustomActionResult(dict):
    def __init__(__self__, *,
                 action_definitions: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult'],
                 action_name: str):
        GetFirewallPolicyFirewallPolicyStatelessCustomActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_definitions=action_definitions,
            action_name=action_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_definitions: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult']] = None,
             action_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_definitions is None and 'actionDefinitions' in kwargs:
            action_definitions = kwargs['actionDefinitions']
        if action_definitions is None:
            raise TypeError("Missing 'action_definitions' argument")
        if action_name is None and 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if action_name is None:
            raise TypeError("Missing 'action_name' argument")

        _setter("action_definitions", action_definitions)
        _setter("action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinitions")
    def action_definitions(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult']:
        return pulumi.get(self, "action_definitions")

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> str:
        return pulumi.get(self, "action_name")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult(dict):
    def __init__(__self__, *,
                 publish_metric_actions: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult']):
        GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish_metric_actions=publish_metric_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish_metric_actions: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publish_metric_actions is None and 'publishMetricActions' in kwargs:
            publish_metric_actions = kwargs['publishMetricActions']
        if publish_metric_actions is None:
            raise TypeError("Missing 'publish_metric_actions' argument")

        _setter("publish_metric_actions", publish_metric_actions)

    @property
    @pulumi.getter(name="publishMetricActions")
    def publish_metric_actions(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult']:
        return pulumi.get(self, "publish_metric_actions")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult(dict):
    def __init__(__self__, *,
                 dimensions: Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult']):
        GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult']:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult(dict):
    def __init__(__self__, *,
                 value: str):
        GetFirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult(dict):
    def __init__(__self__, *,
                 priority: int,
                 resource_arn: str):
        GetFirewallPolicyFirewallPolicyStatelessRuleGroupReferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             resource_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("priority", priority)
        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class GetFirewallSubnetMappingResult(dict):
    def __init__(__self__, *,
                 subnet_id: str):
        """
        :param str subnet_id: The unique identifier for the subnet.
        """
        GetFirewallSubnetMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")


