# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'FirewallEncryptionConfigurationArgs',
    'FirewallFirewallStatusArgs',
    'FirewallFirewallStatusSyncStateArgs',
    'FirewallFirewallStatusSyncStateAttachmentArgs',
    'FirewallPolicyEncryptionConfigurationArgs',
    'FirewallPolicyFirewallPolicyArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs',
    'FirewallSubnetMappingArgs',
    'LoggingConfigurationLoggingConfigurationArgs',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs',
    'RuleGroupEncryptionConfigurationArgs',
    'RuleGroupRuleGroupArgs',
    'RuleGroupRuleGroupReferenceSetsArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs',
    'RuleGroupRuleGroupRuleVariablesArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs',
    'RuleGroupRuleGroupRulesSourceArgs',
    'RuleGroupRuleGroupRulesSourceRulesSourceListArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs',
    'RuleGroupRuleGroupStatefulRuleOptionsArgs',
]

@pulumi.input_type
class FirewallEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        FirewallEncryptionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


@pulumi.input_type
class FirewallFirewallStatusArgs:
    def __init__(__self__, *,
                 sync_states: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]] sync_states: Set of subnets configured for use by the firewall.
        """
        FirewallFirewallStatusArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sync_states=sync_states,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sync_states: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sync_states is None and 'syncStates' in kwargs:
            sync_states = kwargs['syncStates']

        if sync_states is not None:
            _setter("sync_states", sync_states)

    @property
    @pulumi.getter(name="syncStates")
    def sync_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]:
        """
        Set of subnets configured for use by the firewall.
        """
        return pulumi.get(self, "sync_states")

    @sync_states.setter
    def sync_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]):
        pulumi.set(self, "sync_states", value)


@pulumi.input_type
class FirewallFirewallStatusSyncStateArgs:
    def __init__(__self__, *,
                 attachments: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]] attachments: Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        :param pulumi.Input[str] availability_zone: The Availability Zone where the subnet is configured.
        """
        FirewallFirewallStatusSyncStateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachments=attachments,
            availability_zone=availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachments: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]] = None,
             availability_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']

        if attachments is not None:
            _setter("attachments", attachments)
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)

    @property
    @pulumi.getter
    def attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]:
        """
        Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        """
        return pulumi.get(self, "attachments")

    @attachments.setter
    def attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]):
        pulumi.set(self, "attachments", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Zone where the subnet is configured.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)


@pulumi.input_type
class FirewallFirewallStatusSyncStateAttachmentArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        :param pulumi.Input[str] subnet_id: The unique identifier for the subnet.
        """
        FirewallFirewallStatusSyncStateAttachmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_id is None and 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class FirewallPolicyEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        FirewallPolicyEncryptionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyArgs:
    def __init__(__self__, *,
                 stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 policy_variables: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']] = None,
                 stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stateful_engine_options: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']] = None,
                 stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
                 stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]] = None,
                 stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_default_actions: Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_fragment_default_actions: Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs'] policy_variables: . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateful_default_actions: Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs'] stateful_engine_options: A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]] stateful_rule_group_references: Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]] stateless_custom_actions: Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]] stateless_rule_group_references: Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        FirewallPolicyFirewallPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stateless_default_actions=stateless_default_actions,
            stateless_fragment_default_actions=stateless_fragment_default_actions,
            policy_variables=policy_variables,
            stateful_default_actions=stateful_default_actions,
            stateful_engine_options=stateful_engine_options,
            stateful_rule_group_references=stateful_rule_group_references,
            stateless_custom_actions=stateless_custom_actions,
            stateless_rule_group_references=stateless_rule_group_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stateless_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             stateless_fragment_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             policy_variables: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']] = None,
             stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             stateful_engine_options: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']] = None,
             stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
             stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]] = None,
             stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stateless_default_actions is None and 'statelessDefaultActions' in kwargs:
            stateless_default_actions = kwargs['statelessDefaultActions']
        if stateless_default_actions is None:
            raise TypeError("Missing 'stateless_default_actions' argument")
        if stateless_fragment_default_actions is None and 'statelessFragmentDefaultActions' in kwargs:
            stateless_fragment_default_actions = kwargs['statelessFragmentDefaultActions']
        if stateless_fragment_default_actions is None:
            raise TypeError("Missing 'stateless_fragment_default_actions' argument")
        if policy_variables is None and 'policyVariables' in kwargs:
            policy_variables = kwargs['policyVariables']
        if stateful_default_actions is None and 'statefulDefaultActions' in kwargs:
            stateful_default_actions = kwargs['statefulDefaultActions']
        if stateful_engine_options is None and 'statefulEngineOptions' in kwargs:
            stateful_engine_options = kwargs['statefulEngineOptions']
        if stateful_rule_group_references is None and 'statefulRuleGroupReferences' in kwargs:
            stateful_rule_group_references = kwargs['statefulRuleGroupReferences']
        if stateless_custom_actions is None and 'statelessCustomActions' in kwargs:
            stateless_custom_actions = kwargs['statelessCustomActions']
        if stateless_rule_group_references is None and 'statelessRuleGroupReferences' in kwargs:
            stateless_rule_group_references = kwargs['statelessRuleGroupReferences']

        _setter("stateless_default_actions", stateless_default_actions)
        _setter("stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            _setter("policy_variables", policy_variables)
        if stateful_default_actions is not None:
            _setter("stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            _setter("stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            _setter("stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            _setter("stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            _setter("stateless_rule_group_references", stateless_rule_group_references)

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_default_actions")

    @stateless_default_actions.setter
    def stateless_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_default_actions", value)

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @stateless_fragment_default_actions.setter
    def stateless_fragment_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_fragment_default_actions", value)

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]:
        """
        . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        """
        return pulumi.get(self, "policy_variables")

    @policy_variables.setter
    def policy_variables(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]):
        pulumi.set(self, "policy_variables", value)

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        """
        return pulumi.get(self, "stateful_default_actions")

    @stateful_default_actions.setter
    def stateful_default_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stateful_default_actions", value)

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]:
        """
        A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        """
        return pulumi.get(self, "stateful_engine_options")

    @stateful_engine_options.setter
    def stateful_engine_options(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]):
        pulumi.set(self, "stateful_engine_options", value)

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]:
        """
        Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @stateful_rule_group_references.setter
    def stateful_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateful_rule_group_references", value)

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]:
        """
        Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        """
        return pulumi.get(self, "stateless_custom_actions")

    @stateless_custom_actions.setter
    def stateless_custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]):
        pulumi.set(self, "stateless_custom_actions", value)

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]:
        """
        Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateless_rule_group_references")

    @stateless_rule_group_references.setter
    def stateless_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateless_rule_group_references", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesArgs:
    def __init__(__self__, *,
                 rule_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]] = None):
        FirewallPolicyFirewallPolicyPolicyVariablesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_variables=rule_variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_variables is None and 'ruleVariables' in kwargs:
            rule_variables = kwargs['ruleVariables']

        if rule_variables is not None:
            _setter("rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]):
        pulumi.set(self, "rule_variables", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs'],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs'] ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param pulumi.Input[str] key: An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set=ip_set,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set is None and 'ipSet' in kwargs:
            ip_set = kwargs['ipSet']
        if ip_set is None:
            raise TypeError("Missing 'ip_set' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set", ip_set)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']:
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input[str]] = None,
                 stream_exception_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rule_order: Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        :param pulumi.Input[str] stream_exception_policy: Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_order=rule_order,
            stream_exception_policy=stream_exception_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_order: Optional[pulumi.Input[str]] = None,
             stream_exception_policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_order is None and 'ruleOrder' in kwargs:
            rule_order = kwargs['ruleOrder']
        if stream_exception_policy is None and 'streamExceptionPolicy' in kwargs:
            stream_exception_policy = kwargs['streamExceptionPolicy']

        if rule_order is not None:
            _setter("rule_order", rule_order)
        if stream_exception_policy is not None:
            _setter("stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_order", value)

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        return pulumi.get(self, "stream_exception_policy")

    @stream_exception_policy.setter
    def stream_exception_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_exception_policy", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[str],
                 override: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateful rule group.
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs'] override: Configuration block for override values
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_arn=resource_arn,
            override=override,
            priority=priority,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_arn: Optional[pulumi.Input[str]] = None,
             override: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']] = None,
             priority: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("resource_arn", resource_arn)
        if override is not None:
            _setter("override", override)
        if priority is not None:
            _setter("priority", priority)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]:
        """
        Configuration block for override values
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if action is not None:
            _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs'] action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param pulumi.Input[str] action_name: A friendly name of the custom action.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_definition=action_definition,
            action_name=action_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_definition: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']] = None,
             action_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_definition is None and 'actionDefinition' in kwargs:
            action_definition = kwargs['actionDefinition']
        if action_definition is None:
            raise TypeError("Missing 'action_definition' argument")
        if action_name is None and 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if action_name is None:
            raise TypeError("Missing 'action_name' argument")

        _setter("action_definition", action_definition)
        _setter("action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']:
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs'] publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish_metric_action=publish_metric_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish_metric_action: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publish_metric_action is None and 'publishMetricAction' in kwargs:
            publish_metric_action = kwargs['publishMetricAction']
        if publish_metric_action is None:
            raise TypeError("Missing 'publish_metric_action' argument")

        _setter("publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']:
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]] dimensions: Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        """
        Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The string value to use in the custom metric dimension.
        """
        FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The string value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 resource_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateless rule group.
        """
        FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            resource_arn=resource_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[pulumi.Input[int]] = None,
             resource_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if resource_arn is None and 'resourceArn' in kwargs:
            resource_arn = kwargs['resourceArn']
        if resource_arn is None:
            raise TypeError("Missing 'resource_arn' argument")

        _setter("priority", priority)
        _setter("resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)


@pulumi.input_type
class FirewallSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ip_address_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: The unique identifier for the subnet.
        :param pulumi.Input[str] ip_address_type: The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        FirewallSubnetMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            ip_address_type=ip_address_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: Optional[pulumi.Input[str]] = None,
             ip_address_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if ip_address_type is None and 'ipAddressType' in kwargs:
            ip_address_type = kwargs['ipAddressType']

        _setter("subnet_id", subnet_id)
        if ip_address_type is not None:
            _setter("ip_address_type", ip_address_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_type", value)


@pulumi.input_type
class LoggingConfigurationLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]] log_destination_configs: Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        LoggingConfigurationLoggingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_destination_configs=log_destination_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_destination_configs: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_destination_configs is None and 'logDestinationConfigs' in kwargs:
            log_destination_configs = kwargs['logDestinationConfigs']
        if log_destination_configs is None:
            raise TypeError("Missing 'log_destination_configs' argument")

        _setter("log_destination_configs", log_destination_configs)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]:
        """
        Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        return pulumi.get(self, "log_destination_configs")

    @log_destination_configs.setter
    def log_destination_configs(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(self, "log_destination_configs", value)


@pulumi.input_type
class LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs:
    def __init__(__self__, *,
                 log_destination: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 log_destination_type: pulumi.Input[str],
                 log_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] log_destination: A map describing the logging destination for the chosen `log_destination_type`.
               * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
               * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
               * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        :param pulumi.Input[str] log_destination_type: The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        :param pulumi.Input[str] log_type: The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_destination=log_destination,
            log_destination_type=log_destination_type,
            log_type=log_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_destination: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             log_destination_type: Optional[pulumi.Input[str]] = None,
             log_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_destination is None and 'logDestination' in kwargs:
            log_destination = kwargs['logDestination']
        if log_destination is None:
            raise TypeError("Missing 'log_destination' argument")
        if log_destination_type is None and 'logDestinationType' in kwargs:
            log_destination_type = kwargs['logDestinationType']
        if log_destination_type is None:
            raise TypeError("Missing 'log_destination_type' argument")
        if log_type is None and 'logType' in kwargs:
            log_type = kwargs['logType']
        if log_type is None:
            raise TypeError("Missing 'log_type' argument")

        _setter("log_destination", log_destination)
        _setter("log_destination_type", log_destination_type)
        _setter("log_type", log_type)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A map describing the logging destination for the chosen `log_destination_type`.
        * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
        * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
        * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        """
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "log_destination", value)

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> pulumi.Input[str]:
        """
        The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        """
        return pulumi.get(self, "log_destination_type")

    @log_destination_type.setter
    def log_destination_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_destination_type", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[str]:
        """
        The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class RuleGroupEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        RuleGroupEncryptionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            key_id=key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']

        _setter("type", type)
        if key_id is not None:
            _setter("key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


@pulumi.input_type
class RuleGroupRuleGroupArgs:
    def __init__(__self__, *,
                 rules_source: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs'],
                 reference_sets: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']] = None,
                 rule_variables: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']] = None,
                 stateful_rule_options: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceArgs'] rules_source: A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        :param pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs'] reference_sets: A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs'] rule_variables: A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        :param pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs'] stateful_rule_options: A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        RuleGroupRuleGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules_source=rules_source,
            reference_sets=reference_sets,
            rule_variables=rule_variables,
            stateful_rule_options=stateful_rule_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules_source: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']] = None,
             reference_sets: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']] = None,
             rule_variables: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']] = None,
             stateful_rule_options: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules_source is None and 'rulesSource' in kwargs:
            rules_source = kwargs['rulesSource']
        if rules_source is None:
            raise TypeError("Missing 'rules_source' argument")
        if reference_sets is None and 'referenceSets' in kwargs:
            reference_sets = kwargs['referenceSets']
        if rule_variables is None and 'ruleVariables' in kwargs:
            rule_variables = kwargs['ruleVariables']
        if stateful_rule_options is None and 'statefulRuleOptions' in kwargs:
            stateful_rule_options = kwargs['statefulRuleOptions']

        _setter("rules_source", rules_source)
        if reference_sets is not None:
            _setter("reference_sets", reference_sets)
        if rule_variables is not None:
            _setter("rule_variables", rule_variables)
        if stateful_rule_options is not None:
            _setter("stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']:
        """
        A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        """
        return pulumi.get(self, "rules_source")

    @rules_source.setter
    def rules_source(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']):
        pulumi.set(self, "rules_source", value)

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]:
        """
        A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        """
        return pulumi.get(self, "reference_sets")

    @reference_sets.setter
    def reference_sets(self, value: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]):
        pulumi.set(self, "reference_sets", value)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]:
        """
        A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        """
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]):
        pulumi.set(self, "rule_variables", value)

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]:
        """
        A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        return pulumi.get(self, "stateful_rule_options")

    @stateful_rule_options.setter
    def stateful_rule_options(self, value: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]):
        pulumi.set(self, "stateful_rule_options", value)


@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsArgs:
    def __init__(__self__, *,
                 ip_set_references: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]] = None):
        RuleGroupRuleGroupReferenceSetsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set_references=ip_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set_references: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set_references is None and 'ipSetReferences' in kwargs:
            ip_set_references = kwargs['ipSetReferences']

        if ip_set_references is not None:
            _setter("ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]:
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]):
        pulumi.set(self, "ip_set_references", value)


@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs:
    def __init__(__self__, *,
                 ip_set_references: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]] ip_set_references: Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
        :param pulumi.Input[str] key: A unique alphanumeric string to identify the `ip_set`.
        """
        RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set_references=ip_set_references,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set_references: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set_references is None and 'ipSetReferences' in kwargs:
            ip_set_references = kwargs['ipSetReferences']
        if ip_set_references is None:
            raise TypeError("Missing 'ip_set_references' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set_references", ip_set_references)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]:
        """
        Set of configuration blocks that define the IP Reference information. See IP Set Reference below for details.
        """
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]):
        pulumi.set(self, "ip_set_references", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs:
    def __init__(__self__, *,
                 reference_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] reference_arn: Set of Managed Prefix IP ARN(s)
        """
        RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_arn=reference_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_arn is None and 'referenceArn' in kwargs:
            reference_arn = kwargs['referenceArn']
        if reference_arn is None:
            raise TypeError("Missing 'reference_arn' argument")

        _setter("reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> pulumi.Input[str]:
        """
        Set of Managed Prefix IP ARN(s)
        """
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_arn", value)


@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesArgs:
    def __init__(__self__, *,
                 ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]] = None,
                 port_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]] ip_sets: Set of configuration blocks that define IP address information. See IP Sets below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]] port_sets: Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        RuleGroupRuleGroupRuleVariablesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_sets=ip_sets,
            port_sets=port_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]] = None,
             port_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_sets is None and 'ipSets' in kwargs:
            ip_sets = kwargs['ipSets']
        if port_sets is None and 'portSets' in kwargs:
            port_sets = kwargs['portSets']

        if ip_sets is not None:
            _setter("ip_sets", ip_sets)
        if port_sets is not None:
            _setter("port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]:
        """
        Set of configuration blocks that define IP address information. See IP Sets below for details.
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]:
        """
        Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        return pulumi.get(self, "port_sets")

    @port_sets.setter
    def port_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]):
        pulumi.set(self, "port_sets", value)


@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs'],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs'] ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param pulumi.Input[str] key: A unique alphanumeric string to identify the `ip_set`.
        """
        RuleGroupRuleGroupRuleVariablesIpSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_set=ip_set,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_set: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_set is None and 'ipSet' in kwargs:
            ip_set = kwargs['ipSet']
        if ip_set is None:
            raise TypeError("Missing 'ip_set' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("ip_set", ip_set)
        _setter("key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']:
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of IP addresses and address ranges, in CIDR notation.
        """
        RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 port_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        """
        :param pulumi.Input[str] key: An unique alphanumeric string to identify the `port_set`.
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs'] port_set: A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        RuleGroupRuleGroupRuleVariablesPortSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            port_set=port_set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             port_set: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if port_set is None and 'portSet' in kwargs:
            port_set = kwargs['portSet']
        if port_set is None:
            raise TypeError("Missing 'port_set' argument")

        _setter("key", key)
        _setter("port_set", port_set)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An unique alphanumeric string to identify the `port_set`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="portSet")
    def port_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']:
        """
        A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        return pulumi.get(self, "port_set")

    @port_set.setter
    def port_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        pulumi.set(self, "port_set", value)


@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of port ranges.
        """
        RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            definitions=definitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             definitions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if definitions is None:
            raise TypeError("Missing 'definitions' argument")

        _setter("definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of port ranges.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceArgs:
    def __init__(__self__, *,
                 rules_source_list: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']] = None,
                 rules_string: Optional[pulumi.Input[str]] = None,
                 stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]] = None,
                 stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs'] rules_source_list: A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        :param pulumi.Input[str] rules_string: The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]] stateful_rules: Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs'] stateless_rules_and_custom_actions: A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        RuleGroupRuleGroupRulesSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules_source_list=rules_source_list,
            rules_string=rules_string,
            stateful_rules=stateful_rules,
            stateless_rules_and_custom_actions=stateless_rules_and_custom_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules_source_list: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']] = None,
             rules_string: Optional[pulumi.Input[str]] = None,
             stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]] = None,
             stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules_source_list is None and 'rulesSourceList' in kwargs:
            rules_source_list = kwargs['rulesSourceList']
        if rules_string is None and 'rulesString' in kwargs:
            rules_string = kwargs['rulesString']
        if stateful_rules is None and 'statefulRules' in kwargs:
            stateful_rules = kwargs['statefulRules']
        if stateless_rules_and_custom_actions is None and 'statelessRulesAndCustomActions' in kwargs:
            stateless_rules_and_custom_actions = kwargs['statelessRulesAndCustomActions']

        if rules_source_list is not None:
            _setter("rules_source_list", rules_source_list)
        if rules_string is not None:
            _setter("rules_string", rules_string)
        if stateful_rules is not None:
            _setter("stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            _setter("stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]:
        """
        A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        """
        return pulumi.get(self, "rules_source_list")

    @rules_source_list.setter
    def rules_source_list(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]):
        pulumi.set(self, "rules_source_list", value)

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        """
        return pulumi.get(self, "rules_string")

    @rules_string.setter
    def rules_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rules_string", value)

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]:
        """
        Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        """
        return pulumi.get(self, "stateful_rules")

    @stateful_rules.setter
    def stateful_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]):
        pulumi.set(self, "stateful_rules", value)

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]:
        """
        A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")

    @stateless_rules_and_custom_actions.setter
    def stateless_rules_and_custom_actions(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]):
        pulumi.set(self, "stateless_rules_and_custom_actions", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceRulesSourceListArgs:
    def __init__(__self__, *,
                 generated_rules_type: pulumi.Input[str],
                 target_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] generated_rules_type: String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_types: Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: Set of domains that you want to inspect for in your traffic flows.
        """
        RuleGroupRuleGroupRulesSourceRulesSourceListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            generated_rules_type=generated_rules_type,
            target_types=target_types,
            targets=targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             generated_rules_type: Optional[pulumi.Input[str]] = None,
             target_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if generated_rules_type is None and 'generatedRulesType' in kwargs:
            generated_rules_type = kwargs['generatedRulesType']
        if generated_rules_type is None:
            raise TypeError("Missing 'generated_rules_type' argument")
        if target_types is None and 'targetTypes' in kwargs:
            target_types = kwargs['targetTypes']
        if target_types is None:
            raise TypeError("Missing 'target_types' argument")
        if targets is None:
            raise TypeError("Missing 'targets' argument")

        _setter("generated_rules_type", generated_rules_type)
        _setter("target_types", target_types)
        _setter("targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> pulumi.Input[str]:
        """
        String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        """
        return pulumi.get(self, "generated_rules_type")

    @generated_rules_type.setter
    def generated_rules_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "generated_rules_type", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_types", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of domains that you want to inspect for in your traffic flows.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 header: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs'],
                 rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        """
        :param pulumi.Input[str] action: Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs'] header: A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]] rule_options: Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        RuleGroupRuleGroupRulesSourceStatefulRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            header=header,
            rule_options=rule_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             header: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']] = None,
             rule_options: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if header is None:
            raise TypeError("Missing 'header' argument")
        if rule_options is None and 'ruleOptions' in kwargs:
            rule_options = kwargs['ruleOptions']
        if rule_options is None:
            raise TypeError("Missing 'rule_options' argument")

        _setter("action", action)
        _setter("header", header)
        _setter("rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']:
        """
        A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]:
        """
        Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        return pulumi.get(self, "rule_options")

    @rule_options.setter
    def rule_options(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        pulumi.set(self, "rule_options", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 destination_port: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 source_port: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        :param pulumi.Input[str] destination_port: The destination port to inspect for. To match with any address, specify `ANY`.
        :param pulumi.Input[str] direction: The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        :param pulumi.Input[str] protocol: The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        :param pulumi.Input[str] source: The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        :param pulumi.Input[str] source_port: The source port to inspect for. To match with any address, specify `ANY`.
        """
        RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            destination_port=destination_port,
            direction=direction,
            protocol=protocol,
            source=source,
            source_port=source_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             destination_port: Optional[pulumi.Input[str]] = None,
             direction: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             source_port: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if destination_port is None and 'destinationPort' in kwargs:
            destination_port = kwargs['destinationPort']
        if destination_port is None:
            raise TypeError("Missing 'destination_port' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if source_port is None and 'sourcePort' in kwargs:
            source_port = kwargs['sourcePort']
        if source_port is None:
            raise TypeError("Missing 'source_port' argument")

        _setter("destination", destination)
        _setter("destination_port", destination_port)
        _setter("direction", direction)
        _setter("protocol", protocol)
        _setter("source", source)
        _setter("source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[str]:
        """
        The destination port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[str]:
        """
        The source port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_port", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs:
    def __init__(__self__, *,
                 keyword: pulumi.Input[str],
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] keyword: Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
               See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] settings: Set of strings for additional settings to use in stateful rule inspection.
        """
        RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keyword=keyword,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keyword: Optional[pulumi.Input[str]] = None,
             settings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if keyword is None:
            raise TypeError("Missing 'keyword' argument")

        _setter("keyword", keyword)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> pulumi.Input[str]:
        """
        Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
        See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: pulumi.Input[str]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of strings for additional settings to use in stateful rule inspection.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs:
    def __init__(__self__, *,
                 stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]],
                 custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]] stateless_rules: Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]] custom_actions: Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stateless_rules=stateless_rules,
            custom_actions=custom_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stateless_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]] = None,
             custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stateless_rules is None and 'statelessRules' in kwargs:
            stateless_rules = kwargs['statelessRules']
        if stateless_rules is None:
            raise TypeError("Missing 'stateless_rules' argument")
        if custom_actions is None and 'customActions' in kwargs:
            custom_actions = kwargs['customActions']

        _setter("stateless_rules", stateless_rules)
        if custom_actions is not None:
            _setter("custom_actions", custom_actions)

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]:
        """
        Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        """
        return pulumi.get(self, "stateless_rules")

    @stateless_rules.setter
    def stateless_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]):
        pulumi.set(self, "stateless_rules", value)

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]:
        """
        Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        return pulumi.get(self, "custom_actions")

    @custom_actions.setter
    def custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]):
        pulumi.set(self, "custom_actions", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs'] action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param pulumi.Input[str] action_name: A friendly name of the custom action.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_definition=action_definition,
            action_name=action_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_definition: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']] = None,
             action_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_definition is None and 'actionDefinition' in kwargs:
            action_definition = kwargs['actionDefinition']
        if action_definition is None:
            raise TypeError("Missing 'action_definition' argument")
        if action_name is None and 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if action_name is None:
            raise TypeError("Missing 'action_name' argument")

        _setter("action_definition", action_definition)
        _setter("action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']:
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs'] publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish_metric_action=publish_metric_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish_metric_action: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publish_metric_action is None and 'publishMetricAction' in kwargs:
            publish_metric_action = kwargs['publishMetricAction']
        if publish_metric_action is None:
            raise TypeError("Missing 'publish_metric_action' argument")

        _setter("publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']:
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]] dimensions: Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")

        _setter("dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        """
        Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 rule_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        """
        :param pulumi.Input[int] priority: A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs'] rule_definition: A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            rule_definition=rule_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[pulumi.Input[int]] = None,
             rule_definition: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if rule_definition is None and 'ruleDefinition' in kwargs:
            rule_definition = kwargs['ruleDefinition']
        if rule_definition is None:
            raise TypeError("Missing 'rule_definition' argument")

        _setter("priority", priority)
        _setter("rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']:
        """
        A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        pulumi.set(self, "rule_definition", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_attributes: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs'] match_attributes: A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            match_attributes=match_attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             match_attributes: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if match_attributes is None and 'matchAttributes' in kwargs:
            match_attributes = kwargs['matchAttributes']
        if match_attributes is None:
            raise TypeError("Missing 'match_attributes' argument")

        _setter("actions", actions)
        _setter("match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']:
        """
        A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        return pulumi.get(self, "match_attributes")

    @match_attributes.setter
    def match_attributes(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        pulumi.set(self, "match_attributes", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]] = None,
                 tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]] destination_ports: Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]] destinations: Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]] source_ports: Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]] sources: Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]] tcp_flags: Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ports=destination_ports,
            destinations=destinations,
            protocols=protocols,
            source_ports=source_ports,
            sources=sources,
            tcp_flags=tcp_flags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]] = None,
             destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]] = None,
             protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]] = None,
             sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]] = None,
             tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_ports is None and 'destinationPorts' in kwargs:
            destination_ports = kwargs['destinationPorts']
        if source_ports is None and 'sourcePorts' in kwargs:
            source_ports = kwargs['sourcePorts']
        if tcp_flags is None and 'tcpFlags' in kwargs:
            tcp_flags = kwargs['tcpFlags']

        if destination_ports is not None:
            _setter("destination_ports", destination_ports)
        if destinations is not None:
            _setter("destinations", destinations)
        if protocols is not None:
            _setter("protocols", protocols)
        if source_ports is not None:
            _setter("source_ports", source_ports)
        if sources is not None:
            _setter("sources", sources)
        if tcp_flags is not None:
            _setter("tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]:
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]:
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]:
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]:
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]:
        """
        Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]):
        pulumi.set(self, "tcp_flags", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_definition=address_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_definition: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_definition is None and 'addressDefinition' in kwargs:
            address_definition = kwargs['addressDefinition']
        if address_definition is None:
            raise TypeError("Missing 'address_definition' argument")

        _setter("address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[pulumi.Input[int]] = None,
             to_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_definition=address_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_definition: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_definition is None and 'addressDefinition' in kwargs:
            address_definition = kwargs['addressDefinition']
        if address_definition is None:
            raise TypeError("Missing 'address_definition' argument")

        _setter("address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[pulumi.Input[int]] = None,
             to_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']

        _setter("from_port", from_port)
        if to_port is not None:
            _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs:
    def __init__(__self__, *,
                 flags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 masks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] masks: Set of flags to consider in the inspection. To inspect all flags, leave this empty.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flags=flags,
            masks=masks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             masks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if flags is None:
            raise TypeError("Missing 'flags' argument")

        _setter("flags", flags)
        if masks is not None:
            _setter("masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of flags to consider in the inspection. To inspect all flags, leave this empty.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "masks")

    @masks.setter
    def masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "masks", value)


@pulumi.input_type
class RuleGroupRuleGroupStatefulRuleOptionsArgs:
    def __init__(__self__, *,
                 rule_order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] rule_order: Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        RuleGroupRuleGroupStatefulRuleOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_order=rule_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_order: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_order is None and 'ruleOrder' in kwargs:
            rule_order = kwargs['ruleOrder']
        if rule_order is None:
            raise TypeError("Missing 'rule_order' argument")

        _setter("rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> pulumi.Input[str]:
        """
        Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_order", value)


