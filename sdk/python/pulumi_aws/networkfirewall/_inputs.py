# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FirewallEncryptionConfigurationArgs',
    'FirewallEncryptionConfigurationArgsDict',
    'FirewallFirewallStatusArgs',
    'FirewallFirewallStatusArgsDict',
    'FirewallFirewallStatusSyncStateArgs',
    'FirewallFirewallStatusSyncStateArgsDict',
    'FirewallFirewallStatusSyncStateAttachmentArgs',
    'FirewallFirewallStatusSyncStateAttachmentArgsDict',
    'FirewallPolicyEncryptionConfigurationArgs',
    'FirewallPolicyEncryptionConfigurationArgsDict',
    'FirewallPolicyFirewallPolicyArgs',
    'FirewallPolicyFirewallPolicyArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict',
    'FirewallSubnetMappingArgs',
    'FirewallSubnetMappingArgsDict',
    'LoggingConfigurationLoggingConfigurationArgs',
    'LoggingConfigurationLoggingConfigurationArgsDict',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict',
    'RuleGroupEncryptionConfigurationArgs',
    'RuleGroupEncryptionConfigurationArgsDict',
    'RuleGroupRuleGroupArgs',
    'RuleGroupRuleGroupArgsDict',
    'RuleGroupRuleGroupReferenceSetsArgs',
    'RuleGroupRuleGroupReferenceSetsArgsDict',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict',
    'RuleGroupRuleGroupRuleVariablesArgs',
    'RuleGroupRuleGroupRuleVariablesArgsDict',
    'RuleGroupRuleGroupRuleVariablesIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesPortSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict',
    'RuleGroupRuleGroupRulesSourceArgs',
    'RuleGroupRuleGroupRulesSourceArgsDict',
    'RuleGroupRuleGroupRulesSourceRulesSourceListArgs',
    'RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict',
    'RuleGroupRuleGroupStatefulRuleOptionsArgs',
    'RuleGroupRuleGroupStatefulRuleOptionsArgsDict',
    'TlsInspectionConfigurationCertificateArgs',
    'TlsInspectionConfigurationCertificateArgsDict',
    'TlsInspectionConfigurationCertificateAuthorityArgs',
    'TlsInspectionConfigurationCertificateAuthorityArgsDict',
    'TlsInspectionConfigurationEncryptionConfigurationArgs',
    'TlsInspectionConfigurationEncryptionConfigurationArgsDict',
    'TlsInspectionConfigurationTimeoutsArgs',
    'TlsInspectionConfigurationTimeoutsArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict',
]

MYPY = False

if not MYPY:
    class FirewallEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
elif False:
    FirewallEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class FirewallFirewallStatusArgsDict(TypedDict):
        sync_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgsDict']]]]
        """
        Set of subnets configured for use by the firewall.
        """
elif False:
    FirewallFirewallStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusArgs:
    def __init__(__self__, *,
                 sync_states: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]] sync_states: Set of subnets configured for use by the firewall.
        """
        if sync_states is not None:
            pulumi.set(__self__, "sync_states", sync_states)

    @property
    @pulumi.getter(name="syncStates")
    def sync_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]:
        """
        Set of subnets configured for use by the firewall.
        """
        return pulumi.get(self, "sync_states")

    @sync_states.setter
    def sync_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]):
        pulumi.set(self, "sync_states", value)


if not MYPY:
    class FirewallFirewallStatusSyncStateArgsDict(TypedDict):
        attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgsDict']]]]
        """
        Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        """
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        The Availability Zone where the subnet is configured.
        """
elif False:
    FirewallFirewallStatusSyncStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusSyncStateArgs:
    def __init__(__self__, *,
                 attachments: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]] attachments: Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        :param pulumi.Input[str] availability_zone: The Availability Zone where the subnet is configured.
        """
        if attachments is not None:
            pulumi.set(__self__, "attachments", attachments)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @property
    @pulumi.getter
    def attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]:
        """
        Nested list describing the attachment status of the firewall's association with a single VPC subnet.
        """
        return pulumi.get(self, "attachments")

    @attachments.setter
    def attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]):
        pulumi.set(self, "attachments", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Zone where the subnet is configured.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class FirewallFirewallStatusSyncStateAttachmentArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[str]]
        """
        The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the subnet that you've specified to be used for a firewall endpoint.
        """
elif False:
    FirewallFirewallStatusSyncStateAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusSyncStateAttachmentArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        :param pulumi.Input[str] subnet_id: The unique identifier of the subnet that you've specified to be used for a firewall endpoint.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the firewall endpoint that AWS Network Firewall has instantiated in the subnet. You use this to identify the firewall endpoint in the VPC route tables, when you redirect the VPC traffic through the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the subnet that you've specified to be used for a firewall endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class FirewallPolicyEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
elif False:
    FirewallPolicyEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyArgsDict(TypedDict):
        stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        policy_variables: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgsDict']]
        """
        . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        """
        stateful_default_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        """
        stateful_engine_options: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict']]
        """
        A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        """
        stateful_rule_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict']]]]
        """
        Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        """
        stateless_custom_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict']]]]
        """
        Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        """
        stateless_rule_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict']]]]
        """
        Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        tls_inspection_configuration_arn: NotRequired[pulumi.Input[str]]
        """
        The (ARN) of the TLS Inspection policy to attach to the FW Policy.  This must be added at creation of the resource per AWS documentation. "You can only add a TLS inspection configuration to a new policy, not to an existing policy."  This cannot be removed from a FW Policy.
        """
elif False:
    FirewallPolicyFirewallPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyArgs:
    def __init__(__self__, *,
                 stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 policy_variables: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']] = None,
                 stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stateful_engine_options: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']] = None,
                 stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
                 stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]] = None,
                 stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None,
                 tls_inspection_configuration_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_default_actions: Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_fragment_default_actions: Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
               In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        :param pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs'] policy_variables: . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateful_default_actions: Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs'] stateful_engine_options: A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]] stateful_rule_group_references: Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]] stateless_custom_actions: Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]] stateless_rule_group_references: Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        :param pulumi.Input[str] tls_inspection_configuration_arn: The (ARN) of the TLS Inspection policy to attach to the FW Policy.  This must be added at creation of the resource per AWS documentation. "You can only add a TLS inspection configuration to a new policy, not to an existing policy."  This cannot be removed from a FW Policy.
        """
        pulumi.set(__self__, "stateless_default_actions", stateless_default_actions)
        pulumi.set(__self__, "stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            pulumi.set(__self__, "policy_variables", policy_variables)
        if stateful_default_actions is not None:
            pulumi.set(__self__, "stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            pulumi.set(__self__, "stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            pulumi.set(__self__, "stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            pulumi.set(__self__, "stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            pulumi.set(__self__, "stateless_rule_group_references", stateless_rule_group_references)
        if tls_inspection_configuration_arn is not None:
            pulumi.set(__self__, "tls_inspection_configuration_arn", tls_inspection_configuration_arn)

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_default_actions")

    @stateless_default_actions.setter
    def stateless_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_default_actions", value)

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a fragmented packet if it does not match any of the stateless rules in the policy. You must specify one of the standard actions including: `aws:drop`, `aws:pass`, or `aws:forward_to_sfe`.
        In addition, you can specify custom actions that are compatible with your standard action choice. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @stateless_fragment_default_actions.setter
    def stateless_fragment_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_fragment_default_actions", value)

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]:
        """
        . Contains variables that you can use to override default Suricata settings in your firewall policy. See Rule Variables for details.
        """
        return pulumi.get(self, "policy_variables")

    @policy_variables.setter
    def policy_variables(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]):
        pulumi.set(self, "policy_variables", value)

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of actions to take on a packet if it does not match any stateful rules in the policy. This can only be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. You can specify one of either or neither values of `aws:drop_strict` or `aws:drop_established`, as well as any combination of `aws:alert_strict` and `aws:alert_established`.
        """
        return pulumi.get(self, "stateful_default_actions")

    @stateful_default_actions.setter
    def stateful_default_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stateful_default_actions", value)

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]:
        """
        A configuration block that defines options on how the policy handles stateful rules. See Stateful Engine Options below for details.
        """
        return pulumi.get(self, "stateful_engine_options")

    @stateful_engine_options.setter
    def stateful_engine_options(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]):
        pulumi.set(self, "stateful_engine_options", value)

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]:
        """
        Set of configuration blocks containing references to the stateful rule groups that are used in the policy. See Stateful Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @stateful_rule_group_references.setter
    def stateful_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateful_rule_group_references", value)

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]:
        """
        Set of configuration blocks describing the custom action definitions that are available for use in the firewall policy's `stateless_default_actions`. See Stateless Custom Action below for details.
        """
        return pulumi.get(self, "stateless_custom_actions")

    @stateless_custom_actions.setter
    def stateless_custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]):
        pulumi.set(self, "stateless_custom_actions", value)

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]:
        """
        Set of configuration blocks containing references to the stateless rule groups that are used in the policy. See Stateless Rule Group Reference below for details.
        """
        return pulumi.get(self, "stateless_rule_group_references")

    @stateless_rule_group_references.setter
    def stateless_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateless_rule_group_references", value)

    @property
    @pulumi.getter(name="tlsInspectionConfigurationArn")
    def tls_inspection_configuration_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The (ARN) of the TLS Inspection policy to attach to the FW Policy.  This must be added at creation of the resource per AWS documentation. "You can only add a TLS inspection configuration to a new policy, not to an existing policy."  This cannot be removed from a FW Policy.
        """
        return pulumi.get(self, "tls_inspection_configuration_arn")

    @tls_inspection_configuration_arn.setter
    def tls_inspection_configuration_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_inspection_configuration_arn", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesArgsDict(TypedDict):
        rule_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict']]]]
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesArgs:
    def __init__(__self__, *,
                 rule_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]] = None):
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]):
        pulumi.set(self, "rule_variables", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict(TypedDict):
        ip_set: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict']
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        key: pulumi.Input[str]
        """
        An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs'],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs'] ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param pulumi.Input[str] key: An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        pulumi.set(__self__, "ip_set", ip_set)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']:
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An alphanumeric string to identify the `ip_set`. Valid values: `HOME_NET`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        pulumi.set(__self__, "definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of IPv4 or IPv6 addresses in CIDR notation to use for the Suricata `HOME_NET` variable.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict(TypedDict):
        rule_order: NotRequired[pulumi.Input[str]]
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        stream_exception_policy: NotRequired[pulumi.Input[str]]
        """
        Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
elif False:
    FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input[str]] = None,
                 stream_exception_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rule_order: Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        :param pulumi.Input[str] stream_exception_policy: Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)
        if stream_exception_policy is not None:
            pulumi.set(__self__, "stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_order", value)

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how to treat traffic which has broken midstream. Default value: `DROP`. Valid values: `DROP`, `CONTINUE`, `REJECT`.
        """
        return pulumi.get(self, "stream_exception_policy")

    @stream_exception_policy.setter
    def stream_exception_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_exception_policy", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict(TypedDict):
        resource_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        override: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict']]
        """
        Configuration block for override values
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
elif False:
    FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[str],
                 override: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateful rule group.
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs'] override: Configuration block for override values
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        pulumi.set(__self__, "resource_arn", resource_arn)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]:
        """
        Configuration block for override values
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        An integer setting that indicates the order in which to apply the stateful rule groups in a single policy. This argument must be specified if the policy has a `stateful_engine_options` block with a `rule_order` value of `STRICT_ORDER`. AWS Network Firewall applies each stateful rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
elif False:
    FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action that changes the rule group from DROP to ALERT . This only applies to managed rule groups.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict(TypedDict):
        action_definition: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict']
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        action_name: pulumi.Input[str]
        """
        A friendly name of the custom action.
        """
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs'] action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param pulumi.Input[str] action_name: A friendly name of the custom action.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']:
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict(TypedDict):
        publish_metric_action: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict']
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        """
        :param pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs'] publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']:
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict']]]
        """
        Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]] dimensions: Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        """
        Set of configuration blocks describing dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for more details.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The string value to use in the custom metric dimension.
        """
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The string value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The string value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        """
        resource_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
elif False:
    FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 resource_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateless rule group.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single policy. AWS Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)


if not MYPY:
    class FirewallSubnetMappingArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        The unique identifier for the subnet.
        """
        ip_address_type: NotRequired[pulumi.Input[str]]
        """
        The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
elif False:
    FirewallSubnetMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ip_address_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: The unique identifier for the subnet.
        :param pulumi.Input[str] ip_address_type: The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet's IP address type. Valida values: `"DUALSTACK"`, `"IPV4"`.
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_type", value)


if not MYPY:
    class LoggingConfigurationLoggingConfigurationArgsDict(TypedDict):
        log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict']]]
        """
        Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
elif False:
    LoggingConfigurationLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggingConfigurationLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]] log_destination_configs: Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        pulumi.set(__self__, "log_destination_configs", log_destination_configs)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]:
        """
        Set of configuration blocks describing the logging details for a firewall. See Log Destination Config below for details. At most, only two blocks can be specified; one for `FLOW` logs and one for `ALERT` logs.
        """
        return pulumi.get(self, "log_destination_configs")

    @log_destination_configs.setter
    def log_destination_configs(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(self, "log_destination_configs", value)


if not MYPY:
    class LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict(TypedDict):
        log_destination: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        A map describing the logging destination for the chosen `log_destination_type`.
        * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
        * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
        * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        """
        log_destination_type: pulumi.Input[str]
        """
        The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        """
        log_type: pulumi.Input[str]
        """
        The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
elif False:
    LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs:
    def __init__(__self__, *,
                 log_destination: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 log_destination_type: pulumi.Input[str],
                 log_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] log_destination: A map describing the logging destination for the chosen `log_destination_type`.
               * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
               * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
               * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        :param pulumi.Input[str] log_destination_type: The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        :param pulumi.Input[str] log_type: The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        pulumi.set(__self__, "log_destination", log_destination)
        pulumi.set(__self__, "log_destination_type", log_destination_type)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A map describing the logging destination for the chosen `log_destination_type`.
        * For an Amazon S3 bucket, specify the key `bucketName` with the name of the bucket and optionally specify the key `prefix` with a path.
        * For a CloudWatch log group, specify the key `logGroup` with the name of the CloudWatch log group.
        * For a Kinesis Data Firehose delivery stream, specify the key `deliveryStream` with the name of the delivery stream.
        """
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "log_destination", value)

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> pulumi.Input[str]:
        """
        The location to send logs to. Valid values: `S3`, `CloudWatchLogs`, `KinesisDataFirehose`.
        """
        return pulumi.get(self, "log_destination_type")

    @log_destination_type.setter
    def log_destination_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_destination_type", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[str]:
        """
        The type of log to send. Valid values: `ALERT` or `FLOW`. Alert logs report traffic that matches a `StatefulRule` with an action setting that sends a log message. Flow logs are standard network traffic flow logs.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class RuleGroupEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        key_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
elif False:
    RuleGroupEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        :param pulumi.Input[str] key_id: The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of AWS KMS key to use for encryption of your Network Firewall resources. Valid values are `CUSTOMER_KMS` and `AWS_OWNED_KMS_KEY`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the customer managed key. You can use any of the [key identifiers](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class RuleGroupRuleGroupArgsDict(TypedDict):
        rules_source: pulumi.Input['RuleGroupRuleGroupRulesSourceArgsDict']
        """
        A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        """
        reference_sets: NotRequired[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgsDict']]
        """
        A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        """
        rule_variables: NotRequired[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgsDict']]
        """
        A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        """
        stateful_rule_options: NotRequired[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgsDict']]
        """
        A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
elif False:
    RuleGroupRuleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupArgs:
    def __init__(__self__, *,
                 rules_source: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs'],
                 reference_sets: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']] = None,
                 rule_variables: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']] = None,
                 stateful_rule_options: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceArgs'] rules_source: A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        :param pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs'] reference_sets: A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs'] rule_variables: A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        :param pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs'] stateful_rule_options: A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        pulumi.set(__self__, "rules_source", rules_source)
        if reference_sets is not None:
            pulumi.set(__self__, "reference_sets", reference_sets)
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)
        if stateful_rule_options is not None:
            pulumi.set(__self__, "stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']:
        """
        A configuration block that defines the stateful or stateless rules for the rule group. See Rules Source below for details.
        """
        return pulumi.get(self, "rules_source")

    @rules_source.setter
    def rules_source(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']):
        pulumi.set(self, "rules_source", value)

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]:
        """
        A configuration block that defines the IP Set References for the rule group. See Reference Sets below for details. Please notes that there can only be a maximum of 5 `reference_sets` in a `rule_group`. See the [AWS documentation](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html#rule-groups-ip-set-reference-limits) for details.
        """
        return pulumi.get(self, "reference_sets")

    @reference_sets.setter
    def reference_sets(self, value: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]):
        pulumi.set(self, "reference_sets", value)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]:
        """
        A configuration block that defines additional settings available to use in the rules defined in the rule group. Can only be specified for **stateful** rule groups. See Rule Variables below for details.
        """
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]):
        pulumi.set(self, "rule_variables", value)

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]:
        """
        A configuration block that defines stateful rule options for the rule group. See Stateful Rule Options below for details.
        """
        return pulumi.get(self, "stateful_rule_options")

    @stateful_rule_options.setter
    def stateful_rule_options(self, value: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]):
        pulumi.set(self, "stateful_rule_options", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsArgsDict(TypedDict):
        ip_set_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict']]]]
elif False:
    RuleGroupRuleGroupReferenceSetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsArgs:
    def __init__(__self__, *,
                 ip_set_references: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]] = None):
        if ip_set_references is not None:
            pulumi.set(__self__, "ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]:
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]):
        pulumi.set(self, "ip_set_references", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict(TypedDict):
        ip_set_references: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict']]]
        key: pulumi.Input[str]
elif False:
    RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs:
    def __init__(__self__, *,
                 ip_set_references: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "ip_set_references", ip_set_references)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]:
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]):
        pulumi.set(self, "ip_set_references", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict(TypedDict):
        reference_arn: pulumi.Input[str]
        """
        Set of Managed Prefix IP ARN(s)
        """
elif False:
    RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs:
    def __init__(__self__, *,
                 reference_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] reference_arn: Set of Managed Prefix IP ARN(s)
        """
        pulumi.set(__self__, "reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> pulumi.Input[str]:
        """
        Set of Managed Prefix IP ARN(s)
        """
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_arn", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesArgsDict(TypedDict):
        ip_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgsDict']]]]
        """
        Set of configuration blocks that define IP address information. See IP Sets below for details.
        """
        port_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgsDict']]]]
        """
        Set of configuration blocks that define port range information. See Port Sets below for details.
        """
elif False:
    RuleGroupRuleGroupRuleVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesArgs:
    def __init__(__self__, *,
                 ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]] = None,
                 port_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]] ip_sets: Set of configuration blocks that define IP address information. See IP Sets below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]] port_sets: Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if port_sets is not None:
            pulumi.set(__self__, "port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]:
        """
        Set of configuration blocks that define IP address information. See IP Sets below for details.
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]:
        """
        Set of configuration blocks that define port range information. See Port Sets below for details.
        """
        return pulumi.get(self, "port_sets")

    @port_sets.setter
    def port_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]):
        pulumi.set(self, "port_sets", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesIpSetArgsDict(TypedDict):
        ip_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict']
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        key: pulumi.Input[str]
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
elif False:
    RuleGroupRuleGroupRuleVariablesIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs'],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs'] ip_set: A configuration block that defines a set of IP addresses. See IP Set below for details.
        :param pulumi.Input[str] key: A unique alphanumeric string to identify the `ip_set`.
        """
        pulumi.set(__self__, "ip_set", ip_set)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']:
        """
        A configuration block that defines a set of IP addresses. See IP Set below for details.
        """
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A unique alphanumeric string to identify the `ip_set`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of IP addresses and address ranges, in CIDR notation.
        """
elif False:
    RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of IP addresses and address ranges, in CIDR notation.
        """
        pulumi.set(__self__, "definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesPortSetArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        An unique alphanumeric string to identify the `port_set`.
        """
        port_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict']
        """
        A configuration block that defines a set of port ranges. See Port Set below for details.
        """
elif False:
    RuleGroupRuleGroupRuleVariablesPortSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 port_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        """
        :param pulumi.Input[str] key: An unique alphanumeric string to identify the `port_set`.
        :param pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs'] port_set: A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "port_set", port_set)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An unique alphanumeric string to identify the `port_set`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="portSet")
    def port_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']:
        """
        A configuration block that defines a set of port ranges. See Port Set below for details.
        """
        return pulumi.get(self, "port_set")

    @port_set.setter
    def port_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        pulumi.set(self, "port_set", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of port ranges.
        """
elif False:
    RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definitions: Set of port ranges.
        """
        pulumi.set(__self__, "definitions", definitions)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of port ranges.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceArgsDict(TypedDict):
        rules_source_list: NotRequired[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict']]
        """
        A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        """
        rules_string: NotRequired[pulumi.Input[str]]
        """
        The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        """
        stateful_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict']]]]
        """
        Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        """
        stateless_rules_and_custom_actions: NotRequired[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict']]
        """
        A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceArgs:
    def __init__(__self__, *,
                 rules_source_list: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']] = None,
                 rules_string: Optional[pulumi.Input[str]] = None,
                 stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]] = None,
                 stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs'] rules_source_list: A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        :param pulumi.Input[str] rules_string: The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]] stateful_rules: Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs'] stateless_rules_and_custom_actions: A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        if rules_source_list is not None:
            pulumi.set(__self__, "rules_source_list", rules_source_list)
        if rules_string is not None:
            pulumi.set(__self__, "rules_string", rules_string)
        if stateful_rules is not None:
            pulumi.set(__self__, "stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            pulumi.set(__self__, "stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]:
        """
        A configuration block containing **stateful** inspection criteria for a domain list rule group. See Rules Source List below for details.
        """
        return pulumi.get(self, "rules_source_list")

    @rules_source_list.setter
    def rules_source_list(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]):
        pulumi.set(self, "rules_source_list", value)

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified name of a file in an S3 bucket that contains Suricata compatible intrusion preventions system (IPS) rules or the Suricata rules as a string. These rules contain **stateful** inspection criteria and the action to take for traffic that matches the criteria.
        """
        return pulumi.get(self, "rules_string")

    @rules_string.setter
    def rules_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rules_string", value)

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]:
        """
        Set of configuration blocks containing **stateful** inspection criteria for 5-tuple rules to be used together in a rule group. See Stateful Rule below for details.
        """
        return pulumi.get(self, "stateful_rules")

    @stateful_rules.setter
    def stateful_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]):
        pulumi.set(self, "stateful_rules", value)

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]:
        """
        A configuration block containing **stateless** inspection criteria for a stateless rule group. See Stateless Rules and Custom Actions below for details.
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")

    @stateless_rules_and_custom_actions.setter
    def stateless_rules_and_custom_actions(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]):
        pulumi.set(self, "stateless_rules_and_custom_actions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict(TypedDict):
        generated_rules_type: pulumi.Input[str]
        """
        String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        """
        target_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        """
        targets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of domains that you want to inspect for in your traffic flows.
        """
elif False:
    RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceRulesSourceListArgs:
    def __init__(__self__, *,
                 generated_rules_type: pulumi.Input[str],
                 target_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] generated_rules_type: String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_types: Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: Set of domains that you want to inspect for in your traffic flows.
        """
        pulumi.set(__self__, "generated_rules_type", generated_rules_type)
        pulumi.set(__self__, "target_types", target_types)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> pulumi.Input[str]:
        """
        String value to specify whether domains in the target list are allowed or denied access. Valid values: `ALLOWLIST`, `DENYLIST`.
        """
        return pulumi.get(self, "generated_rules_type")

    @generated_rules_type.setter
    def generated_rules_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "generated_rules_type", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of types of domain specifications that are provided in the `targets` argument. Valid values: `HTTP_HOST`, `TLS_SNI`.
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_types", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of domains that you want to inspect for in your traffic flows.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        """
        header: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict']
        """
        A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        """
        rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict']]]
        """
        Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 header: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs'],
                 rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        """
        :param pulumi.Input[str] action: Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs'] header: A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]] rule_options: Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to take with packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, AWS Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow. Valid values: `ALERT`, `DROP`, `PASS`, or `REJECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']:
        """
        A configuration block containing the stateful 5-tuple inspection criteria for the rule, used to inspect traffic flows. See Header below for details.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]:
        """
        Set of configuration blocks containing additional settings for a stateful rule. See Rule Option below for details.
        """
        return pulumi.get(self, "rule_options")

    @rule_options.setter
    def rule_options(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        pulumi.set(self, "rule_options", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        """
        destination_port: pulumi.Input[str]
        """
        The destination port to inspect for. To match with any address, specify `ANY`.
        """
        direction: pulumi.Input[str]
        """
        The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        """
        protocol: pulumi.Input[str]
        """
        The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        """
        source: pulumi.Input[str]
        """
        The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        """
        source_port: pulumi.Input[str]
        """
        The source port to inspect for. To match with any address, specify `ANY`.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 destination_port: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 source_port: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        :param pulumi.Input[str] destination_port: The destination port to inspect for. To match with any address, specify `ANY`.
        :param pulumi.Input[str] direction: The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        :param pulumi.Input[str] protocol: The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        :param pulumi.Input[str] source: The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        :param pulumi.Input[str] source_port: The source port to inspect for. To match with any address, specify `ANY`.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[str]:
        """
        The destination port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        The direction of traffic flow to inspect. Valid values: `ANY` or `FORWARD`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to inspect. Valid values: `IP`, `TCP`, `UDP`, `ICMP`, `HTTP`, `FTP`, `TLS`, `SMB`, `DNS`, `DCERPC`, `SSH`, `SMTP`, `IMAP`, `MSN`, `KRB5`, `IKEV2`, `TFTP`, `NTP`, `DHCP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source IP address or address range for, in CIDR notation. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[str]:
        """
        The source port to inspect for. To match with any address, specify `ANY`.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict(TypedDict):
        keyword: pulumi.Input[str]
        """
        Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
        See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        """
        settings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of strings for additional settings to use in stateful rule inspection.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs:
    def __init__(__self__, *,
                 keyword: pulumi.Input[str],
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] keyword: Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
               See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] settings: Set of strings for additional settings to use in stateful rule inspection.
        """
        pulumi.set(__self__, "keyword", keyword)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> pulumi.Input[str]:
        """
        Keyword defined by open source detection systems like Snort or Suricata for stateful rule inspection.
        See [Snort General Rule Options](http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node31.html) or [Suricata Rule Options](https://suricata.readthedocs.io/en/suricata-5.0.1/rules/intro.html#rule-options) for more details.
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: pulumi.Input[str]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of strings for additional settings to use in stateful rule inspection.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict(TypedDict):
        stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict']]]
        """
        Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        """
        custom_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict']]]]
        """
        Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs:
    def __init__(__self__, *,
                 stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]],
                 custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]] stateless_rules: Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]] custom_actions: Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        pulumi.set(__self__, "stateless_rules", stateless_rules)
        if custom_actions is not None:
            pulumi.set(__self__, "custom_actions", custom_actions)

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]:
        """
        Set of configuration blocks containing the stateless rules for use in the stateless rule group. See Stateless Rule below for details.
        """
        return pulumi.get(self, "stateless_rules")

    @stateless_rules.setter
    def stateless_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]):
        pulumi.set(self, "stateless_rules", value)

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]:
        """
        Set of configuration blocks containing custom action definitions that are available for use by the set of `stateless rule`. See Custom Action below for details.
        """
        return pulumi.get(self, "custom_actions")

    @custom_actions.setter
    def custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]):
        pulumi.set(self, "custom_actions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict(TypedDict):
        action_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict']
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        action_name: pulumi.Input[str]
        """
        A friendly name of the custom action.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs'] action_definition: A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        :param pulumi.Input[str] action_name: A friendly name of the custom action.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']:
        """
        A configuration block describing the custom action associated with the `action_name`. See Action Definition below for details.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        A friendly name of the custom action.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict(TypedDict):
        publish_metric_action: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict']
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        """
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs'] publish_metric_action: A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']:
        """
        A configuration block describing the stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. You can pair this custom action with any of the standard stateless rule actions. See Publish Metric Action below for details.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict']]]
        """
        Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]] dimensions: Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        """
        Set of configuration blocks containing the dimension settings to use for Amazon CloudWatch custom metrics. See Dimension below for details.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The value to use in the custom metric dimension.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        """
        rule_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict']
        """
        A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 rule_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        """
        :param pulumi.Input[int] priority: A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs'] rule_definition: A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        A setting that indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. AWS Network Firewall evaluates the rules in a rule group starting with the lowest priority setting.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']:
        """
        A configuration block defining the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria. See Rule Definition below for details.
        """
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        pulumi.set(self, "rule_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        """
        match_attributes: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict']
        """
        A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_attributes: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        :param pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs'] match_attributes: A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of actions to take on a packet that matches one of the stateless rule definition's `match_attributes`. For every rule you must specify 1 standard action, and you can add custom actions. Standard actions include: `aws:pass`, `aws:drop`, `aws:forward_to_sfe`.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']:
        """
        A configuration block containing criteria for AWS Network Firewall to use to inspect an individual packet in stateless rule inspection. See Match Attributes below for details.
        """
        return pulumi.get(self, "match_attributes")

    @match_attributes.setter
    def match_attributes(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        pulumi.set(self, "match_attributes", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict(TypedDict):
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict']]]]
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict']]]]
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        source_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict']]]]
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict']]]]
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        tcp_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict']]]]
        """
        Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]] = None,
                 tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]] destination_ports: Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]] destinations: Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]] source_ports: Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]] sources: Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]] tcp_flags: Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]:
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Port below for details.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]:
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]:
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Port below for details.
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]:
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]:
        """
        Set of configuration blocks containing the TCP flags and masks to inspect for. If not specified, this matches with any settings.
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]):
        pulumi.set(self, "tcp_flags", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict(TypedDict):
        address_definition: pulumi.Input[str]
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict(TypedDict):
        from_port: pulumi.Input[int]
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict(TypedDict):
        address_definition: pulumi.Input[str]
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict(TypedDict):
        from_port: pulumi.Input[int]
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        to_port: NotRequired[pulumi.Input[int]]
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict(TypedDict):
        flags: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        masks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of flags to consider in the inspection. To inspect all flags, leave this empty.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs:
    def __init__(__self__, *,
                 flags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 masks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] masks: Set of flags to consider in the inspection. To inspect all flags, leave this empty.
               Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        pulumi.set(__self__, "flags", flags)
        if masks is not None:
            pulumi.set(__self__, "masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of flags to look for in a packet. This setting can only specify values that are also specified in `masks`.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of flags to consider in the inspection. To inspect all flags, leave this empty.
        Valid values: `FIN`, `SYN`, `RST`, `PSH`, `ACK`, `URG`, `ECE`, `CWR`.
        """
        return pulumi.get(self, "masks")

    @masks.setter
    def masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "masks", value)


if not MYPY:
    class RuleGroupRuleGroupStatefulRuleOptionsArgsDict(TypedDict):
        rule_order: pulumi.Input[str]
        """
        Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
elif False:
    RuleGroupRuleGroupStatefulRuleOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupStatefulRuleOptionsArgs:
    def __init__(__self__, *,
                 rule_order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] rule_order: Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        pulumi.set(__self__, "rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> pulumi.Input[str]:
        """
        Indicates how to manage the order of the rule evaluation for the rule group. Default value: `DEFAULT_ACTION_ORDER`. Valid values: `DEFAULT_ACTION_ORDER`, `STRICT_ORDER`.
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_order", value)


if not MYPY:
    class TlsInspectionConfigurationCertificateArgsDict(TypedDict):
        certificate_arn: pulumi.Input[str]
        """
        ARN of the certificate.
        """
        certificate_serial: pulumi.Input[str]
        """
        Serial number of the certificate.
        """
        status: pulumi.Input[str]
        """
        Status of the certificate.
        """
        status_message: pulumi.Input[str]
        """
        Details about the certificate status, including information about certificate errors.
        """
elif False:
    TlsInspectionConfigurationCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationCertificateArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[str],
                 certificate_serial: pulumi.Input[str],
                 status: pulumi.Input[str],
                 status_message: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_arn: ARN of the certificate.
        :param pulumi.Input[str] certificate_serial: Serial number of the certificate.
        :param pulumi.Input[str] status: Status of the certificate.
        :param pulumi.Input[str] status_message: Details about the certificate status, including information about certificate errors.
        """
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "certificate_serial", certificate_serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[str]:
        """
        ARN of the certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_arn", value)

    @property
    @pulumi.getter(name="certificateSerial")
    def certificate_serial(self) -> pulumi.Input[str]:
        """
        Serial number of the certificate.
        """
        return pulumi.get(self, "certificate_serial")

    @certificate_serial.setter
    def certificate_serial(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_serial", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the certificate.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[str]:
        """
        Details about the certificate status, including information about certificate errors.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class TlsInspectionConfigurationCertificateAuthorityArgsDict(TypedDict):
        certificate_arn: pulumi.Input[str]
        """
        ARN of the certificate.
        """
        certificate_serial: pulumi.Input[str]
        """
        Serial number of the certificate.
        """
        status: pulumi.Input[str]
        """
        Status of the certificate.
        """
        status_message: pulumi.Input[str]
        """
        Details about the certificate status, including information about certificate errors.
        """
elif False:
    TlsInspectionConfigurationCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationCertificateAuthorityArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[str],
                 certificate_serial: pulumi.Input[str],
                 status: pulumi.Input[str],
                 status_message: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_arn: ARN of the certificate.
        :param pulumi.Input[str] certificate_serial: Serial number of the certificate.
        :param pulumi.Input[str] status: Status of the certificate.
        :param pulumi.Input[str] status_message: Details about the certificate status, including information about certificate errors.
        """
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "certificate_serial", certificate_serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[str]:
        """
        ARN of the certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_arn", value)

    @property
    @pulumi.getter(name="certificateSerial")
    def certificate_serial(self) -> pulumi.Input[str]:
        """
        Serial number of the certificate.
        """
        return pulumi.get(self, "certificate_serial")

    @certificate_serial.setter
    def certificate_serial(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_serial", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the certificate.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[str]:
        """
        Details about the certificate status, including information about certificate errors.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class TlsInspectionConfigurationEncryptionConfigurationArgsDict(TypedDict):
        key_id: pulumi.Input[str]
        """
        ARN of the Amazon Web Services Key Management Service (KMS) customer managed key.
        """
        type: pulumi.Input[str]
        """
        Type of KMS key to use for encryption of your Network Firewall resources. Valid values: `AWS_OWNED_KMS_KEY`, `CUSTOMER_KMS`.
        """
elif False:
    TlsInspectionConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key_id: ARN of the Amazon Web Services Key Management Service (KMS) customer managed key.
        :param pulumi.Input[str] type: Type of KMS key to use for encryption of your Network Firewall resources. Valid values: `AWS_OWNED_KMS_KEY`, `CUSTOMER_KMS`.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        ARN of the Amazon Web Services Key Management Service (KMS) customer managed key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of KMS key to use for encryption of your Network Firewall resources. Valid values: `AWS_OWNED_KMS_KEY`, `CUSTOMER_KMS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TlsInspectionConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    TlsInspectionConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationArgsDict(TypedDict):
        server_certificate_configuration: NotRequired[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict']]
        """
        Server certificate configurations that are associated with the TLS configuration. Detailed below.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationArgs:
    def __init__(__self__, *,
                 server_certificate_configuration: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']] = None):
        """
        :param pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs'] server_certificate_configuration: Server certificate configurations that are associated with the TLS configuration. Detailed below.
        """
        if server_certificate_configuration is not None:
            pulumi.set(__self__, "server_certificate_configuration", server_certificate_configuration)

    @property
    @pulumi.getter(name="serverCertificateConfiguration")
    def server_certificate_configuration(self) -> Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']]:
        """
        Server certificate configurations that are associated with the TLS configuration. Detailed below.
        """
        return pulumi.get(self, "server_certificate_configuration")

    @server_certificate_configuration.setter
    def server_certificate_configuration(self, value: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']]):
        pulumi.set(self, "server_certificate_configuration", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict(TypedDict):
        certificate_authority_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the imported certificate authority (CA) certificate within Certificate Manager (ACM) to use for outbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) for limitations on CA certificates.
        """
        check_certificate_revocation_status: NotRequired[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict']]
        """
        Check Certificate Revocation Status block. Detailed below.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict']]]]
        """
        Scope block. Detailed below.
        """
        server_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict']]]]
        """
        Server certificates to use for inbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html).
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs:
    def __init__(__self__, *,
                 certificate_authority_arn: Optional[pulumi.Input[str]] = None,
                 check_certificate_revocation_status: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]] = None,
                 server_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] certificate_authority_arn: ARN of the imported certificate authority (CA) certificate within Certificate Manager (ACM) to use for outbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) for limitations on CA certificates.
        :param pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs'] check_certificate_revocation_status: Check Certificate Revocation Status block. Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]] scopes: Scope block. Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]] server_certificates: Server certificates to use for inbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html).
        """
        if certificate_authority_arn is not None:
            pulumi.set(__self__, "certificate_authority_arn", certificate_authority_arn)
        if check_certificate_revocation_status is not None:
            pulumi.set(__self__, "check_certificate_revocation_status", check_certificate_revocation_status)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @property
    @pulumi.getter(name="certificateAuthorityArn")
    def certificate_authority_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the imported certificate authority (CA) certificate within Certificate Manager (ACM) to use for outbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) for limitations on CA certificates.
        """
        return pulumi.get(self, "certificate_authority_arn")

    @certificate_authority_arn.setter
    def certificate_authority_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority_arn", value)

    @property
    @pulumi.getter(name="checkCertificateRevocationStatus")
    def check_certificate_revocation_status(self) -> Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']]:
        """
        Check Certificate Revocation Status block. Detailed below.
        """
        return pulumi.get(self, "check_certificate_revocation_status")

    @check_certificate_revocation_status.setter
    def check_certificate_revocation_status(self, value: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']]):
        pulumi.set(self, "check_certificate_revocation_status", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]]:
        """
        Scope block. Detailed below.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]]:
        """
        Server certificates to use for inbound SSL/TLS inspection. See [Using SSL/TLS certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html).
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict(TypedDict):
        revoked_status_action: NotRequired[pulumi.Input[str]]
        unknown_status_action: NotRequired[pulumi.Input[str]]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs:
    def __init__(__self__, *,
                 revoked_status_action: Optional[pulumi.Input[str]] = None,
                 unknown_status_action: Optional[pulumi.Input[str]] = None):
        if revoked_status_action is not None:
            pulumi.set(__self__, "revoked_status_action", revoked_status_action)
        if unknown_status_action is not None:
            pulumi.set(__self__, "unknown_status_action", unknown_status_action)

    @property
    @pulumi.getter(name="revokedStatusAction")
    def revoked_status_action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "revoked_status_action")

    @revoked_status_action.setter
    def revoked_status_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revoked_status_action", value)

    @property
    @pulumi.getter(name="unknownStatusAction")
    def unknown_status_action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unknown_status_action")

    @unknown_status_action.setter
    def unknown_status_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unknown_status_action", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict(TypedDict):
        protocols: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). Network Firewall currently supports TCP only. Valid values: `6`
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict']]]]
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Ports below for details.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict']]]]
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        source_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict']]]]
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Ports below for details.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict']]]]
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs:
    def __init__(__self__, *,
                 protocols: pulumi.Input[Sequence[pulumi.Input[int]]],
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). Network Firewall currently supports TCP only. Valid values: `6`
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]] destination_ports: Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Ports below for details.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]] destinations: Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]] source_ports: Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Ports below for details.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]] sources: Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        pulumi.set(__self__, "protocols", protocols)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        Set of protocols to inspect for, specified using the protocol's assigned internet protocol number (IANA). Network Firewall currently supports TCP only. Valid values: `6`
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]]:
        """
        Set of configuration blocks describing the destination ports to inspect for. If not specified, this matches with any destination port. See Destination Ports below for details.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]]:
        """
        Set of configuration blocks describing the destination IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address. See Destination below for details.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]]:
        """
        Set of configuration blocks describing the source ports to inspect for. If not specified, this matches with any source port. See Source Ports below for details.
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]]:
        """
        Set of configuration blocks describing the source IP address and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address. See Source below for details.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict(TypedDict):
        address_definition: pulumi.Input[str]
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict(TypedDict):
        from_port: pulumi.Input[int]
        to_port: pulumi.Input[int]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict(TypedDict):
        address_definition: pulumi.Input[str]
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        An IP address or a block of IP addresses in CIDR notation. AWS Network Firewall supports all address ranges for IPv4.
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict(TypedDict):
        from_port: pulumi.Input[int]
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        to_port: pulumi.Input[int]
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `to_port`.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `to_port`.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `from_port`.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict(TypedDict):
        resource_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs:
    def __init__(__self__, *,
                 resource_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_arn: ARN of the Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_arn", value)


