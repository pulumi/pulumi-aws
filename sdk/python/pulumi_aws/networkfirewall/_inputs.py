# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FirewallAvailabilityZoneMappingArgs',
    'FirewallAvailabilityZoneMappingArgsDict',
    'FirewallEncryptionConfigurationArgs',
    'FirewallEncryptionConfigurationArgsDict',
    'FirewallFirewallStatusArgs',
    'FirewallFirewallStatusArgsDict',
    'FirewallFirewallStatusSyncStateArgs',
    'FirewallFirewallStatusSyncStateArgsDict',
    'FirewallFirewallStatusSyncStateAttachmentArgs',
    'FirewallFirewallStatusSyncStateAttachmentArgsDict',
    'FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgs',
    'FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgsDict',
    'FirewallPolicyEncryptionConfigurationArgs',
    'FirewallPolicyEncryptionConfigurationArgsDict',
    'FirewallPolicyFirewallPolicyArgs',
    'FirewallPolicyFirewallPolicyArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs',
    'FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgs',
    'FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgsDict',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs',
    'FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs',
    'FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict',
    'FirewallSubnetMappingArgs',
    'FirewallSubnetMappingArgsDict',
    'FirewallTransitGatewayAttachmentAccepterTimeoutsArgs',
    'FirewallTransitGatewayAttachmentAccepterTimeoutsArgsDict',
    'LoggingConfigurationLoggingConfigurationArgs',
    'LoggingConfigurationLoggingConfigurationArgsDict',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs',
    'LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict',
    'RuleGroupEncryptionConfigurationArgs',
    'RuleGroupEncryptionConfigurationArgsDict',
    'RuleGroupRuleGroupArgs',
    'RuleGroupRuleGroupArgsDict',
    'RuleGroupRuleGroupReferenceSetsArgs',
    'RuleGroupRuleGroupReferenceSetsArgsDict',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs',
    'RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict',
    'RuleGroupRuleGroupRuleVariablesArgs',
    'RuleGroupRuleGroupRuleVariablesArgsDict',
    'RuleGroupRuleGroupRuleVariablesIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs',
    'RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesPortSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetArgsDict',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs',
    'RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict',
    'RuleGroupRuleGroupRulesSourceArgs',
    'RuleGroupRuleGroupRulesSourceArgsDict',
    'RuleGroupRuleGroupRulesSourceRulesSourceListArgs',
    'RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs',
    'RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs',
    'RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict',
    'RuleGroupRuleGroupStatefulRuleOptionsArgs',
    'RuleGroupRuleGroupStatefulRuleOptionsArgsDict',
    'TlsInspectionConfigurationCertificateArgs',
    'TlsInspectionConfigurationCertificateArgsDict',
    'TlsInspectionConfigurationCertificateAuthorityArgs',
    'TlsInspectionConfigurationCertificateAuthorityArgsDict',
    'TlsInspectionConfigurationEncryptionConfigurationArgs',
    'TlsInspectionConfigurationEncryptionConfigurationArgsDict',
    'TlsInspectionConfigurationTimeoutsArgs',
    'TlsInspectionConfigurationTimeoutsArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict',
    'VpcEndpointAssociationSubnetMappingArgs',
    'VpcEndpointAssociationSubnetMappingArgsDict',
    'VpcEndpointAssociationTimeoutsArgs',
    'VpcEndpointAssociationTimeoutsArgsDict',
    'VpcEndpointAssociationVpcEndpointAssociationStatusArgs',
    'VpcEndpointAssociationVpcEndpointAssociationStatusArgsDict',
    'VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgs',
    'VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgsDict',
    'VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgs',
    'VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgsDict',
]

MYPY = False

if not MYPY:
    class FirewallAvailabilityZoneMappingArgsDict(TypedDict):
        availability_zone_id: pulumi.Input[_builtins.str]
elif False:
    FirewallAvailabilityZoneMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallAvailabilityZoneMappingArgs:
    def __init__(__self__, *,
                 availability_zone_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "availability_zone_id", availability_zone_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "availability_zone_id")

    @availability_zone_id.setter
    def availability_zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "availability_zone_id", value)


if not MYPY:
    class FirewallEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class FirewallFirewallStatusArgsDict(TypedDict):
        sync_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgsDict']]]]
        transit_gateway_attachment_sync_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgsDict']]]]
elif False:
    FirewallFirewallStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusArgs:
    def __init__(__self__, *,
                 sync_states: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]] = None,
                 transit_gateway_attachment_sync_states: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgs']]]] = None):
        if sync_states is not None:
            pulumi.set(__self__, "sync_states", sync_states)
        if transit_gateway_attachment_sync_states is not None:
            pulumi.set(__self__, "transit_gateway_attachment_sync_states", transit_gateway_attachment_sync_states)

    @_builtins.property
    @pulumi.getter(name="syncStates")
    def sync_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]:
        return pulumi.get(self, "sync_states")

    @sync_states.setter
    def sync_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateArgs']]]]):
        pulumi.set(self, "sync_states", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachmentSyncStates")
    def transit_gateway_attachment_sync_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgs']]]]:
        return pulumi.get(self, "transit_gateway_attachment_sync_states")

    @transit_gateway_attachment_sync_states.setter
    def transit_gateway_attachment_sync_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgs']]]]):
        pulumi.set(self, "transit_gateway_attachment_sync_states", value)


if not MYPY:
    class FirewallFirewallStatusSyncStateArgsDict(TypedDict):
        attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgsDict']]]]
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallFirewallStatusSyncStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusSyncStateArgs:
    def __init__(__self__, *,
                 attachments: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]] = None,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None):
        if attachments is not None:
            pulumi.set(__self__, "attachments", attachments)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter
    def attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]:
        return pulumi.get(self, "attachments")

    @attachments.setter
    def attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallFirewallStatusSyncStateAttachmentArgs']]]]):
        pulumi.set(self, "attachments", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class FirewallFirewallStatusSyncStateAttachmentArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[_builtins.str]]
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallFirewallStatusSyncStateAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusSyncStateAttachmentArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgsDict(TypedDict):
        attachment_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallFirewallStatusTransitGatewayAttachmentSyncStateArgs:
    def __init__(__self__, *,
                 attachment_id: Optional[pulumi.Input[_builtins.str]] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attachment_id")

    @attachment_id.setter
    def attachment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attachment_id", value)


if not MYPY:
    class FirewallPolicyEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallPolicyEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyArgsDict(TypedDict):
        stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        policy_variables: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgsDict']]
        stateful_default_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        stateful_engine_options: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict']]
        stateful_rule_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict']]]]
        stateless_custom_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict']]]]
        stateless_rule_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict']]]]
        tls_inspection_configuration_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallPolicyFirewallPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyArgs:
    def __init__(__self__, *,
                 stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 policy_variables: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']] = None,
                 stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 stateful_engine_options: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']] = None,
                 stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
                 stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]] = None,
                 stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None,
                 tls_inspection_configuration_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "stateless_default_actions", stateless_default_actions)
        pulumi.set(__self__, "stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            pulumi.set(__self__, "policy_variables", policy_variables)
        if stateful_default_actions is not None:
            pulumi.set(__self__, "stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            pulumi.set(__self__, "stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            pulumi.set(__self__, "stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            pulumi.set(__self__, "stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            pulumi.set(__self__, "stateless_rule_group_references", stateless_rule_group_references)
        if tls_inspection_configuration_arn is not None:
            pulumi.set(__self__, "tls_inspection_configuration_arn", tls_inspection_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "stateless_default_actions")

    @stateless_default_actions.setter
    def stateless_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "stateless_default_actions", value)

    @_builtins.property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "stateless_fragment_default_actions")

    @stateless_fragment_default_actions.setter
    def stateless_fragment_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "stateless_fragment_default_actions", value)

    @_builtins.property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]:
        return pulumi.get(self, "policy_variables")

    @policy_variables.setter
    def policy_variables(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesArgs']]):
        pulumi.set(self, "policy_variables", value)

    @_builtins.property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "stateful_default_actions")

    @stateful_default_actions.setter
    def stateful_default_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stateful_default_actions", value)

    @_builtins.property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]:
        return pulumi.get(self, "stateful_engine_options")

    @stateful_engine_options.setter
    def stateful_engine_options(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs']]):
        pulumi.set(self, "stateful_engine_options", value)

    @_builtins.property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]:
        return pulumi.get(self, "stateful_rule_group_references")

    @stateful_rule_group_references.setter
    def stateful_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateful_rule_group_references", value)

    @_builtins.property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]:
        return pulumi.get(self, "stateless_custom_actions")

    @stateless_custom_actions.setter
    def stateless_custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionArgs']]]]):
        pulumi.set(self, "stateless_custom_actions", value)

    @_builtins.property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]:
        return pulumi.get(self, "stateless_rule_group_references")

    @stateless_rule_group_references.setter
    def stateless_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateless_rule_group_references", value)

    @_builtins.property
    @pulumi.getter(name="tlsInspectionConfigurationArn")
    def tls_inspection_configuration_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tls_inspection_configuration_arn")

    @tls_inspection_configuration_arn.setter
    def tls_inspection_configuration_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_inspection_configuration_arn", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesArgsDict(TypedDict):
        rule_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict']]]]
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesArgs:
    def __init__(__self__, *,
                 rule_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]] = None):
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)

    @_builtins.property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs']]]]):
        pulumi.set(self, "rule_variables", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict(TypedDict):
        ip_set: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict']
        key: pulumi.Input[_builtins.str]
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs'],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ip_set", ip_set)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']:
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyPolicyVariablesRuleVariableIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "definitions", definitions)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict(TypedDict):
        flow_timeouts: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgsDict']]
        rule_order: NotRequired[pulumi.Input[_builtins.str]]
        stream_exception_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallPolicyFirewallPolicyStatefulEngineOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulEngineOptionsArgs:
    def __init__(__self__, *,
                 flow_timeouts: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgs']] = None,
                 rule_order: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_exception_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if flow_timeouts is not None:
            pulumi.set(__self__, "flow_timeouts", flow_timeouts)
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)
        if stream_exception_policy is not None:
            pulumi.set(__self__, "stream_exception_policy", stream_exception_policy)

    @_builtins.property
    @pulumi.getter(name="flowTimeouts")
    def flow_timeouts(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgs']]:
        return pulumi.get(self, "flow_timeouts")

    @flow_timeouts.setter
    def flow_timeouts(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgs']]):
        pulumi.set(self, "flow_timeouts", value)

    @_builtins.property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_order", value)

    @_builtins.property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "stream_exception_policy")

    @stream_exception_policy.setter
    def stream_exception_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_exception_policy", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgsDict(TypedDict):
        tcp_idle_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulEngineOptionsFlowTimeoutsArgs:
    def __init__(__self__, *,
                 tcp_idle_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if tcp_idle_timeout_seconds is not None:
            pulumi.set(__self__, "tcp_idle_timeout_seconds", tcp_idle_timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="tcpIdleTimeoutSeconds")
    def tcp_idle_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "tcp_idle_timeout_seconds")

    @tcp_idle_timeout_seconds.setter
    def tcp_idle_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_idle_timeout_seconds", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict(TypedDict):
        resource_arn: pulumi.Input[_builtins.str]
        deep_threat_inspection: NotRequired[pulumi.Input[_builtins.str]]
        override: NotRequired[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict']]
        priority: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[_builtins.str],
                 deep_threat_inspection: Optional[pulumi.Input[_builtins.str]] = None,
                 override: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "resource_arn", resource_arn)
        if deep_threat_inspection is not None:
            pulumi.set(__self__, "deep_threat_inspection", deep_threat_inspection)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="deepThreatInspection")
    def deep_threat_inspection(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "deep_threat_inspection")

    @deep_threat_inspection.setter
    def deep_threat_inspection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deep_threat_inspection", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs']]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatefulRuleGroupReferenceOverrideArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict(TypedDict):
        action_definition: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict']
        action_name: pulumi.Input[_builtins.str]
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @_builtins.property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']:
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict(TypedDict):
        publish_metric_action: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict']
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @_builtins.property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']:
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict']]]
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        resource_arn: pulumi.Input[_builtins.str]
elif False:
    FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFirewallPolicyStatelessRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 resource_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "resource_arn", resource_arn)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)


if not MYPY:
    class FirewallSubnetMappingArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallSubnetMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)


if not MYPY:
    class FirewallTransitGatewayAttachmentAccepterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    FirewallTransitGatewayAttachmentAccepterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallTransitGatewayAttachmentAccepterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class LoggingConfigurationLoggingConfigurationArgsDict(TypedDict):
        log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict']]]
elif False:
    LoggingConfigurationLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggingConfigurationLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(__self__, "log_destination_configs", log_destination_configs)

    @_builtins.property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]:
        return pulumi.get(self, "log_destination_configs")

    @log_destination_configs.setter
    def log_destination_configs(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(self, "log_destination_configs", value)


if not MYPY:
    class LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict(TypedDict):
        log_destination: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        log_destination_type: pulumi.Input[_builtins.str]
        log_type: pulumi.Input[_builtins.str]
elif False:
    LoggingConfigurationLoggingConfigurationLogDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggingConfigurationLoggingConfigurationLogDestinationConfigArgs:
    def __init__(__self__, *,
                 log_destination: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 log_destination_type: pulumi.Input[_builtins.str],
                 log_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "log_destination", log_destination)
        pulumi.set(__self__, "log_destination_type", log_destination_type)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "log_destination", value)

    @_builtins.property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_destination_type")

    @log_destination_type.setter
    def log_destination_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_destination_type", value)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class RuleGroupEncryptionConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 key_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class RuleGroupRuleGroupArgsDict(TypedDict):
        rules_source: pulumi.Input['RuleGroupRuleGroupRulesSourceArgsDict']
        reference_sets: NotRequired[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgsDict']]
        rule_variables: NotRequired[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgsDict']]
        stateful_rule_options: NotRequired[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgsDict']]
elif False:
    RuleGroupRuleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupArgs:
    def __init__(__self__, *,
                 rules_source: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs'],
                 reference_sets: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']] = None,
                 rule_variables: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']] = None,
                 stateful_rule_options: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']] = None):
        pulumi.set(__self__, "rules_source", rules_source)
        if reference_sets is not None:
            pulumi.set(__self__, "reference_sets", reference_sets)
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)
        if stateful_rule_options is not None:
            pulumi.set(__self__, "stateful_rule_options", stateful_rule_options)

    @_builtins.property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']:
        return pulumi.get(self, "rules_source")

    @rules_source.setter
    def rules_source(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceArgs']):
        pulumi.set(self, "rules_source", value)

    @_builtins.property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]:
        return pulumi.get(self, "reference_sets")

    @reference_sets.setter
    def reference_sets(self, value: Optional[pulumi.Input['RuleGroupRuleGroupReferenceSetsArgs']]):
        pulumi.set(self, "reference_sets", value)

    @_builtins.property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRuleVariablesArgs']]):
        pulumi.set(self, "rule_variables", value)

    @_builtins.property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]:
        return pulumi.get(self, "stateful_rule_options")

    @stateful_rule_options.setter
    def stateful_rule_options(self, value: Optional[pulumi.Input['RuleGroupRuleGroupStatefulRuleOptionsArgs']]):
        pulumi.set(self, "stateful_rule_options", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsArgsDict(TypedDict):
        ip_set_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict']]]]
elif False:
    RuleGroupRuleGroupReferenceSetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsArgs:
    def __init__(__self__, *,
                 ip_set_references: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]] = None):
        if ip_set_references is not None:
            pulumi.set(__self__, "ip_set_references", ip_set_references)

    @_builtins.property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]:
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs']]]]):
        pulumi.set(self, "ip_set_references", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict(TypedDict):
        ip_set_references: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict']]]
        key: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupReferenceSetsIpSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceArgs:
    def __init__(__self__, *,
                 ip_set_references: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ip_set_references", ip_set_references)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]:
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs']]]):
        pulumi.set(self, "ip_set_references", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict(TypedDict):
        reference_arn: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupReferenceSetsIpSetReferenceIpSetReferenceArgs:
    def __init__(__self__, *,
                 reference_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "reference_arn", reference_arn)

    @_builtins.property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference_arn", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesArgsDict(TypedDict):
        ip_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgsDict']]]]
        port_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgsDict']]]]
elif False:
    RuleGroupRuleGroupRuleVariablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesArgs:
    def __init__(__self__, *,
                 ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]] = None,
                 port_sets: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]] = None):
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if port_sets is not None:
            pulumi.set(__self__, "port_sets", port_sets)

    @_builtins.property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]:
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetArgs']]]]):
        pulumi.set(self, "ip_sets", value)

    @_builtins.property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]:
        return pulumi.get(self, "port_sets")

    @port_sets.setter
    def port_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetArgs']]]]):
        pulumi.set(self, "port_sets", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesIpSetArgsDict(TypedDict):
        ip_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict']
        key: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRuleVariablesIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetArgs:
    def __init__(__self__, *,
                 ip_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs'],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ip_set", ip_set)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="ipSet")
    def ip_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']:
        return pulumi.get(self, "ip_set")

    @ip_set.setter
    def ip_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs']):
        pulumi.set(self, "ip_set", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    RuleGroupRuleGroupRuleVariablesIpSetIpSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "definitions", definitions)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesPortSetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        port_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict']
elif False:
    RuleGroupRuleGroupRuleVariablesPortSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 port_set: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "port_set", port_set)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="portSet")
    def port_set(self) -> pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']:
        return pulumi.get(self, "port_set")

    @port_set.setter
    def port_set(self, value: pulumi.Input['RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs']):
        pulumi.set(self, "port_set", value)


if not MYPY:
    class RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict(TypedDict):
        definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    RuleGroupRuleGroupRuleVariablesPortSetPortSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "definitions", definitions)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceArgsDict(TypedDict):
        rules_source_list: NotRequired[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict']]
        rules_string: NotRequired[pulumi.Input[_builtins.str]]
        stateful_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict']]]]
        stateless_rules_and_custom_actions: NotRequired[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict']]
elif False:
    RuleGroupRuleGroupRulesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceArgs:
    def __init__(__self__, *,
                 rules_source_list: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']] = None,
                 rules_string: Optional[pulumi.Input[_builtins.str]] = None,
                 stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]] = None,
                 stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']] = None):
        if rules_source_list is not None:
            pulumi.set(__self__, "rules_source_list", rules_source_list)
        if rules_string is not None:
            pulumi.set(__self__, "rules_string", rules_string)
        if stateful_rules is not None:
            pulumi.set(__self__, "stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            pulumi.set(__self__, "stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @_builtins.property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]:
        return pulumi.get(self, "rules_source_list")

    @rules_source_list.setter
    def rules_source_list(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceRulesSourceListArgs']]):
        pulumi.set(self, "rules_source_list", value)

    @_builtins.property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rules_string")

    @rules_string.setter
    def rules_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rules_string", value)

    @_builtins.property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]:
        return pulumi.get(self, "stateful_rules")

    @stateful_rules.setter
    def stateful_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleArgs']]]]):
        pulumi.set(self, "stateful_rules", value)

    @_builtins.property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]:
        return pulumi.get(self, "stateless_rules_and_custom_actions")

    @stateless_rules_and_custom_actions.setter
    def stateless_rules_and_custom_actions(self, value: Optional[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs']]):
        pulumi.set(self, "stateless_rules_and_custom_actions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict(TypedDict):
        generated_rules_type: pulumi.Input[_builtins.str]
        target_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        targets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    RuleGroupRuleGroupRulesSourceRulesSourceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceRulesSourceListArgs:
    def __init__(__self__, *,
                 generated_rules_type: pulumi.Input[_builtins.str],
                 target_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 targets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "generated_rules_type", generated_rules_type)
        pulumi.set(__self__, "target_types", target_types)
        pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "generated_rules_type")

    @generated_rules_type.setter
    def generated_rules_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "generated_rules_type", value)

    @_builtins.property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "target_types", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        header: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict']
        rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict']]]
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 header: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs'],
                 rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "rule_options", rule_options)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs']):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]:
        return pulumi.get(self, "rule_options")

    @rule_options.setter
    def rule_options(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs']]]):
        pulumi.set(self, "rule_options", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        destination_port: pulumi.Input[_builtins.str]
        direction: pulumi.Input[_builtins.str]
        protocol: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        source_port: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleHeaderArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 destination_port: pulumi.Input[_builtins.str],
                 direction: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 source_port: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict(TypedDict):
        keyword: pulumi.Input[_builtins.str]
        settings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatefulRuleRuleOptionArgs:
    def __init__(__self__, *,
                 keyword: pulumi.Input[_builtins.str],
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "keyword", keyword)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keyword", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict(TypedDict):
        stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict']]]
        custom_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict']]]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs:
    def __init__(__self__, *,
                 stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]],
                 custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]] = None):
        pulumi.set(__self__, "stateless_rules", stateless_rules)
        if custom_actions is not None:
            pulumi.set(__self__, "custom_actions", custom_actions)

    @_builtins.property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]:
        return pulumi.get(self, "stateless_rules")

    @stateless_rules.setter
    def stateless_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs']]]):
        pulumi.set(self, "stateless_rules", value)

    @_builtins.property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]:
        return pulumi.get(self, "custom_actions")

    @custom_actions.setter
    def custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs']]]]):
        pulumi.set(self, "custom_actions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict(TypedDict):
        action_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict']
        action_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs'],
                 action_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @_builtins.property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']:
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @_builtins.property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_name", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict(TypedDict):
        publish_metric_action: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict']
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @_builtins.property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']:
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs']):
        pulumi.set(self, "publish_metric_action", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict']]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        rule_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict']
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 rule_definition: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_definition", rule_definition)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']:
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs']):
        pulumi.set(self, "rule_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        match_attributes: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict']
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 match_attributes: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_attributes", match_attributes)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']:
        return pulumi.get(self, "match_attributes")

    @match_attributes.setter
    def match_attributes(self, value: pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs']):
        pulumi.set(self, "match_attributes", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict(TypedDict):
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict']]]]
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict']]]]
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        source_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict']]]]
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict']]]]
        tcp_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict']]]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]] = None,
                 tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]] = None):
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]:
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]:
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]:
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @_builtins.property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]:
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs']]]]):
        pulumi.set(self, "tcp_flags", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict(TypedDict):
        address_definition: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "address_definition", address_definition)

    @_builtins.property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict(TypedDict):
        from_port: pulumi.Input[_builtins.int]
        to_port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesDestinationPortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[_builtins.int],
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict(TypedDict):
        address_definition: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourceArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "address_definition", address_definition)

    @_builtins.property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict(TypedDict):
        from_port: pulumi.Input[_builtins.int]
        to_port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesSourcePortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[_builtins.int],
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict(TypedDict):
        flags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        masks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesTcpFlagArgs:
    def __init__(__self__, *,
                 flags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 masks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "flags", flags)
        if masks is not None:
            pulumi.set(__self__, "masks", masks)

    @_builtins.property
    @pulumi.getter
    def flags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "flags", value)

    @_builtins.property
    @pulumi.getter
    def masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "masks")

    @masks.setter
    def masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "masks", value)


if not MYPY:
    class RuleGroupRuleGroupStatefulRuleOptionsArgsDict(TypedDict):
        rule_order: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleGroupStatefulRuleOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleGroupStatefulRuleOptionsArgs:
    def __init__(__self__, *,
                 rule_order: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "rule_order", rule_order)

    @_builtins.property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_order", value)


if not MYPY:
    class TlsInspectionConfigurationCertificateArgsDict(TypedDict):
        certificate_arn: pulumi.Input[_builtins.str]
        certificate_serial: pulumi.Input[_builtins.str]
        status: pulumi.Input[_builtins.str]
        status_message: pulumi.Input[_builtins.str]
elif False:
    TlsInspectionConfigurationCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationCertificateArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[_builtins.str],
                 certificate_serial: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 status_message: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "certificate_serial", certificate_serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_arn", value)

    @_builtins.property
    @pulumi.getter(name="certificateSerial")
    def certificate_serial(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "certificate_serial")

    @certificate_serial.setter
    def certificate_serial(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_serial", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class TlsInspectionConfigurationCertificateAuthorityArgsDict(TypedDict):
        certificate_arn: pulumi.Input[_builtins.str]
        certificate_serial: pulumi.Input[_builtins.str]
        status: pulumi.Input[_builtins.str]
        status_message: pulumi.Input[_builtins.str]
elif False:
    TlsInspectionConfigurationCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationCertificateAuthorityArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[_builtins.str],
                 certificate_serial: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 status_message: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "certificate_serial", certificate_serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_arn", value)

    @_builtins.property
    @pulumi.getter(name="certificateSerial")
    def certificate_serial(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "certificate_serial")

    @certificate_serial.setter
    def certificate_serial(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_serial", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class TlsInspectionConfigurationEncryptionConfigurationArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    TlsInspectionConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TlsInspectionConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    TlsInspectionConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationArgsDict(TypedDict):
        server_certificate_configuration: NotRequired[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict']]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationArgs:
    def __init__(__self__, *,
                 server_certificate_configuration: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']] = None):
        if server_certificate_configuration is not None:
            pulumi.set(__self__, "server_certificate_configuration", server_certificate_configuration)

    @_builtins.property
    @pulumi.getter(name="serverCertificateConfiguration")
    def server_certificate_configuration(self) -> Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']]:
        return pulumi.get(self, "server_certificate_configuration")

    @server_certificate_configuration.setter
    def server_certificate_configuration(self, value: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs']]):
        pulumi.set(self, "server_certificate_configuration", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict(TypedDict):
        certificate_authority_arn: NotRequired[pulumi.Input[_builtins.str]]
        check_certificate_revocation_status: NotRequired[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict']]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict']]]]
        server_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict']]]]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationArgs:
    def __init__(__self__, *,
                 certificate_authority_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 check_certificate_revocation_status: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]] = None,
                 server_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]] = None):
        if certificate_authority_arn is not None:
            pulumi.set(__self__, "certificate_authority_arn", certificate_authority_arn)
        if check_certificate_revocation_status is not None:
            pulumi.set(__self__, "check_certificate_revocation_status", check_certificate_revocation_status)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityArn")
    def certificate_authority_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_authority_arn")

    @certificate_authority_arn.setter
    def certificate_authority_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority_arn", value)

    @_builtins.property
    @pulumi.getter(name="checkCertificateRevocationStatus")
    def check_certificate_revocation_status(self) -> Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']]:
        return pulumi.get(self, "check_certificate_revocation_status")

    @check_certificate_revocation_status.setter
    def check_certificate_revocation_status(self, value: Optional[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs']]):
        pulumi.set(self, "check_certificate_revocation_status", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs']]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]]:
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs']]]]):
        pulumi.set(self, "server_certificates", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict(TypedDict):
        revoked_status_action: NotRequired[pulumi.Input[_builtins.str]]
        unknown_status_action: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusArgs:
    def __init__(__self__, *,
                 revoked_status_action: Optional[pulumi.Input[_builtins.str]] = None,
                 unknown_status_action: Optional[pulumi.Input[_builtins.str]] = None):
        if revoked_status_action is not None:
            pulumi.set(__self__, "revoked_status_action", revoked_status_action)
        if unknown_status_action is not None:
            pulumi.set(__self__, "unknown_status_action", unknown_status_action)

    @_builtins.property
    @pulumi.getter(name="revokedStatusAction")
    def revoked_status_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "revoked_status_action")

    @revoked_status_action.setter
    def revoked_status_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "revoked_status_action", value)

    @_builtins.property
    @pulumi.getter(name="unknownStatusAction")
    def unknown_status_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unknown_status_action")

    @unknown_status_action.setter
    def unknown_status_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unknown_status_action", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict(TypedDict):
        protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict']]]]
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict']]]]
        source_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict']]]]
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict']]]]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeArgs:
    def __init__(__self__, *,
                 protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]] = None):
        pulumi.set(__self__, "protocols", protocols)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]]:
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]]:
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]]:
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict(TypedDict):
        address_definition: pulumi.Input[_builtins.str]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "address_definition", address_definition)

    @_builtins.property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict(TypedDict):
        from_port: pulumi.Input[_builtins.int]
        to_port: pulumi.Input[_builtins.int]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeDestinationPortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[_builtins.int],
                 to_port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict(TypedDict):
        address_definition: pulumi.Input[_builtins.str]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourceArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "address_definition", address_definition)

    @_builtins.property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address_definition", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict(TypedDict):
        from_port: pulumi.Input[_builtins.int]
        to_port: pulumi.Input[_builtins.int]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationScopeSourcePortArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[_builtins.int],
                 to_port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict(TypedDict):
        resource_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationServerCertificateConfigurationServerCertificateArgs:
    def __init__(__self__, *,
                 resource_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_arn", value)


if not MYPY:
    class VpcEndpointAssociationSubnetMappingArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VpcEndpointAssociationSubnetMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointAssociationSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)


if not MYPY:
    class VpcEndpointAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    VpcEndpointAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class VpcEndpointAssociationVpcEndpointAssociationStatusArgsDict(TypedDict):
        association_sync_states: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgsDict']]]
elif False:
    VpcEndpointAssociationVpcEndpointAssociationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointAssociationVpcEndpointAssociationStatusArgs:
    def __init__(__self__, *,
                 association_sync_states: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgs']]]):
        pulumi.set(__self__, "association_sync_states", association_sync_states)

    @_builtins.property
    @pulumi.getter(name="associationSyncStates")
    def association_sync_states(self) -> pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgs']]]:
        return pulumi.get(self, "association_sync_states")

    @association_sync_states.setter
    def association_sync_states(self, value: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgs']]]):
        pulumi.set(self, "association_sync_states", value)


if not MYPY:
    class VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgsDict(TypedDict):
        attachments: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgsDict']]]
        availability_zone: pulumi.Input[_builtins.str]
elif False:
    VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateArgs:
    def __init__(__self__, *,
                 attachments: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgs']]],
                 availability_zone: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "attachments", attachments)
        pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter
    def attachments(self) -> pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgs']]]:
        return pulumi.get(self, "attachments")

    @attachments.setter
    def attachments(self, value: pulumi.Input[Sequence[pulumi.Input['VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgs']]]):
        pulumi.set(self, "attachments", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgsDict(TypedDict):
        endpoint_id: pulumi.Input[_builtins.str]
        status: pulumi.Input[_builtins.str]
        status_message: pulumi.Input[_builtins.str]
        subnet_id: pulumi.Input[_builtins.str]
elif False:
    VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointAssociationVpcEndpointAssociationStatusAssociationSyncStateAttachmentArgs:
    def __init__(__self__, *,
                 endpoint_id: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 status_message: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_message", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


