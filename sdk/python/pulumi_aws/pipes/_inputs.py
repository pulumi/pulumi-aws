# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'PipeEnrichmentParametersArgs',
    'PipeEnrichmentParametersHttpParametersArgs',
    'PipeSourceParametersArgs',
    'PipeSourceParametersActivemqBrokerParametersArgs',
    'PipeSourceParametersActivemqBrokerParametersCredentialsArgs',
    'PipeSourceParametersDynamodbStreamParametersArgs',
    'PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs',
    'PipeSourceParametersFilterCriteriaArgs',
    'PipeSourceParametersFilterCriteriaFilterArgs',
    'PipeSourceParametersKinesisStreamParametersArgs',
    'PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs',
    'PipeSourceParametersManagedStreamingKafkaParametersArgs',
    'PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs',
    'PipeSourceParametersRabbitmqBrokerParametersArgs',
    'PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs',
    'PipeSourceParametersSelfManagedKafkaParametersArgs',
    'PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs',
    'PipeSourceParametersSelfManagedKafkaParametersVpcArgs',
    'PipeSourceParametersSqsQueueParametersArgs',
    'PipeTargetParametersArgs',
    'PipeTargetParametersBatchJobParametersArgs',
    'PipeTargetParametersBatchJobParametersArrayPropertiesArgs',
    'PipeTargetParametersBatchJobParametersContainerOverridesArgs',
    'PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs',
    'PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs',
    'PipeTargetParametersBatchJobParametersDependsOnArgs',
    'PipeTargetParametersBatchJobParametersRetryStrategyArgs',
    'PipeTargetParametersCloudwatchLogsParametersArgs',
    'PipeTargetParametersEcsTaskParametersArgs',
    'PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs',
    'PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs',
    'PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs',
    'PipeTargetParametersEcsTaskParametersOverridesArgs',
    'PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs',
    'PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs',
    'PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs',
    'PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs',
    'PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs',
    'PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs',
    'PipeTargetParametersEcsTaskParametersPlacementConstraintArgs',
    'PipeTargetParametersEcsTaskParametersPlacementStrategyArgs',
    'PipeTargetParametersEventbridgeEventBusParametersArgs',
    'PipeTargetParametersHttpParametersArgs',
    'PipeTargetParametersKinesisStreamParametersArgs',
    'PipeTargetParametersLambdaFunctionParametersArgs',
    'PipeTargetParametersRedshiftDataParametersArgs',
    'PipeTargetParametersSagemakerPipelineParametersArgs',
    'PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs',
    'PipeTargetParametersSqsQueueParametersArgs',
    'PipeTargetParametersStepFunctionStateMachineParametersArgs',
]

@pulumi.input_type
class PipeEnrichmentParametersArgs:
    def __init__(__self__, *,
                 http_parameters: Optional[pulumi.Input['PipeEnrichmentParametersHttpParametersArgs']] = None,
                 input_template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PipeEnrichmentParametersHttpParametersArgs'] http_parameters: Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge ApiDestination. If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence. Detailed below.
        :param pulumi.Input[str] input_template: Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
        """
        if http_parameters is not None:
            pulumi.set(__self__, "http_parameters", http_parameters)
        if input_template is not None:
            pulumi.set(__self__, "input_template", input_template)

    @property
    @pulumi.getter(name="httpParameters")
    def http_parameters(self) -> Optional[pulumi.Input['PipeEnrichmentParametersHttpParametersArgs']]:
        """
        Contains the HTTP parameters to use when the target is a API Gateway REST endpoint or EventBridge ApiDestination. If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you can use this parameter to specify headers, path parameters, and query string keys/values as part of your target invoking request. If you're using ApiDestinations, the corresponding Connection can also have these values configured. In case of any conflicting keys, values from the Connection take precedence. Detailed below.
        """
        return pulumi.get(self, "http_parameters")

    @http_parameters.setter
    def http_parameters(self, value: Optional[pulumi.Input['PipeEnrichmentParametersHttpParametersArgs']]):
        pulumi.set(self, "http_parameters", value)

    @property
    @pulumi.getter(name="inputTemplate")
    def input_template(self) -> Optional[pulumi.Input[str]]:
        """
        Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
        """
        return pulumi.get(self, "input_template")

    @input_template.setter
    def input_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_template", value)


@pulumi.input_type
class PipeEnrichmentParametersHttpParametersArgs:
    def __init__(__self__, *,
                 header_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 path_parameter_values: Optional[pulumi.Input[str]] = None,
                 query_string_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] header_parameters: Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        :param pulumi.Input[str] path_parameter_values: The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] query_string_parameters: Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        if header_parameters is not None:
            pulumi.set(__self__, "header_parameters", header_parameters)
        if path_parameter_values is not None:
            pulumi.set(__self__, "path_parameter_values", path_parameter_values)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @property
    @pulumi.getter(name="headerParameters")
    def header_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        return pulumi.get(self, "header_parameters")

    @header_parameters.setter
    def header_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "header_parameters", value)

    @property
    @pulumi.getter(name="pathParameterValues")
    def path_parameter_values(self) -> Optional[pulumi.Input[str]]:
        """
        The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
        """
        return pulumi.get(self, "path_parameter_values")

    @path_parameter_values.setter
    def path_parameter_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_parameter_values", value)

    @property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        return pulumi.get(self, "query_string_parameters")

    @query_string_parameters.setter
    def query_string_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_string_parameters", value)


@pulumi.input_type
class PipeSourceParametersArgs:
    def __init__(__self__, *,
                 activemq_broker_parameters: Optional[pulumi.Input['PipeSourceParametersActivemqBrokerParametersArgs']] = None,
                 dynamodb_stream_parameters: Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersArgs']] = None,
                 filter_criteria: Optional[pulumi.Input['PipeSourceParametersFilterCriteriaArgs']] = None,
                 kinesis_stream_parameters: Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersArgs']] = None,
                 managed_streaming_kafka_parameters: Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersArgs']] = None,
                 rabbitmq_broker_parameters: Optional[pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersArgs']] = None,
                 self_managed_kafka_parameters: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersArgs']] = None,
                 sqs_queue_parameters: Optional[pulumi.Input['PipeSourceParametersSqsQueueParametersArgs']] = None):
        """
        :param pulumi.Input['PipeSourceParametersActivemqBrokerParametersArgs'] activemq_broker_parameters: The parameters for using an Active MQ broker as a source. Detailed below.
        :param pulumi.Input['PipeSourceParametersDynamodbStreamParametersArgs'] dynamodb_stream_parameters: The parameters for using a DynamoDB stream as a source.  Detailed below.
        :param pulumi.Input['PipeSourceParametersFilterCriteriaArgs'] filter_criteria: The collection of event patterns used to [filter events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-event-filtering.html). Detailed below.
        :param pulumi.Input['PipeSourceParametersKinesisStreamParametersArgs'] kinesis_stream_parameters: The parameters for using a Kinesis stream as a source. Detailed below.
        :param pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersArgs'] managed_streaming_kafka_parameters: The parameters for using an MSK stream as a source. Detailed below.
        :param pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersArgs'] rabbitmq_broker_parameters: The parameters for using a Rabbit MQ broker as a source. Detailed below.
        :param pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersArgs'] self_managed_kafka_parameters: The parameters for using a self-managed Apache Kafka stream as a source. Detailed below.
        :param pulumi.Input['PipeSourceParametersSqsQueueParametersArgs'] sqs_queue_parameters: The parameters for using a Amazon SQS stream as a source. Detailed below.
        """
        if activemq_broker_parameters is not None:
            pulumi.set(__self__, "activemq_broker_parameters", activemq_broker_parameters)
        if dynamodb_stream_parameters is not None:
            pulumi.set(__self__, "dynamodb_stream_parameters", dynamodb_stream_parameters)
        if filter_criteria is not None:
            pulumi.set(__self__, "filter_criteria", filter_criteria)
        if kinesis_stream_parameters is not None:
            pulumi.set(__self__, "kinesis_stream_parameters", kinesis_stream_parameters)
        if managed_streaming_kafka_parameters is not None:
            pulumi.set(__self__, "managed_streaming_kafka_parameters", managed_streaming_kafka_parameters)
        if rabbitmq_broker_parameters is not None:
            pulumi.set(__self__, "rabbitmq_broker_parameters", rabbitmq_broker_parameters)
        if self_managed_kafka_parameters is not None:
            pulumi.set(__self__, "self_managed_kafka_parameters", self_managed_kafka_parameters)
        if sqs_queue_parameters is not None:
            pulumi.set(__self__, "sqs_queue_parameters", sqs_queue_parameters)

    @property
    @pulumi.getter(name="activemqBrokerParameters")
    def activemq_broker_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersActivemqBrokerParametersArgs']]:
        """
        The parameters for using an Active MQ broker as a source. Detailed below.
        """
        return pulumi.get(self, "activemq_broker_parameters")

    @activemq_broker_parameters.setter
    def activemq_broker_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersActivemqBrokerParametersArgs']]):
        pulumi.set(self, "activemq_broker_parameters", value)

    @property
    @pulumi.getter(name="dynamodbStreamParameters")
    def dynamodb_stream_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersArgs']]:
        """
        The parameters for using a DynamoDB stream as a source.  Detailed below.
        """
        return pulumi.get(self, "dynamodb_stream_parameters")

    @dynamodb_stream_parameters.setter
    def dynamodb_stream_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersArgs']]):
        pulumi.set(self, "dynamodb_stream_parameters", value)

    @property
    @pulumi.getter(name="filterCriteria")
    def filter_criteria(self) -> Optional[pulumi.Input['PipeSourceParametersFilterCriteriaArgs']]:
        """
        The collection of event patterns used to [filter events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-event-filtering.html). Detailed below.
        """
        return pulumi.get(self, "filter_criteria")

    @filter_criteria.setter
    def filter_criteria(self, value: Optional[pulumi.Input['PipeSourceParametersFilterCriteriaArgs']]):
        pulumi.set(self, "filter_criteria", value)

    @property
    @pulumi.getter(name="kinesisStreamParameters")
    def kinesis_stream_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersArgs']]:
        """
        The parameters for using a Kinesis stream as a source. Detailed below.
        """
        return pulumi.get(self, "kinesis_stream_parameters")

    @kinesis_stream_parameters.setter
    def kinesis_stream_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersArgs']]):
        pulumi.set(self, "kinesis_stream_parameters", value)

    @property
    @pulumi.getter(name="managedStreamingKafkaParameters")
    def managed_streaming_kafka_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersArgs']]:
        """
        The parameters for using an MSK stream as a source. Detailed below.
        """
        return pulumi.get(self, "managed_streaming_kafka_parameters")

    @managed_streaming_kafka_parameters.setter
    def managed_streaming_kafka_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersArgs']]):
        pulumi.set(self, "managed_streaming_kafka_parameters", value)

    @property
    @pulumi.getter(name="rabbitmqBrokerParameters")
    def rabbitmq_broker_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersArgs']]:
        """
        The parameters for using a Rabbit MQ broker as a source. Detailed below.
        """
        return pulumi.get(self, "rabbitmq_broker_parameters")

    @rabbitmq_broker_parameters.setter
    def rabbitmq_broker_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersArgs']]):
        pulumi.set(self, "rabbitmq_broker_parameters", value)

    @property
    @pulumi.getter(name="selfManagedKafkaParameters")
    def self_managed_kafka_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersArgs']]:
        """
        The parameters for using a self-managed Apache Kafka stream as a source. Detailed below.
        """
        return pulumi.get(self, "self_managed_kafka_parameters")

    @self_managed_kafka_parameters.setter
    def self_managed_kafka_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersArgs']]):
        pulumi.set(self, "self_managed_kafka_parameters", value)

    @property
    @pulumi.getter(name="sqsQueueParameters")
    def sqs_queue_parameters(self) -> Optional[pulumi.Input['PipeSourceParametersSqsQueueParametersArgs']]:
        """
        The parameters for using a Amazon SQS stream as a source. Detailed below.
        """
        return pulumi.get(self, "sqs_queue_parameters")

    @sqs_queue_parameters.setter
    def sqs_queue_parameters(self, value: Optional[pulumi.Input['PipeSourceParametersSqsQueueParametersArgs']]):
        pulumi.set(self, "sqs_queue_parameters", value)


@pulumi.input_type
class PipeSourceParametersActivemqBrokerParametersArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['PipeSourceParametersActivemqBrokerParametersCredentialsArgs'],
                 queue_name: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['PipeSourceParametersActivemqBrokerParametersCredentialsArgs'] credentials: The credentials needed to access the resource. Detailed below.
        :param pulumi.Input[str] queue_name: The name of the destination queue to consume. Maximum length of 1000.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "queue_name", queue_name)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['PipeSourceParametersActivemqBrokerParametersCredentialsArgs']:
        """
        The credentials needed to access the resource. Detailed below.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['PipeSourceParametersActivemqBrokerParametersCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[str]:
        """
        The name of the destination queue to consume. Maximum length of 1000.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)


@pulumi.input_type
class PipeSourceParametersActivemqBrokerParametersCredentialsArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input[str]):
        """
        :param pulumi.Input[str] basic_auth: The ARN of the Secrets Manager secret containing the basic auth credentials.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input[str]:
        """
        The ARN of the Secrets Manager secret containing the basic auth credentials.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input[str]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class PipeSourceParametersDynamodbStreamParametersArgs:
    def __init__(__self__, *,
                 starting_position: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 dead_letter_config: Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs']] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None,
                 maximum_record_age_in_seconds: Optional[pulumi.Input[int]] = None,
                 maximum_retry_attempts: Optional[pulumi.Input[int]] = None,
                 on_partial_batch_item_failure: Optional[pulumi.Input[str]] = None,
                 parallelization_factor: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] starting_position: The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input['PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs'] dead_letter_config: Define the target queue to send dead-letter queue events to. Detailed below.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        :param pulumi.Input[int] maximum_record_age_in_seconds: Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
        :param pulumi.Input[int] maximum_retry_attempts: Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
        :param pulumi.Input[str] on_partial_batch_item_failure: Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
        :param pulumi.Input[int] parallelization_factor: The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
        """
        pulumi.set(__self__, "starting_position", starting_position)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if dead_letter_config is not None:
            pulumi.set(__self__, "dead_letter_config", dead_letter_config)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)
        if maximum_record_age_in_seconds is not None:
            pulumi.set(__self__, "maximum_record_age_in_seconds", maximum_record_age_in_seconds)
        if maximum_retry_attempts is not None:
            pulumi.set(__self__, "maximum_retry_attempts", maximum_retry_attempts)
        if on_partial_batch_item_failure is not None:
            pulumi.set(__self__, "on_partial_batch_item_failure", on_partial_batch_item_failure)
        if parallelization_factor is not None:
            pulumi.set(__self__, "parallelization_factor", parallelization_factor)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> pulumi.Input[str]:
        """
        The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: pulumi.Input[str]):
        pulumi.set(self, "starting_position", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="deadLetterConfig")
    def dead_letter_config(self) -> Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs']]:
        """
        Define the target queue to send dead-letter queue events to. Detailed below.
        """
        return pulumi.get(self, "dead_letter_config")

    @dead_letter_config.setter
    def dead_letter_config(self, value: Optional[pulumi.Input['PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs']]):
        pulumi.set(self, "dead_letter_config", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)

    @property
    @pulumi.getter(name="maximumRecordAgeInSeconds")
    def maximum_record_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
        """
        return pulumi.get(self, "maximum_record_age_in_seconds")

    @maximum_record_age_in_seconds.setter
    def maximum_record_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_record_age_in_seconds", value)

    @property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
        """
        return pulumi.get(self, "maximum_retry_attempts")

    @maximum_retry_attempts.setter
    def maximum_retry_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_retry_attempts", value)

    @property
    @pulumi.getter(name="onPartialBatchItemFailure")
    def on_partial_batch_item_failure(self) -> Optional[pulumi.Input[str]]:
        """
        Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
        """
        return pulumi.get(self, "on_partial_batch_item_failure")

    @on_partial_batch_item_failure.setter
    def on_partial_batch_item_failure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_partial_batch_item_failure", value)

    @property
    @pulumi.getter(name="parallelizationFactor")
    def parallelization_factor(self) -> Optional[pulumi.Input[int]]:
        """
        The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
        """
        return pulumi.get(self, "parallelization_factor")

    @parallelization_factor.setter
    def parallelization_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelization_factor", value)


@pulumi.input_type
class PipeSourceParametersDynamodbStreamParametersDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)


@pulumi.input_type
class PipeSourceParametersFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['PipeSourceParametersFilterCriteriaFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipeSourceParametersFilterCriteriaFilterArgs']]] filters: An array of up to 5 event patterns. Detailed below.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeSourceParametersFilterCriteriaFilterArgs']]]]:
        """
        An array of up to 5 event patterns. Detailed below.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeSourceParametersFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class PipeSourceParametersFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str]):
        """
        :param pulumi.Input[str] pattern: The event pattern. At most 4096 characters.
        """
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The event pattern. At most 4096 characters.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class PipeSourceParametersKinesisStreamParametersArgs:
    def __init__(__self__, *,
                 starting_position: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 dead_letter_config: Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs']] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None,
                 maximum_record_age_in_seconds: Optional[pulumi.Input[int]] = None,
                 maximum_retry_attempts: Optional[pulumi.Input[int]] = None,
                 on_partial_batch_item_failure: Optional[pulumi.Input[str]] = None,
                 parallelization_factor: Optional[pulumi.Input[int]] = None,
                 starting_position_timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] starting_position: The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input['PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs'] dead_letter_config: Define the target queue to send dead-letter queue events to. Detailed below.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        :param pulumi.Input[int] maximum_record_age_in_seconds: Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
        :param pulumi.Input[int] maximum_retry_attempts: Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
        :param pulumi.Input[str] on_partial_batch_item_failure: Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
        :param pulumi.Input[int] parallelization_factor: The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
        :param pulumi.Input[str] starting_position_timestamp: With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.
        """
        pulumi.set(__self__, "starting_position", starting_position)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if dead_letter_config is not None:
            pulumi.set(__self__, "dead_letter_config", dead_letter_config)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)
        if maximum_record_age_in_seconds is not None:
            pulumi.set(__self__, "maximum_record_age_in_seconds", maximum_record_age_in_seconds)
        if maximum_retry_attempts is not None:
            pulumi.set(__self__, "maximum_retry_attempts", maximum_retry_attempts)
        if on_partial_batch_item_failure is not None:
            pulumi.set(__self__, "on_partial_batch_item_failure", on_partial_batch_item_failure)
        if parallelization_factor is not None:
            pulumi.set(__self__, "parallelization_factor", parallelization_factor)
        if starting_position_timestamp is not None:
            pulumi.set(__self__, "starting_position_timestamp", starting_position_timestamp)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> pulumi.Input[str]:
        """
        The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: pulumi.Input[str]):
        pulumi.set(self, "starting_position", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="deadLetterConfig")
    def dead_letter_config(self) -> Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs']]:
        """
        Define the target queue to send dead-letter queue events to. Detailed below.
        """
        return pulumi.get(self, "dead_letter_config")

    @dead_letter_config.setter
    def dead_letter_config(self, value: Optional[pulumi.Input['PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs']]):
        pulumi.set(self, "dead_letter_config", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)

    @property
    @pulumi.getter(name="maximumRecordAgeInSeconds")
    def maximum_record_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Discard records older than the specified age. The default value is -1, which sets the maximum age to infinite. When the value is set to infinite, EventBridge never discards old records. Maximum value of 604,800.
        """
        return pulumi.get(self, "maximum_record_age_in_seconds")

    @maximum_record_age_in_seconds.setter
    def maximum_record_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_record_age_in_seconds", value)

    @property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Discard records after the specified number of retries. The default value is -1, which sets the maximum number of retries to infinite. When MaximumRetryAttempts is infinite, EventBridge retries failed records until the record expires in the event source. Maximum value of 10,000.
        """
        return pulumi.get(self, "maximum_retry_attempts")

    @maximum_retry_attempts.setter
    def maximum_retry_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_retry_attempts", value)

    @property
    @pulumi.getter(name="onPartialBatchItemFailure")
    def on_partial_batch_item_failure(self) -> Optional[pulumi.Input[str]]:
        """
        Define how to handle item process failures. AUTOMATIC_BISECT halves each batch and retry each half until all the records are processed or there is one failed message left in the batch. Valid values: AUTOMATIC_BISECT.
        """
        return pulumi.get(self, "on_partial_batch_item_failure")

    @on_partial_batch_item_failure.setter
    def on_partial_batch_item_failure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_partial_batch_item_failure", value)

    @property
    @pulumi.getter(name="parallelizationFactor")
    def parallelization_factor(self) -> Optional[pulumi.Input[int]]:
        """
        The number of batches to process concurrently from each shard. The default value is 1. Maximum value of 10.
        """
        return pulumi.get(self, "parallelization_factor")

    @parallelization_factor.setter
    def parallelization_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelization_factor", value)

    @property
    @pulumi.getter(name="startingPositionTimestamp")
    def starting_position_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.
        """
        return pulumi.get(self, "starting_position_timestamp")

    @starting_position_timestamp.setter
    def starting_position_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starting_position_timestamp", value)


@pulumi.input_type
class PipeSourceParametersKinesisStreamParametersDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Amazon SQS queue specified as the target for the dead-letter queue.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)


@pulumi.input_type
class PipeSourceParametersManagedStreamingKafkaParametersArgs:
    def __init__(__self__, *,
                 topic_name: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 consumer_group_id: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs']] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None,
                 starting_position: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] topic_name: The name of the topic that the pipe will read from. Maximum length of 249.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input[str] consumer_group_id: The name of the destination queue to consume. Maximum value of 200.
        :param pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs'] credentials: The credentials needed to access the resource. Detailed below.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        :param pulumi.Input[str] starting_position: The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)
        if starting_position is not None:
            pulumi.set(__self__, "starting_position", starting_position)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        The name of the topic that the pipe will read from. Maximum length of 249.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the destination queue to consume. Maximum value of 200.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs']]:
        """
        The credentials needed to access the resource. Detailed below.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> Optional[pulumi.Input[str]]:
        """
        The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starting_position", value)


@pulumi.input_type
class PipeSourceParametersManagedStreamingKafkaParametersCredentialsArgs:
    def __init__(__self__, *,
                 client_certificate_tls_auth: Optional[pulumi.Input[str]] = None,
                 sasl_scram512_auth: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate_tls_auth: The ARN of the Secrets Manager secret containing the credentials.
        :param pulumi.Input[str] sasl_scram512_auth: The ARN of the Secrets Manager secret containing the credentials.
        """
        if client_certificate_tls_auth is not None:
            pulumi.set(__self__, "client_certificate_tls_auth", client_certificate_tls_auth)
        if sasl_scram512_auth is not None:
            pulumi.set(__self__, "sasl_scram512_auth", sasl_scram512_auth)

    @property
    @pulumi.getter(name="clientCertificateTlsAuth")
    def client_certificate_tls_auth(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret containing the credentials.
        """
        return pulumi.get(self, "client_certificate_tls_auth")

    @client_certificate_tls_auth.setter
    def client_certificate_tls_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_tls_auth", value)

    @property
    @pulumi.getter(name="saslScram512Auth")
    def sasl_scram512_auth(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret containing the credentials.
        """
        return pulumi.get(self, "sasl_scram512_auth")

    @sasl_scram512_auth.setter
    def sasl_scram512_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_scram512_auth", value)


@pulumi.input_type
class PipeSourceParametersRabbitmqBrokerParametersArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs'],
                 queue_name: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None,
                 virtual_host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs'] credentials: The credentials needed to access the resource. Detailed below.
        :param pulumi.Input[str] queue_name: The name of the destination queue to consume. Maximum length of 1000.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        :param pulumi.Input[str] virtual_host: The name of the virtual host associated with the source broker. Maximum length of 200.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "queue_name", queue_name)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)
        if virtual_host is not None:
            pulumi.set(__self__, "virtual_host", virtual_host)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs']:
        """
        The credentials needed to access the resource. Detailed below.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[str]:
        """
        The name of the destination queue to consume. Maximum length of 1000.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)

    @property
    @pulumi.getter(name="virtualHost")
    def virtual_host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the virtual host associated with the source broker. Maximum length of 200.
        """
        return pulumi.get(self, "virtual_host")

    @virtual_host.setter
    def virtual_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_host", value)


@pulumi.input_type
class PipeSourceParametersRabbitmqBrokerParametersCredentialsArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input[str]):
        """
        :param pulumi.Input[str] basic_auth: The ARN of the Secrets Manager secret containing the basic auth credentials.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input[str]:
        """
        The ARN of the Secrets Manager secret containing the basic auth credentials.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input[str]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class PipeSourceParametersSelfManagedKafkaParametersArgs:
    def __init__(__self__, *,
                 topic_name: pulumi.Input[str],
                 additional_bootstrap_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 consumer_group_id: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs']] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None,
                 server_root_ca_certificate: Optional[pulumi.Input[str]] = None,
                 starting_position: Optional[pulumi.Input[str]] = None,
                 vpc: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersVpcArgs']] = None):
        """
        :param pulumi.Input[str] topic_name: The name of the topic that the pipe will read from. Maximum length of 249.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_bootstrap_servers: An array of server URLs. Maximum number of 2 items, each of maximum length 300.
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input[str] consumer_group_id: The name of the destination queue to consume. Maximum value of 200.
        :param pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs'] credentials: The credentials needed to access the resource. Detailed below.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        :param pulumi.Input[str] server_root_ca_certificate: The ARN of the Secrets Manager secret used for certification.
        :param pulumi.Input[str] starting_position: The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        :param pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersVpcArgs'] vpc: This structure specifies the VPC subnets and security groups for the stream, and whether a public IP address is to be used. Detailed below.
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if additional_bootstrap_servers is not None:
            pulumi.set(__self__, "additional_bootstrap_servers", additional_bootstrap_servers)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)
        if server_root_ca_certificate is not None:
            pulumi.set(__self__, "server_root_ca_certificate", server_root_ca_certificate)
        if starting_position is not None:
            pulumi.set(__self__, "starting_position", starting_position)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        The name of the topic that the pipe will read from. Maximum length of 249.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="additionalBootstrapServers")
    def additional_bootstrap_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of server URLs. Maximum number of 2 items, each of maximum length 300.
        """
        return pulumi.get(self, "additional_bootstrap_servers")

    @additional_bootstrap_servers.setter
    def additional_bootstrap_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_bootstrap_servers", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the destination queue to consume. Maximum value of 200.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs']]:
        """
        The credentials needed to access the resource. Detailed below.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)

    @property
    @pulumi.getter(name="serverRootCaCertificate")
    def server_root_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret used for certification.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @server_root_ca_certificate.setter
    def server_root_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_root_ca_certificate", value)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> Optional[pulumi.Input[str]]:
        """
        The position in a stream from which to start reading. Valid values: TRIM_HORIZON, LATEST.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starting_position", value)

    @property
    @pulumi.getter
    def vpc(self) -> Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersVpcArgs']]:
        """
        This structure specifies the VPC subnets and security groups for the stream, and whether a public IP address is to be used. Detailed below.
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: Optional[pulumi.Input['PipeSourceParametersSelfManagedKafkaParametersVpcArgs']]):
        pulumi.set(self, "vpc", value)


@pulumi.input_type
class PipeSourceParametersSelfManagedKafkaParametersCredentialsArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input[str],
                 client_certificate_tls_auth: Optional[pulumi.Input[str]] = None,
                 sasl_scram256_auth: Optional[pulumi.Input[str]] = None,
                 sasl_scram512_auth: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] basic_auth: The ARN of the Secrets Manager secret containing the basic auth credentials.
        :param pulumi.Input[str] client_certificate_tls_auth: The ARN of the Secrets Manager secret containing the credentials.
        :param pulumi.Input[str] sasl_scram256_auth: The ARN of the Secrets Manager secret containing the credentials.
        :param pulumi.Input[str] sasl_scram512_auth: The ARN of the Secrets Manager secret containing the credentials.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if client_certificate_tls_auth is not None:
            pulumi.set(__self__, "client_certificate_tls_auth", client_certificate_tls_auth)
        if sasl_scram256_auth is not None:
            pulumi.set(__self__, "sasl_scram256_auth", sasl_scram256_auth)
        if sasl_scram512_auth is not None:
            pulumi.set(__self__, "sasl_scram512_auth", sasl_scram512_auth)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input[str]:
        """
        The ARN of the Secrets Manager secret containing the basic auth credentials.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input[str]):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="clientCertificateTlsAuth")
    def client_certificate_tls_auth(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret containing the credentials.
        """
        return pulumi.get(self, "client_certificate_tls_auth")

    @client_certificate_tls_auth.setter
    def client_certificate_tls_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_tls_auth", value)

    @property
    @pulumi.getter(name="saslScram256Auth")
    def sasl_scram256_auth(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret containing the credentials.
        """
        return pulumi.get(self, "sasl_scram256_auth")

    @sasl_scram256_auth.setter
    def sasl_scram256_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_scram256_auth", value)

    @property
    @pulumi.getter(name="saslScram512Auth")
    def sasl_scram512_auth(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Secrets Manager secret containing the credentials.
        """
        return pulumi.get(self, "sasl_scram512_auth")

    @sasl_scram512_auth.setter
    def sasl_scram512_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sasl_scram512_auth", value)


@pulumi.input_type
class PipeSourceParametersSelfManagedKafkaParametersVpcArgs:
    def __init__(__self__, *,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        """
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


@pulumi.input_type
class PipeSourceParametersSqsQueueParametersArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 maximum_batching_window_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] batch_size: The maximum number of records to include in each batch. Maximum value of 10000.
        :param pulumi.Input[int] maximum_batching_window_in_seconds: The maximum length of a time to wait for events. Maximum value of 300.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if maximum_batching_window_in_seconds is not None:
            pulumi.set(__self__, "maximum_batching_window_in_seconds", maximum_batching_window_in_seconds)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of records to include in each batch. Maximum value of 10000.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="maximumBatchingWindowInSeconds")
    def maximum_batching_window_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of a time to wait for events. Maximum value of 300.
        """
        return pulumi.get(self, "maximum_batching_window_in_seconds")

    @maximum_batching_window_in_seconds.setter
    def maximum_batching_window_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_batching_window_in_seconds", value)


@pulumi.input_type
class PipeTargetParametersArgs:
    def __init__(__self__, *,
                 batch_job_parameters: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArgs']] = None,
                 cloudwatch_logs_parameters: Optional[pulumi.Input['PipeTargetParametersCloudwatchLogsParametersArgs']] = None,
                 ecs_task_parameters: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersArgs']] = None,
                 eventbridge_event_bus_parameters: Optional[pulumi.Input['PipeTargetParametersEventbridgeEventBusParametersArgs']] = None,
                 http_parameters: Optional[pulumi.Input['PipeTargetParametersHttpParametersArgs']] = None,
                 input_template: Optional[pulumi.Input[str]] = None,
                 kinesis_stream_parameters: Optional[pulumi.Input['PipeTargetParametersKinesisStreamParametersArgs']] = None,
                 lambda_function_parameters: Optional[pulumi.Input['PipeTargetParametersLambdaFunctionParametersArgs']] = None,
                 redshift_data_parameters: Optional[pulumi.Input['PipeTargetParametersRedshiftDataParametersArgs']] = None,
                 sagemaker_pipeline_parameters: Optional[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersArgs']] = None,
                 sqs_queue_parameters: Optional[pulumi.Input['PipeTargetParametersSqsQueueParametersArgs']] = None,
                 step_function_state_machine_parameters: Optional[pulumi.Input['PipeTargetParametersStepFunctionStateMachineParametersArgs']] = None):
        """
        :param pulumi.Input['PipeTargetParametersBatchJobParametersArgs'] batch_job_parameters: The parameters for using an AWS Batch job as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersCloudwatchLogsParametersArgs'] cloudwatch_logs_parameters: The parameters for using an CloudWatch Logs log stream as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersEcsTaskParametersArgs'] ecs_task_parameters: The parameters for using an Amazon ECS task as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersEventbridgeEventBusParametersArgs'] eventbridge_event_bus_parameters: The parameters for using an EventBridge event bus as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersHttpParametersArgs'] http_parameters: These are custom parameter to be used when the target is an API Gateway REST APIs or EventBridge ApiDestinations. Detailed below.
        :param pulumi.Input[str] input_template: Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
        :param pulumi.Input['PipeTargetParametersKinesisStreamParametersArgs'] kinesis_stream_parameters: The parameters for using a Kinesis stream as a source. Detailed below.
        :param pulumi.Input['PipeTargetParametersLambdaFunctionParametersArgs'] lambda_function_parameters: The parameters for using a Lambda function as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersRedshiftDataParametersArgs'] redshift_data_parameters: These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the Amazon Redshift Data API BatchExecuteStatement. Detailed below.
        :param pulumi.Input['PipeTargetParametersSagemakerPipelineParametersArgs'] sagemaker_pipeline_parameters: The parameters for using a SageMaker pipeline as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersSqsQueueParametersArgs'] sqs_queue_parameters: The parameters for using a Amazon SQS stream as a target. Detailed below.
        :param pulumi.Input['PipeTargetParametersStepFunctionStateMachineParametersArgs'] step_function_state_machine_parameters: The parameters for using a Step Functions state machine as a target. Detailed below.
        """
        if batch_job_parameters is not None:
            pulumi.set(__self__, "batch_job_parameters", batch_job_parameters)
        if cloudwatch_logs_parameters is not None:
            pulumi.set(__self__, "cloudwatch_logs_parameters", cloudwatch_logs_parameters)
        if ecs_task_parameters is not None:
            pulumi.set(__self__, "ecs_task_parameters", ecs_task_parameters)
        if eventbridge_event_bus_parameters is not None:
            pulumi.set(__self__, "eventbridge_event_bus_parameters", eventbridge_event_bus_parameters)
        if http_parameters is not None:
            pulumi.set(__self__, "http_parameters", http_parameters)
        if input_template is not None:
            pulumi.set(__self__, "input_template", input_template)
        if kinesis_stream_parameters is not None:
            pulumi.set(__self__, "kinesis_stream_parameters", kinesis_stream_parameters)
        if lambda_function_parameters is not None:
            pulumi.set(__self__, "lambda_function_parameters", lambda_function_parameters)
        if redshift_data_parameters is not None:
            pulumi.set(__self__, "redshift_data_parameters", redshift_data_parameters)
        if sagemaker_pipeline_parameters is not None:
            pulumi.set(__self__, "sagemaker_pipeline_parameters", sagemaker_pipeline_parameters)
        if sqs_queue_parameters is not None:
            pulumi.set(__self__, "sqs_queue_parameters", sqs_queue_parameters)
        if step_function_state_machine_parameters is not None:
            pulumi.set(__self__, "step_function_state_machine_parameters", step_function_state_machine_parameters)

    @property
    @pulumi.getter(name="batchJobParameters")
    def batch_job_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArgs']]:
        """
        The parameters for using an AWS Batch job as a target. Detailed below.
        """
        return pulumi.get(self, "batch_job_parameters")

    @batch_job_parameters.setter
    def batch_job_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArgs']]):
        pulumi.set(self, "batch_job_parameters", value)

    @property
    @pulumi.getter(name="cloudwatchLogsParameters")
    def cloudwatch_logs_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersCloudwatchLogsParametersArgs']]:
        """
        The parameters for using an CloudWatch Logs log stream as a target. Detailed below.
        """
        return pulumi.get(self, "cloudwatch_logs_parameters")

    @cloudwatch_logs_parameters.setter
    def cloudwatch_logs_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersCloudwatchLogsParametersArgs']]):
        pulumi.set(self, "cloudwatch_logs_parameters", value)

    @property
    @pulumi.getter(name="ecsTaskParameters")
    def ecs_task_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersArgs']]:
        """
        The parameters for using an Amazon ECS task as a target. Detailed below.
        """
        return pulumi.get(self, "ecs_task_parameters")

    @ecs_task_parameters.setter
    def ecs_task_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersArgs']]):
        pulumi.set(self, "ecs_task_parameters", value)

    @property
    @pulumi.getter(name="eventbridgeEventBusParameters")
    def eventbridge_event_bus_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersEventbridgeEventBusParametersArgs']]:
        """
        The parameters for using an EventBridge event bus as a target. Detailed below.
        """
        return pulumi.get(self, "eventbridge_event_bus_parameters")

    @eventbridge_event_bus_parameters.setter
    def eventbridge_event_bus_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersEventbridgeEventBusParametersArgs']]):
        pulumi.set(self, "eventbridge_event_bus_parameters", value)

    @property
    @pulumi.getter(name="httpParameters")
    def http_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersHttpParametersArgs']]:
        """
        These are custom parameter to be used when the target is an API Gateway REST APIs or EventBridge ApiDestinations. Detailed below.
        """
        return pulumi.get(self, "http_parameters")

    @http_parameters.setter
    def http_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersHttpParametersArgs']]):
        pulumi.set(self, "http_parameters", value)

    @property
    @pulumi.getter(name="inputTemplate")
    def input_template(self) -> Optional[pulumi.Input[str]]:
        """
        Valid JSON text passed to the target. In this case, nothing from the event itself is passed to the target. Maximum length of 8192 characters.
        """
        return pulumi.get(self, "input_template")

    @input_template.setter
    def input_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_template", value)

    @property
    @pulumi.getter(name="kinesisStreamParameters")
    def kinesis_stream_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersKinesisStreamParametersArgs']]:
        """
        The parameters for using a Kinesis stream as a source. Detailed below.
        """
        return pulumi.get(self, "kinesis_stream_parameters")

    @kinesis_stream_parameters.setter
    def kinesis_stream_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersKinesisStreamParametersArgs']]):
        pulumi.set(self, "kinesis_stream_parameters", value)

    @property
    @pulumi.getter(name="lambdaFunctionParameters")
    def lambda_function_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersLambdaFunctionParametersArgs']]:
        """
        The parameters for using a Lambda function as a target. Detailed below.
        """
        return pulumi.get(self, "lambda_function_parameters")

    @lambda_function_parameters.setter
    def lambda_function_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersLambdaFunctionParametersArgs']]):
        pulumi.set(self, "lambda_function_parameters", value)

    @property
    @pulumi.getter(name="redshiftDataParameters")
    def redshift_data_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersRedshiftDataParametersArgs']]:
        """
        These are custom parameters to be used when the target is a Amazon Redshift cluster to invoke the Amazon Redshift Data API BatchExecuteStatement. Detailed below.
        """
        return pulumi.get(self, "redshift_data_parameters")

    @redshift_data_parameters.setter
    def redshift_data_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersRedshiftDataParametersArgs']]):
        pulumi.set(self, "redshift_data_parameters", value)

    @property
    @pulumi.getter(name="sagemakerPipelineParameters")
    def sagemaker_pipeline_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersArgs']]:
        """
        The parameters for using a SageMaker pipeline as a target. Detailed below.
        """
        return pulumi.get(self, "sagemaker_pipeline_parameters")

    @sagemaker_pipeline_parameters.setter
    def sagemaker_pipeline_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersArgs']]):
        pulumi.set(self, "sagemaker_pipeline_parameters", value)

    @property
    @pulumi.getter(name="sqsQueueParameters")
    def sqs_queue_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersSqsQueueParametersArgs']]:
        """
        The parameters for using a Amazon SQS stream as a target. Detailed below.
        """
        return pulumi.get(self, "sqs_queue_parameters")

    @sqs_queue_parameters.setter
    def sqs_queue_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersSqsQueueParametersArgs']]):
        pulumi.set(self, "sqs_queue_parameters", value)

    @property
    @pulumi.getter(name="stepFunctionStateMachineParameters")
    def step_function_state_machine_parameters(self) -> Optional[pulumi.Input['PipeTargetParametersStepFunctionStateMachineParametersArgs']]:
        """
        The parameters for using a Step Functions state machine as a target. Detailed below.
        """
        return pulumi.get(self, "step_function_state_machine_parameters")

    @step_function_state_machine_parameters.setter
    def step_function_state_machine_parameters(self, value: Optional[pulumi.Input['PipeTargetParametersStepFunctionStateMachineParametersArgs']]):
        pulumi.set(self, "step_function_state_machine_parameters", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersArgs:
    def __init__(__self__, *,
                 job_definition: pulumi.Input[str],
                 job_name: pulumi.Input[str],
                 array_properties: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArrayPropertiesArgs']] = None,
                 container_overrides: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesArgs']] = None,
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersDependsOnArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 retry_strategy: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersRetryStrategyArgs']] = None):
        """
        :param pulumi.Input[str] job_definition: The job definition used by this job. This value can be one of name, name:revision, or the Amazon Resource Name (ARN) for the job definition. If name is specified without a revision then the latest active revision is used.
        :param pulumi.Input[str] job_name: The name of the job. It can be up to 128 letters long.
        :param pulumi.Input['PipeTargetParametersBatchJobParametersArrayPropertiesArgs'] array_properties: The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an AWS Batch job. Detailed below.
        :param pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesArgs'] container_overrides: The overrides that are sent to a container. Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersDependsOnArgs']]] depends_ons: A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. You can specify a SEQUENTIAL type dependency without specifying a job ID for array jobs so that each child array job completes sequentially, starting at index 0. You can also specify an N_TO_N type dependency with a job ID for array jobs. In that case, each index child of this job must wait for the corresponding index child of each dependency to complete before it can begin. Detailed below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: Additional parameters passed to the job that replace parameter substitution placeholders that are set in the job definition. Parameters are specified as a key and value pair mapping. Parameters included here override any corresponding parameter defaults from the job definition. Detailed below.
        :param pulumi.Input['PipeTargetParametersBatchJobParametersRetryStrategyArgs'] retry_strategy: The retry strategy to use for failed jobs. When a retry strategy is specified here, it overrides the retry strategy defined in the job definition. Detailed below.
        """
        pulumi.set(__self__, "job_definition", job_definition)
        pulumi.set(__self__, "job_name", job_name)
        if array_properties is not None:
            pulumi.set(__self__, "array_properties", array_properties)
        if container_overrides is not None:
            pulumi.set(__self__, "container_overrides", container_overrides)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if retry_strategy is not None:
            pulumi.set(__self__, "retry_strategy", retry_strategy)

    @property
    @pulumi.getter(name="jobDefinition")
    def job_definition(self) -> pulumi.Input[str]:
        """
        The job definition used by this job. This value can be one of name, name:revision, or the Amazon Resource Name (ARN) for the job definition. If name is specified without a revision then the latest active revision is used.
        """
        return pulumi.get(self, "job_definition")

    @job_definition.setter
    def job_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_definition", value)

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> pulumi.Input[str]:
        """
        The name of the job. It can be up to 128 letters long.
        """
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_name", value)

    @property
    @pulumi.getter(name="arrayProperties")
    def array_properties(self) -> Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArrayPropertiesArgs']]:
        """
        The array properties for the submitted job, such as the size of the array. The array size can be between 2 and 10,000. If you specify array properties for a job, it becomes an array job. This parameter is used only if the target is an AWS Batch job. Detailed below.
        """
        return pulumi.get(self, "array_properties")

    @array_properties.setter
    def array_properties(self, value: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersArrayPropertiesArgs']]):
        pulumi.set(self, "array_properties", value)

    @property
    @pulumi.getter(name="containerOverrides")
    def container_overrides(self) -> Optional[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesArgs']]:
        """
        The overrides that are sent to a container. Detailed below.
        """
        return pulumi.get(self, "container_overrides")

    @container_overrides.setter
    def container_overrides(self, value: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesArgs']]):
        pulumi.set(self, "container_overrides", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersDependsOnArgs']]]]:
        """
        A list of dependencies for the job. A job can depend upon a maximum of 20 jobs. You can specify a SEQUENTIAL type dependency without specifying a job ID for array jobs so that each child array job completes sequentially, starting at index 0. You can also specify an N_TO_N type dependency with a job ID for array jobs. In that case, each index child of this job must wait for the corresponding index child of each dependency to complete before it can begin. Detailed below.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersDependsOnArgs']]]]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional parameters passed to the job that replace parameter substitution placeholders that are set in the job definition. Parameters are specified as a key and value pair mapping. Parameters included here override any corresponding parameter defaults from the job definition. Detailed below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="retryStrategy")
    def retry_strategy(self) -> Optional[pulumi.Input['PipeTargetParametersBatchJobParametersRetryStrategyArgs']]:
        """
        The retry strategy to use for failed jobs. When a retry strategy is specified here, it overrides the retry strategy defined in the job definition. Detailed below.
        """
        return pulumi.get(self, "retry_strategy")

    @retry_strategy.setter
    def retry_strategy(self, value: Optional[pulumi.Input['PipeTargetParametersBatchJobParametersRetryStrategyArgs']]):
        pulumi.set(self, "retry_strategy", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersArrayPropertiesArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] size: The size of the array, if this is an array batch job. Minimum value of 2. Maximum value of 10,000.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the array, if this is an array batch job. Minimum value of 2. Maximum value of 10,000.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersContainerOverridesArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs']]]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: List of commands to send to the container that overrides the default command from the Docker image or the task definition.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs']]] environments: The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
        :param pulumi.Input[str] instance_type: The instance type to use for a multi-node parallel job. This parameter isn't applicable to single-node container jobs or jobs that run on Fargate resources, and shouldn't be provided.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs']]] resource_requirements: The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if resource_requirements is not None:
            pulumi.set(__self__, "resource_requirements", resource_requirements)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to send to the container that overrides the default command from the Docker image or the task definition.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs']]]]:
        """
        The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs']]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The instance type to use for a multi-node parallel job. This parameter isn't applicable to single-node container jobs or jobs that run on Fargate resources, and shouldn't be provided.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="resourceRequirements")
    def resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs']]]]:
        """
        The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
        """
        return pulumi.get(self, "resource_requirements")

    @resource_requirements.setter
    def resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs']]]]):
        pulumi.set(self, "resource_requirements", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersContainerOverridesEnvironmentArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersContainerOverridesResourceRequirementArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersDependsOnArgs:
    def __init__(__self__, *,
                 job_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] job_id: The job ID of the AWS Batch job that's associated with this dependency.
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[pulumi.Input[str]]:
        """
        The job ID of the AWS Batch job that's associated with this dependency.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PipeTargetParametersBatchJobParametersRetryStrategyArgs:
    def __init__(__self__, *,
                 attempts: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] attempts: The number of times to move a job to the RUNNABLE status. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Maximum value of 10.
        """
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)

    @property
    @pulumi.getter
    def attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times to move a job to the RUNNABLE status. If the value of attempts is greater than one, the job is retried on failure the same number of attempts as the value. Maximum value of 10.
        """
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "attempts", value)


@pulumi.input_type
class PipeTargetParametersCloudwatchLogsParametersArgs:
    def __init__(__self__, *,
                 log_stream_name: Optional[pulumi.Input[str]] = None,
                 timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_stream_name: The name of the log stream.
        :param pulumi.Input[str] timestamp: The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. This is the JSON path to the field in the event e.g. $.detail.timestamp
        """
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the log stream.
        """
        return pulumi.get(self, "log_stream_name")

    @log_stream_name.setter
    def log_stream_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_stream_name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. This is the JSON path to the field in the event e.g. $.detail.timestamp
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersArgs:
    def __init__(__self__, *,
                 task_definition_arn: pulumi.Input[str],
                 capacity_provider_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs']]]] = None,
                 enable_ecs_managed_tags: Optional[pulumi.Input[bool]] = None,
                 enable_execute_command: Optional[pulumi.Input[bool]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 launch_type: Optional[pulumi.Input[str]] = None,
                 network_configuration: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs']] = None,
                 overrides: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesArgs']] = None,
                 placement_constraints: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementConstraintArgs']]]] = None,
                 placement_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementStrategyArgs']]]] = None,
                 platform_version: Optional[pulumi.Input[str]] = None,
                 propagate_tags: Optional[pulumi.Input[str]] = None,
                 reference_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 task_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] task_definition_arn: The ARN of the task definition to use if the event target is an Amazon ECS task.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs']]] capacity_provider_strategies: List of capacity provider strategies to use for the task. If a capacityProviderStrategy is specified, the launchType parameter must be omitted. If no capacityProviderStrategy or launchType is specified, the defaultCapacityProviderStrategy for the cluster is used. Detailed below.
        :param pulumi.Input[bool] enable_ecs_managed_tags: Specifies whether to enable Amazon ECS managed tags for the task. Valid values: true, false.
        :param pulumi.Input[bool] enable_execute_command: Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task. Valid values: true, false.
        :param pulumi.Input[str] group: Specifies an Amazon ECS task group for the task. The maximum length is 255 characters.
        :param pulumi.Input[str] launch_type: Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. Valid Values: EC2, FARGATE, EXTERNAL
        :param pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs'] network_configuration: Use this structure if the Amazon ECS task uses the awsvpc network mode. This structure specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. This structure is required if LaunchType is FARGATE because the awsvpc mode is required for Fargate tasks. If you specify NetworkConfiguration when the target ECS task does not use the awsvpc network mode, the task fails. Detailed below.
        :param pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesArgs'] overrides: The overrides that are associated with a task. Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementConstraintArgs']]] placement_constraints: An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementStrategyArgs']]] placement_strategies: The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task. Detailed below.
        :param pulumi.Input[str] platform_version: Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0. This structure is used only if LaunchType is FARGATE.
        :param pulumi.Input[str] propagate_tags: Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action. Valid Values: TASK_DEFINITION
        :param pulumi.Input[str] reference_id: The reference ID to use for the task. Maximum length of 1,024.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        :param pulumi.Input[int] task_count: The number of tasks to create based on TaskDefinition. The default is 1.
        """
        pulumi.set(__self__, "task_definition_arn", task_definition_arn)
        if capacity_provider_strategies is not None:
            pulumi.set(__self__, "capacity_provider_strategies", capacity_provider_strategies)
        if enable_ecs_managed_tags is not None:
            pulumi.set(__self__, "enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            pulumi.set(__self__, "enable_execute_command", enable_execute_command)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if launch_type is not None:
            pulumi.set(__self__, "launch_type", launch_type)
        if network_configuration is not None:
            pulumi.set(__self__, "network_configuration", network_configuration)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if placement_strategies is not None:
            pulumi.set(__self__, "placement_strategies", placement_strategies)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if reference_id is not None:
            pulumi.set(__self__, "reference_id", reference_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the task definition to use if the event target is an Amazon ECS task.
        """
        return pulumi.get(self, "task_definition_arn")

    @task_definition_arn.setter
    def task_definition_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_definition_arn", value)

    @property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs']]]]:
        """
        List of capacity provider strategies to use for the task. If a capacityProviderStrategy is specified, the launchType parameter must be omitted. If no capacityProviderStrategy or launchType is specified, the defaultCapacityProviderStrategy for the cluster is used. Detailed below.
        """
        return pulumi.get(self, "capacity_provider_strategies")

    @capacity_provider_strategies.setter
    def capacity_provider_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs']]]]):
        pulumi.set(self, "capacity_provider_strategies", value)

    @property
    @pulumi.getter(name="enableEcsManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to enable Amazon ECS managed tags for the task. Valid values: true, false.
        """
        return pulumi.get(self, "enable_ecs_managed_tags")

    @enable_ecs_managed_tags.setter
    def enable_ecs_managed_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ecs_managed_tags", value)

    @property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task. Valid values: true, false.
        """
        return pulumi.get(self, "enable_execute_command")

    @enable_execute_command.setter
    def enable_execute_command(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_execute_command", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an Amazon ECS task group for the task. The maximum length is 255 characters.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where AWS Fargate with Amazon ECS is supported. Valid Values: EC2, FARGATE, EXTERNAL
        """
        return pulumi.get(self, "launch_type")

    @launch_type.setter
    def launch_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_type", value)

    @property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs']]:
        """
        Use this structure if the Amazon ECS task uses the awsvpc network mode. This structure specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. This structure is required if LaunchType is FARGATE because the awsvpc mode is required for Fargate tasks. If you specify NetworkConfiguration when the target ECS task does not use the awsvpc network mode, the task fails. Detailed below.
        """
        return pulumi.get(self, "network_configuration")

    @network_configuration.setter
    def network_configuration(self, value: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs']]):
        pulumi.set(self, "network_configuration", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesArgs']]:
        """
        The overrides that are associated with a task. Detailed below.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementConstraintArgs']]]]:
        """
        An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). Detailed below.
        """
        return pulumi.get(self, "placement_constraints")

    @placement_constraints.setter
    def placement_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementConstraintArgs']]]]):
        pulumi.set(self, "placement_constraints", value)

    @property
    @pulumi.getter(name="placementStrategies")
    def placement_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementStrategyArgs']]]]:
        """
        The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task. Detailed below.
        """
        return pulumi.get(self, "placement_strategies")

    @placement_strategies.setter
    def placement_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersPlacementStrategyArgs']]]]):
        pulumi.set(self, "placement_strategies", value)

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0. This structure is used only if LaunchType is FARGATE.
        """
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_version", value)

    @property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the TagResource API action. Valid Values: TASK_DEFINITION
        """
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "propagate_tags", value)

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        The reference ID to use for the task. Maximum length of 1,024.
        """
        return pulumi.get(self, "reference_id")

    @reference_id.setter
    def reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of tasks to create based on TaskDefinition. The default is 1.
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "task_count", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[str],
                 base: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] capacity_provider: The short name of the capacity provider. Maximum value of 255.
        :param pulumi.Input[int] base: The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used. Maximum value of 100,000.
        :param pulumi.Input[int] weight: The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Maximum value of 1,000.
        """
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[str]:
        """
        The short name of the capacity provider. Maximum value of 255.
        """
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "capacity_provider", value)

    @property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[int]]:
        """
        The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used. Maximum value of 100,000.
        """
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied. Maximum value of 1,000.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersNetworkConfigurationArgs:
    def __init__(__self__, *,
                 aws_vpc_configuration: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs']] = None):
        """
        :param pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs'] aws_vpc_configuration: Use this structure to specify the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode. Detailed below.
        """
        if aws_vpc_configuration is not None:
            pulumi.set(__self__, "aws_vpc_configuration", aws_vpc_configuration)

    @property
    @pulumi.getter(name="awsVpcConfiguration")
    def aws_vpc_configuration(self) -> Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs']]:
        """
        Use this structure to specify the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode. Detailed below.
        """
        return pulumi.get(self, "aws_vpc_configuration")

    @aws_vpc_configuration.setter
    def aws_vpc_configuration(self, value: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs']]):
        pulumi.set(self, "aws_vpc_configuration", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersNetworkConfigurationAwsVpcConfigurationArgs:
    def __init__(__self__, *,
                 assign_public_ip: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] assign_public_ip: Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE. Valid Values: ENABLED, DISABLED.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE. Valid Values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups associated with the stream. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the subnets associated with the stream. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesArgs:
    def __init__(__self__, *,
                 container_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs']]]] = None,
                 cpu: Optional[pulumi.Input[str]] = None,
                 ephemeral_storage: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs']] = None,
                 execution_role_arn: Optional[pulumi.Input[str]] = None,
                 inference_accelerator_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs']]]] = None,
                 memory: Optional[pulumi.Input[str]] = None,
                 task_role_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs']]] container_overrides: One or more container overrides that are sent to a task. Detailed below.
        :param pulumi.Input[str] cpu: The cpu override for the task.
        :param pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs'] ephemeral_storage: The ephemeral storage setting override for the task.  Detailed below.
        :param pulumi.Input[str] execution_role_arn: The Amazon Resource Name (ARN) of the task execution IAM role override for the task.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs']]] inference_accelerator_overrides: List of Elastic Inference accelerator overrides for the task. Detailed below.
        :param pulumi.Input[str] memory: The memory override for the task.
        :param pulumi.Input[str] task_role_arn: The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.
        """
        if container_overrides is not None:
            pulumi.set(__self__, "container_overrides", container_overrides)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if ephemeral_storage is not None:
            pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if execution_role_arn is not None:
            pulumi.set(__self__, "execution_role_arn", execution_role_arn)
        if inference_accelerator_overrides is not None:
            pulumi.set(__self__, "inference_accelerator_overrides", inference_accelerator_overrides)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if task_role_arn is not None:
            pulumi.set(__self__, "task_role_arn", task_role_arn)

    @property
    @pulumi.getter(name="containerOverrides")
    def container_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs']]]]:
        """
        One or more container overrides that are sent to a task. Detailed below.
        """
        return pulumi.get(self, "container_overrides")

    @container_overrides.setter
    def container_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs']]]]):
        pulumi.set(self, "container_overrides", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[str]]:
        """
        The cpu override for the task.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs']]:
        """
        The ephemeral storage setting override for the task.  Detailed below.
        """
        return pulumi.get(self, "ephemeral_storage")

    @ephemeral_storage.setter
    def ephemeral_storage(self, value: Optional[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs']]):
        pulumi.set(self, "ephemeral_storage", value)

    @property
    @pulumi.getter(name="executionRoleArn")
    def execution_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the task execution IAM role override for the task.
        """
        return pulumi.get(self, "execution_role_arn")

    @execution_role_arn.setter
    def execution_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_role_arn", value)

    @property
    @pulumi.getter(name="inferenceAcceleratorOverrides")
    def inference_accelerator_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs']]]]:
        """
        List of Elastic Inference accelerator overrides for the task. Detailed below.
        """
        return pulumi.get(self, "inference_accelerator_overrides")

    @inference_accelerator_overrides.setter
    def inference_accelerator_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs']]]]):
        pulumi.set(self, "inference_accelerator_overrides", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        The memory override for the task.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="taskRoleArn")
    def task_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.
        """
        return pulumi.get(self, "task_role_arn")

    @task_role_arn.setter
    def task_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_role_arn", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesContainerOverrideArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu: Optional[pulumi.Input[int]] = None,
                 environment_files: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs']]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs']]]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 memory_reservation: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: List of commands to send to the container that overrides the default command from the Docker image or the task definition.
        :param pulumi.Input[int] cpu: The cpu override for the task.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs']]] environment_files: A list of files containing the environment variables to pass to a container, instead of the value from the container definition. Detailed below.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs']]] environments: The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
        :param pulumi.Input[int] memory: The memory override for the task.
        :param pulumi.Input[int] memory_reservation: The soft limit (in MiB) of memory to reserve for the container, instead of the default value from the task definition. You must also specify a container name.
        :param pulumi.Input[str] name: Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs']]] resource_requirements: The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if environment_files is not None:
            pulumi.set(__self__, "environment_files", environment_files)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if memory_reservation is not None:
            pulumi.set(__self__, "memory_reservation", memory_reservation)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_requirements is not None:
            pulumi.set(__self__, "resource_requirements", resource_requirements)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of commands to send to the container that overrides the default command from the Docker image or the task definition.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[int]]:
        """
        The cpu override for the task.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="environmentFiles")
    def environment_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs']]]]:
        """
        A list of files containing the environment variables to pass to a container, instead of the value from the container definition. Detailed below.
        """
        return pulumi.get(self, "environment_files")

    @environment_files.setter
    def environment_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs']]]]):
        pulumi.set(self, "environment_files", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs']]]]:
        """
        The environment variables to send to the container. You can add new environment variables, which are added to the container at launch, or you can override the existing environment variables from the Docker image or the task definition. Environment variables cannot start with " AWS Batch ". This naming convention is reserved for variables that AWS Batch sets. Detailed below.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs']]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The memory override for the task.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="memoryReservation")
    def memory_reservation(self) -> Optional[pulumi.Input[int]]:
        """
        The soft limit (in MiB) of memory to reserve for the container, instead of the default value from the task definition. You must also specify a container name.
        """
        return pulumi.get(self, "memory_reservation")

    @memory_reservation.setter
    def memory_reservation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_reservation", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceRequirements")
    def resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs']]]]:
        """
        The type and amount of resources to assign to a container. This overrides the settings in the job definition. The supported resources include GPU, MEMORY, and VCPU. Detailed below.
        """
        return pulumi.get(self, "resource_requirements")

    @resource_requirements.setter
    def resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs']]]]):
        pulumi.set(self, "resource_requirements", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesContainerOverrideEnvironmentFileArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesContainerOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesEphemeralStorageArgs:
    def __init__(__self__, *,
                 size_in_gib: pulumi.Input[int]):
        """
        :param pulumi.Input[int] size_in_gib: The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is 21 GiB and the maximum supported value is 200 GiB.
        """
        pulumi.set(__self__, "size_in_gib", size_in_gib)

    @property
    @pulumi.getter(name="sizeInGib")
    def size_in_gib(self) -> pulumi.Input[int]:
        """
        The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is 21 GiB and the maximum supported value is 200 GiB.
        """
        return pulumi.get(self, "size_in_gib")

    @size_in_gib.setter
    def size_in_gib(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_gib", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersOverridesInferenceAcceleratorOverrideArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 device_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The Elastic Inference accelerator device name to override for the task. This parameter must match a deviceName specified in the task definition.
        :param pulumi.Input[str] device_type: The Elastic Inference accelerator type to use.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Elastic Inference accelerator device name to override for the task. This parameter must match a deviceName specified in the task definition.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Elastic Inference accelerator type to use.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_type", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersPlacementConstraintArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. Maximum length of 2,000.
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. Maximum length of 2,000.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PipeTargetParametersEcsTaskParametersPlacementStrategyArgs:
    def __init__(__self__, *,
                 field: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field: The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used. Maximum length of 255.
        :param pulumi.Input[str] type: The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used. Maximum length of 255.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource to assign to a container. The supported resources include GPU, MEMORY, and VCPU.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PipeTargetParametersEventbridgeEventBusParametersArgs:
    def __init__(__self__, *,
                 detail_type: Optional[pulumi.Input[str]] = None,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detail_type: A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
        :param pulumi.Input[str] endpoint_id: The URL subdomain of the endpoint. For example, if the URL for Endpoint is https://abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resources: List of AWS resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
        :param pulumi.Input[str] source: Source resource of the pipe (typically an ARN).
        :param pulumi.Input[str] time: The time stamp of the event, per RFC3339. If no time stamp is provided, the time stamp of the PutEvents call is used. This is the JSON path to the field in the event e.g. $.detail.timestamp
        """
        if detail_type is not None:
            pulumi.set(__self__, "detail_type", detail_type)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="detailType")
    def detail_type(self) -> Optional[pulumi.Input[str]]:
        """
        A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
        """
        return pulumi.get(self, "detail_type")

    @detail_type.setter
    def detail_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail_type", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The URL subdomain of the endpoint. For example, if the URL for Endpoint is https://abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of AWS resources, identified by Amazon Resource Name (ARN), which the event primarily concerns. Any number, including zero, may be present.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Source resource of the pipe (typically an ARN).
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        The time stamp of the event, per RFC3339. If no time stamp is provided, the time stamp of the PutEvents call is used. This is the JSON path to the field in the event e.g. $.detail.timestamp
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class PipeTargetParametersHttpParametersArgs:
    def __init__(__self__, *,
                 header_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 path_parameter_values: Optional[pulumi.Input[str]] = None,
                 query_string_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] header_parameters: Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        :param pulumi.Input[str] path_parameter_values: The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] query_string_parameters: Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        if header_parameters is not None:
            pulumi.set(__self__, "header_parameters", header_parameters)
        if path_parameter_values is not None:
            pulumi.set(__self__, "path_parameter_values", path_parameter_values)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @property
    @pulumi.getter(name="headerParameters")
    def header_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value mapping of the headers that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        return pulumi.get(self, "header_parameters")

    @header_parameters.setter
    def header_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "header_parameters", value)

    @property
    @pulumi.getter(name="pathParameterValues")
    def path_parameter_values(self) -> Optional[pulumi.Input[str]]:
        """
        The path parameter values to be used to populate API Gateway REST API or EventBridge ApiDestination path wildcards ("*").
        """
        return pulumi.get(self, "path_parameter_values")

    @path_parameter_values.setter
    def path_parameter_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_parameter_values", value)

    @property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value mapping of the query strings that need to be sent as part of request invoking the API Gateway REST API or EventBridge ApiDestination.
        """
        return pulumi.get(self, "query_string_parameters")

    @query_string_parameters.setter
    def query_string_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_string_parameters", value)


@pulumi.input_type
class PipeTargetParametersKinesisStreamParametersArgs:
    def __init__(__self__, *,
                 partition_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] partition_key: Determines which shard in the stream the data record is assigned to. Partition keys are Unicode strings with a maximum length limit of 256 characters for each key. Amazon Kinesis Data Streams uses the partition key as input to a hash function that maps the partition key and associated data to a specific shard. Specifically, an MD5 hash function is used to map partition keys to 128-bit integer values and to map associated data records to shards. As a result of this hashing mechanism, all data records with the same partition key map to the same shard within the stream.
        """
        pulumi.set(__self__, "partition_key", partition_key)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> pulumi.Input[str]:
        """
        Determines which shard in the stream the data record is assigned to. Partition keys are Unicode strings with a maximum length limit of 256 characters for each key. Amazon Kinesis Data Streams uses the partition key as input to a hash function that maps the partition key and associated data to a specific shard. Specifically, an MD5 hash function is used to map partition keys to 128-bit integer values and to map associated data records to shards. As a result of this hashing mechanism, all data records with the same partition key map to the same shard within the stream.
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "partition_key", value)


@pulumi.input_type
class PipeTargetParametersLambdaFunctionParametersArgs:
    def __init__(__self__, *,
                 invocation_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] invocation_type: Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
        """
        pulumi.set(__self__, "invocation_type", invocation_type)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> pulumi.Input[str]:
        """
        Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "invocation_type", value)


@pulumi.input_type
class PipeTargetParametersRedshiftDataParametersArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 sqls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 db_user: Optional[pulumi.Input[str]] = None,
                 secret_manager_arn: Optional[pulumi.Input[str]] = None,
                 statement_name: Optional[pulumi.Input[str]] = None,
                 with_event: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database: The name of the database. Required when authenticating using temporary credentials.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sqls: List of SQL statements text to run, each of maximum length of 100,000.
        :param pulumi.Input[str] db_user: The database user name. Required when authenticating using temporary credentials.
        :param pulumi.Input[str] secret_manager_arn: The name or ARN of the secret that enables access to the database. Required when authenticating using Secrets Manager.
        :param pulumi.Input[str] statement_name: The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
        :param pulumi.Input[bool] with_event: Indicates whether to send an event back to EventBridge after the SQL statement runs.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "sqls", sqls)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if secret_manager_arn is not None:
            pulumi.set(__self__, "secret_manager_arn", secret_manager_arn)
        if statement_name is not None:
            pulumi.set(__self__, "statement_name", statement_name)
        if with_event is not None:
            pulumi.set(__self__, "with_event", with_event)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the database. Required when authenticating using temporary credentials.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def sqls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of SQL statements text to run, each of maximum length of 100,000.
        """
        return pulumi.get(self, "sqls")

    @sqls.setter
    def sqls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sqls", value)

    @property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[str]]:
        """
        The database user name. Required when authenticating using temporary credentials.
        """
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_user", value)

    @property
    @pulumi.getter(name="secretManagerArn")
    def secret_manager_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The name or ARN of the secret that enables access to the database. Required when authenticating using Secrets Manager.
        """
        return pulumi.get(self, "secret_manager_arn")

    @secret_manager_arn.setter
    def secret_manager_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_manager_arn", value)

    @property
    @pulumi.getter(name="statementName")
    def statement_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
        """
        return pulumi.get(self, "statement_name")

    @statement_name.setter
    def statement_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statement_name", value)

    @property
    @pulumi.getter(name="withEvent")
    def with_event(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to send an event back to EventBridge after the SQL statement runs.
        """
        return pulumi.get(self, "with_event")

    @with_event.setter
    def with_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "with_event", value)


@pulumi.input_type
class PipeTargetParametersSagemakerPipelineParametersArgs:
    def __init__(__self__, *,
                 pipeline_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs']]] pipeline_parameters: List of Parameter names and values for SageMaker Model Building Pipeline execution. Detailed below.
        """
        if pipeline_parameters is not None:
            pulumi.set(__self__, "pipeline_parameters", pipeline_parameters)

    @property
    @pulumi.getter(name="pipelineParameters")
    def pipeline_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs']]]]:
        """
        List of Parameter names and values for SageMaker Model Building Pipeline execution. Detailed below.
        """
        return pulumi.get(self, "pipeline_parameters")

    @pipeline_parameters.setter
    def pipeline_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs']]]]):
        pulumi.set(self, "pipeline_parameters", value)


@pulumi.input_type
class PipeTargetParametersSagemakerPipelineParametersPipelineParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        :param pulumi.Input[str] value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PipeTargetParametersSqsQueueParametersArgs:
    def __init__(__self__, *,
                 message_deduplication_id: Optional[pulumi.Input[str]] = None,
                 message_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message_deduplication_id: This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of sent messages.
        :param pulumi.Input[str] message_group_id: The FIFO message group ID to use as the target.
        """
        if message_deduplication_id is not None:
            pulumi.set(__self__, "message_deduplication_id", message_deduplication_id)
        if message_group_id is not None:
            pulumi.set(__self__, "message_group_id", message_group_id)

    @property
    @pulumi.getter(name="messageDeduplicationId")
    def message_deduplication_id(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter applies only to FIFO (first-in-first-out) queues. The token used for deduplication of sent messages.
        """
        return pulumi.get(self, "message_deduplication_id")

    @message_deduplication_id.setter
    def message_deduplication_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_deduplication_id", value)

    @property
    @pulumi.getter(name="messageGroupId")
    def message_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The FIFO message group ID to use as the target.
        """
        return pulumi.get(self, "message_group_id")

    @message_group_id.setter
    def message_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_group_id", value)


@pulumi.input_type
class PipeTargetParametersStepFunctionStateMachineParametersArgs:
    def __init__(__self__, *,
                 invocation_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] invocation_type: Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
        """
        pulumi.set(__self__, "invocation_type", invocation_type)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> pulumi.Input[str]:
        """
        Specify whether to invoke the function synchronously or asynchronously. Valid Values: REQUEST_RESPONSE, FIRE_AND_FORGET.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "invocation_type", value)


