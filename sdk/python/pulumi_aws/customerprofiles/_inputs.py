# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DomainMatchingArgs',
    'DomainMatchingArgsDict',
    'DomainMatchingAutoMergingArgs',
    'DomainMatchingAutoMergingArgsDict',
    'DomainMatchingAutoMergingConflictResolutionArgs',
    'DomainMatchingAutoMergingConflictResolutionArgsDict',
    'DomainMatchingAutoMergingConsolidationArgs',
    'DomainMatchingAutoMergingConsolidationArgsDict',
    'DomainMatchingExportingConfigArgs',
    'DomainMatchingExportingConfigArgsDict',
    'DomainMatchingExportingConfigS3ExportingArgs',
    'DomainMatchingExportingConfigS3ExportingArgsDict',
    'DomainMatchingJobScheduleArgs',
    'DomainMatchingJobScheduleArgsDict',
    'DomainRuleBasedMatchingArgs',
    'DomainRuleBasedMatchingArgsDict',
    'DomainRuleBasedMatchingAttributeTypesSelectorArgs',
    'DomainRuleBasedMatchingAttributeTypesSelectorArgsDict',
    'DomainRuleBasedMatchingConflictResolutionArgs',
    'DomainRuleBasedMatchingConflictResolutionArgsDict',
    'DomainRuleBasedMatchingExportingConfigArgs',
    'DomainRuleBasedMatchingExportingConfigArgsDict',
    'DomainRuleBasedMatchingExportingConfigS3ExportingArgs',
    'DomainRuleBasedMatchingExportingConfigS3ExportingArgsDict',
    'DomainRuleBasedMatchingMatchingRuleArgs',
    'DomainRuleBasedMatchingMatchingRuleArgsDict',
    'ProfileAddressArgs',
    'ProfileAddressArgsDict',
    'ProfileBillingAddressArgs',
    'ProfileBillingAddressArgsDict',
    'ProfileMailingAddressArgs',
    'ProfileMailingAddressArgsDict',
    'ProfileShippingAddressArgs',
    'ProfileShippingAddressArgsDict',
]

MYPY = False

if not MYPY:
    class DomainMatchingArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        auto_merging: NotRequired[pulumi.Input['DomainMatchingAutoMergingArgsDict']]
        exporting_config: NotRequired[pulumi.Input['DomainMatchingExportingConfigArgsDict']]
        job_schedule: NotRequired[pulumi.Input['DomainMatchingJobScheduleArgsDict']]
elif False:
    DomainMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 auto_merging: Optional[pulumi.Input['DomainMatchingAutoMergingArgs']] = None,
                 exporting_config: Optional[pulumi.Input['DomainMatchingExportingConfigArgs']] = None,
                 job_schedule: Optional[pulumi.Input['DomainMatchingJobScheduleArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if auto_merging is not None:
            pulumi.set(__self__, "auto_merging", auto_merging)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if job_schedule is not None:
            pulumi.set(__self__, "job_schedule", job_schedule)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="autoMerging")
    def auto_merging(self) -> Optional[pulumi.Input['DomainMatchingAutoMergingArgs']]:
        return pulumi.get(self, "auto_merging")

    @auto_merging.setter
    def auto_merging(self, value: Optional[pulumi.Input['DomainMatchingAutoMergingArgs']]):
        pulumi.set(self, "auto_merging", value)

    @_builtins.property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional[pulumi.Input['DomainMatchingExportingConfigArgs']]:
        return pulumi.get(self, "exporting_config")

    @exporting_config.setter
    def exporting_config(self, value: Optional[pulumi.Input['DomainMatchingExportingConfigArgs']]):
        pulumi.set(self, "exporting_config", value)

    @_builtins.property
    @pulumi.getter(name="jobSchedule")
    def job_schedule(self) -> Optional[pulumi.Input['DomainMatchingJobScheduleArgs']]:
        return pulumi.get(self, "job_schedule")

    @job_schedule.setter
    def job_schedule(self, value: Optional[pulumi.Input['DomainMatchingJobScheduleArgs']]):
        pulumi.set(self, "job_schedule", value)


if not MYPY:
    class DomainMatchingAutoMergingArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        conflict_resolution: NotRequired[pulumi.Input['DomainMatchingAutoMergingConflictResolutionArgsDict']]
        consolidation: NotRequired[pulumi.Input['DomainMatchingAutoMergingConsolidationArgsDict']]
        min_allowed_confidence_score_for_merging: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    DomainMatchingAutoMergingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingAutoMergingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 conflict_resolution: Optional[pulumi.Input['DomainMatchingAutoMergingConflictResolutionArgs']] = None,
                 consolidation: Optional[pulumi.Input['DomainMatchingAutoMergingConsolidationArgs']] = None,
                 min_allowed_confidence_score_for_merging: Optional[pulumi.Input[_builtins.float]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if min_allowed_confidence_score_for_merging is not None:
            pulumi.set(__self__, "min_allowed_confidence_score_for_merging", min_allowed_confidence_score_for_merging)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional[pulumi.Input['DomainMatchingAutoMergingConflictResolutionArgs']]:
        return pulumi.get(self, "conflict_resolution")

    @conflict_resolution.setter
    def conflict_resolution(self, value: Optional[pulumi.Input['DomainMatchingAutoMergingConflictResolutionArgs']]):
        pulumi.set(self, "conflict_resolution", value)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> Optional[pulumi.Input['DomainMatchingAutoMergingConsolidationArgs']]:
        return pulumi.get(self, "consolidation")

    @consolidation.setter
    def consolidation(self, value: Optional[pulumi.Input['DomainMatchingAutoMergingConsolidationArgs']]):
        pulumi.set(self, "consolidation", value)

    @_builtins.property
    @pulumi.getter(name="minAllowedConfidenceScoreForMerging")
    def min_allowed_confidence_score_for_merging(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "min_allowed_confidence_score_for_merging")

    @min_allowed_confidence_score_for_merging.setter
    def min_allowed_confidence_score_for_merging(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_allowed_confidence_score_for_merging", value)


if not MYPY:
    class DomainMatchingAutoMergingConflictResolutionArgsDict(TypedDict):
        conflict_resolving_model: pulumi.Input[_builtins.str]
        source_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainMatchingAutoMergingConflictResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingAutoMergingConflictResolutionArgs:
    def __init__(__self__, *,
                 conflict_resolving_model: pulumi.Input[_builtins.str],
                 source_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "conflict_resolving_model", conflict_resolving_model)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @_builtins.property
    @pulumi.getter(name="conflictResolvingModel")
    def conflict_resolving_model(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "conflict_resolving_model")

    @conflict_resolving_model.setter
    def conflict_resolving_model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "conflict_resolving_model", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class DomainMatchingAutoMergingConsolidationArgsDict(TypedDict):
        matching_attributes_lists: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]
elif False:
    DomainMatchingAutoMergingConsolidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingAutoMergingConsolidationArgs:
    def __init__(__self__, *,
                 matching_attributes_lists: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        pulumi.set(__self__, "matching_attributes_lists", matching_attributes_lists)

    @_builtins.property
    @pulumi.getter(name="matchingAttributesLists")
    def matching_attributes_lists(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]:
        return pulumi.get(self, "matching_attributes_lists")

    @matching_attributes_lists.setter
    def matching_attributes_lists(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        pulumi.set(self, "matching_attributes_lists", value)


if not MYPY:
    class DomainMatchingExportingConfigArgsDict(TypedDict):
        s3_exporting: NotRequired[pulumi.Input['DomainMatchingExportingConfigS3ExportingArgsDict']]
elif False:
    DomainMatchingExportingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingExportingConfigArgs:
    def __init__(__self__, *,
                 s3_exporting: Optional[pulumi.Input['DomainMatchingExportingConfigS3ExportingArgs']] = None):
        if s3_exporting is not None:
            pulumi.set(__self__, "s3_exporting", s3_exporting)

    @_builtins.property
    @pulumi.getter(name="s3Exporting")
    def s3_exporting(self) -> Optional[pulumi.Input['DomainMatchingExportingConfigS3ExportingArgs']]:
        return pulumi.get(self, "s3_exporting")

    @s3_exporting.setter
    def s3_exporting(self, value: Optional[pulumi.Input['DomainMatchingExportingConfigS3ExportingArgs']]):
        pulumi.set(self, "s3_exporting", value)


if not MYPY:
    class DomainMatchingExportingConfigS3ExportingArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[_builtins.str]
        s3_key_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainMatchingExportingConfigS3ExportingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingExportingConfigS3ExportingArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[_builtins.str],
                 s3_key_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_name is not None:
            pulumi.set(__self__, "s3_key_name", s3_key_name)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3KeyName")
    def s3_key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_key_name")

    @s3_key_name.setter
    def s3_key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key_name", value)


if not MYPY:
    class DomainMatchingJobScheduleArgsDict(TypedDict):
        day_of_the_week: pulumi.Input[_builtins.str]
        time: pulumi.Input[_builtins.str]
elif False:
    DomainMatchingJobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingJobScheduleArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input[_builtins.str],
                 time: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_the_week", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class DomainRuleBasedMatchingArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        attribute_types_selector: NotRequired[pulumi.Input['DomainRuleBasedMatchingAttributeTypesSelectorArgsDict']]
        conflict_resolution: NotRequired[pulumi.Input['DomainRuleBasedMatchingConflictResolutionArgsDict']]
        exporting_config: NotRequired[pulumi.Input['DomainRuleBasedMatchingExportingConfigArgsDict']]
        matching_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainRuleBasedMatchingMatchingRuleArgsDict']]]]
        max_allowed_rule_level_for_matching: NotRequired[pulumi.Input[_builtins.int]]
        max_allowed_rule_level_for_merging: NotRequired[pulumi.Input[_builtins.int]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainRuleBasedMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 attribute_types_selector: Optional[pulumi.Input['DomainRuleBasedMatchingAttributeTypesSelectorArgs']] = None,
                 conflict_resolution: Optional[pulumi.Input['DomainRuleBasedMatchingConflictResolutionArgs']] = None,
                 exporting_config: Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigArgs']] = None,
                 matching_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleBasedMatchingMatchingRuleArgs']]]] = None,
                 max_allowed_rule_level_for_matching: Optional[pulumi.Input[_builtins.int]] = None,
                 max_allowed_rule_level_for_merging: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if attribute_types_selector is not None:
            pulumi.set(__self__, "attribute_types_selector", attribute_types_selector)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if matching_rules is not None:
            pulumi.set(__self__, "matching_rules", matching_rules)
        if max_allowed_rule_level_for_matching is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_matching", max_allowed_rule_level_for_matching)
        if max_allowed_rule_level_for_merging is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_merging", max_allowed_rule_level_for_merging)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="attributeTypesSelector")
    def attribute_types_selector(self) -> Optional[pulumi.Input['DomainRuleBasedMatchingAttributeTypesSelectorArgs']]:
        return pulumi.get(self, "attribute_types_selector")

    @attribute_types_selector.setter
    def attribute_types_selector(self, value: Optional[pulumi.Input['DomainRuleBasedMatchingAttributeTypesSelectorArgs']]):
        pulumi.set(self, "attribute_types_selector", value)

    @_builtins.property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional[pulumi.Input['DomainRuleBasedMatchingConflictResolutionArgs']]:
        return pulumi.get(self, "conflict_resolution")

    @conflict_resolution.setter
    def conflict_resolution(self, value: Optional[pulumi.Input['DomainRuleBasedMatchingConflictResolutionArgs']]):
        pulumi.set(self, "conflict_resolution", value)

    @_builtins.property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigArgs']]:
        return pulumi.get(self, "exporting_config")

    @exporting_config.setter
    def exporting_config(self, value: Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigArgs']]):
        pulumi.set(self, "exporting_config", value)

    @_builtins.property
    @pulumi.getter(name="matchingRules")
    def matching_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleBasedMatchingMatchingRuleArgs']]]]:
        return pulumi.get(self, "matching_rules")

    @matching_rules.setter
    def matching_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleBasedMatchingMatchingRuleArgs']]]]):
        pulumi.set(self, "matching_rules", value)

    @_builtins.property
    @pulumi.getter(name="maxAllowedRuleLevelForMatching")
    def max_allowed_rule_level_for_matching(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_allowed_rule_level_for_matching")

    @max_allowed_rule_level_for_matching.setter
    def max_allowed_rule_level_for_matching(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_allowed_rule_level_for_matching", value)

    @_builtins.property
    @pulumi.getter(name="maxAllowedRuleLevelForMerging")
    def max_allowed_rule_level_for_merging(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_allowed_rule_level_for_merging")

    @max_allowed_rule_level_for_merging.setter
    def max_allowed_rule_level_for_merging(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_allowed_rule_level_for_merging", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainRuleBasedMatchingAttributeTypesSelectorArgsDict(TypedDict):
        attribute_matching_model: pulumi.Input[_builtins.str]
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        phone_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DomainRuleBasedMatchingAttributeTypesSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingAttributeTypesSelectorArgs:
    def __init__(__self__, *,
                 attribute_matching_model: pulumi.Input[_builtins.str],
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 phone_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if phone_numbers is not None:
            pulumi.set(__self__, "phone_numbers", phone_numbers)

    @_builtins.property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "attribute_matching_model")

    @attribute_matching_model.setter
    def attribute_matching_model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_matching_model", value)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "email_addresses", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumbers")
    def phone_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "phone_numbers")

    @phone_numbers.setter
    def phone_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "phone_numbers", value)


if not MYPY:
    class DomainRuleBasedMatchingConflictResolutionArgsDict(TypedDict):
        conflict_resolving_model: pulumi.Input[_builtins.str]
        source_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainRuleBasedMatchingConflictResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingConflictResolutionArgs:
    def __init__(__self__, *,
                 conflict_resolving_model: pulumi.Input[_builtins.str],
                 source_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "conflict_resolving_model", conflict_resolving_model)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @_builtins.property
    @pulumi.getter(name="conflictResolvingModel")
    def conflict_resolving_model(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "conflict_resolving_model")

    @conflict_resolving_model.setter
    def conflict_resolving_model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "conflict_resolving_model", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class DomainRuleBasedMatchingExportingConfigArgsDict(TypedDict):
        s3_exporting: NotRequired[pulumi.Input['DomainRuleBasedMatchingExportingConfigS3ExportingArgsDict']]
elif False:
    DomainRuleBasedMatchingExportingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingExportingConfigArgs:
    def __init__(__self__, *,
                 s3_exporting: Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigS3ExportingArgs']] = None):
        if s3_exporting is not None:
            pulumi.set(__self__, "s3_exporting", s3_exporting)

    @_builtins.property
    @pulumi.getter(name="s3Exporting")
    def s3_exporting(self) -> Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigS3ExportingArgs']]:
        return pulumi.get(self, "s3_exporting")

    @s3_exporting.setter
    def s3_exporting(self, value: Optional[pulumi.Input['DomainRuleBasedMatchingExportingConfigS3ExportingArgs']]):
        pulumi.set(self, "s3_exporting", value)


if not MYPY:
    class DomainRuleBasedMatchingExportingConfigS3ExportingArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[_builtins.str]
        s3_key_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainRuleBasedMatchingExportingConfigS3ExportingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingExportingConfigS3ExportingArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[_builtins.str],
                 s3_key_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_name is not None:
            pulumi.set(__self__, "s3_key_name", s3_key_name)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3KeyName")
    def s3_key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_key_name")

    @s3_key_name.setter
    def s3_key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key_name", value)


if not MYPY:
    class DomainRuleBasedMatchingMatchingRuleArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DomainRuleBasedMatchingMatchingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingMatchingRuleArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ProfileAddressArgsDict(TypedDict):
        address1: NotRequired[pulumi.Input[_builtins.str]]
        address2: NotRequired[pulumi.Input[_builtins.str]]
        address3: NotRequired[pulumi.Input[_builtins.str]]
        address4: NotRequired[pulumi.Input[_builtins.str]]
        city: NotRequired[pulumi.Input[_builtins.str]]
        country: NotRequired[pulumi.Input[_builtins.str]]
        county: NotRequired[pulumi.Input[_builtins.str]]
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        province: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProfileAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileAddressArgs:
    def __init__(__self__, *,
                 address1: Optional[pulumi.Input[_builtins.str]] = None,
                 address2: Optional[pulumi.Input[_builtins.str]] = None,
                 address3: Optional[pulumi.Input[_builtins.str]] = None,
                 address4: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 county: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 province: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if address1 is not None:
            pulumi.set(__self__, "address1", address1)
        if address2 is not None:
            pulumi.set(__self__, "address2", address2)
        if address3 is not None:
            pulumi.set(__self__, "address3", address3)
        if address4 is not None:
            pulumi.set(__self__, "address4", address4)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def address1(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address1")

    @address1.setter
    def address1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address1", value)

    @_builtins.property
    @pulumi.getter
    def address2(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address2")

    @address2.setter
    def address2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address2", value)

    @_builtins.property
    @pulumi.getter
    def address3(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address3")

    @address3.setter
    def address3(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address3", value)

    @_builtins.property
    @pulumi.getter
    def address4(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address4")

    @address4.setter
    def address4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address4", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def county(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "county")

    @county.setter
    def county(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "county", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "province", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ProfileBillingAddressArgsDict(TypedDict):
        address1: NotRequired[pulumi.Input[_builtins.str]]
        address2: NotRequired[pulumi.Input[_builtins.str]]
        address3: NotRequired[pulumi.Input[_builtins.str]]
        address4: NotRequired[pulumi.Input[_builtins.str]]
        city: NotRequired[pulumi.Input[_builtins.str]]
        country: NotRequired[pulumi.Input[_builtins.str]]
        county: NotRequired[pulumi.Input[_builtins.str]]
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        province: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProfileBillingAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileBillingAddressArgs:
    def __init__(__self__, *,
                 address1: Optional[pulumi.Input[_builtins.str]] = None,
                 address2: Optional[pulumi.Input[_builtins.str]] = None,
                 address3: Optional[pulumi.Input[_builtins.str]] = None,
                 address4: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 county: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 province: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if address1 is not None:
            pulumi.set(__self__, "address1", address1)
        if address2 is not None:
            pulumi.set(__self__, "address2", address2)
        if address3 is not None:
            pulumi.set(__self__, "address3", address3)
        if address4 is not None:
            pulumi.set(__self__, "address4", address4)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def address1(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address1")

    @address1.setter
    def address1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address1", value)

    @_builtins.property
    @pulumi.getter
    def address2(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address2")

    @address2.setter
    def address2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address2", value)

    @_builtins.property
    @pulumi.getter
    def address3(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address3")

    @address3.setter
    def address3(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address3", value)

    @_builtins.property
    @pulumi.getter
    def address4(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address4")

    @address4.setter
    def address4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address4", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def county(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "county")

    @county.setter
    def county(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "county", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "province", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ProfileMailingAddressArgsDict(TypedDict):
        address1: NotRequired[pulumi.Input[_builtins.str]]
        address2: NotRequired[pulumi.Input[_builtins.str]]
        address3: NotRequired[pulumi.Input[_builtins.str]]
        address4: NotRequired[pulumi.Input[_builtins.str]]
        city: NotRequired[pulumi.Input[_builtins.str]]
        country: NotRequired[pulumi.Input[_builtins.str]]
        county: NotRequired[pulumi.Input[_builtins.str]]
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        province: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProfileMailingAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileMailingAddressArgs:
    def __init__(__self__, *,
                 address1: Optional[pulumi.Input[_builtins.str]] = None,
                 address2: Optional[pulumi.Input[_builtins.str]] = None,
                 address3: Optional[pulumi.Input[_builtins.str]] = None,
                 address4: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 county: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 province: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if address1 is not None:
            pulumi.set(__self__, "address1", address1)
        if address2 is not None:
            pulumi.set(__self__, "address2", address2)
        if address3 is not None:
            pulumi.set(__self__, "address3", address3)
        if address4 is not None:
            pulumi.set(__self__, "address4", address4)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def address1(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address1")

    @address1.setter
    def address1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address1", value)

    @_builtins.property
    @pulumi.getter
    def address2(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address2")

    @address2.setter
    def address2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address2", value)

    @_builtins.property
    @pulumi.getter
    def address3(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address3")

    @address3.setter
    def address3(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address3", value)

    @_builtins.property
    @pulumi.getter
    def address4(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address4")

    @address4.setter
    def address4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address4", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def county(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "county")

    @county.setter
    def county(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "county", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "province", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ProfileShippingAddressArgsDict(TypedDict):
        address1: NotRequired[pulumi.Input[_builtins.str]]
        address2: NotRequired[pulumi.Input[_builtins.str]]
        address3: NotRequired[pulumi.Input[_builtins.str]]
        address4: NotRequired[pulumi.Input[_builtins.str]]
        city: NotRequired[pulumi.Input[_builtins.str]]
        country: NotRequired[pulumi.Input[_builtins.str]]
        county: NotRequired[pulumi.Input[_builtins.str]]
        postal_code: NotRequired[pulumi.Input[_builtins.str]]
        province: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProfileShippingAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileShippingAddressArgs:
    def __init__(__self__, *,
                 address1: Optional[pulumi.Input[_builtins.str]] = None,
                 address2: Optional[pulumi.Input[_builtins.str]] = None,
                 address3: Optional[pulumi.Input[_builtins.str]] = None,
                 address4: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 county: Optional[pulumi.Input[_builtins.str]] = None,
                 postal_code: Optional[pulumi.Input[_builtins.str]] = None,
                 province: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if address1 is not None:
            pulumi.set(__self__, "address1", address1)
        if address2 is not None:
            pulumi.set(__self__, "address2", address2)
        if address3 is not None:
            pulumi.set(__self__, "address3", address3)
        if address4 is not None:
            pulumi.set(__self__, "address4", address4)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def address1(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address1")

    @address1.setter
    def address1(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address1", value)

    @_builtins.property
    @pulumi.getter
    def address2(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address2")

    @address2.setter
    def address2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address2", value)

    @_builtins.property
    @pulumi.getter
    def address3(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address3")

    @address3.setter
    def address3(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address3", value)

    @_builtins.property
    @pulumi.getter
    def address4(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address4")

    @address4.setter
    def address4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address4", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def county(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "county")

    @county.setter
    def county(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "county", value)

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postal_code", value)

    @_builtins.property
    @pulumi.getter
    def province(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "province")

    @province.setter
    def province(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "province", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


