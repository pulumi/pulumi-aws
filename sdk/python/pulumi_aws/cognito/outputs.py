# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'IdentityPoolCognitoIdentityProvider',
    'IdentityPoolRoleAttachmentRoleMapping',
    'IdentityPoolRoleAttachmentRoleMappingMappingRule',
    'LogDeliveryConfigurationLogConfiguration',
    'LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration',
    'LogDeliveryConfigurationLogConfigurationFirehoseConfiguration',
    'LogDeliveryConfigurationLogConfigurationS3Configuration',
    'ManagedLoginBrandingAsset',
    'ManagedUserPoolClientAnalyticsConfiguration',
    'ManagedUserPoolClientRefreshTokenRotation',
    'ManagedUserPoolClientTokenValidityUnits',
    'ResourceServerScope',
    'RiskConfigurationAccountTakeoverRiskConfiguration',
    'RiskConfigurationAccountTakeoverRiskConfigurationActions',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail',
    'RiskConfigurationCompromisedCredentialsRiskConfiguration',
    'RiskConfigurationCompromisedCredentialsRiskConfigurationActions',
    'RiskConfigurationRiskExceptionConfiguration',
    'UserPoolAccountRecoverySetting',
    'UserPoolAccountRecoverySettingRecoveryMechanism',
    'UserPoolAdminCreateUserConfig',
    'UserPoolAdminCreateUserConfigInviteMessageTemplate',
    'UserPoolClientAnalyticsConfiguration',
    'UserPoolClientRefreshTokenRotation',
    'UserPoolClientTokenValidityUnits',
    'UserPoolDeviceConfiguration',
    'UserPoolEmailConfiguration',
    'UserPoolEmailMfaConfiguration',
    'UserPoolLambdaConfig',
    'UserPoolLambdaConfigCustomEmailSender',
    'UserPoolLambdaConfigCustomSmsSender',
    'UserPoolLambdaConfigPreTokenGenerationConfig',
    'UserPoolPasswordPolicy',
    'UserPoolSchema',
    'UserPoolSchemaNumberAttributeConstraints',
    'UserPoolSchemaStringAttributeConstraints',
    'UserPoolSignInPolicy',
    'UserPoolSmsConfiguration',
    'UserPoolSoftwareTokenMfaConfiguration',
    'UserPoolUserAttributeUpdateSettings',
    'UserPoolUserPoolAddOns',
    'UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows',
    'UserPoolUsernameConfiguration',
    'UserPoolVerificationMessageTemplate',
    'UserPoolWebAuthnConfiguration',
    'GetIdentityPoolCognitoIdentityProviderResult',
    'GetUserGroupsGroupResult',
    'GetUserPoolAccountRecoverySettingResult',
    'GetUserPoolAccountRecoverySettingRecoveryMechanismResult',
    'GetUserPoolAdminCreateUserConfigResult',
    'GetUserPoolAdminCreateUserConfigInviteMessageTemplateResult',
    'GetUserPoolClientAnalyticsConfigurationResult',
    'GetUserPoolClientRefreshTokenRotationResult',
    'GetUserPoolClientTokenValidityUnitResult',
    'GetUserPoolDeviceConfigurationResult',
    'GetUserPoolEmailConfigurationResult',
    'GetUserPoolLambdaConfigResult',
    'GetUserPoolLambdaConfigCustomEmailSenderResult',
    'GetUserPoolLambdaConfigCustomSmsSenderResult',
    'GetUserPoolLambdaConfigPreTokenGenerationConfigResult',
    'GetUserPoolSchemaAttributeResult',
    'GetUserPoolSchemaAttributeNumberAttributeConstraintResult',
    'GetUserPoolSchemaAttributeStringAttributeConstraintResult',
    'GetUserPoolUserPoolAddOnResult',
    'GetUserPoolUserPoolAddOnAdvancedSecurityAdditionalFlowResult',
]

@pulumi.output_type
class IdentityPoolCognitoIdentityProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "providerName":
            suggest = "provider_name"
        elif key == "serverSideTokenCheck":
            suggest = "server_side_token_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityPoolCognitoIdentityProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityPoolCognitoIdentityProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityPoolCognitoIdentityProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 provider_name: Optional[_builtins.str] = None,
                 server_side_token_check: Optional[_builtins.bool] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if server_side_token_check is not None:
            pulumi.set(__self__, "server_side_token_check", server_side_token_check)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="serverSideTokenCheck")
    def server_side_token_check(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "server_side_token_check")


@pulumi.output_type
class IdentityPoolRoleAttachmentRoleMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProvider":
            suggest = "identity_provider"
        elif key == "ambiguousRoleResolution":
            suggest = "ambiguous_role_resolution"
        elif key == "mappingRules":
            suggest = "mapping_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityPoolRoleAttachmentRoleMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityPoolRoleAttachmentRoleMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityPoolRoleAttachmentRoleMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider: _builtins.str,
                 type: _builtins.str,
                 ambiguous_role_resolution: Optional[_builtins.str] = None,
                 mapping_rules: Optional[Sequence['outputs.IdentityPoolRoleAttachmentRoleMappingMappingRule']] = None):
        pulumi.set(__self__, "identity_provider", identity_provider)
        pulumi.set(__self__, "type", type)
        if ambiguous_role_resolution is not None:
            pulumi.set(__self__, "ambiguous_role_resolution", ambiguous_role_resolution)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)

    @_builtins.property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> _builtins.str:
        return pulumi.get(self, "identity_provider")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="ambiguousRoleResolution")
    def ambiguous_role_resolution(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ambiguous_role_resolution")

    @_builtins.property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional[Sequence['outputs.IdentityPoolRoleAttachmentRoleMappingMappingRule']]:
        return pulumi.get(self, "mapping_rules")


@pulumi.output_type
class IdentityPoolRoleAttachmentRoleMappingMappingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityPoolRoleAttachmentRoleMappingMappingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityPoolRoleAttachmentRoleMappingMappingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityPoolRoleAttachmentRoleMappingMappingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim: _builtins.str,
                 match_type: _builtins.str,
                 role_arn: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "claim", claim)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def claim(self) -> _builtins.str:
        return pulumi.get(self, "claim")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class LogDeliveryConfigurationLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSource":
            suggest = "event_source"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "cloudWatchLogsConfiguration":
            suggest = "cloud_watch_logs_configuration"
        elif key == "firehoseConfiguration":
            suggest = "firehose_configuration"
        elif key == "s3Configuration":
            suggest = "s3_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryConfigurationLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryConfigurationLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryConfigurationLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_source: _builtins.str,
                 log_level: _builtins.str,
                 cloud_watch_logs_configuration: Optional['outputs.LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration'] = None,
                 firehose_configuration: Optional['outputs.LogDeliveryConfigurationLogConfigurationFirehoseConfiguration'] = None,
                 s3_configuration: Optional['outputs.LogDeliveryConfigurationLogConfigurationS3Configuration'] = None):
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "log_level", log_level)
        if cloud_watch_logs_configuration is not None:
            pulumi.set(__self__, "cloud_watch_logs_configuration", cloud_watch_logs_configuration)
        if firehose_configuration is not None:
            pulumi.set(__self__, "firehose_configuration", firehose_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> _builtins.str:
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> _builtins.str:
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogsConfiguration")
    def cloud_watch_logs_configuration(self) -> Optional['outputs.LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration']:
        return pulumi.get(self, "cloud_watch_logs_configuration")

    @_builtins.property
    @pulumi.getter(name="firehoseConfiguration")
    def firehose_configuration(self) -> Optional['outputs.LogDeliveryConfigurationLogConfigurationFirehoseConfiguration']:
        return pulumi.get(self, "firehose_configuration")

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional['outputs.LogDeliveryConfigurationLogConfigurationS3Configuration']:
        return pulumi.get(self, "s3_configuration")


@pulumi.output_type
class LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupArn":
            suggest = "log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryConfigurationLogConfigurationCloudWatchLogsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_arn: Optional[_builtins.str] = None):
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group_arn")


@pulumi.output_type
class LogDeliveryConfigurationLogConfigurationFirehoseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamArn":
            suggest = "stream_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryConfigurationLogConfigurationFirehoseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryConfigurationLogConfigurationFirehoseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryConfigurationLogConfigurationFirehoseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stream_arn: Optional[_builtins.str] = None):
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "stream_arn")


@pulumi.output_type
class LogDeliveryConfigurationLogConfigurationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryConfigurationLogConfigurationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryConfigurationLogConfigurationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryConfigurationLogConfigurationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: Optional[_builtins.str] = None):
        if bucket_arn is not None:
            pulumi.set(__self__, "bucket_arn", bucket_arn)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_arn")


@pulumi.output_type
class ManagedLoginBrandingAsset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorMode":
            suggest = "color_mode"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedLoginBrandingAsset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedLoginBrandingAsset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedLoginBrandingAsset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: _builtins.str,
                 color_mode: _builtins.str,
                 extension: _builtins.str,
                 bytes: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "color_mode", color_mode)
        pulumi.set(__self__, "extension", extension)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="colorMode")
    def color_mode(self) -> _builtins.str:
        return pulumi.get(self, "color_mode")

    @_builtins.property
    @pulumi.getter
    def extension(self) -> _builtins.str:
        return pulumi.get(self, "extension")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bytes")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedUserPoolClientAnalyticsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationArn":
            suggest = "application_arn"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "userDataShared":
            suggest = "user_data_shared"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedUserPoolClientAnalyticsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedUserPoolClientAnalyticsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedUserPoolClientAnalyticsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_arn: Optional[_builtins.str] = None,
                 application_id: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 user_data_shared: Optional[_builtins.bool] = None):
        if application_arn is not None:
            pulumi.set(__self__, "application_arn", application_arn)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if user_data_shared is not None:
            pulumi.set(__self__, "user_data_shared", user_data_shared)

    @_builtins.property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_arn")

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="userDataShared")
    def user_data_shared(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "user_data_shared")


@pulumi.output_type
class ManagedUserPoolClientRefreshTokenRotation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryGracePeriodSeconds":
            suggest = "retry_grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedUserPoolClientRefreshTokenRotation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedUserPoolClientRefreshTokenRotation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedUserPoolClientRefreshTokenRotation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature: _builtins.str,
                 retry_grace_period_seconds: Optional[_builtins.int] = None):
        pulumi.set(__self__, "feature", feature)
        if retry_grace_period_seconds is not None:
            pulumi.set(__self__, "retry_grace_period_seconds", retry_grace_period_seconds)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter(name="retryGracePeriodSeconds")
    def retry_grace_period_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retry_grace_period_seconds")


@pulumi.output_type
class ManagedUserPoolClientTokenValidityUnits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "idToken":
            suggest = "id_token"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedUserPoolClientTokenValidityUnits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedUserPoolClientTokenValidityUnits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedUserPoolClientTokenValidityUnits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[_builtins.str] = None,
                 id_token: Optional[_builtins.str] = None,
                 refresh_token: Optional[_builtins.str] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if id_token is not None:
            pulumi.set(__self__, "id_token", id_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id_token")

    @_builtins.property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class ResourceServerScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopeDescription":
            suggest = "scope_description"
        elif key == "scopeName":
            suggest = "scope_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceServerScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceServerScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceServerScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope_description: _builtins.str,
                 scope_name: _builtins.str):
        pulumi.set(__self__, "scope_description", scope_description)
        pulumi.set(__self__, "scope_name", scope_name)

    @_builtins.property
    @pulumi.getter(name="scopeDescription")
    def scope_description(self) -> _builtins.str:
        return pulumi.get(self, "scope_description")

    @_builtins.property
    @pulumi.getter(name="scopeName")
    def scope_name(self) -> _builtins.str:
        return pulumi.get(self, "scope_name")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyConfiguration":
            suggest = "notify_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: 'outputs.RiskConfigurationAccountTakeoverRiskConfigurationActions',
                 notify_configuration: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration'] = None):
        pulumi.set(__self__, "actions", actions)
        if notify_configuration is not None:
            pulumi.set(__self__, "notify_configuration", notify_configuration)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.RiskConfigurationAccountTakeoverRiskConfigurationActions':
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notifyConfiguration")
    def notify_configuration(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration']:
        return pulumi.get(self, "notify_configuration")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highAction":
            suggest = "high_action"
        elif key == "lowAction":
            suggest = "low_action"
        elif key == "mediumAction":
            suggest = "medium_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_action: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction'] = None,
                 low_action: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction'] = None,
                 medium_action: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction'] = None):
        if high_action is not None:
            pulumi.set(__self__, "high_action", high_action)
        if low_action is not None:
            pulumi.set(__self__, "low_action", low_action)
        if medium_action is not None:
            pulumi.set(__self__, "medium_action", medium_action)

    @_builtins.property
    @pulumi.getter(name="highAction")
    def high_action(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction']:
        return pulumi.get(self, "high_action")

    @_builtins.property
    @pulumi.getter(name="lowAction")
    def low_action(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction']:
        return pulumi.get(self, "low_action")

    @_builtins.property
    @pulumi.getter(name="mediumAction")
    def medium_action(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction']:
        return pulumi.get(self, "medium_action")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsHighAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: _builtins.str,
                 notify: _builtins.bool):
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> _builtins.str:
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def notify(self) -> _builtins.bool:
        return pulumi.get(self, "notify")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsLowAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: _builtins.str,
                 notify: _builtins.bool):
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> _builtins.str:
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def notify(self) -> _builtins.bool:
        return pulumi.get(self, "notify")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: _builtins.str,
                 notify: _builtins.bool):
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> _builtins.str:
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def notify(self) -> _builtins.bool:
        return pulumi.get(self, "notify")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceArn":
            suggest = "source_arn"
        elif key == "blockEmail":
            suggest = "block_email"
        elif key == "from":
            suggest = "from_"
        elif key == "mfaEmail":
            suggest = "mfa_email"
        elif key == "noActionEmail":
            suggest = "no_action_email"
        elif key == "replyTo":
            suggest = "reply_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_arn: _builtins.str,
                 block_email: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail'] = None,
                 from_: Optional[_builtins.str] = None,
                 mfa_email: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail'] = None,
                 no_action_email: Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail'] = None,
                 reply_to: Optional[_builtins.str] = None):
        pulumi.set(__self__, "source_arn", source_arn)
        if block_email is not None:
            pulumi.set(__self__, "block_email", block_email)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if mfa_email is not None:
            pulumi.set(__self__, "mfa_email", mfa_email)
        if no_action_email is not None:
            pulumi.set(__self__, "no_action_email", no_action_email)
        if reply_to is not None:
            pulumi.set(__self__, "reply_to", reply_to)

    @_builtins.property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> _builtins.str:
        return pulumi.get(self, "source_arn")

    @_builtins.property
    @pulumi.getter(name="blockEmail")
    def block_email(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail']:
        return pulumi.get(self, "block_email")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter(name="mfaEmail")
    def mfa_email(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail']:
        return pulumi.get(self, "mfa_email")

    @_builtins.property
    @pulumi.getter(name="noActionEmail")
    def no_action_email(self) -> Optional['outputs.RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail']:
        return pulumi.get(self, "no_action_email")

    @_builtins.property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reply_to")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "textBody":
            suggest = "text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_body: _builtins.str,
                 subject: _builtins.str,
                 text_body: _builtins.str):
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> _builtins.str:
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="textBody")
    def text_body(self) -> _builtins.str:
        return pulumi.get(self, "text_body")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "textBody":
            suggest = "text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_body: _builtins.str,
                 subject: _builtins.str,
                 text_body: _builtins.str):
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> _builtins.str:
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="textBody")
    def text_body(self) -> _builtins.str:
        return pulumi.get(self, "text_body")


@pulumi.output_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlBody":
            suggest = "html_body"
        elif key == "textBody":
            suggest = "text_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_body: _builtins.str,
                 subject: _builtins.str,
                 text_body: _builtins.str):
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> _builtins.str:
        return pulumi.get(self, "html_body")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="textBody")
    def text_body(self) -> _builtins.str:
        return pulumi.get(self, "text_body")


@pulumi.output_type
class RiskConfigurationCompromisedCredentialsRiskConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventFilters":
            suggest = "event_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationCompromisedCredentialsRiskConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationCompromisedCredentialsRiskConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationCompromisedCredentialsRiskConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: 'outputs.RiskConfigurationCompromisedCredentialsRiskConfigurationActions',
                 event_filters: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "actions", actions)
        if event_filters is not None:
            pulumi.set(__self__, "event_filters", event_filters)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.RiskConfigurationCompromisedCredentialsRiskConfigurationActions':
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="eventFilters")
    def event_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "event_filters")


@pulumi.output_type
class RiskConfigurationCompromisedCredentialsRiskConfigurationActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationCompromisedCredentialsRiskConfigurationActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationCompromisedCredentialsRiskConfigurationActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationCompromisedCredentialsRiskConfigurationActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: _builtins.str):
        pulumi.set(__self__, "event_action", event_action)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> _builtins.str:
        return pulumi.get(self, "event_action")


@pulumi.output_type
class RiskConfigurationRiskExceptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockedIpRangeLists":
            suggest = "blocked_ip_range_lists"
        elif key == "skippedIpRangeLists":
            suggest = "skipped_ip_range_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RiskConfigurationRiskExceptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RiskConfigurationRiskExceptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RiskConfigurationRiskExceptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocked_ip_range_lists: Optional[Sequence[_builtins.str]] = None,
                 skipped_ip_range_lists: Optional[Sequence[_builtins.str]] = None):
        if blocked_ip_range_lists is not None:
            pulumi.set(__self__, "blocked_ip_range_lists", blocked_ip_range_lists)
        if skipped_ip_range_lists is not None:
            pulumi.set(__self__, "skipped_ip_range_lists", skipped_ip_range_lists)

    @_builtins.property
    @pulumi.getter(name="blockedIpRangeLists")
    def blocked_ip_range_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "blocked_ip_range_lists")

    @_builtins.property
    @pulumi.getter(name="skippedIpRangeLists")
    def skipped_ip_range_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "skipped_ip_range_lists")


@pulumi.output_type
class UserPoolAccountRecoverySetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryMechanisms":
            suggest = "recovery_mechanisms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolAccountRecoverySetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolAccountRecoverySetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolAccountRecoverySetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_mechanisms: Optional[Sequence['outputs.UserPoolAccountRecoverySettingRecoveryMechanism']] = None):
        if recovery_mechanisms is not None:
            pulumi.set(__self__, "recovery_mechanisms", recovery_mechanisms)

    @_builtins.property
    @pulumi.getter(name="recoveryMechanisms")
    def recovery_mechanisms(self) -> Optional[Sequence['outputs.UserPoolAccountRecoverySettingRecoveryMechanism']]:
        return pulumi.get(self, "recovery_mechanisms")


@pulumi.output_type
class UserPoolAccountRecoverySettingRecoveryMechanism(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 priority: _builtins.int):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class UserPoolAdminCreateUserConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAdminCreateUserOnly":
            suggest = "allow_admin_create_user_only"
        elif key == "inviteMessageTemplate":
            suggest = "invite_message_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolAdminCreateUserConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolAdminCreateUserConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolAdminCreateUserConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_admin_create_user_only: Optional[_builtins.bool] = None,
                 invite_message_template: Optional['outputs.UserPoolAdminCreateUserConfigInviteMessageTemplate'] = None):
        if allow_admin_create_user_only is not None:
            pulumi.set(__self__, "allow_admin_create_user_only", allow_admin_create_user_only)
        if invite_message_template is not None:
            pulumi.set(__self__, "invite_message_template", invite_message_template)

    @_builtins.property
    @pulumi.getter(name="allowAdminCreateUserOnly")
    def allow_admin_create_user_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_admin_create_user_only")

    @_builtins.property
    @pulumi.getter(name="inviteMessageTemplate")
    def invite_message_template(self) -> Optional['outputs.UserPoolAdminCreateUserConfigInviteMessageTemplate']:
        return pulumi.get(self, "invite_message_template")


@pulumi.output_type
class UserPoolAdminCreateUserConfigInviteMessageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailMessage":
            suggest = "email_message"
        elif key == "emailSubject":
            suggest = "email_subject"
        elif key == "smsMessage":
            suggest = "sms_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolAdminCreateUserConfigInviteMessageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolAdminCreateUserConfigInviteMessageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolAdminCreateUserConfigInviteMessageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_message: Optional[_builtins.str] = None,
                 email_subject: Optional[_builtins.str] = None,
                 sms_message: Optional[_builtins.str] = None):
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if sms_message is not None:
            pulumi.set(__self__, "sms_message", sms_message)

    @_builtins.property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_message")

    @_builtins.property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_subject")

    @_builtins.property
    @pulumi.getter(name="smsMessage")
    def sms_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_message")


@pulumi.output_type
class UserPoolClientAnalyticsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationArn":
            suggest = "application_arn"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "userDataShared":
            suggest = "user_data_shared"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolClientAnalyticsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolClientAnalyticsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolClientAnalyticsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_arn: Optional[_builtins.str] = None,
                 application_id: Optional[_builtins.str] = None,
                 external_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 user_data_shared: Optional[_builtins.bool] = None):
        if application_arn is not None:
            pulumi.set(__self__, "application_arn", application_arn)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if user_data_shared is not None:
            pulumi.set(__self__, "user_data_shared", user_data_shared)

    @_builtins.property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_arn")

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="userDataShared")
    def user_data_shared(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "user_data_shared")


@pulumi.output_type
class UserPoolClientRefreshTokenRotation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryGracePeriodSeconds":
            suggest = "retry_grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolClientRefreshTokenRotation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolClientRefreshTokenRotation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolClientRefreshTokenRotation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature: _builtins.str,
                 retry_grace_period_seconds: Optional[_builtins.int] = None):
        pulumi.set(__self__, "feature", feature)
        if retry_grace_period_seconds is not None:
            pulumi.set(__self__, "retry_grace_period_seconds", retry_grace_period_seconds)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter(name="retryGracePeriodSeconds")
    def retry_grace_period_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retry_grace_period_seconds")


@pulumi.output_type
class UserPoolClientTokenValidityUnits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "idToken":
            suggest = "id_token"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolClientTokenValidityUnits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolClientTokenValidityUnits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolClientTokenValidityUnits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[_builtins.str] = None,
                 id_token: Optional[_builtins.str] = None,
                 refresh_token: Optional[_builtins.str] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if id_token is not None:
            pulumi.set(__self__, "id_token", id_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id_token")

    @_builtins.property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class UserPoolDeviceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "challengeRequiredOnNewDevice":
            suggest = "challenge_required_on_new_device"
        elif key == "deviceOnlyRememberedOnUserPrompt":
            suggest = "device_only_remembered_on_user_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolDeviceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolDeviceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolDeviceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 challenge_required_on_new_device: Optional[_builtins.bool] = None,
                 device_only_remembered_on_user_prompt: Optional[_builtins.bool] = None):
        if challenge_required_on_new_device is not None:
            pulumi.set(__self__, "challenge_required_on_new_device", challenge_required_on_new_device)
        if device_only_remembered_on_user_prompt is not None:
            pulumi.set(__self__, "device_only_remembered_on_user_prompt", device_only_remembered_on_user_prompt)

    @_builtins.property
    @pulumi.getter(name="challengeRequiredOnNewDevice")
    def challenge_required_on_new_device(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "challenge_required_on_new_device")

    @_builtins.property
    @pulumi.getter(name="deviceOnlyRememberedOnUserPrompt")
    def device_only_remembered_on_user_prompt(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "device_only_remembered_on_user_prompt")


@pulumi.output_type
class UserPoolEmailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationSet":
            suggest = "configuration_set"
        elif key == "emailSendingAccount":
            suggest = "email_sending_account"
        elif key == "fromEmailAddress":
            suggest = "from_email_address"
        elif key == "replyToEmailAddress":
            suggest = "reply_to_email_address"
        elif key == "sourceArn":
            suggest = "source_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolEmailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolEmailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolEmailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_set: Optional[_builtins.str] = None,
                 email_sending_account: Optional[_builtins.str] = None,
                 from_email_address: Optional[_builtins.str] = None,
                 reply_to_email_address: Optional[_builtins.str] = None,
                 source_arn: Optional[_builtins.str] = None):
        if configuration_set is not None:
            pulumi.set(__self__, "configuration_set", configuration_set)
        if email_sending_account is not None:
            pulumi.set(__self__, "email_sending_account", email_sending_account)
        if from_email_address is not None:
            pulumi.set(__self__, "from_email_address", from_email_address)
        if reply_to_email_address is not None:
            pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)
        if source_arn is not None:
            pulumi.set(__self__, "source_arn", source_arn)

    @_builtins.property
    @pulumi.getter(name="configurationSet")
    def configuration_set(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "configuration_set")

    @_builtins.property
    @pulumi.getter(name="emailSendingAccount")
    def email_sending_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_sending_account")

    @_builtins.property
    @pulumi.getter(name="fromEmailAddress")
    def from_email_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "from_email_address")

    @_builtins.property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reply_to_email_address")

    @_builtins.property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_arn")


@pulumi.output_type
class UserPoolEmailMfaConfiguration(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject")


@pulumi.output_type
class UserPoolLambdaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createAuthChallenge":
            suggest = "create_auth_challenge"
        elif key == "customEmailSender":
            suggest = "custom_email_sender"
        elif key == "customMessage":
            suggest = "custom_message"
        elif key == "customSmsSender":
            suggest = "custom_sms_sender"
        elif key == "defineAuthChallenge":
            suggest = "define_auth_challenge"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "postAuthentication":
            suggest = "post_authentication"
        elif key == "postConfirmation":
            suggest = "post_confirmation"
        elif key == "preAuthentication":
            suggest = "pre_authentication"
        elif key == "preSignUp":
            suggest = "pre_sign_up"
        elif key == "preTokenGeneration":
            suggest = "pre_token_generation"
        elif key == "preTokenGenerationConfig":
            suggest = "pre_token_generation_config"
        elif key == "userMigration":
            suggest = "user_migration"
        elif key == "verifyAuthChallengeResponse":
            suggest = "verify_auth_challenge_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolLambdaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolLambdaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolLambdaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_auth_challenge: Optional[_builtins.str] = None,
                 custom_email_sender: Optional['outputs.UserPoolLambdaConfigCustomEmailSender'] = None,
                 custom_message: Optional[_builtins.str] = None,
                 custom_sms_sender: Optional['outputs.UserPoolLambdaConfigCustomSmsSender'] = None,
                 define_auth_challenge: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 post_authentication: Optional[_builtins.str] = None,
                 post_confirmation: Optional[_builtins.str] = None,
                 pre_authentication: Optional[_builtins.str] = None,
                 pre_sign_up: Optional[_builtins.str] = None,
                 pre_token_generation: Optional[_builtins.str] = None,
                 pre_token_generation_config: Optional['outputs.UserPoolLambdaConfigPreTokenGenerationConfig'] = None,
                 user_migration: Optional[_builtins.str] = None,
                 verify_auth_challenge_response: Optional[_builtins.str] = None):
        if create_auth_challenge is not None:
            pulumi.set(__self__, "create_auth_challenge", create_auth_challenge)
        if custom_email_sender is not None:
            pulumi.set(__self__, "custom_email_sender", custom_email_sender)
        if custom_message is not None:
            pulumi.set(__self__, "custom_message", custom_message)
        if custom_sms_sender is not None:
            pulumi.set(__self__, "custom_sms_sender", custom_sms_sender)
        if define_auth_challenge is not None:
            pulumi.set(__self__, "define_auth_challenge", define_auth_challenge)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if post_authentication is not None:
            pulumi.set(__self__, "post_authentication", post_authentication)
        if post_confirmation is not None:
            pulumi.set(__self__, "post_confirmation", post_confirmation)
        if pre_authentication is not None:
            pulumi.set(__self__, "pre_authentication", pre_authentication)
        if pre_sign_up is not None:
            pulumi.set(__self__, "pre_sign_up", pre_sign_up)
        if pre_token_generation is not None:
            pulumi.set(__self__, "pre_token_generation", pre_token_generation)
        if pre_token_generation_config is not None:
            pulumi.set(__self__, "pre_token_generation_config", pre_token_generation_config)
        if user_migration is not None:
            pulumi.set(__self__, "user_migration", user_migration)
        if verify_auth_challenge_response is not None:
            pulumi.set(__self__, "verify_auth_challenge_response", verify_auth_challenge_response)

    @_builtins.property
    @pulumi.getter(name="createAuthChallenge")
    def create_auth_challenge(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "create_auth_challenge")

    @_builtins.property
    @pulumi.getter(name="customEmailSender")
    def custom_email_sender(self) -> Optional['outputs.UserPoolLambdaConfigCustomEmailSender']:
        return pulumi.get(self, "custom_email_sender")

    @_builtins.property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_message")

    @_builtins.property
    @pulumi.getter(name="customSmsSender")
    def custom_sms_sender(self) -> Optional['outputs.UserPoolLambdaConfigCustomSmsSender']:
        return pulumi.get(self, "custom_sms_sender")

    @_builtins.property
    @pulumi.getter(name="defineAuthChallenge")
    def define_auth_challenge(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "define_auth_challenge")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="postAuthentication")
    def post_authentication(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "post_authentication")

    @_builtins.property
    @pulumi.getter(name="postConfirmation")
    def post_confirmation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "post_confirmation")

    @_builtins.property
    @pulumi.getter(name="preAuthentication")
    def pre_authentication(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pre_authentication")

    @_builtins.property
    @pulumi.getter(name="preSignUp")
    def pre_sign_up(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pre_sign_up")

    @_builtins.property
    @pulumi.getter(name="preTokenGeneration")
    def pre_token_generation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pre_token_generation")

    @_builtins.property
    @pulumi.getter(name="preTokenGenerationConfig")
    def pre_token_generation_config(self) -> Optional['outputs.UserPoolLambdaConfigPreTokenGenerationConfig']:
        return pulumi.get(self, "pre_token_generation_config")

    @_builtins.property
    @pulumi.getter(name="userMigration")
    def user_migration(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_migration")

    @_builtins.property
    @pulumi.getter(name="verifyAuthChallengeResponse")
    def verify_auth_challenge_response(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "verify_auth_challenge_response")


@pulumi.output_type
class UserPoolLambdaConfigCustomEmailSender(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "lambdaVersion":
            suggest = "lambda_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolLambdaConfigCustomEmailSender. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolLambdaConfigCustomEmailSender.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolLambdaConfigCustomEmailSender.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class UserPoolLambdaConfigCustomSmsSender(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "lambdaVersion":
            suggest = "lambda_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolLambdaConfigCustomSmsSender. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolLambdaConfigCustomSmsSender.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolLambdaConfigCustomSmsSender.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class UserPoolLambdaConfigPreTokenGenerationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "lambdaVersion":
            suggest = "lambda_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolLambdaConfigPreTokenGenerationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolLambdaConfigPreTokenGenerationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolLambdaConfigPreTokenGenerationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class UserPoolPasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumLength":
            suggest = "minimum_length"
        elif key == "passwordHistorySize":
            suggest = "password_history_size"
        elif key == "requireLowercase":
            suggest = "require_lowercase"
        elif key == "requireNumbers":
            suggest = "require_numbers"
        elif key == "requireSymbols":
            suggest = "require_symbols"
        elif key == "requireUppercase":
            suggest = "require_uppercase"
        elif key == "temporaryPasswordValidityDays":
            suggest = "temporary_password_validity_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolPasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolPasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolPasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum_length: Optional[_builtins.int] = None,
                 password_history_size: Optional[_builtins.int] = None,
                 require_lowercase: Optional[_builtins.bool] = None,
                 require_numbers: Optional[_builtins.bool] = None,
                 require_symbols: Optional[_builtins.bool] = None,
                 require_uppercase: Optional[_builtins.bool] = None,
                 temporary_password_validity_days: Optional[_builtins.int] = None):
        if minimum_length is not None:
            pulumi.set(__self__, "minimum_length", minimum_length)
        if password_history_size is not None:
            pulumi.set(__self__, "password_history_size", password_history_size)
        if require_lowercase is not None:
            pulumi.set(__self__, "require_lowercase", require_lowercase)
        if require_numbers is not None:
            pulumi.set(__self__, "require_numbers", require_numbers)
        if require_symbols is not None:
            pulumi.set(__self__, "require_symbols", require_symbols)
        if require_uppercase is not None:
            pulumi.set(__self__, "require_uppercase", require_uppercase)
        if temporary_password_validity_days is not None:
            pulumi.set(__self__, "temporary_password_validity_days", temporary_password_validity_days)

    @_builtins.property
    @pulumi.getter(name="minimumLength")
    def minimum_length(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minimum_length")

    @_builtins.property
    @pulumi.getter(name="passwordHistorySize")
    def password_history_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "password_history_size")

    @_builtins.property
    @pulumi.getter(name="requireLowercase")
    def require_lowercase(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_lowercase")

    @_builtins.property
    @pulumi.getter(name="requireNumbers")
    def require_numbers(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_numbers")

    @_builtins.property
    @pulumi.getter(name="requireSymbols")
    def require_symbols(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_symbols")

    @_builtins.property
    @pulumi.getter(name="requireUppercase")
    def require_uppercase(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_uppercase")

    @_builtins.property
    @pulumi.getter(name="temporaryPasswordValidityDays")
    def temporary_password_validity_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "temporary_password_validity_days")


@pulumi.output_type
class UserPoolSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeDataType":
            suggest = "attribute_data_type"
        elif key == "developerOnlyAttribute":
            suggest = "developer_only_attribute"
        elif key == "numberAttributeConstraints":
            suggest = "number_attribute_constraints"
        elif key == "stringAttributeConstraints":
            suggest = "string_attribute_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_data_type: _builtins.str,
                 name: _builtins.str,
                 developer_only_attribute: Optional[_builtins.bool] = None,
                 mutable: Optional[_builtins.bool] = None,
                 number_attribute_constraints: Optional['outputs.UserPoolSchemaNumberAttributeConstraints'] = None,
                 required: Optional[_builtins.bool] = None,
                 string_attribute_constraints: Optional['outputs.UserPoolSchemaStringAttributeConstraints'] = None):
        pulumi.set(__self__, "attribute_data_type", attribute_data_type)
        pulumi.set(__self__, "name", name)
        if developer_only_attribute is not None:
            pulumi.set(__self__, "developer_only_attribute", developer_only_attribute)
        if mutable is not None:
            pulumi.set(__self__, "mutable", mutable)
        if number_attribute_constraints is not None:
            pulumi.set(__self__, "number_attribute_constraints", number_attribute_constraints)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if string_attribute_constraints is not None:
            pulumi.set(__self__, "string_attribute_constraints", string_attribute_constraints)

    @_builtins.property
    @pulumi.getter(name="attributeDataType")
    def attribute_data_type(self) -> _builtins.str:
        return pulumi.get(self, "attribute_data_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="developerOnlyAttribute")
    def developer_only_attribute(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "developer_only_attribute")

    @_builtins.property
    @pulumi.getter
    def mutable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "mutable")

    @_builtins.property
    @pulumi.getter(name="numberAttributeConstraints")
    def number_attribute_constraints(self) -> Optional['outputs.UserPoolSchemaNumberAttributeConstraints']:
        return pulumi.get(self, "number_attribute_constraints")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="stringAttributeConstraints")
    def string_attribute_constraints(self) -> Optional['outputs.UserPoolSchemaStringAttributeConstraints']:
        return pulumi.get(self, "string_attribute_constraints")


@pulumi.output_type
class UserPoolSchemaNumberAttributeConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxValue":
            suggest = "max_value"
        elif key == "minValue":
            suggest = "min_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolSchemaNumberAttributeConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolSchemaNumberAttributeConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolSchemaNumberAttributeConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_value: Optional[_builtins.str] = None,
                 min_value: Optional[_builtins.str] = None):
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "min_value")


@pulumi.output_type
class UserPoolSchemaStringAttributeConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolSchemaStringAttributeConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolSchemaStringAttributeConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolSchemaStringAttributeConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_length: Optional[_builtins.str] = None,
                 min_length: Optional[_builtins.str] = None):
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "min_length")


@pulumi.output_type
class UserPoolSignInPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedFirstAuthFactors":
            suggest = "allowed_first_auth_factors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolSignInPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolSignInPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolSignInPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_first_auth_factors: Optional[Sequence[_builtins.str]] = None):
        if allowed_first_auth_factors is not None:
            pulumi.set(__self__, "allowed_first_auth_factors", allowed_first_auth_factors)

    @_builtins.property
    @pulumi.getter(name="allowedFirstAuthFactors")
    def allowed_first_auth_factors(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_first_auth_factors")


@pulumi.output_type
class UserPoolSmsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalId":
            suggest = "external_id"
        elif key == "snsCallerArn":
            suggest = "sns_caller_arn"
        elif key == "snsRegion":
            suggest = "sns_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolSmsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolSmsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolSmsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_id: _builtins.str,
                 sns_caller_arn: _builtins.str,
                 sns_region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "sns_caller_arn", sns_caller_arn)
        if sns_region is not None:
            pulumi.set(__self__, "sns_region", sns_region)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="snsCallerArn")
    def sns_caller_arn(self) -> _builtins.str:
        return pulumi.get(self, "sns_caller_arn")

    @_builtins.property
    @pulumi.getter(name="snsRegion")
    def sns_region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sns_region")


@pulumi.output_type
class UserPoolSoftwareTokenMfaConfiguration(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class UserPoolUserAttributeUpdateSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributesRequireVerificationBeforeUpdates":
            suggest = "attributes_require_verification_before_updates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolUserAttributeUpdateSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolUserAttributeUpdateSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolUserAttributeUpdateSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes_require_verification_before_updates: Sequence[_builtins.str]):
        pulumi.set(__self__, "attributes_require_verification_before_updates", attributes_require_verification_before_updates)

    @_builtins.property
    @pulumi.getter(name="attributesRequireVerificationBeforeUpdates")
    def attributes_require_verification_before_updates(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "attributes_require_verification_before_updates")


@pulumi.output_type
class UserPoolUserPoolAddOns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSecurityMode":
            suggest = "advanced_security_mode"
        elif key == "advancedSecurityAdditionalFlows":
            suggest = "advanced_security_additional_flows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolUserPoolAddOns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolUserPoolAddOns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolUserPoolAddOns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_security_mode: _builtins.str,
                 advanced_security_additional_flows: Optional['outputs.UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows'] = None):
        pulumi.set(__self__, "advanced_security_mode", advanced_security_mode)
        if advanced_security_additional_flows is not None:
            pulumi.set(__self__, "advanced_security_additional_flows", advanced_security_additional_flows)

    @_builtins.property
    @pulumi.getter(name="advancedSecurityMode")
    def advanced_security_mode(self) -> _builtins.str:
        return pulumi.get(self, "advanced_security_mode")

    @_builtins.property
    @pulumi.getter(name="advancedSecurityAdditionalFlows")
    def advanced_security_additional_flows(self) -> Optional['outputs.UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows']:
        return pulumi.get(self, "advanced_security_additional_flows")


@pulumi.output_type
class UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAuthMode":
            suggest = "custom_auth_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolUserPoolAddOnsAdvancedSecurityAdditionalFlows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_auth_mode: Optional[_builtins.str] = None):
        if custom_auth_mode is not None:
            pulumi.set(__self__, "custom_auth_mode", custom_auth_mode)

    @_builtins.property
    @pulumi.getter(name="customAuthMode")
    def custom_auth_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_auth_mode")


@pulumi.output_type
class UserPoolUsernameConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolUsernameConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolUsernameConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolUsernameConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class UserPoolVerificationMessageTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultEmailOption":
            suggest = "default_email_option"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "emailMessageByLink":
            suggest = "email_message_by_link"
        elif key == "emailSubject":
            suggest = "email_subject"
        elif key == "emailSubjectByLink":
            suggest = "email_subject_by_link"
        elif key == "smsMessage":
            suggest = "sms_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolVerificationMessageTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolVerificationMessageTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolVerificationMessageTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_email_option: Optional[_builtins.str] = None,
                 email_message: Optional[_builtins.str] = None,
                 email_message_by_link: Optional[_builtins.str] = None,
                 email_subject: Optional[_builtins.str] = None,
                 email_subject_by_link: Optional[_builtins.str] = None,
                 sms_message: Optional[_builtins.str] = None):
        if default_email_option is not None:
            pulumi.set(__self__, "default_email_option", default_email_option)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_message_by_link is not None:
            pulumi.set(__self__, "email_message_by_link", email_message_by_link)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if email_subject_by_link is not None:
            pulumi.set(__self__, "email_subject_by_link", email_subject_by_link)
        if sms_message is not None:
            pulumi.set(__self__, "sms_message", sms_message)

    @_builtins.property
    @pulumi.getter(name="defaultEmailOption")
    def default_email_option(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_email_option")

    @_builtins.property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_message")

    @_builtins.property
    @pulumi.getter(name="emailMessageByLink")
    def email_message_by_link(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_message_by_link")

    @_builtins.property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_subject")

    @_builtins.property
    @pulumi.getter(name="emailSubjectByLink")
    def email_subject_by_link(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_subject_by_link")

    @_builtins.property
    @pulumi.getter(name="smsMessage")
    def sms_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_message")


@pulumi.output_type
class UserPoolWebAuthnConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relyingPartyId":
            suggest = "relying_party_id"
        elif key == "userVerification":
            suggest = "user_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolWebAuthnConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolWebAuthnConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolWebAuthnConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relying_party_id: Optional[_builtins.str] = None,
                 user_verification: Optional[_builtins.str] = None):
        if relying_party_id is not None:
            pulumi.set(__self__, "relying_party_id", relying_party_id)
        if user_verification is not None:
            pulumi.set(__self__, "user_verification", user_verification)

    @_builtins.property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "relying_party_id")

    @_builtins.property
    @pulumi.getter(name="userVerification")
    def user_verification(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_verification")


@pulumi.output_type
class GetIdentityPoolCognitoIdentityProviderResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 provider_name: _builtins.str,
                 server_side_token_check: _builtins.bool):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "server_side_token_check", server_side_token_check)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="serverSideTokenCheck")
    def server_side_token_check(self) -> _builtins.bool:
        return pulumi.get(self, "server_side_token_check")


@pulumi.output_type
class GetUserGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 group_name: _builtins.str,
                 precedence: _builtins.int,
                 role_arn: _builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "precedence", precedence)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> _builtins.int:
        return pulumi.get(self, "precedence")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetUserPoolAccountRecoverySettingResult(dict):
    def __init__(__self__, *,
                 recovery_mechanisms: Sequence['outputs.GetUserPoolAccountRecoverySettingRecoveryMechanismResult']):
        pulumi.set(__self__, "recovery_mechanisms", recovery_mechanisms)

    @_builtins.property
    @pulumi.getter(name="recoveryMechanisms")
    def recovery_mechanisms(self) -> Sequence['outputs.GetUserPoolAccountRecoverySettingRecoveryMechanismResult']:
        return pulumi.get(self, "recovery_mechanisms")


@pulumi.output_type
class GetUserPoolAccountRecoverySettingRecoveryMechanismResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 priority: _builtins.int):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetUserPoolAdminCreateUserConfigResult(dict):
    def __init__(__self__, *,
                 allow_admin_create_user_only: _builtins.bool,
                 invite_message_templates: Sequence['outputs.GetUserPoolAdminCreateUserConfigInviteMessageTemplateResult'],
                 unused_account_validity_days: _builtins.int):
        pulumi.set(__self__, "allow_admin_create_user_only", allow_admin_create_user_only)
        pulumi.set(__self__, "invite_message_templates", invite_message_templates)
        pulumi.set(__self__, "unused_account_validity_days", unused_account_validity_days)

    @_builtins.property
    @pulumi.getter(name="allowAdminCreateUserOnly")
    def allow_admin_create_user_only(self) -> _builtins.bool:
        return pulumi.get(self, "allow_admin_create_user_only")

    @_builtins.property
    @pulumi.getter(name="inviteMessageTemplates")
    def invite_message_templates(self) -> Sequence['outputs.GetUserPoolAdminCreateUserConfigInviteMessageTemplateResult']:
        return pulumi.get(self, "invite_message_templates")

    @_builtins.property
    @pulumi.getter(name="unusedAccountValidityDays")
    def unused_account_validity_days(self) -> _builtins.int:
        return pulumi.get(self, "unused_account_validity_days")


@pulumi.output_type
class GetUserPoolAdminCreateUserConfigInviteMessageTemplateResult(dict):
    def __init__(__self__, *,
                 email_message: _builtins.str,
                 email_subject: _builtins.str,
                 sms_message: _builtins.str):
        pulumi.set(__self__, "email_message", email_message)
        pulumi.set(__self__, "email_subject", email_subject)
        pulumi.set(__self__, "sms_message", sms_message)

    @_builtins.property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> _builtins.str:
        return pulumi.get(self, "email_message")

    @_builtins.property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> _builtins.str:
        return pulumi.get(self, "email_subject")

    @_builtins.property
    @pulumi.getter(name="smsMessage")
    def sms_message(self) -> _builtins.str:
        return pulumi.get(self, "sms_message")


@pulumi.output_type
class GetUserPoolClientAnalyticsConfigurationResult(dict):
    def __init__(__self__, *,
                 application_arn: _builtins.str,
                 application_id: _builtins.str,
                 external_id: _builtins.str,
                 role_arn: _builtins.str,
                 user_data_shared: _builtins.bool):
        pulumi.set(__self__, "application_arn", application_arn)
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "user_data_shared", user_data_shared)

    @_builtins.property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> _builtins.str:
        return pulumi.get(self, "application_arn")

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="userDataShared")
    def user_data_shared(self) -> _builtins.bool:
        return pulumi.get(self, "user_data_shared")


@pulumi.output_type
class GetUserPoolClientRefreshTokenRotationResult(dict):
    def __init__(__self__, *,
                 feature: _builtins.str,
                 retry_grace_period_seconds: _builtins.int):
        pulumi.set(__self__, "feature", feature)
        pulumi.set(__self__, "retry_grace_period_seconds", retry_grace_period_seconds)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter(name="retryGracePeriodSeconds")
    def retry_grace_period_seconds(self) -> _builtins.int:
        return pulumi.get(self, "retry_grace_period_seconds")


@pulumi.output_type
class GetUserPoolClientTokenValidityUnitResult(dict):
    def __init__(__self__, *,
                 access_token: _builtins.str,
                 id_token: _builtins.str,
                 refresh_token: _builtins.str):
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "id_token", id_token)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> _builtins.str:
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter(name="idToken")
    def id_token(self) -> _builtins.str:
        return pulumi.get(self, "id_token")

    @_builtins.property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> _builtins.str:
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class GetUserPoolDeviceConfigurationResult(dict):
    def __init__(__self__, *,
                 challenge_required_on_new_device: _builtins.bool,
                 device_only_remembered_on_user_prompt: _builtins.bool):
        pulumi.set(__self__, "challenge_required_on_new_device", challenge_required_on_new_device)
        pulumi.set(__self__, "device_only_remembered_on_user_prompt", device_only_remembered_on_user_prompt)

    @_builtins.property
    @pulumi.getter(name="challengeRequiredOnNewDevice")
    def challenge_required_on_new_device(self) -> _builtins.bool:
        return pulumi.get(self, "challenge_required_on_new_device")

    @_builtins.property
    @pulumi.getter(name="deviceOnlyRememberedOnUserPrompt")
    def device_only_remembered_on_user_prompt(self) -> _builtins.bool:
        return pulumi.get(self, "device_only_remembered_on_user_prompt")


@pulumi.output_type
class GetUserPoolEmailConfigurationResult(dict):
    def __init__(__self__, *,
                 configuration_set: _builtins.str,
                 email_sending_account: _builtins.str,
                 from_: _builtins.str,
                 reply_to_email_address: _builtins.str,
                 source_arn: _builtins.str):
        pulumi.set(__self__, "configuration_set", configuration_set)
        pulumi.set(__self__, "email_sending_account", email_sending_account)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)
        pulumi.set(__self__, "source_arn", source_arn)

    @_builtins.property
    @pulumi.getter(name="configurationSet")
    def configuration_set(self) -> _builtins.str:
        return pulumi.get(self, "configuration_set")

    @_builtins.property
    @pulumi.getter(name="emailSendingAccount")
    def email_sending_account(self) -> _builtins.str:
        return pulumi.get(self, "email_sending_account")

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> _builtins.str:
        return pulumi.get(self, "reply_to_email_address")

    @_builtins.property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> _builtins.str:
        return pulumi.get(self, "source_arn")


@pulumi.output_type
class GetUserPoolLambdaConfigResult(dict):
    def __init__(__self__, *,
                 create_auth_challenge: _builtins.str,
                 custom_email_senders: Sequence['outputs.GetUserPoolLambdaConfigCustomEmailSenderResult'],
                 custom_message: _builtins.str,
                 custom_sms_senders: Sequence['outputs.GetUserPoolLambdaConfigCustomSmsSenderResult'],
                 define_auth_challenge: _builtins.str,
                 kms_key_id: _builtins.str,
                 post_authentication: _builtins.str,
                 post_confirmation: _builtins.str,
                 pre_authentication: _builtins.str,
                 pre_sign_up: _builtins.str,
                 pre_token_generation: _builtins.str,
                 pre_token_generation_configs: Sequence['outputs.GetUserPoolLambdaConfigPreTokenGenerationConfigResult'],
                 user_migration: _builtins.str,
                 verify_auth_challenge_response: _builtins.str):
        pulumi.set(__self__, "create_auth_challenge", create_auth_challenge)
        pulumi.set(__self__, "custom_email_senders", custom_email_senders)
        pulumi.set(__self__, "custom_message", custom_message)
        pulumi.set(__self__, "custom_sms_senders", custom_sms_senders)
        pulumi.set(__self__, "define_auth_challenge", define_auth_challenge)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "post_authentication", post_authentication)
        pulumi.set(__self__, "post_confirmation", post_confirmation)
        pulumi.set(__self__, "pre_authentication", pre_authentication)
        pulumi.set(__self__, "pre_sign_up", pre_sign_up)
        pulumi.set(__self__, "pre_token_generation", pre_token_generation)
        pulumi.set(__self__, "pre_token_generation_configs", pre_token_generation_configs)
        pulumi.set(__self__, "user_migration", user_migration)
        pulumi.set(__self__, "verify_auth_challenge_response", verify_auth_challenge_response)

    @_builtins.property
    @pulumi.getter(name="createAuthChallenge")
    def create_auth_challenge(self) -> _builtins.str:
        return pulumi.get(self, "create_auth_challenge")

    @_builtins.property
    @pulumi.getter(name="customEmailSenders")
    def custom_email_senders(self) -> Sequence['outputs.GetUserPoolLambdaConfigCustomEmailSenderResult']:
        return pulumi.get(self, "custom_email_senders")

    @_builtins.property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> _builtins.str:
        return pulumi.get(self, "custom_message")

    @_builtins.property
    @pulumi.getter(name="customSmsSenders")
    def custom_sms_senders(self) -> Sequence['outputs.GetUserPoolLambdaConfigCustomSmsSenderResult']:
        return pulumi.get(self, "custom_sms_senders")

    @_builtins.property
    @pulumi.getter(name="defineAuthChallenge")
    def define_auth_challenge(self) -> _builtins.str:
        return pulumi.get(self, "define_auth_challenge")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="postAuthentication")
    def post_authentication(self) -> _builtins.str:
        return pulumi.get(self, "post_authentication")

    @_builtins.property
    @pulumi.getter(name="postConfirmation")
    def post_confirmation(self) -> _builtins.str:
        return pulumi.get(self, "post_confirmation")

    @_builtins.property
    @pulumi.getter(name="preAuthentication")
    def pre_authentication(self) -> _builtins.str:
        return pulumi.get(self, "pre_authentication")

    @_builtins.property
    @pulumi.getter(name="preSignUp")
    def pre_sign_up(self) -> _builtins.str:
        return pulumi.get(self, "pre_sign_up")

    @_builtins.property
    @pulumi.getter(name="preTokenGeneration")
    def pre_token_generation(self) -> _builtins.str:
        return pulumi.get(self, "pre_token_generation")

    @_builtins.property
    @pulumi.getter(name="preTokenGenerationConfigs")
    def pre_token_generation_configs(self) -> Sequence['outputs.GetUserPoolLambdaConfigPreTokenGenerationConfigResult']:
        return pulumi.get(self, "pre_token_generation_configs")

    @_builtins.property
    @pulumi.getter(name="userMigration")
    def user_migration(self) -> _builtins.str:
        return pulumi.get(self, "user_migration")

    @_builtins.property
    @pulumi.getter(name="verifyAuthChallengeResponse")
    def verify_auth_challenge_response(self) -> _builtins.str:
        return pulumi.get(self, "verify_auth_challenge_response")


@pulumi.output_type
class GetUserPoolLambdaConfigCustomEmailSenderResult(dict):
    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class GetUserPoolLambdaConfigCustomSmsSenderResult(dict):
    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class GetUserPoolLambdaConfigPreTokenGenerationConfigResult(dict):
    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 lambda_version: _builtins.str):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> _builtins.str:
        return pulumi.get(self, "lambda_version")


@pulumi.output_type
class GetUserPoolSchemaAttributeResult(dict):
    def __init__(__self__, *,
                 attribute_data_type: _builtins.str,
                 developer_only_attribute: _builtins.bool,
                 mutable: _builtins.bool,
                 name: _builtins.str,
                 number_attribute_constraints: Sequence['outputs.GetUserPoolSchemaAttributeNumberAttributeConstraintResult'],
                 required: _builtins.bool,
                 string_attribute_constraints: Sequence['outputs.GetUserPoolSchemaAttributeStringAttributeConstraintResult']):
        pulumi.set(__self__, "attribute_data_type", attribute_data_type)
        pulumi.set(__self__, "developer_only_attribute", developer_only_attribute)
        pulumi.set(__self__, "mutable", mutable)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number_attribute_constraints", number_attribute_constraints)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "string_attribute_constraints", string_attribute_constraints)

    @_builtins.property
    @pulumi.getter(name="attributeDataType")
    def attribute_data_type(self) -> _builtins.str:
        return pulumi.get(self, "attribute_data_type")

    @_builtins.property
    @pulumi.getter(name="developerOnlyAttribute")
    def developer_only_attribute(self) -> _builtins.bool:
        return pulumi.get(self, "developer_only_attribute")

    @_builtins.property
    @pulumi.getter
    def mutable(self) -> _builtins.bool:
        return pulumi.get(self, "mutable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="numberAttributeConstraints")
    def number_attribute_constraints(self) -> Sequence['outputs.GetUserPoolSchemaAttributeNumberAttributeConstraintResult']:
        return pulumi.get(self, "number_attribute_constraints")

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="stringAttributeConstraints")
    def string_attribute_constraints(self) -> Sequence['outputs.GetUserPoolSchemaAttributeStringAttributeConstraintResult']:
        return pulumi.get(self, "string_attribute_constraints")


@pulumi.output_type
class GetUserPoolSchemaAttributeNumberAttributeConstraintResult(dict):
    def __init__(__self__, *,
                 max_value: _builtins.str,
                 min_value: _builtins.str):
        pulumi.set(__self__, "max_value", max_value)
        pulumi.set(__self__, "min_value", min_value)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> _builtins.str:
        return pulumi.get(self, "max_value")

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> _builtins.str:
        return pulumi.get(self, "min_value")


@pulumi.output_type
class GetUserPoolSchemaAttributeStringAttributeConstraintResult(dict):
    def __init__(__self__, *,
                 max_length: _builtins.str,
                 min_length: _builtins.str):
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> _builtins.str:
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> _builtins.str:
        return pulumi.get(self, "min_length")


@pulumi.output_type
class GetUserPoolUserPoolAddOnResult(dict):
    def __init__(__self__, *,
                 advanced_security_additional_flows: Sequence['outputs.GetUserPoolUserPoolAddOnAdvancedSecurityAdditionalFlowResult'],
                 advanced_security_mode: _builtins.str):
        pulumi.set(__self__, "advanced_security_additional_flows", advanced_security_additional_flows)
        pulumi.set(__self__, "advanced_security_mode", advanced_security_mode)

    @_builtins.property
    @pulumi.getter(name="advancedSecurityAdditionalFlows")
    def advanced_security_additional_flows(self) -> Sequence['outputs.GetUserPoolUserPoolAddOnAdvancedSecurityAdditionalFlowResult']:
        return pulumi.get(self, "advanced_security_additional_flows")

    @_builtins.property
    @pulumi.getter(name="advancedSecurityMode")
    def advanced_security_mode(self) -> _builtins.str:
        return pulumi.get(self, "advanced_security_mode")


@pulumi.output_type
class GetUserPoolUserPoolAddOnAdvancedSecurityAdditionalFlowResult(dict):
    def __init__(__self__, *,
                 custom_auth_mode: _builtins.str):
        pulumi.set(__self__, "custom_auth_mode", custom_auth_mode)

    @_builtins.property
    @pulumi.getter(name="customAuthMode")
    def custom_auth_mode(self) -> _builtins.str:
        return pulumi.get(self, "custom_auth_mode")


