# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'IdentityPoolCognitoIdentityProviderArgs',
    'IdentityPoolCognitoIdentityProviderArgsDict',
    'IdentityPoolRoleAttachmentRoleMappingArgs',
    'IdentityPoolRoleAttachmentRoleMappingArgsDict',
    'IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs',
    'IdentityPoolRoleAttachmentRoleMappingMappingRuleArgsDict',
    'ManagedUserPoolClientAnalyticsConfigurationArgs',
    'ManagedUserPoolClientAnalyticsConfigurationArgsDict',
    'ManagedUserPoolClientTokenValidityUnitsArgs',
    'ManagedUserPoolClientTokenValidityUnitsArgsDict',
    'ResourceServerScopeArgs',
    'ResourceServerScopeArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgsDict',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs',
    'RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgsDict',
    'RiskConfigurationCompromisedCredentialsRiskConfigurationArgs',
    'RiskConfigurationCompromisedCredentialsRiskConfigurationArgsDict',
    'RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs',
    'RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgsDict',
    'RiskConfigurationRiskExceptionConfigurationArgs',
    'RiskConfigurationRiskExceptionConfigurationArgsDict',
    'UserPoolAccountRecoverySettingArgs',
    'UserPoolAccountRecoverySettingArgsDict',
    'UserPoolAccountRecoverySettingRecoveryMechanismArgs',
    'UserPoolAccountRecoverySettingRecoveryMechanismArgsDict',
    'UserPoolAdminCreateUserConfigArgs',
    'UserPoolAdminCreateUserConfigArgsDict',
    'UserPoolAdminCreateUserConfigInviteMessageTemplateArgs',
    'UserPoolAdminCreateUserConfigInviteMessageTemplateArgsDict',
    'UserPoolClientAnalyticsConfigurationArgs',
    'UserPoolClientAnalyticsConfigurationArgsDict',
    'UserPoolClientTokenValidityUnitsArgs',
    'UserPoolClientTokenValidityUnitsArgsDict',
    'UserPoolDeviceConfigurationArgs',
    'UserPoolDeviceConfigurationArgsDict',
    'UserPoolEmailConfigurationArgs',
    'UserPoolEmailConfigurationArgsDict',
    'UserPoolEmailMfaConfigurationArgs',
    'UserPoolEmailMfaConfigurationArgsDict',
    'UserPoolLambdaConfigArgs',
    'UserPoolLambdaConfigArgsDict',
    'UserPoolLambdaConfigCustomEmailSenderArgs',
    'UserPoolLambdaConfigCustomEmailSenderArgsDict',
    'UserPoolLambdaConfigCustomSmsSenderArgs',
    'UserPoolLambdaConfigCustomSmsSenderArgsDict',
    'UserPoolLambdaConfigPreTokenGenerationConfigArgs',
    'UserPoolLambdaConfigPreTokenGenerationConfigArgsDict',
    'UserPoolPasswordPolicyArgs',
    'UserPoolPasswordPolicyArgsDict',
    'UserPoolSchemaArgs',
    'UserPoolSchemaArgsDict',
    'UserPoolSchemaNumberAttributeConstraintsArgs',
    'UserPoolSchemaNumberAttributeConstraintsArgsDict',
    'UserPoolSchemaStringAttributeConstraintsArgs',
    'UserPoolSchemaStringAttributeConstraintsArgsDict',
    'UserPoolSignInPolicyArgs',
    'UserPoolSignInPolicyArgsDict',
    'UserPoolSmsConfigurationArgs',
    'UserPoolSmsConfigurationArgsDict',
    'UserPoolSoftwareTokenMfaConfigurationArgs',
    'UserPoolSoftwareTokenMfaConfigurationArgsDict',
    'UserPoolUserAttributeUpdateSettingsArgs',
    'UserPoolUserAttributeUpdateSettingsArgsDict',
    'UserPoolUserPoolAddOnsArgs',
    'UserPoolUserPoolAddOnsArgsDict',
    'UserPoolUsernameConfigurationArgs',
    'UserPoolUsernameConfigurationArgsDict',
    'UserPoolVerificationMessageTemplateArgs',
    'UserPoolVerificationMessageTemplateArgsDict',
    'UserPoolWebAuthnConfigurationArgs',
    'UserPoolWebAuthnConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class IdentityPoolCognitoIdentityProviderArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client ID for the Amazon Cognito Identity User Pool.
        """
        provider_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The provider name for an Amazon Cognito Identity User Pool.
        """
        server_side_token_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether server-side token validation is enabled for the identity provider’s token or not.
        """
elif False:
    IdentityPoolCognitoIdentityProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPoolCognitoIdentityProviderArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 provider_name: Optional[pulumi.Input[builtins.str]] = None,
                 server_side_token_check: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: The client ID for the Amazon Cognito Identity User Pool.
        :param pulumi.Input[builtins.str] provider_name: The provider name for an Amazon Cognito Identity User Pool.
        :param pulumi.Input[builtins.bool] server_side_token_check: Whether server-side token validation is enabled for the identity provider’s token or not.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if server_side_token_check is not None:
            pulumi.set(__self__, "server_side_token_check", server_side_token_check)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client ID for the Amazon Cognito Identity User Pool.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The provider name for an Amazon Cognito Identity User Pool.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter(name="serverSideTokenCheck")
    def server_side_token_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether server-side token validation is enabled for the identity provider’s token or not.
        """
        return pulumi.get(self, "server_side_token_check")

    @server_side_token_check.setter
    def server_side_token_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "server_side_token_check", value)


if not MYPY:
    class IdentityPoolRoleAttachmentRoleMappingArgsDict(TypedDict):
        identity_provider: pulumi.Input[builtins.str]
        """
        A string identifying the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Depends on `cognito_identity_providers` set on `cognito.IdentityPool` resource or a `cognito.IdentityProvider` resource.
        """
        type: pulumi.Input[builtins.str]
        """
        The role mapping type.
        """
        ambiguous_role_resolution: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type. `Required` if you specify Token or Rules as the Type.
        """
        mapping_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityPoolRoleAttachmentRoleMappingMappingRuleArgsDict']]]]
        """
        The Rules Configuration to be used for mapping users to roles. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
        """
elif False:
    IdentityPoolRoleAttachmentRoleMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPoolRoleAttachmentRoleMappingArgs:
    def __init__(__self__, *,
                 identity_provider: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 ambiguous_role_resolution: Optional[pulumi.Input[builtins.str]] = None,
                 mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] identity_provider: A string identifying the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Depends on `cognito_identity_providers` set on `cognito.IdentityPool` resource or a `cognito.IdentityProvider` resource.
        :param pulumi.Input[builtins.str] type: The role mapping type.
        :param pulumi.Input[builtins.str] ambiguous_role_resolution: Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type. `Required` if you specify Token or Rules as the Type.
        :param pulumi.Input[Sequence[pulumi.Input['IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs']]] mapping_rules: The Rules Configuration to be used for mapping users to roles. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
        """
        pulumi.set(__self__, "identity_provider", identity_provider)
        pulumi.set(__self__, "type", type)
        if ambiguous_role_resolution is not None:
            pulumi.set(__self__, "ambiguous_role_resolution", ambiguous_role_resolution)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> pulumi.Input[builtins.str]:
        """
        A string identifying the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Depends on `cognito_identity_providers` set on `cognito.IdentityPool` resource or a `cognito.IdentityProvider` resource.
        """
        return pulumi.get(self, "identity_provider")

    @identity_provider.setter
    def identity_provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identity_provider", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The role mapping type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="ambiguousRoleResolution")
    def ambiguous_role_resolution(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type. `Required` if you specify Token or Rules as the Type.
        """
        return pulumi.get(self, "ambiguous_role_resolution")

    @ambiguous_role_resolution.setter
    def ambiguous_role_resolution(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ambiguous_role_resolution", value)

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs']]]]:
        """
        The Rules Configuration to be used for mapping users to roles. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
        """
        return pulumi.get(self, "mapping_rules")

    @mapping_rules.setter
    def mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs']]]]):
        pulumi.set(self, "mapping_rules", value)


if not MYPY:
    class IdentityPoolRoleAttachmentRoleMappingMappingRuleArgsDict(TypedDict):
        claim: pulumi.Input[builtins.str]
        """
        The claim name that must be present in the token, for example, "isAdmin" or "paid".
        """
        match_type: pulumi.Input[builtins.str]
        """
        The match condition that specifies how closely the claim value in the IdP token must match Value.
        """
        role_arn: pulumi.Input[builtins.str]
        """
        The role ARN.
        """
        value: pulumi.Input[builtins.str]
        """
        A brief string that the claim must match, for example, "paid" or "yes".
        """
elif False:
    IdentityPoolRoleAttachmentRoleMappingMappingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPoolRoleAttachmentRoleMappingMappingRuleArgs:
    def __init__(__self__, *,
                 claim: pulumi.Input[builtins.str],
                 match_type: pulumi.Input[builtins.str],
                 role_arn: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] claim: The claim name that must be present in the token, for example, "isAdmin" or "paid".
        :param pulumi.Input[builtins.str] match_type: The match condition that specifies how closely the claim value in the IdP token must match Value.
        :param pulumi.Input[builtins.str] role_arn: The role ARN.
        :param pulumi.Input[builtins.str] value: A brief string that the claim must match, for example, "paid" or "yes".
        """
        pulumi.set(__self__, "claim", claim)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def claim(self) -> pulumi.Input[builtins.str]:
        """
        The claim name that must be present in the token, for example, "isAdmin" or "paid".
        """
        return pulumi.get(self, "claim")

    @claim.setter
    def claim(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "claim", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[builtins.str]:
        """
        The match condition that specifies how closely the claim value in the IdP token must match Value.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The role ARN.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        A brief string that the claim must match, for example, "paid" or "yes".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ManagedUserPoolClientAnalyticsConfigurationArgsDict(TypedDict):
        application_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        Application ARN for an Amazon Pinpoint application. It conflicts with `external_id` and `role_arn`.
        """
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Unique identifier for an Amazon Pinpoint application.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID for the Analytics Configuration and conflicts with `application_arn`.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. It conflicts with `application_arn`.
        """
        user_data_shared: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `user_data_shared` is set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
elif False:
    ManagedUserPoolClientAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedUserPoolClientAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 application_arn: Optional[pulumi.Input[builtins.str]] = None,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 user_data_shared: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] application_arn: Application ARN for an Amazon Pinpoint application. It conflicts with `external_id` and `role_arn`.
        :param pulumi.Input[builtins.str] application_id: Unique identifier for an Amazon Pinpoint application.
        :param pulumi.Input[builtins.str] external_id: ID for the Analytics Configuration and conflicts with `application_arn`.
        :param pulumi.Input[builtins.str] role_arn: ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. It conflicts with `application_arn`.
        :param pulumi.Input[builtins.bool] user_data_shared: If `user_data_shared` is set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
        if application_arn is not None:
            pulumi.set(__self__, "application_arn", application_arn)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if user_data_shared is not None:
            pulumi.set(__self__, "user_data_shared", user_data_shared)

    @property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Application ARN for an Amazon Pinpoint application. It conflicts with `external_id` and `role_arn`.
        """
        return pulumi.get(self, "application_arn")

    @application_arn.setter
    def application_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_arn", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unique identifier for an Amazon Pinpoint application.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID for the Analytics Configuration and conflicts with `application_arn`.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. It conflicts with `application_arn`.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="userDataShared")
    def user_data_shared(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `user_data_shared` is set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
        return pulumi.get(self, "user_data_shared")

    @user_data_shared.setter
    def user_data_shared(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "user_data_shared", value)


if not MYPY:
    class ManagedUserPoolClientTokenValidityUnitsArgsDict(TypedDict):
        access_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit for the value in `access_token_validity` and defaults to `hours`.
        """
        id_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit for the value in `id_token_validity`, and it defaults to `hours`.
        """
        refresh_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit for the value in `refresh_token_validity` and defaults to `days`.
        """
elif False:
    ManagedUserPoolClientTokenValidityUnitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedUserPoolClientTokenValidityUnitsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[builtins.str]] = None,
                 id_token: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_token: Time unit for the value in `access_token_validity` and defaults to `hours`.
        :param pulumi.Input[builtins.str] id_token: Time unit for the value in `id_token_validity`, and it defaults to `hours`.
        :param pulumi.Input[builtins.str] refresh_token: Time unit for the value in `refresh_token_validity` and defaults to `days`.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if id_token is not None:
            pulumi.set(__self__, "id_token", id_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit for the value in `access_token_validity` and defaults to `hours`.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit for the value in `id_token_validity`, and it defaults to `hours`.
        """
        return pulumi.get(self, "id_token")

    @id_token.setter
    def id_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit for the value in `refresh_token_validity` and defaults to `days`.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token", value)


if not MYPY:
    class ResourceServerScopeArgsDict(TypedDict):
        scope_description: pulumi.Input[builtins.str]
        """
        The scope description.
        """
        scope_name: pulumi.Input[builtins.str]
        """
        The scope name.
        """
elif False:
    ResourceServerScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceServerScopeArgs:
    def __init__(__self__, *,
                 scope_description: pulumi.Input[builtins.str],
                 scope_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] scope_description: The scope description.
        :param pulumi.Input[builtins.str] scope_name: The scope name.
        """
        pulumi.set(__self__, "scope_description", scope_description)
        pulumi.set(__self__, "scope_name", scope_name)

    @property
    @pulumi.getter(name="scopeDescription")
    def scope_description(self) -> pulumi.Input[builtins.str]:
        """
        The scope description.
        """
        return pulumi.get(self, "scope_description")

    @scope_description.setter
    def scope_description(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scope_description", value)

    @property
    @pulumi.getter(name="scopeName")
    def scope_name(self) -> pulumi.Input[builtins.str]:
        """
        The scope name.
        """
        return pulumi.get(self, "scope_name")

    @scope_name.setter
    def scope_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scope_name", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationArgsDict(TypedDict):
        actions: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsArgsDict']
        """
        Account takeover risk configuration actions. See details below.
        """
        notify_configuration: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgsDict']
        """
        The notify configuration used to construct email notifications. See details below.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs'],
                 notify_configuration: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs']):
        """
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs'] actions: Account takeover risk configuration actions. See details below.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs'] notify_configuration: The notify configuration used to construct email notifications. See details below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "notify_configuration", notify_configuration)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs']:
        """
        Account takeover risk configuration actions. See details below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="notifyConfiguration")
    def notify_configuration(self) -> pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs']:
        """
        The notify configuration used to construct email notifications. See details below.
        """
        return pulumi.get(self, "notify_configuration")

    @notify_configuration.setter
    def notify_configuration(self, value: pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs']):
        pulumi.set(self, "notify_configuration", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationActionsArgsDict(TypedDict):
        high_action: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgsDict']]
        """
        Action to take for a high risk. See action block below.
        """
        low_action: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgsDict']]
        """
        Action to take for a low risk. See action block below.
        """
        medium_action: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgsDict']]
        """
        Action to take for a medium risk. See action block below.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsArgs:
    def __init__(__self__, *,
                 high_action: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs']] = None,
                 low_action: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs']] = None,
                 medium_action: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs']] = None):
        """
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs'] high_action: Action to take for a high risk. See action block below.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs'] low_action: Action to take for a low risk. See action block below.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs'] medium_action: Action to take for a medium risk. See action block below.
        """
        if high_action is not None:
            pulumi.set(__self__, "high_action", high_action)
        if low_action is not None:
            pulumi.set(__self__, "low_action", low_action)
        if medium_action is not None:
            pulumi.set(__self__, "medium_action", medium_action)

    @property
    @pulumi.getter(name="highAction")
    def high_action(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs']]:
        """
        Action to take for a high risk. See action block below.
        """
        return pulumi.get(self, "high_action")

    @high_action.setter
    def high_action(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs']]):
        pulumi.set(self, "high_action", value)

    @property
    @pulumi.getter(name="lowAction")
    def low_action(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs']]:
        """
        Action to take for a low risk. See action block below.
        """
        return pulumi.get(self, "low_action")

    @low_action.setter
    def low_action(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs']]):
        pulumi.set(self, "low_action", value)

    @property
    @pulumi.getter(name="mediumAction")
    def medium_action(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs']]:
        """
        Action to take for a medium risk. See action block below.
        """
        return pulumi.get(self, "medium_action")

    @medium_action.setter
    def medium_action(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs']]):
        pulumi.set(self, "medium_action", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgsDict(TypedDict):
        event_action: pulumi.Input[builtins.str]
        notify: pulumi.Input[builtins.bool]
        """
        Whether to send a notification.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsHighActionArgs:
    def __init__(__self__, *,
                 event_action: pulumi.Input[builtins.str],
                 notify: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] notify: Whether to send a notification.
        """
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def notify(self) -> pulumi.Input[builtins.bool]:
        """
        Whether to send a notification.
        """
        return pulumi.get(self, "notify")

    @notify.setter
    def notify(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "notify", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgsDict(TypedDict):
        event_action: pulumi.Input[builtins.str]
        notify: pulumi.Input[builtins.bool]
        """
        Whether to send a notification.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsLowActionArgs:
    def __init__(__self__, *,
                 event_action: pulumi.Input[builtins.str],
                 notify: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] notify: Whether to send a notification.
        """
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def notify(self) -> pulumi.Input[builtins.bool]:
        """
        Whether to send a notification.
        """
        return pulumi.get(self, "notify")

    @notify.setter
    def notify(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "notify", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgsDict(TypedDict):
        event_action: pulumi.Input[builtins.str]
        notify: pulumi.Input[builtins.bool]
        """
        Whether to send a notification.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationActionsMediumActionArgs:
    def __init__(__self__, *,
                 event_action: pulumi.Input[builtins.str],
                 notify: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] notify: Whether to send a notification.
        """
        pulumi.set(__self__, "event_action", event_action)
        pulumi.set(__self__, "notify", notify)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def notify(self) -> pulumi.Input[builtins.bool]:
        """
        Whether to send a notification.
        """
        return pulumi.get(self, "notify")

    @notify.setter
    def notify(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "notify", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgsDict(TypedDict):
        source_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
        """
        block_email: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgsDict']]
        """
        Email template used when a detected risk event is blocked. See notify email type below.
        """
        from_: NotRequired[pulumi.Input[builtins.str]]
        """
        The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
        """
        mfa_email: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgsDict']]
        """
        The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
        """
        no_action_email: NotRequired[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgsDict']]
        """
        The email template used when a detected risk event is allowed. See notify email type below.
        """
        reply_to: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination to which the receiver of an email should reply to.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationArgs:
    def __init__(__self__, *,
                 source_arn: pulumi.Input[builtins.str],
                 block_email: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs']] = None,
                 from_: Optional[pulumi.Input[builtins.str]] = None,
                 mfa_email: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs']] = None,
                 no_action_email: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs']] = None,
                 reply_to: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] source_arn: The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs'] block_email: Email template used when a detected risk event is blocked. See notify email type below.
        :param pulumi.Input[builtins.str] from_: The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs'] mfa_email: The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
        :param pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs'] no_action_email: The email template used when a detected risk event is allowed. See notify email type below.
        :param pulumi.Input[builtins.str] reply_to: The destination to which the receiver of an email should reply to.
        """
        pulumi.set(__self__, "source_arn", source_arn)
        if block_email is not None:
            pulumi.set(__self__, "block_email", block_email)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if mfa_email is not None:
            pulumi.set(__self__, "mfa_email", mfa_email)
        if no_action_email is not None:
            pulumi.set(__self__, "no_action_email", no_action_email)
        if reply_to is not None:
            pulumi.set(__self__, "reply_to", reply_to)

    @property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
        """
        return pulumi.get(self, "source_arn")

    @source_arn.setter
    def source_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_arn", value)

    @property
    @pulumi.getter(name="blockEmail")
    def block_email(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs']]:
        """
        Email template used when a detected risk event is blocked. See notify email type below.
        """
        return pulumi.get(self, "block_email")

    @block_email.setter
    def block_email(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs']]):
        pulumi.set(self, "block_email", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="mfaEmail")
    def mfa_email(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs']]:
        """
        The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
        """
        return pulumi.get(self, "mfa_email")

    @mfa_email.setter
    def mfa_email(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs']]):
        pulumi.set(self, "mfa_email", value)

    @property
    @pulumi.getter(name="noActionEmail")
    def no_action_email(self) -> Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs']]:
        """
        The email template used when a detected risk event is allowed. See notify email type below.
        """
        return pulumi.get(self, "no_action_email")

    @no_action_email.setter
    def no_action_email(self, value: Optional[pulumi.Input['RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs']]):
        pulumi.set(self, "no_action_email", value)

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination to which the receiver of an email should reply to.
        """
        return pulumi.get(self, "reply_to")

    @reply_to.setter
    def reply_to(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reply_to", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgsDict(TypedDict):
        html_body: pulumi.Input[builtins.str]
        """
        The email HTML body.
        """
        subject: pulumi.Input[builtins.str]
        """
        The email subject.
        """
        text_body: pulumi.Input[builtins.str]
        """
        The email text body.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmailArgs:
    def __init__(__self__, *,
                 html_body: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 text_body: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] html_body: The email HTML body.
        :param pulumi.Input[builtins.str] subject: The email subject.
        :param pulumi.Input[builtins.str] text_body: The email text body.
        """
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> pulumi.Input[builtins.str]:
        """
        The email HTML body.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        """
        The email subject.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="textBody")
    def text_body(self) -> pulumi.Input[builtins.str]:
        """
        The email text body.
        """
        return pulumi.get(self, "text_body")

    @text_body.setter
    def text_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text_body", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgsDict(TypedDict):
        html_body: pulumi.Input[builtins.str]
        """
        The email HTML body.
        """
        subject: pulumi.Input[builtins.str]
        """
        The email subject.
        """
        text_body: pulumi.Input[builtins.str]
        """
        The email text body.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmailArgs:
    def __init__(__self__, *,
                 html_body: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 text_body: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] html_body: The email HTML body.
        :param pulumi.Input[builtins.str] subject: The email subject.
        :param pulumi.Input[builtins.str] text_body: The email text body.
        """
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> pulumi.Input[builtins.str]:
        """
        The email HTML body.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        """
        The email subject.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="textBody")
    def text_body(self) -> pulumi.Input[builtins.str]:
        """
        The email text body.
        """
        return pulumi.get(self, "text_body")

    @text_body.setter
    def text_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text_body", value)


if not MYPY:
    class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgsDict(TypedDict):
        html_body: pulumi.Input[builtins.str]
        """
        The email HTML body.
        """
        subject: pulumi.Input[builtins.str]
        """
        The email subject.
        """
        text_body: pulumi.Input[builtins.str]
        """
        The email text body.
        """
elif False:
    RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmailArgs:
    def __init__(__self__, *,
                 html_body: pulumi.Input[builtins.str],
                 subject: pulumi.Input[builtins.str],
                 text_body: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] html_body: The email HTML body.
        :param pulumi.Input[builtins.str] subject: The email subject.
        :param pulumi.Input[builtins.str] text_body: The email text body.
        """
        pulumi.set(__self__, "html_body", html_body)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "text_body", text_body)

    @property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> pulumi.Input[builtins.str]:
        """
        The email HTML body.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "html_body", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[builtins.str]:
        """
        The email subject.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="textBody")
    def text_body(self) -> pulumi.Input[builtins.str]:
        """
        The email text body.
        """
        return pulumi.get(self, "text_body")

    @text_body.setter
    def text_body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text_body", value)


if not MYPY:
    class RiskConfigurationCompromisedCredentialsRiskConfigurationArgsDict(TypedDict):
        actions: pulumi.Input['RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgsDict']
        """
        The compromised credentials risk configuration actions. See details below.
        """
        event_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are `SIGN_IN`, `PASSWORD_CHANGE`, and `SIGN_UP`.
        """
elif False:
    RiskConfigurationCompromisedCredentialsRiskConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationCompromisedCredentialsRiskConfigurationArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs'],
                 event_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input['RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs'] actions: The compromised credentials risk configuration actions. See details below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] event_filters: Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are `SIGN_IN`, `PASSWORD_CHANGE`, and `SIGN_UP`.
        """
        pulumi.set(__self__, "actions", actions)
        if event_filters is not None:
            pulumi.set(__self__, "event_filters", event_filters)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs']:
        """
        The compromised credentials risk configuration actions. See details below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="eventFilters")
    def event_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are `SIGN_IN`, `PASSWORD_CHANGE`, and `SIGN_UP`.
        """
        return pulumi.get(self, "event_filters")

    @event_filters.setter
    def event_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "event_filters", value)


if not MYPY:
    class RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgsDict(TypedDict):
        event_action: pulumi.Input[builtins.str]
        """
        The event action. Valid values are `BLOCK` or `NO_ACTION`.
        """
elif False:
    RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationCompromisedCredentialsRiskConfigurationActionsArgs:
    def __init__(__self__, *,
                 event_action: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] event_action: The event action. Valid values are `BLOCK` or `NO_ACTION`.
        """
        pulumi.set(__self__, "event_action", event_action)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> pulumi.Input[builtins.str]:
        """
        The event action. Valid values are `BLOCK` or `NO_ACTION`.
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_action", value)


if not MYPY:
    class RiskConfigurationRiskExceptionConfigurationArgsDict(TypedDict):
        blocked_ip_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Overrides the risk decision to always block the pre-authentication requests.
        The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
        Can contain a maximum of 200 items.
        """
        skipped_ip_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Risk detection isn't performed on the IP addresses in this range list.
        The IP range is in CIDR notation.
        Can contain a maximum of 200 items.
        """
elif False:
    RiskConfigurationRiskExceptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskConfigurationRiskExceptionConfigurationArgs:
    def __init__(__self__, *,
                 blocked_ip_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 skipped_ip_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] blocked_ip_range_lists: Overrides the risk decision to always block the pre-authentication requests.
               The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
               Can contain a maximum of 200 items.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] skipped_ip_range_lists: Risk detection isn't performed on the IP addresses in this range list.
               The IP range is in CIDR notation.
               Can contain a maximum of 200 items.
        """
        if blocked_ip_range_lists is not None:
            pulumi.set(__self__, "blocked_ip_range_lists", blocked_ip_range_lists)
        if skipped_ip_range_lists is not None:
            pulumi.set(__self__, "skipped_ip_range_lists", skipped_ip_range_lists)

    @property
    @pulumi.getter(name="blockedIpRangeLists")
    def blocked_ip_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Overrides the risk decision to always block the pre-authentication requests.
        The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
        Can contain a maximum of 200 items.
        """
        return pulumi.get(self, "blocked_ip_range_lists")

    @blocked_ip_range_lists.setter
    def blocked_ip_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "blocked_ip_range_lists", value)

    @property
    @pulumi.getter(name="skippedIpRangeLists")
    def skipped_ip_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Risk detection isn't performed on the IP addresses in this range list.
        The IP range is in CIDR notation.
        Can contain a maximum of 200 items.
        """
        return pulumi.get(self, "skipped_ip_range_lists")

    @skipped_ip_range_lists.setter
    def skipped_ip_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "skipped_ip_range_lists", value)


if not MYPY:
    class UserPoolAccountRecoverySettingArgsDict(TypedDict):
        recovery_mechanisms: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserPoolAccountRecoverySettingRecoveryMechanismArgsDict']]]]
        """
        List of Account Recovery Options of the following structure:
        """
elif False:
    UserPoolAccountRecoverySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolAccountRecoverySettingArgs:
    def __init__(__self__, *,
                 recovery_mechanisms: Optional[pulumi.Input[Sequence[pulumi.Input['UserPoolAccountRecoverySettingRecoveryMechanismArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UserPoolAccountRecoverySettingRecoveryMechanismArgs']]] recovery_mechanisms: List of Account Recovery Options of the following structure:
        """
        if recovery_mechanisms is not None:
            pulumi.set(__self__, "recovery_mechanisms", recovery_mechanisms)

    @property
    @pulumi.getter(name="recoveryMechanisms")
    def recovery_mechanisms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserPoolAccountRecoverySettingRecoveryMechanismArgs']]]]:
        """
        List of Account Recovery Options of the following structure:
        """
        return pulumi.get(self, "recovery_mechanisms")

    @recovery_mechanisms.setter
    def recovery_mechanisms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserPoolAccountRecoverySettingRecoveryMechanismArgs']]]]):
        pulumi.set(self, "recovery_mechanisms", value)


if not MYPY:
    class UserPoolAccountRecoverySettingRecoveryMechanismArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Recovery method for a user. Can be of the following: `verified_email`, `verified_phone_number`, and `admin_only`.
        """
        priority: pulumi.Input[builtins.int]
        """
        Positive integer specifying priority of a method with 1 being the highest priority.
        """
elif False:
    UserPoolAccountRecoverySettingRecoveryMechanismArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolAccountRecoverySettingRecoveryMechanismArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 priority: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] name: Recovery method for a user. Can be of the following: `verified_email`, `verified_phone_number`, and `admin_only`.
        :param pulumi.Input[builtins.int] priority: Positive integer specifying priority of a method with 1 being the highest priority.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Recovery method for a user. Can be of the following: `verified_email`, `verified_phone_number`, and `admin_only`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[builtins.int]:
        """
        Positive integer specifying priority of a method with 1 being the highest priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class UserPoolAdminCreateUserConfigArgsDict(TypedDict):
        allow_admin_create_user_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
        """
        invite_message_template: NotRequired[pulumi.Input['UserPoolAdminCreateUserConfigInviteMessageTemplateArgsDict']]
        """
        Invite message template structure. Detailed below.
        """
elif False:
    UserPoolAdminCreateUserConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolAdminCreateUserConfigArgs:
    def __init__(__self__, *,
                 allow_admin_create_user_only: Optional[pulumi.Input[builtins.bool]] = None,
                 invite_message_template: Optional[pulumi.Input['UserPoolAdminCreateUserConfigInviteMessageTemplateArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] allow_admin_create_user_only: Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
        :param pulumi.Input['UserPoolAdminCreateUserConfigInviteMessageTemplateArgs'] invite_message_template: Invite message template structure. Detailed below.
        """
        if allow_admin_create_user_only is not None:
            pulumi.set(__self__, "allow_admin_create_user_only", allow_admin_create_user_only)
        if invite_message_template is not None:
            pulumi.set(__self__, "invite_message_template", invite_message_template)

    @property
    @pulumi.getter(name="allowAdminCreateUserOnly")
    def allow_admin_create_user_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
        """
        return pulumi.get(self, "allow_admin_create_user_only")

    @allow_admin_create_user_only.setter
    def allow_admin_create_user_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_admin_create_user_only", value)

    @property
    @pulumi.getter(name="inviteMessageTemplate")
    def invite_message_template(self) -> Optional[pulumi.Input['UserPoolAdminCreateUserConfigInviteMessageTemplateArgs']]:
        """
        Invite message template structure. Detailed below.
        """
        return pulumi.get(self, "invite_message_template")

    @invite_message_template.setter
    def invite_message_template(self, value: Optional[pulumi.Input['UserPoolAdminCreateUserConfigInviteMessageTemplateArgs']]):
        pulumi.set(self, "invite_message_template", value)


if not MYPY:
    class UserPoolAdminCreateUserConfigInviteMessageTemplateArgsDict(TypedDict):
        email_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Message template for email messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        """
        email_subject: NotRequired[pulumi.Input[builtins.str]]
        """
        Subject line for email messages.
        """
        sms_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Message template for SMS messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        """
elif False:
    UserPoolAdminCreateUserConfigInviteMessageTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolAdminCreateUserConfigInviteMessageTemplateArgs:
    def __init__(__self__, *,
                 email_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_subject: Optional[pulumi.Input[builtins.str]] = None,
                 sms_message: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] email_message: Message template for email messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        :param pulumi.Input[builtins.str] email_subject: Subject line for email messages.
        :param pulumi.Input[builtins.str] sms_message: Message template for SMS messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        """
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if sms_message is not None:
            pulumi.set(__self__, "sms_message", sms_message)

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Message template for email messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        """
        return pulumi.get(self, "email_message")

    @email_message.setter
    def email_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_message", value)

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subject line for email messages.
        """
        return pulumi.get(self, "email_subject")

    @email_subject.setter
    def email_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_subject", value)

    @property
    @pulumi.getter(name="smsMessage")
    def sms_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Message template for SMS messages. Must contain `{username}` and `{####}` placeholders, for username and temporary password, respectively.
        """
        return pulumi.get(self, "sms_message")

    @sms_message.setter
    def sms_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_message", value)


if not MYPY:
    class UserPoolClientAnalyticsConfigurationArgsDict(TypedDict):
        application_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        Application ARN for an Amazon Pinpoint application. Conflicts with `external_id` and `role_arn`.
        """
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Application ID for an Amazon Pinpoint application.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID for the Analytics Configuration. Conflicts with `application_arn`.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `application_arn`.
        """
        user_data_shared: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
elif False:
    UserPoolClientAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolClientAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 application_arn: Optional[pulumi.Input[builtins.str]] = None,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 external_id: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 user_data_shared: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] application_arn: Application ARN for an Amazon Pinpoint application. Conflicts with `external_id` and `role_arn`.
        :param pulumi.Input[builtins.str] application_id: Application ID for an Amazon Pinpoint application.
        :param pulumi.Input[builtins.str] external_id: ID for the Analytics Configuration. Conflicts with `application_arn`.
        :param pulumi.Input[builtins.str] role_arn: ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `application_arn`.
        :param pulumi.Input[builtins.bool] user_data_shared: If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
        if application_arn is not None:
            pulumi.set(__self__, "application_arn", application_arn)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if user_data_shared is not None:
            pulumi.set(__self__, "user_data_shared", user_data_shared)

    @property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Application ARN for an Amazon Pinpoint application. Conflicts with `external_id` and `role_arn`.
        """
        return pulumi.get(self, "application_arn")

    @application_arn.setter
    def application_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_arn", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Application ID for an Amazon Pinpoint application.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID for the Analytics Configuration. Conflicts with `application_arn`.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with `application_arn`.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="userDataShared")
    def user_data_shared(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to `true`, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
        """
        return pulumi.get(self, "user_data_shared")

    @user_data_shared.setter
    def user_data_shared(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "user_data_shared", value)


if not MYPY:
    class UserPoolClientTokenValidityUnitsArgsDict(TypedDict):
        access_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit in for the value in `access_token_validity`, defaults to `hours`.
        """
        id_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit in for the value in `id_token_validity`, defaults to `hours`.
        """
        refresh_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Time unit in for the value in `refresh_token_validity`, defaults to `days`.
        """
elif False:
    UserPoolClientTokenValidityUnitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolClientTokenValidityUnitsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[builtins.str]] = None,
                 id_token: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] access_token: Time unit in for the value in `access_token_validity`, defaults to `hours`.
        :param pulumi.Input[builtins.str] id_token: Time unit in for the value in `id_token_validity`, defaults to `hours`.
        :param pulumi.Input[builtins.str] refresh_token: Time unit in for the value in `refresh_token_validity`, defaults to `days`.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if id_token is not None:
            pulumi.set(__self__, "id_token", id_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit in for the value in `access_token_validity`, defaults to `hours`.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit in for the value in `id_token_validity`, defaults to `hours`.
        """
        return pulumi.get(self, "id_token")

    @id_token.setter
    def id_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time unit in for the value in `refresh_token_validity`, defaults to `days`.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "refresh_token", value)


if not MYPY:
    class UserPoolDeviceConfigurationArgsDict(TypedDict):
        challenge_required_on_new_device: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether a challenge is required on a new device. Only applicable to a new device.
        """
        device_only_remembered_on_user_prompt: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether a device is only remembered on user prompt. `false` equates to "Always" remember, `true` is "User Opt In," and not using a `device_configuration` block is "No."
        """
elif False:
    UserPoolDeviceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolDeviceConfigurationArgs:
    def __init__(__self__, *,
                 challenge_required_on_new_device: Optional[pulumi.Input[builtins.bool]] = None,
                 device_only_remembered_on_user_prompt: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] challenge_required_on_new_device: Whether a challenge is required on a new device. Only applicable to a new device.
        :param pulumi.Input[builtins.bool] device_only_remembered_on_user_prompt: Whether a device is only remembered on user prompt. `false` equates to "Always" remember, `true` is "User Opt In," and not using a `device_configuration` block is "No."
        """
        if challenge_required_on_new_device is not None:
            pulumi.set(__self__, "challenge_required_on_new_device", challenge_required_on_new_device)
        if device_only_remembered_on_user_prompt is not None:
            pulumi.set(__self__, "device_only_remembered_on_user_prompt", device_only_remembered_on_user_prompt)

    @property
    @pulumi.getter(name="challengeRequiredOnNewDevice")
    def challenge_required_on_new_device(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether a challenge is required on a new device. Only applicable to a new device.
        """
        return pulumi.get(self, "challenge_required_on_new_device")

    @challenge_required_on_new_device.setter
    def challenge_required_on_new_device(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "challenge_required_on_new_device", value)

    @property
    @pulumi.getter(name="deviceOnlyRememberedOnUserPrompt")
    def device_only_remembered_on_user_prompt(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether a device is only remembered on user prompt. `false` equates to "Always" remember, `true` is "User Opt In," and not using a `device_configuration` block is "No."
        """
        return pulumi.get(self, "device_only_remembered_on_user_prompt")

    @device_only_remembered_on_user_prompt.setter
    def device_only_remembered_on_user_prompt(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "device_only_remembered_on_user_prompt", value)


if not MYPY:
    class UserPoolEmailConfigurationArgsDict(TypedDict):
        configuration_set: NotRequired[pulumi.Input[builtins.str]]
        """
        Email configuration set name from SES.
        """
        email_sending_account: NotRequired[pulumi.Input[builtins.str]]
        """
        Email delivery method to use. `COGNITO_DEFAULT` for the default email functionality built into Cognito or `DEVELOPER` to use your Amazon SES configuration. Required to be `DEVELOPER` if `from_email_address` is set.
        """
        from_email_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Sender’s email address or sender’s display name with their email address (e.g., `john@example.com`, `John Smith <john@example.com>` or `\\"John Smith Ph.D.\\" <john@example.com>`). Escaped double quotes are required around display names that contain certain characters as specified in [RFC 5322](https://tools.ietf.org/html/rfc5322).
        """
        reply_to_email_address: NotRequired[pulumi.Input[builtins.str]]
        """
        REPLY-TO email address.
        """
        source_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of the SES verified email identity to use. Required if `email_sending_account` is set to `DEVELOPER`.
        """
elif False:
    UserPoolEmailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolEmailConfigurationArgs:
    def __init__(__self__, *,
                 configuration_set: Optional[pulumi.Input[builtins.str]] = None,
                 email_sending_account: Optional[pulumi.Input[builtins.str]] = None,
                 from_email_address: Optional[pulumi.Input[builtins.str]] = None,
                 reply_to_email_address: Optional[pulumi.Input[builtins.str]] = None,
                 source_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] configuration_set: Email configuration set name from SES.
        :param pulumi.Input[builtins.str] email_sending_account: Email delivery method to use. `COGNITO_DEFAULT` for the default email functionality built into Cognito or `DEVELOPER` to use your Amazon SES configuration. Required to be `DEVELOPER` if `from_email_address` is set.
        :param pulumi.Input[builtins.str] from_email_address: Sender’s email address or sender’s display name with their email address (e.g., `john@example.com`, `John Smith <john@example.com>` or `\\"John Smith Ph.D.\\" <john@example.com>`). Escaped double quotes are required around display names that contain certain characters as specified in [RFC 5322](https://tools.ietf.org/html/rfc5322).
        :param pulumi.Input[builtins.str] reply_to_email_address: REPLY-TO email address.
        :param pulumi.Input[builtins.str] source_arn: ARN of the SES verified email identity to use. Required if `email_sending_account` is set to `DEVELOPER`.
        """
        if configuration_set is not None:
            pulumi.set(__self__, "configuration_set", configuration_set)
        if email_sending_account is not None:
            pulumi.set(__self__, "email_sending_account", email_sending_account)
        if from_email_address is not None:
            pulumi.set(__self__, "from_email_address", from_email_address)
        if reply_to_email_address is not None:
            pulumi.set(__self__, "reply_to_email_address", reply_to_email_address)
        if source_arn is not None:
            pulumi.set(__self__, "source_arn", source_arn)

    @property
    @pulumi.getter(name="configurationSet")
    def configuration_set(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Email configuration set name from SES.
        """
        return pulumi.get(self, "configuration_set")

    @configuration_set.setter
    def configuration_set(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "configuration_set", value)

    @property
    @pulumi.getter(name="emailSendingAccount")
    def email_sending_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Email delivery method to use. `COGNITO_DEFAULT` for the default email functionality built into Cognito or `DEVELOPER` to use your Amazon SES configuration. Required to be `DEVELOPER` if `from_email_address` is set.
        """
        return pulumi.get(self, "email_sending_account")

    @email_sending_account.setter
    def email_sending_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_sending_account", value)

    @property
    @pulumi.getter(name="fromEmailAddress")
    def from_email_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sender’s email address or sender’s display name with their email address (e.g., `john@example.com`, `John Smith <john@example.com>` or `\\"John Smith Ph.D.\\" <john@example.com>`). Escaped double quotes are required around display names that contain certain characters as specified in [RFC 5322](https://tools.ietf.org/html/rfc5322).
        """
        return pulumi.get(self, "from_email_address")

    @from_email_address.setter
    def from_email_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "from_email_address", value)

    @property
    @pulumi.getter(name="replyToEmailAddress")
    def reply_to_email_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        REPLY-TO email address.
        """
        return pulumi.get(self, "reply_to_email_address")

    @reply_to_email_address.setter
    def reply_to_email_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reply_to_email_address", value)

    @property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of the SES verified email identity to use. Required if `email_sending_account` is set to `DEVELOPER`.
        """
        return pulumi.get(self, "source_arn")

    @source_arn.setter
    def source_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_arn", value)


if not MYPY:
    class UserPoolEmailMfaConfigurationArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        The template for the email messages that your user pool sends to users with codes for MFA and sign-in with email OTPs. The message must contain the {####} placeholder. In the message, Amazon Cognito replaces this placeholder with the code. If you don't provide this parameter, Amazon Cognito sends messages in the default format.
        """
        subject: NotRequired[pulumi.Input[builtins.str]]
        """
        The subject of the email messages that your user pool sends to users with codes for MFA and email OTP sign-in.
        """
elif False:
    UserPoolEmailMfaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolEmailMfaConfigurationArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 subject: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] message: The template for the email messages that your user pool sends to users with codes for MFA and sign-in with email OTPs. The message must contain the {####} placeholder. In the message, Amazon Cognito replaces this placeholder with the code. If you don't provide this parameter, Amazon Cognito sends messages in the default format.
        :param pulumi.Input[builtins.str] subject: The subject of the email messages that your user pool sends to users with codes for MFA and email OTP sign-in.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The template for the email messages that your user pool sends to users with codes for MFA and sign-in with email OTPs. The message must contain the {####} placeholder. In the message, Amazon Cognito replaces this placeholder with the code. If you don't provide this parameter, Amazon Cognito sends messages in the default format.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The subject of the email messages that your user pool sends to users with codes for MFA and email OTP sign-in.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class UserPoolLambdaConfigArgsDict(TypedDict):
        create_auth_challenge: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of the lambda creating an authentication challenge.
        """
        custom_email_sender: NotRequired[pulumi.Input['UserPoolLambdaConfigCustomEmailSenderArgsDict']]
        """
        A custom email sender AWS Lambda trigger. See custom_email_sender Below.
        """
        custom_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom Message AWS Lambda trigger.
        """
        custom_sms_sender: NotRequired[pulumi.Input['UserPoolLambdaConfigCustomSmsSenderArgsDict']]
        """
        A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
        """
        define_auth_challenge: NotRequired[pulumi.Input[builtins.str]]
        """
        Defines the authentication challenge.
        """
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
        """
        post_authentication: NotRequired[pulumi.Input[builtins.str]]
        """
        Post-authentication AWS Lambda trigger.
        """
        post_confirmation: NotRequired[pulumi.Input[builtins.str]]
        """
        Post-confirmation AWS Lambda trigger.
        """
        pre_authentication: NotRequired[pulumi.Input[builtins.str]]
        """
        Pre-authentication AWS Lambda trigger.
        """
        pre_sign_up: NotRequired[pulumi.Input[builtins.str]]
        """
        Pre-registration AWS Lambda trigger.
        """
        pre_token_generation: NotRequired[pulumi.Input[builtins.str]]
        """
        Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of `pre_token_generation_config`.
        """
        pre_token_generation_config: NotRequired[pulumi.Input['UserPoolLambdaConfigPreTokenGenerationConfigArgsDict']]
        """
        Allow to customize access tokens. See pre_token_configuration_type
        """
        user_migration: NotRequired[pulumi.Input[builtins.str]]
        """
        User migration Lambda config type.
        """
        verify_auth_challenge_response: NotRequired[pulumi.Input[builtins.str]]
        """
        Verifies the authentication challenge response.
        """
elif False:
    UserPoolLambdaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolLambdaConfigArgs:
    def __init__(__self__, *,
                 create_auth_challenge: Optional[pulumi.Input[builtins.str]] = None,
                 custom_email_sender: Optional[pulumi.Input['UserPoolLambdaConfigCustomEmailSenderArgs']] = None,
                 custom_message: Optional[pulumi.Input[builtins.str]] = None,
                 custom_sms_sender: Optional[pulumi.Input['UserPoolLambdaConfigCustomSmsSenderArgs']] = None,
                 define_auth_challenge: Optional[pulumi.Input[builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 post_authentication: Optional[pulumi.Input[builtins.str]] = None,
                 post_confirmation: Optional[pulumi.Input[builtins.str]] = None,
                 pre_authentication: Optional[pulumi.Input[builtins.str]] = None,
                 pre_sign_up: Optional[pulumi.Input[builtins.str]] = None,
                 pre_token_generation: Optional[pulumi.Input[builtins.str]] = None,
                 pre_token_generation_config: Optional[pulumi.Input['UserPoolLambdaConfigPreTokenGenerationConfigArgs']] = None,
                 user_migration: Optional[pulumi.Input[builtins.str]] = None,
                 verify_auth_challenge_response: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create_auth_challenge: ARN of the lambda creating an authentication challenge.
        :param pulumi.Input['UserPoolLambdaConfigCustomEmailSenderArgs'] custom_email_sender: A custom email sender AWS Lambda trigger. See custom_email_sender Below.
        :param pulumi.Input[builtins.str] custom_message: Custom Message AWS Lambda trigger.
        :param pulumi.Input['UserPoolLambdaConfigCustomSmsSenderArgs'] custom_sms_sender: A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
        :param pulumi.Input[builtins.str] define_auth_challenge: Defines the authentication challenge.
        :param pulumi.Input[builtins.str] kms_key_id: The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
        :param pulumi.Input[builtins.str] post_authentication: Post-authentication AWS Lambda trigger.
        :param pulumi.Input[builtins.str] post_confirmation: Post-confirmation AWS Lambda trigger.
        :param pulumi.Input[builtins.str] pre_authentication: Pre-authentication AWS Lambda trigger.
        :param pulumi.Input[builtins.str] pre_sign_up: Pre-registration AWS Lambda trigger.
        :param pulumi.Input[builtins.str] pre_token_generation: Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of `pre_token_generation_config`.
        :param pulumi.Input['UserPoolLambdaConfigPreTokenGenerationConfigArgs'] pre_token_generation_config: Allow to customize access tokens. See pre_token_configuration_type
        :param pulumi.Input[builtins.str] user_migration: User migration Lambda config type.
        :param pulumi.Input[builtins.str] verify_auth_challenge_response: Verifies the authentication challenge response.
        """
        if create_auth_challenge is not None:
            pulumi.set(__self__, "create_auth_challenge", create_auth_challenge)
        if custom_email_sender is not None:
            pulumi.set(__self__, "custom_email_sender", custom_email_sender)
        if custom_message is not None:
            pulumi.set(__self__, "custom_message", custom_message)
        if custom_sms_sender is not None:
            pulumi.set(__self__, "custom_sms_sender", custom_sms_sender)
        if define_auth_challenge is not None:
            pulumi.set(__self__, "define_auth_challenge", define_auth_challenge)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if post_authentication is not None:
            pulumi.set(__self__, "post_authentication", post_authentication)
        if post_confirmation is not None:
            pulumi.set(__self__, "post_confirmation", post_confirmation)
        if pre_authentication is not None:
            pulumi.set(__self__, "pre_authentication", pre_authentication)
        if pre_sign_up is not None:
            pulumi.set(__self__, "pre_sign_up", pre_sign_up)
        if pre_token_generation is not None:
            pulumi.set(__self__, "pre_token_generation", pre_token_generation)
        if pre_token_generation_config is not None:
            pulumi.set(__self__, "pre_token_generation_config", pre_token_generation_config)
        if user_migration is not None:
            pulumi.set(__self__, "user_migration", user_migration)
        if verify_auth_challenge_response is not None:
            pulumi.set(__self__, "verify_auth_challenge_response", verify_auth_challenge_response)

    @property
    @pulumi.getter(name="createAuthChallenge")
    def create_auth_challenge(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of the lambda creating an authentication challenge.
        """
        return pulumi.get(self, "create_auth_challenge")

    @create_auth_challenge.setter
    def create_auth_challenge(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create_auth_challenge", value)

    @property
    @pulumi.getter(name="customEmailSender")
    def custom_email_sender(self) -> Optional[pulumi.Input['UserPoolLambdaConfigCustomEmailSenderArgs']]:
        """
        A custom email sender AWS Lambda trigger. See custom_email_sender Below.
        """
        return pulumi.get(self, "custom_email_sender")

    @custom_email_sender.setter
    def custom_email_sender(self, value: Optional[pulumi.Input['UserPoolLambdaConfigCustomEmailSenderArgs']]):
        pulumi.set(self, "custom_email_sender", value)

    @property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom Message AWS Lambda trigger.
        """
        return pulumi.get(self, "custom_message")

    @custom_message.setter
    def custom_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_message", value)

    @property
    @pulumi.getter(name="customSmsSender")
    def custom_sms_sender(self) -> Optional[pulumi.Input['UserPoolLambdaConfigCustomSmsSenderArgs']]:
        """
        A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
        """
        return pulumi.get(self, "custom_sms_sender")

    @custom_sms_sender.setter
    def custom_sms_sender(self, value: Optional[pulumi.Input['UserPoolLambdaConfigCustomSmsSenderArgs']]):
        pulumi.set(self, "custom_sms_sender", value)

    @property
    @pulumi.getter(name="defineAuthChallenge")
    def define_auth_challenge(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Defines the authentication challenge.
        """
        return pulumi.get(self, "define_auth_challenge")

    @define_auth_challenge.setter
    def define_auth_challenge(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "define_auth_challenge", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="postAuthentication")
    def post_authentication(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Post-authentication AWS Lambda trigger.
        """
        return pulumi.get(self, "post_authentication")

    @post_authentication.setter
    def post_authentication(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "post_authentication", value)

    @property
    @pulumi.getter(name="postConfirmation")
    def post_confirmation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Post-confirmation AWS Lambda trigger.
        """
        return pulumi.get(self, "post_confirmation")

    @post_confirmation.setter
    def post_confirmation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "post_confirmation", value)

    @property
    @pulumi.getter(name="preAuthentication")
    def pre_authentication(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pre-authentication AWS Lambda trigger.
        """
        return pulumi.get(self, "pre_authentication")

    @pre_authentication.setter
    def pre_authentication(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pre_authentication", value)

    @property
    @pulumi.getter(name="preSignUp")
    def pre_sign_up(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pre-registration AWS Lambda trigger.
        """
        return pulumi.get(self, "pre_sign_up")

    @pre_sign_up.setter
    def pre_sign_up(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pre_sign_up", value)

    @property
    @pulumi.getter(name="preTokenGeneration")
    def pre_token_generation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allow to customize identity token claims before token generation. Set this parameter for legacy purposes; for new instances of pre token generation triggers, set the lambda_arn of `pre_token_generation_config`.
        """
        return pulumi.get(self, "pre_token_generation")

    @pre_token_generation.setter
    def pre_token_generation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pre_token_generation", value)

    @property
    @pulumi.getter(name="preTokenGenerationConfig")
    def pre_token_generation_config(self) -> Optional[pulumi.Input['UserPoolLambdaConfigPreTokenGenerationConfigArgs']]:
        """
        Allow to customize access tokens. See pre_token_configuration_type
        """
        return pulumi.get(self, "pre_token_generation_config")

    @pre_token_generation_config.setter
    def pre_token_generation_config(self, value: Optional[pulumi.Input['UserPoolLambdaConfigPreTokenGenerationConfigArgs']]):
        pulumi.set(self, "pre_token_generation_config", value)

    @property
    @pulumi.getter(name="userMigration")
    def user_migration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User migration Lambda config type.
        """
        return pulumi.get(self, "user_migration")

    @user_migration.setter
    def user_migration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_migration", value)

    @property
    @pulumi.getter(name="verifyAuthChallengeResponse")
    def verify_auth_challenge_response(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Verifies the authentication challenge response.
        """
        return pulumi.get(self, "verify_auth_challenge_response")

    @verify_auth_challenge_response.setter
    def verify_auth_challenge_response(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "verify_auth_challenge_response", value)


if not MYPY:
    class UserPoolLambdaConfigCustomEmailSenderArgsDict(TypedDict):
        lambda_arn: pulumi.Input[builtins.str]
        """
        The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
        """
        lambda_version: pulumi.Input[builtins.str]
        """
        The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is `V1_0`.
        """
elif False:
    UserPoolLambdaConfigCustomEmailSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolLambdaConfigCustomEmailSenderArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[builtins.str],
                 lambda_version: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] lambda_arn: The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
        :param pulumi.Input[builtins.str] lambda_version: The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is `V1_0`.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> pulumi.Input[builtins.str]:
        """
        The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is `V1_0`.
        """
        return pulumi.get(self, "lambda_version")

    @lambda_version.setter
    def lambda_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_version", value)


if not MYPY:
    class UserPoolLambdaConfigCustomSmsSenderArgsDict(TypedDict):
        lambda_arn: pulumi.Input[builtins.str]
        """
        The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
        """
        lambda_version: pulumi.Input[builtins.str]
        """
        The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is `V1_0`.
        """
elif False:
    UserPoolLambdaConfigCustomSmsSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolLambdaConfigCustomSmsSenderArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[builtins.str],
                 lambda_version: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] lambda_arn: The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
        :param pulumi.Input[builtins.str] lambda_version: The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is `V1_0`.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> pulumi.Input[builtins.str]:
        """
        The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is `V1_0`.
        """
        return pulumi.get(self, "lambda_version")

    @lambda_version.setter
    def lambda_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_version", value)


if not MYPY:
    class UserPoolLambdaConfigPreTokenGenerationConfigArgsDict(TypedDict):
        lambda_arn: pulumi.Input[builtins.str]
        lambda_version: pulumi.Input[builtins.str]
elif False:
    UserPoolLambdaConfigPreTokenGenerationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolLambdaConfigPreTokenGenerationConfigArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[builtins.str],
                 lambda_version: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "lambda_version", lambda_version)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @property
    @pulumi.getter(name="lambdaVersion")
    def lambda_version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "lambda_version")

    @lambda_version.setter
    def lambda_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_version", value)


if not MYPY:
    class UserPoolPasswordPolicyArgsDict(TypedDict):
        minimum_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum length of the password policy that you have set.
        """
        password_history_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.

        **Note:** This argument requires advanced security features to be active in the user pool.
        """
        require_lowercase: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether you have required users to use at least one lowercase letter in their password.
        """
        require_numbers: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether you have required users to use at least one number in their password.
        """
        require_symbols: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether you have required users to use at least one symbol in their password.
        """
        require_uppercase: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether you have required users to use at least one uppercase letter in their password.
        """
        temporary_password_validity_days: NotRequired[pulumi.Input[builtins.int]]
        """
        In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
        """
elif False:
    UserPoolPasswordPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolPasswordPolicyArgs:
    def __init__(__self__, *,
                 minimum_length: Optional[pulumi.Input[builtins.int]] = None,
                 password_history_size: Optional[pulumi.Input[builtins.int]] = None,
                 require_lowercase: Optional[pulumi.Input[builtins.bool]] = None,
                 require_numbers: Optional[pulumi.Input[builtins.bool]] = None,
                 require_symbols: Optional[pulumi.Input[builtins.bool]] = None,
                 require_uppercase: Optional[pulumi.Input[builtins.bool]] = None,
                 temporary_password_validity_days: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] minimum_length: Minimum length of the password policy that you have set.
        :param pulumi.Input[builtins.int] password_history_size: Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.
               
               **Note:** This argument requires advanced security features to be active in the user pool.
        :param pulumi.Input[builtins.bool] require_lowercase: Whether you have required users to use at least one lowercase letter in their password.
        :param pulumi.Input[builtins.bool] require_numbers: Whether you have required users to use at least one number in their password.
        :param pulumi.Input[builtins.bool] require_symbols: Whether you have required users to use at least one symbol in their password.
        :param pulumi.Input[builtins.bool] require_uppercase: Whether you have required users to use at least one uppercase letter in their password.
        :param pulumi.Input[builtins.int] temporary_password_validity_days: In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
        """
        if minimum_length is not None:
            pulumi.set(__self__, "minimum_length", minimum_length)
        if password_history_size is not None:
            pulumi.set(__self__, "password_history_size", password_history_size)
        if require_lowercase is not None:
            pulumi.set(__self__, "require_lowercase", require_lowercase)
        if require_numbers is not None:
            pulumi.set(__self__, "require_numbers", require_numbers)
        if require_symbols is not None:
            pulumi.set(__self__, "require_symbols", require_symbols)
        if require_uppercase is not None:
            pulumi.set(__self__, "require_uppercase", require_uppercase)
        if temporary_password_validity_days is not None:
            pulumi.set(__self__, "temporary_password_validity_days", temporary_password_validity_days)

    @property
    @pulumi.getter(name="minimumLength")
    def minimum_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum length of the password policy that you have set.
        """
        return pulumi.get(self, "minimum_length")

    @minimum_length.setter
    def minimum_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum_length", value)

    @property
    @pulumi.getter(name="passwordHistorySize")
    def password_history_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of previous passwords that you want Amazon Cognito to restrict each user from reusing. Users can't set a password that matches any of number of previous passwords specified by this argument. A value of 0 means that password history is not enforced. Valid values are between 0 and 24.

        **Note:** This argument requires advanced security features to be active in the user pool.
        """
        return pulumi.get(self, "password_history_size")

    @password_history_size.setter
    def password_history_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "password_history_size", value)

    @property
    @pulumi.getter(name="requireLowercase")
    def require_lowercase(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether you have required users to use at least one lowercase letter in their password.
        """
        return pulumi.get(self, "require_lowercase")

    @require_lowercase.setter
    def require_lowercase(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_lowercase", value)

    @property
    @pulumi.getter(name="requireNumbers")
    def require_numbers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether you have required users to use at least one number in their password.
        """
        return pulumi.get(self, "require_numbers")

    @require_numbers.setter
    def require_numbers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_numbers", value)

    @property
    @pulumi.getter(name="requireSymbols")
    def require_symbols(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether you have required users to use at least one symbol in their password.
        """
        return pulumi.get(self, "require_symbols")

    @require_symbols.setter
    def require_symbols(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_symbols", value)

    @property
    @pulumi.getter(name="requireUppercase")
    def require_uppercase(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether you have required users to use at least one uppercase letter in their password.
        """
        return pulumi.get(self, "require_uppercase")

    @require_uppercase.setter
    def require_uppercase(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_uppercase", value)

    @property
    @pulumi.getter(name="temporaryPasswordValidityDays")
    def temporary_password_validity_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
        """
        return pulumi.get(self, "temporary_password_validity_days")

    @temporary_password_validity_days.setter
    def temporary_password_validity_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "temporary_password_validity_days", value)


if not MYPY:
    class UserPoolSchemaArgsDict(TypedDict):
        attribute_data_type: pulumi.Input[builtins.str]
        """
        Attribute data type. Must be one of `Boolean`, `Number`, `String`, `DateTime`.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the attribute.
        """
        developer_only_attribute: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the attribute type is developer only.
        """
        mutable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the attribute can be changed once it has been created.
        """
        number_attribute_constraints: NotRequired[pulumi.Input['UserPoolSchemaNumberAttributeConstraintsArgsDict']]
        """
        Configuration block for the constraints for an attribute of the number type. Detailed below.
        """
        required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
        """
        string_attribute_constraints: NotRequired[pulumi.Input['UserPoolSchemaStringAttributeConstraintsArgsDict']]
        """
        Constraints for an attribute of the string type. Detailed below.
        """
elif False:
    UserPoolSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSchemaArgs:
    def __init__(__self__, *,
                 attribute_data_type: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 developer_only_attribute: Optional[pulumi.Input[builtins.bool]] = None,
                 mutable: Optional[pulumi.Input[builtins.bool]] = None,
                 number_attribute_constraints: Optional[pulumi.Input['UserPoolSchemaNumberAttributeConstraintsArgs']] = None,
                 required: Optional[pulumi.Input[builtins.bool]] = None,
                 string_attribute_constraints: Optional[pulumi.Input['UserPoolSchemaStringAttributeConstraintsArgs']] = None):
        """
        :param pulumi.Input[builtins.str] attribute_data_type: Attribute data type. Must be one of `Boolean`, `Number`, `String`, `DateTime`.
        :param pulumi.Input[builtins.str] name: Name of the attribute.
        :param pulumi.Input[builtins.bool] developer_only_attribute: Whether the attribute type is developer only.
        :param pulumi.Input[builtins.bool] mutable: Whether the attribute can be changed once it has been created.
        :param pulumi.Input['UserPoolSchemaNumberAttributeConstraintsArgs'] number_attribute_constraints: Configuration block for the constraints for an attribute of the number type. Detailed below.
        :param pulumi.Input[builtins.bool] required: Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
        :param pulumi.Input['UserPoolSchemaStringAttributeConstraintsArgs'] string_attribute_constraints: Constraints for an attribute of the string type. Detailed below.
        """
        pulumi.set(__self__, "attribute_data_type", attribute_data_type)
        pulumi.set(__self__, "name", name)
        if developer_only_attribute is not None:
            pulumi.set(__self__, "developer_only_attribute", developer_only_attribute)
        if mutable is not None:
            pulumi.set(__self__, "mutable", mutable)
        if number_attribute_constraints is not None:
            pulumi.set(__self__, "number_attribute_constraints", number_attribute_constraints)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if string_attribute_constraints is not None:
            pulumi.set(__self__, "string_attribute_constraints", string_attribute_constraints)

    @property
    @pulumi.getter(name="attributeDataType")
    def attribute_data_type(self) -> pulumi.Input[builtins.str]:
        """
        Attribute data type. Must be one of `Boolean`, `Number`, `String`, `DateTime`.
        """
        return pulumi.get(self, "attribute_data_type")

    @attribute_data_type.setter
    def attribute_data_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "attribute_data_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="developerOnlyAttribute")
    def developer_only_attribute(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the attribute type is developer only.
        """
        return pulumi.get(self, "developer_only_attribute")

    @developer_only_attribute.setter
    def developer_only_attribute(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "developer_only_attribute", value)

    @property
    @pulumi.getter
    def mutable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the attribute can be changed once it has been created.
        """
        return pulumi.get(self, "mutable")

    @mutable.setter
    def mutable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mutable", value)

    @property
    @pulumi.getter(name="numberAttributeConstraints")
    def number_attribute_constraints(self) -> Optional[pulumi.Input['UserPoolSchemaNumberAttributeConstraintsArgs']]:
        """
        Configuration block for the constraints for an attribute of the number type. Detailed below.
        """
        return pulumi.get(self, "number_attribute_constraints")

    @number_attribute_constraints.setter
    def number_attribute_constraints(self, value: Optional[pulumi.Input['UserPoolSchemaNumberAttributeConstraintsArgs']]):
        pulumi.set(self, "number_attribute_constraints", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="stringAttributeConstraints")
    def string_attribute_constraints(self) -> Optional[pulumi.Input['UserPoolSchemaStringAttributeConstraintsArgs']]:
        """
        Constraints for an attribute of the string type. Detailed below.
        """
        return pulumi.get(self, "string_attribute_constraints")

    @string_attribute_constraints.setter
    def string_attribute_constraints(self, value: Optional[pulumi.Input['UserPoolSchemaStringAttributeConstraintsArgs']]):
        pulumi.set(self, "string_attribute_constraints", value)


if not MYPY:
    class UserPoolSchemaNumberAttributeConstraintsArgsDict(TypedDict):
        max_value: NotRequired[pulumi.Input[builtins.str]]
        """
        Maximum value of an attribute that is of the number data type.
        """
        min_value: NotRequired[pulumi.Input[builtins.str]]
        """
        Minimum value of an attribute that is of the number data type.
        """
elif False:
    UserPoolSchemaNumberAttributeConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSchemaNumberAttributeConstraintsArgs:
    def __init__(__self__, *,
                 max_value: Optional[pulumi.Input[builtins.str]] = None,
                 min_value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] max_value: Maximum value of an attribute that is of the number data type.
        :param pulumi.Input[builtins.str] min_value: Minimum value of an attribute that is of the number data type.
        """
        if max_value is not None:
            pulumi.set(__self__, "max_value", max_value)
        if min_value is not None:
            pulumi.set(__self__, "min_value", min_value)

    @property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maximum value of an attribute that is of the number data type.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_value", value)

    @property
    @pulumi.getter(name="minValue")
    def min_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Minimum value of an attribute that is of the number data type.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_value", value)


if not MYPY:
    class UserPoolSchemaStringAttributeConstraintsArgsDict(TypedDict):
        max_length: NotRequired[pulumi.Input[builtins.str]]
        """
        Maximum length of an attribute value of the string type.
        """
        min_length: NotRequired[pulumi.Input[builtins.str]]
        """
        Minimum length of an attribute value of the string type.
        """
elif False:
    UserPoolSchemaStringAttributeConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSchemaStringAttributeConstraintsArgs:
    def __init__(__self__, *,
                 max_length: Optional[pulumi.Input[builtins.str]] = None,
                 min_length: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] max_length: Maximum length of an attribute value of the string type.
        :param pulumi.Input[builtins.str] min_length: Minimum length of an attribute value of the string type.
        """
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maximum length of an attribute value of the string type.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Minimum length of an attribute value of the string type.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_length", value)


if not MYPY:
    class UserPoolSignInPolicyArgsDict(TypedDict):
        allowed_first_auth_factors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The sign in methods your user pool supports as the first factor. This is a list of strings, allowed values are `PASSWORD`, `EMAIL_OTP`, `SMS_OTP`, and `WEB_AUTHN`.
        """
elif False:
    UserPoolSignInPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSignInPolicyArgs:
    def __init__(__self__, *,
                 allowed_first_auth_factors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_first_auth_factors: The sign in methods your user pool supports as the first factor. This is a list of strings, allowed values are `PASSWORD`, `EMAIL_OTP`, `SMS_OTP`, and `WEB_AUTHN`.
        """
        if allowed_first_auth_factors is not None:
            pulumi.set(__self__, "allowed_first_auth_factors", allowed_first_auth_factors)

    @property
    @pulumi.getter(name="allowedFirstAuthFactors")
    def allowed_first_auth_factors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The sign in methods your user pool supports as the first factor. This is a list of strings, allowed values are `PASSWORD`, `EMAIL_OTP`, `SMS_OTP`, and `WEB_AUTHN`.
        """
        return pulumi.get(self, "allowed_first_auth_factors")

    @allowed_first_auth_factors.setter
    def allowed_first_auth_factors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_first_auth_factors", value)


if not MYPY:
    class UserPoolSmsConfigurationArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        External ID used in IAM role trust relationships. For more information about using external IDs, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html).
        """
        sns_caller_arn: pulumi.Input[builtins.str]
        """
        ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
        """
        sns_region: NotRequired[pulumi.Input[builtins.str]]
        """
        The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see [SMS message settings for Amazon Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-sms-settings.html).
        """
elif False:
    UserPoolSmsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSmsConfigurationArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 sns_caller_arn: pulumi.Input[builtins.str],
                 sns_region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] external_id: External ID used in IAM role trust relationships. For more information about using external IDs, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html).
        :param pulumi.Input[builtins.str] sns_caller_arn: ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
        :param pulumi.Input[builtins.str] sns_region: The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see [SMS message settings for Amazon Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-sms-settings.html).
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "sns_caller_arn", sns_caller_arn)
        if sns_region is not None:
            pulumi.set(__self__, "sns_region", sns_region)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        External ID used in IAM role trust relationships. For more information about using external IDs, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html).
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="snsCallerArn")
    def sns_caller_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
        """
        return pulumi.get(self, "sns_caller_arn")

    @sns_caller_arn.setter
    def sns_caller_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sns_caller_arn", value)

    @property
    @pulumi.getter(name="snsRegion")
    def sns_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see [SMS message settings for Amazon Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-sms-settings.html).
        """
        return pulumi.get(self, "sns_region")

    @sns_region.setter
    def sns_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sns_region", value)


if not MYPY:
    class UserPoolSoftwareTokenMfaConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When `sms_configuration` is not present, the `mfa_configuration` argument must be set to `OFF` and the `software_token_mfa_configuration` configuration block must be fully removed.
        """
elif False:
    UserPoolSoftwareTokenMfaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolSoftwareTokenMfaConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] enabled: Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When `sms_configuration` is not present, the `mfa_configuration` argument must be set to `OFF` and the `software_token_mfa_configuration` configuration block must be fully removed.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When `sms_configuration` is not present, the `mfa_configuration` argument must be set to `OFF` and the `software_token_mfa_configuration` configuration block must be fully removed.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class UserPoolUserAttributeUpdateSettingsArgsDict(TypedDict):
        attributes_require_verification_before_updates: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of attributes requiring verification before update. If set, the provided value(s) must also be set in `auto_verified_attributes`. Valid values: `email`, `phone_number`.
        """
elif False:
    UserPoolUserAttributeUpdateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolUserAttributeUpdateSettingsArgs:
    def __init__(__self__, *,
                 attributes_require_verification_before_updates: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] attributes_require_verification_before_updates: A list of attributes requiring verification before update. If set, the provided value(s) must also be set in `auto_verified_attributes`. Valid values: `email`, `phone_number`.
        """
        pulumi.set(__self__, "attributes_require_verification_before_updates", attributes_require_verification_before_updates)

    @property
    @pulumi.getter(name="attributesRequireVerificationBeforeUpdates")
    def attributes_require_verification_before_updates(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of attributes requiring verification before update. If set, the provided value(s) must also be set in `auto_verified_attributes`. Valid values: `email`, `phone_number`.
        """
        return pulumi.get(self, "attributes_require_verification_before_updates")

    @attributes_require_verification_before_updates.setter
    def attributes_require_verification_before_updates(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "attributes_require_verification_before_updates", value)


if not MYPY:
    class UserPoolUserPoolAddOnsArgsDict(TypedDict):
        advanced_security_mode: pulumi.Input[builtins.str]
        """
        Mode for advanced security, must be one of `OFF`, `AUDIT` or `ENFORCED`.
        """
elif False:
    UserPoolUserPoolAddOnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolUserPoolAddOnsArgs:
    def __init__(__self__, *,
                 advanced_security_mode: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] advanced_security_mode: Mode for advanced security, must be one of `OFF`, `AUDIT` or `ENFORCED`.
        """
        pulumi.set(__self__, "advanced_security_mode", advanced_security_mode)

    @property
    @pulumi.getter(name="advancedSecurityMode")
    def advanced_security_mode(self) -> pulumi.Input[builtins.str]:
        """
        Mode for advanced security, must be one of `OFF`, `AUDIT` or `ENFORCED`.
        """
        return pulumi.get(self, "advanced_security_mode")

    @advanced_security_mode.setter
    def advanced_security_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "advanced_security_mode", value)


if not MYPY:
    class UserPoolUsernameConfigurationArgsDict(TypedDict):
        case_sensitive: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
        """
elif False:
    UserPoolUsernameConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolUsernameConfigurationArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] case_sensitive: Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)


if not MYPY:
    class UserPoolVerificationMessageTemplateArgsDict(TypedDict):
        default_email_option: NotRequired[pulumi.Input[builtins.str]]
        """
        Default email option. Must be either `CONFIRM_WITH_CODE` or `CONFIRM_WITH_LINK`. Defaults to `CONFIRM_WITH_CODE`.
        """
        email_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Email message template. Must contain the `{####}` placeholder. Conflicts with `email_verification_message` argument.
        """
        email_message_by_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Email message template for sending a confirmation link to the user, it must contain the `{##Click Here##}` placeholder.
        """
        email_subject: NotRequired[pulumi.Input[builtins.str]]
        """
        Subject line for the email message template. Conflicts with `email_verification_subject` argument.
        """
        email_subject_by_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Subject line for the email message template for sending a confirmation link to the user.
        """
        sms_message: NotRequired[pulumi.Input[builtins.str]]
        """
        SMS message template. Must contain the `{####}` placeholder. Conflicts with `sms_verification_message` argument.
        """
elif False:
    UserPoolVerificationMessageTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolVerificationMessageTemplateArgs:
    def __init__(__self__, *,
                 default_email_option: Optional[pulumi.Input[builtins.str]] = None,
                 email_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_message_by_link: Optional[pulumi.Input[builtins.str]] = None,
                 email_subject: Optional[pulumi.Input[builtins.str]] = None,
                 email_subject_by_link: Optional[pulumi.Input[builtins.str]] = None,
                 sms_message: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] default_email_option: Default email option. Must be either `CONFIRM_WITH_CODE` or `CONFIRM_WITH_LINK`. Defaults to `CONFIRM_WITH_CODE`.
        :param pulumi.Input[builtins.str] email_message: Email message template. Must contain the `{####}` placeholder. Conflicts with `email_verification_message` argument.
        :param pulumi.Input[builtins.str] email_message_by_link: Email message template for sending a confirmation link to the user, it must contain the `{##Click Here##}` placeholder.
        :param pulumi.Input[builtins.str] email_subject: Subject line for the email message template. Conflicts with `email_verification_subject` argument.
        :param pulumi.Input[builtins.str] email_subject_by_link: Subject line for the email message template for sending a confirmation link to the user.
        :param pulumi.Input[builtins.str] sms_message: SMS message template. Must contain the `{####}` placeholder. Conflicts with `sms_verification_message` argument.
        """
        if default_email_option is not None:
            pulumi.set(__self__, "default_email_option", default_email_option)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_message_by_link is not None:
            pulumi.set(__self__, "email_message_by_link", email_message_by_link)
        if email_subject is not None:
            pulumi.set(__self__, "email_subject", email_subject)
        if email_subject_by_link is not None:
            pulumi.set(__self__, "email_subject_by_link", email_subject_by_link)
        if sms_message is not None:
            pulumi.set(__self__, "sms_message", sms_message)

    @property
    @pulumi.getter(name="defaultEmailOption")
    def default_email_option(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default email option. Must be either `CONFIRM_WITH_CODE` or `CONFIRM_WITH_LINK`. Defaults to `CONFIRM_WITH_CODE`.
        """
        return pulumi.get(self, "default_email_option")

    @default_email_option.setter
    def default_email_option(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_email_option", value)

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Email message template. Must contain the `{####}` placeholder. Conflicts with `email_verification_message` argument.
        """
        return pulumi.get(self, "email_message")

    @email_message.setter
    def email_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_message", value)

    @property
    @pulumi.getter(name="emailMessageByLink")
    def email_message_by_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Email message template for sending a confirmation link to the user, it must contain the `{##Click Here##}` placeholder.
        """
        return pulumi.get(self, "email_message_by_link")

    @email_message_by_link.setter
    def email_message_by_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_message_by_link", value)

    @property
    @pulumi.getter(name="emailSubject")
    def email_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subject line for the email message template. Conflicts with `email_verification_subject` argument.
        """
        return pulumi.get(self, "email_subject")

    @email_subject.setter
    def email_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_subject", value)

    @property
    @pulumi.getter(name="emailSubjectByLink")
    def email_subject_by_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subject line for the email message template for sending a confirmation link to the user.
        """
        return pulumi.get(self, "email_subject_by_link")

    @email_subject_by_link.setter
    def email_subject_by_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_subject_by_link", value)

    @property
    @pulumi.getter(name="smsMessage")
    def sms_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SMS message template. Must contain the `{####}` placeholder. Conflicts with `sms_verification_message` argument.
        """
        return pulumi.get(self, "sms_message")

    @sms_message.setter
    def sms_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_message", value)


if not MYPY:
    class UserPoolWebAuthnConfigurationArgsDict(TypedDict):
        relying_party_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The authentication domain that passkeys providers use as a relying party.
        """
        user_verification: NotRequired[pulumi.Input[builtins.str]]
        """
        If your user pool should require a passkey. Must be one of `required` or `preferred`.
        """
elif False:
    UserPoolWebAuthnConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPoolWebAuthnConfigurationArgs:
    def __init__(__self__, *,
                 relying_party_id: Optional[pulumi.Input[builtins.str]] = None,
                 user_verification: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] relying_party_id: The authentication domain that passkeys providers use as a relying party.
        :param pulumi.Input[builtins.str] user_verification: If your user pool should require a passkey. Must be one of `required` or `preferred`.
        """
        if relying_party_id is not None:
            pulumi.set(__self__, "relying_party_id", relying_party_id)
        if user_verification is not None:
            pulumi.set(__self__, "user_verification", user_verification)

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authentication domain that passkeys providers use as a relying party.
        """
        return pulumi.get(self, "relying_party_id")

    @relying_party_id.setter
    def relying_party_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "relying_party_id", value)

    @property
    @pulumi.getter(name="userVerification")
    def user_verification(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If your user pool should require a passkey. Must be one of `required` or `preferred`.
        """
        return pulumi.get(self, "user_verification")

    @user_verification.setter
    def user_verification(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_verification", value)


