# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'EventSourcesConfigEventSourceArgs',
    'EventSourcesConfigEventSourceArgsDict',
    'EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgs',
    'EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgsDict',
    'NotificationChannelFiltersArgs',
    'NotificationChannelFiltersArgsDict',
    'NotificationChannelSnsArgs',
    'NotificationChannelSnsArgsDict',
    'ResourceCollectionCloudformationArgs',
    'ResourceCollectionCloudformationArgsDict',
    'ResourceCollectionTagsArgs',
    'ResourceCollectionTagsArgsDict',
    'ServiceIntegrationKmsServerSideEncryptionArgs',
    'ServiceIntegrationKmsServerSideEncryptionArgsDict',
    'ServiceIntegrationLogsAnomalyDetectionArgs',
    'ServiceIntegrationLogsAnomalyDetectionArgsDict',
    'ServiceIntegrationOpsCenterArgs',
    'ServiceIntegrationOpsCenterArgsDict',
    'GetNotificationChannelFilterArgs',
    'GetNotificationChannelFilterArgsDict',
    'GetNotificationChannelSnArgs',
    'GetNotificationChannelSnArgsDict',
]

MYPY = False

if not MYPY:
    class EventSourcesConfigEventSourceArgsDict(TypedDict):
        amazon_code_guru_profilers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgsDict']]]]
elif False:
    EventSourcesConfigEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourcesConfigEventSourceArgs:
    def __init__(__self__, *,
                 amazon_code_guru_profilers: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgs']]]] = None):
        if amazon_code_guru_profilers is not None:
            pulumi.set(__self__, "amazon_code_guru_profilers", amazon_code_guru_profilers)

    @_builtins.property
    @pulumi.getter(name="amazonCodeGuruProfilers")
    def amazon_code_guru_profilers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgs']]]]:
        return pulumi.get(self, "amazon_code_guru_profilers")

    @amazon_code_guru_profilers.setter
    def amazon_code_guru_profilers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgs']]]]):
        pulumi.set(self, "amazon_code_guru_profilers", value)


if not MYPY:
    class EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
elif False:
    EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourcesConfigEventSourceAmazonCodeGuruProfilerArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NotificationChannelFiltersArgsDict(TypedDict):
        message_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    NotificationChannelFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationChannelFiltersArgs:
    def __init__(__self__, *,
                 message_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if message_types is not None:
            pulumi.set(__self__, "message_types", message_types)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="messageTypes")
    def message_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "message_types")

    @message_types.setter
    def message_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "message_types", value)

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class NotificationChannelSnsArgsDict(TypedDict):
        topic_arn: pulumi.Input[_builtins.str]
elif False:
    NotificationChannelSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationChannelSnsArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "topic_arn", topic_arn)

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_arn", value)


if not MYPY:
    class ResourceCollectionCloudformationArgsDict(TypedDict):
        stack_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ResourceCollectionCloudformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCollectionCloudformationArgs:
    def __init__(__self__, *,
                 stack_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "stack_names", stack_names)

    @_builtins.property
    @pulumi.getter(name="stackNames")
    def stack_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "stack_names")

    @stack_names.setter
    def stack_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "stack_names", value)


if not MYPY:
    class ResourceCollectionTagsArgsDict(TypedDict):
        app_boundary_key: pulumi.Input[_builtins.str]
        tag_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ResourceCollectionTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceCollectionTagsArgs:
    def __init__(__self__, *,
                 app_boundary_key: pulumi.Input[_builtins.str],
                 tag_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "app_boundary_key", app_boundary_key)
        pulumi.set(__self__, "tag_values", tag_values)

    @_builtins.property
    @pulumi.getter(name="appBoundaryKey")
    def app_boundary_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "app_boundary_key")

    @app_boundary_key.setter
    def app_boundary_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_boundary_key", value)

    @_builtins.property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "tag_values")

    @tag_values.setter
    def tag_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "tag_values", value)


if not MYPY:
    class ServiceIntegrationKmsServerSideEncryptionArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        opt_in_status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceIntegrationKmsServerSideEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationKmsServerSideEncryptionArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 opt_in_status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if opt_in_status is not None:
            pulumi.set(__self__, "opt_in_status", opt_in_status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="optInStatus")
    def opt_in_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "opt_in_status")

    @opt_in_status.setter
    def opt_in_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opt_in_status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceIntegrationLogsAnomalyDetectionArgsDict(TypedDict):
        opt_in_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceIntegrationLogsAnomalyDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationLogsAnomalyDetectionArgs:
    def __init__(__self__, *,
                 opt_in_status: Optional[pulumi.Input[_builtins.str]] = None):
        if opt_in_status is not None:
            pulumi.set(__self__, "opt_in_status", opt_in_status)

    @_builtins.property
    @pulumi.getter(name="optInStatus")
    def opt_in_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "opt_in_status")

    @opt_in_status.setter
    def opt_in_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opt_in_status", value)


if not MYPY:
    class ServiceIntegrationOpsCenterArgsDict(TypedDict):
        opt_in_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceIntegrationOpsCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationOpsCenterArgs:
    def __init__(__self__, *,
                 opt_in_status: Optional[pulumi.Input[_builtins.str]] = None):
        if opt_in_status is not None:
            pulumi.set(__self__, "opt_in_status", opt_in_status)

    @_builtins.property
    @pulumi.getter(name="optInStatus")
    def opt_in_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "opt_in_status")

    @opt_in_status.setter
    def opt_in_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opt_in_status", value)


if not MYPY:
    class GetNotificationChannelFilterArgsDict(TypedDict):
        message_types: Sequence[_builtins.str]
        severities: Sequence[_builtins.str]
elif False:
    GetNotificationChannelFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNotificationChannelFilterArgs:
    def __init__(__self__, *,
                 message_types: Sequence[_builtins.str],
                 severities: Sequence[_builtins.str]):
        pulumi.set(__self__, "message_types", message_types)
        pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="messageTypes")
    def message_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "message_types")

    @message_types.setter
    def message_types(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "message_types", value)

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class GetNotificationChannelSnArgsDict(TypedDict):
        topic_arn: _builtins.str
elif False:
    GetNotificationChannelSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNotificationChannelSnArgs:
    def __init__(__self__, *,
                 topic_arn: _builtins.str):
        pulumi.set(__self__, "topic_arn", topic_arn)

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> _builtins.str:
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: _builtins.str):
        pulumi.set(self, "topic_arn", value)


