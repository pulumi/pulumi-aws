# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterCacheNode',
    'ClusterLogDeliveryConfiguration',
    'GlobalReplicationGroupGlobalNodeGroup',
    'ParameterGroupParameter',
    'ReplicationGroupLogDeliveryConfiguration',
    'ReplicationGroupNodeGroupConfiguration',
    'ReservedCacheNodeRecurringCharge',
    'ReservedCacheNodeTimeouts',
    'ServerlessCacheCacheUsageLimits',
    'ServerlessCacheCacheUsageLimitsDataStorage',
    'ServerlessCacheCacheUsageLimitsEcpuPerSecond',
    'ServerlessCacheEndpoint',
    'ServerlessCacheReaderEndpoint',
    'ServerlessCacheTimeouts',
    'UserAuthenticationMode',
    'GetClusterCacheNodeResult',
    'GetClusterLogDeliveryConfigurationResult',
    'GetReplicationGroupLogDeliveryConfigurationResult',
    'GetReplicationGroupNodeGroupConfigurationResult',
    'GetServerlessCacheCacheUsageLimitsResult',
    'GetServerlessCacheCacheUsageLimitsDataStorageResult',
    'GetServerlessCacheCacheUsageLimitsEcpuPerSecondResult',
    'GetServerlessCacheEndpointResult',
    'GetServerlessCacheReaderEndpointResult',
    'GetUserAuthenticationModeResult',
]

@pulumi.output_type
class ClusterCacheNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "outpostArn":
            suggest = "outpost_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCacheNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCacheNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCacheNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 outpost_arn: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ClusterLogDeliveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogDeliveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogDeliveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogDeliveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 destination_type: _builtins.str,
                 log_format: _builtins.str,
                 log_type: _builtins.str):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")


@pulumi.output_type
class GlobalReplicationGroupGlobalNodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalNodeGroupId":
            suggest = "global_node_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalReplicationGroupGlobalNodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalReplicationGroupGlobalNodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalReplicationGroupGlobalNodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_node_group_id: Optional[_builtins.str] = None,
                 slots: Optional[_builtins.str] = None):
        if global_node_group_id is not None:
            pulumi.set(__self__, "global_node_group_id", global_node_group_id)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter(name="globalNodeGroupId")
    def global_node_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "global_node_group_id")

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slots")


@pulumi.output_type
class ParameterGroupParameter(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ReplicationGroupLogDeliveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationGroupLogDeliveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationGroupLogDeliveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationGroupLogDeliveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 destination_type: _builtins.str,
                 log_format: _builtins.str,
                 log_type: _builtins.str):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")


@pulumi.output_type
class ReplicationGroupNodeGroupConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeGroupId":
            suggest = "node_group_id"
        elif key == "primaryAvailabilityZone":
            suggest = "primary_availability_zone"
        elif key == "primaryOutpostArn":
            suggest = "primary_outpost_arn"
        elif key == "replicaAvailabilityZones":
            suggest = "replica_availability_zones"
        elif key == "replicaCount":
            suggest = "replica_count"
        elif key == "replicaOutpostArns":
            suggest = "replica_outpost_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationGroupNodeGroupConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationGroupNodeGroupConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationGroupNodeGroupConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_group_id: Optional[_builtins.str] = None,
                 primary_availability_zone: Optional[_builtins.str] = None,
                 primary_outpost_arn: Optional[_builtins.str] = None,
                 replica_availability_zones: Optional[Sequence[_builtins.str]] = None,
                 replica_count: Optional[_builtins.int] = None,
                 replica_outpost_arns: Optional[Sequence[_builtins.str]] = None,
                 slots: Optional[_builtins.str] = None):
        if node_group_id is not None:
            pulumi.set(__self__, "node_group_id", node_group_id)
        if primary_availability_zone is not None:
            pulumi.set(__self__, "primary_availability_zone", primary_availability_zone)
        if primary_outpost_arn is not None:
            pulumi.set(__self__, "primary_outpost_arn", primary_outpost_arn)
        if replica_availability_zones is not None:
            pulumi.set(__self__, "replica_availability_zones", replica_availability_zones)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)
        if replica_outpost_arns is not None:
            pulumi.set(__self__, "replica_outpost_arns", replica_outpost_arns)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter(name="nodeGroupId")
    def node_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_group_id")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilityZone")
    def primary_availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_availability_zone")

    @_builtins.property
    @pulumi.getter(name="primaryOutpostArn")
    def primary_outpost_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_outpost_arn")

    @_builtins.property
    @pulumi.getter(name="replicaAvailabilityZones")
    def replica_availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "replica_availability_zones")

    @_builtins.property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "replica_count")

    @_builtins.property
    @pulumi.getter(name="replicaOutpostArns")
    def replica_outpost_arns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "replica_outpost_arns")

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slots")


@pulumi.output_type
class ReservedCacheNodeRecurringCharge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurringChargeAmount":
            suggest = "recurring_charge_amount"
        elif key == "recurringChargeFrequency":
            suggest = "recurring_charge_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReservedCacheNodeRecurringCharge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReservedCacheNodeRecurringCharge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReservedCacheNodeRecurringCharge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurring_charge_amount: _builtins.float,
                 recurring_charge_frequency: _builtins.str):
        pulumi.set(__self__, "recurring_charge_amount", recurring_charge_amount)
        pulumi.set(__self__, "recurring_charge_frequency", recurring_charge_frequency)

    @_builtins.property
    @pulumi.getter(name="recurringChargeAmount")
    def recurring_charge_amount(self) -> _builtins.float:
        return pulumi.get(self, "recurring_charge_amount")

    @_builtins.property
    @pulumi.getter(name="recurringChargeFrequency")
    def recurring_charge_frequency(self) -> _builtins.str:
        return pulumi.get(self, "recurring_charge_frequency")


@pulumi.output_type
class ReservedCacheNodeTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ServerlessCacheCacheUsageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStorage":
            suggest = "data_storage"
        elif key == "ecpuPerSeconds":
            suggest = "ecpu_per_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessCacheCacheUsageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessCacheCacheUsageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessCacheCacheUsageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_storage: Optional['outputs.ServerlessCacheCacheUsageLimitsDataStorage'] = None,
                 ecpu_per_seconds: Optional[Sequence['outputs.ServerlessCacheCacheUsageLimitsEcpuPerSecond']] = None):
        if data_storage is not None:
            pulumi.set(__self__, "data_storage", data_storage)
        if ecpu_per_seconds is not None:
            pulumi.set(__self__, "ecpu_per_seconds", ecpu_per_seconds)

    @_builtins.property
    @pulumi.getter(name="dataStorage")
    def data_storage(self) -> Optional['outputs.ServerlessCacheCacheUsageLimitsDataStorage']:
        return pulumi.get(self, "data_storage")

    @_builtins.property
    @pulumi.getter(name="ecpuPerSeconds")
    def ecpu_per_seconds(self) -> Optional[Sequence['outputs.ServerlessCacheCacheUsageLimitsEcpuPerSecond']]:
        return pulumi.get(self, "ecpu_per_seconds")


@pulumi.output_type
class ServerlessCacheCacheUsageLimitsDataStorage(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 maximum: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.int] = None):
        pulumi.set(__self__, "unit", unit)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class ServerlessCacheCacheUsageLimitsEcpuPerSecond(dict):
    def __init__(__self__, *,
                 maximum: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.int] = None):
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class ServerlessCacheEndpoint(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class ServerlessCacheReaderEndpoint(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class ServerlessCacheTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class UserAuthenticationMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordCount":
            suggest = "password_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAuthenticationMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAuthenticationMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAuthenticationMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 password_count: Optional[_builtins.int] = None,
                 passwords: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if password_count is not None:
            pulumi.set(__self__, "password_count", password_count)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="passwordCount")
    def password_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "password_count")

    @_builtins.property
    @pulumi.getter
    def passwords(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "passwords")


@pulumi.output_type
class GetClusterCacheNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 availability_zone: _builtins.str,
                 id: _builtins.str,
                 outpost_arn: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "outpost_arn", outpost_arn)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> _builtins.str:
        return pulumi.get(self, "outpost_arn")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetClusterLogDeliveryConfigurationResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 destination_type: _builtins.str,
                 log_format: _builtins.str,
                 log_type: _builtins.str):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")


@pulumi.output_type
class GetReplicationGroupLogDeliveryConfigurationResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 destination_type: _builtins.str,
                 log_format: _builtins.str,
                 log_type: _builtins.str):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> _builtins.str:
        return pulumi.get(self, "log_type")


@pulumi.output_type
class GetReplicationGroupNodeGroupConfigurationResult(dict):
    def __init__(__self__, *,
                 node_group_id: _builtins.str,
                 primary_availability_zone: _builtins.str,
                 primary_outpost_arn: _builtins.str,
                 replica_availability_zones: Sequence[_builtins.str],
                 replica_count: _builtins.int,
                 replica_outpost_arns: Sequence[_builtins.str],
                 slots: _builtins.str):
        pulumi.set(__self__, "node_group_id", node_group_id)
        pulumi.set(__self__, "primary_availability_zone", primary_availability_zone)
        pulumi.set(__self__, "primary_outpost_arn", primary_outpost_arn)
        pulumi.set(__self__, "replica_availability_zones", replica_availability_zones)
        pulumi.set(__self__, "replica_count", replica_count)
        pulumi.set(__self__, "replica_outpost_arns", replica_outpost_arns)
        pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter(name="nodeGroupId")
    def node_group_id(self) -> _builtins.str:
        return pulumi.get(self, "node_group_id")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilityZone")
    def primary_availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "primary_availability_zone")

    @_builtins.property
    @pulumi.getter(name="primaryOutpostArn")
    def primary_outpost_arn(self) -> _builtins.str:
        return pulumi.get(self, "primary_outpost_arn")

    @_builtins.property
    @pulumi.getter(name="replicaAvailabilityZones")
    def replica_availability_zones(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "replica_availability_zones")

    @_builtins.property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> _builtins.int:
        return pulumi.get(self, "replica_count")

    @_builtins.property
    @pulumi.getter(name="replicaOutpostArns")
    def replica_outpost_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "replica_outpost_arns")

    @_builtins.property
    @pulumi.getter
    def slots(self) -> _builtins.str:
        return pulumi.get(self, "slots")


@pulumi.output_type
class GetServerlessCacheCacheUsageLimitsResult(dict):
    def __init__(__self__, *,
                 data_storage: 'outputs.GetServerlessCacheCacheUsageLimitsDataStorageResult',
                 ecpu_per_second: 'outputs.GetServerlessCacheCacheUsageLimitsEcpuPerSecondResult'):
        pulumi.set(__self__, "data_storage", data_storage)
        pulumi.set(__self__, "ecpu_per_second", ecpu_per_second)

    @_builtins.property
    @pulumi.getter(name="dataStorage")
    def data_storage(self) -> 'outputs.GetServerlessCacheCacheUsageLimitsDataStorageResult':
        return pulumi.get(self, "data_storage")

    @_builtins.property
    @pulumi.getter(name="ecpuPerSecond")
    def ecpu_per_second(self) -> 'outputs.GetServerlessCacheCacheUsageLimitsEcpuPerSecondResult':
        return pulumi.get(self, "ecpu_per_second")


@pulumi.output_type
class GetServerlessCacheCacheUsageLimitsDataStorageResult(dict):
    def __init__(__self__, *,
                 maximum: _builtins.int,
                 minimum: _builtins.int,
                 unit: _builtins.str):
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> _builtins.int:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> _builtins.int:
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetServerlessCacheCacheUsageLimitsEcpuPerSecondResult(dict):
    def __init__(__self__, *,
                 maximum: _builtins.int,
                 minimum: _builtins.int):
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> _builtins.int:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> _builtins.int:
        return pulumi.get(self, "minimum")


@pulumi.output_type
class GetServerlessCacheEndpointResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetServerlessCacheReaderEndpointResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetUserAuthenticationModeResult(dict):
    def __init__(__self__, *,
                 password_count: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        if password_count is not None:
            pulumi.set(__self__, "password_count", password_count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="passwordCount")
    def password_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "password_count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


