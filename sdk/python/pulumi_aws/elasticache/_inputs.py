# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterCacheNodeArgs',
    'ClusterCacheNodeArgsDict',
    'ClusterLogDeliveryConfigurationArgs',
    'ClusterLogDeliveryConfigurationArgsDict',
    'GlobalReplicationGroupGlobalNodeGroupArgs',
    'GlobalReplicationGroupGlobalNodeGroupArgsDict',
    'ParameterGroupParameterArgs',
    'ParameterGroupParameterArgsDict',
    'ReplicationGroupLogDeliveryConfigurationArgs',
    'ReplicationGroupLogDeliveryConfigurationArgsDict',
    'ReplicationGroupNodeGroupConfigurationArgs',
    'ReplicationGroupNodeGroupConfigurationArgsDict',
    'ReservedCacheNodeRecurringChargeArgs',
    'ReservedCacheNodeRecurringChargeArgsDict',
    'ReservedCacheNodeTimeoutsArgs',
    'ReservedCacheNodeTimeoutsArgsDict',
    'ServerlessCacheCacheUsageLimitsArgs',
    'ServerlessCacheCacheUsageLimitsArgsDict',
    'ServerlessCacheCacheUsageLimitsDataStorageArgs',
    'ServerlessCacheCacheUsageLimitsDataStorageArgsDict',
    'ServerlessCacheCacheUsageLimitsEcpuPerSecondArgs',
    'ServerlessCacheCacheUsageLimitsEcpuPerSecondArgsDict',
    'ServerlessCacheEndpointArgs',
    'ServerlessCacheEndpointArgsDict',
    'ServerlessCacheReaderEndpointArgs',
    'ServerlessCacheReaderEndpointArgsDict',
    'ServerlessCacheTimeoutsArgs',
    'ServerlessCacheTimeoutsArgsDict',
    'UserAuthenticationModeArgs',
    'UserAuthenticationModeArgsDict',
    'GetUserAuthenticationModeArgs',
    'GetUserAuthenticationModeArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterCacheNodeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        outpost_arn: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCacheNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCacheNodeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 outpost_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "outpost_arn")

    @outpost_arn.setter
    def outpost_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outpost_arn", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ClusterLogDeliveryConfigurationArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        destination_type: pulumi.Input[_builtins.str]
        log_format: pulumi.Input[_builtins.str]
        log_type: pulumi.Input[_builtins.str]
elif False:
    ClusterLogDeliveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogDeliveryConfigurationArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 destination_type: pulumi.Input[_builtins.str],
                 log_format: pulumi.Input[_builtins.str],
                 log_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class GlobalReplicationGroupGlobalNodeGroupArgsDict(TypedDict):
        global_node_group_id: NotRequired[pulumi.Input[_builtins.str]]
        slots: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GlobalReplicationGroupGlobalNodeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalReplicationGroupGlobalNodeGroupArgs:
    def __init__(__self__, *,
                 global_node_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 slots: Optional[pulumi.Input[_builtins.str]] = None):
        if global_node_group_id is not None:
            pulumi.set(__self__, "global_node_group_id", global_node_group_id)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter(name="globalNodeGroupId")
    def global_node_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "global_node_group_id")

    @global_node_group_id.setter
    def global_node_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_node_group_id", value)

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slots", value)


if not MYPY:
    class ParameterGroupParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    ParameterGroupParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParameterGroupParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReplicationGroupLogDeliveryConfigurationArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        destination_type: pulumi.Input[_builtins.str]
        log_format: pulumi.Input[_builtins.str]
        log_type: pulumi.Input[_builtins.str]
elif False:
    ReplicationGroupLogDeliveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicationGroupLogDeliveryConfigurationArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 destination_type: pulumi.Input[_builtins.str],
                 log_format: pulumi.Input[_builtins.str],
                 log_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class ReplicationGroupNodeGroupConfigurationArgsDict(TypedDict):
        node_group_id: NotRequired[pulumi.Input[_builtins.str]]
        primary_availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        primary_outpost_arn: NotRequired[pulumi.Input[_builtins.str]]
        replica_availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        replica_count: NotRequired[pulumi.Input[_builtins.int]]
        replica_outpost_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        slots: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ReplicationGroupNodeGroupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicationGroupNodeGroupConfigurationArgs:
    def __init__(__self__, *,
                 node_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_outpost_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 replica_availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 replica_count: Optional[pulumi.Input[_builtins.int]] = None,
                 replica_outpost_arns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slots: Optional[pulumi.Input[_builtins.str]] = None):
        if node_group_id is not None:
            pulumi.set(__self__, "node_group_id", node_group_id)
        if primary_availability_zone is not None:
            pulumi.set(__self__, "primary_availability_zone", primary_availability_zone)
        if primary_outpost_arn is not None:
            pulumi.set(__self__, "primary_outpost_arn", primary_outpost_arn)
        if replica_availability_zones is not None:
            pulumi.set(__self__, "replica_availability_zones", replica_availability_zones)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)
        if replica_outpost_arns is not None:
            pulumi.set(__self__, "replica_outpost_arns", replica_outpost_arns)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter(name="nodeGroupId")
    def node_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_group_id")

    @node_group_id.setter
    def node_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_group_id", value)

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilityZone")
    def primary_availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_availability_zone")

    @primary_availability_zone.setter
    def primary_availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="primaryOutpostArn")
    def primary_outpost_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_outpost_arn")

    @primary_outpost_arn.setter
    def primary_outpost_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_outpost_arn", value)

    @_builtins.property
    @pulumi.getter(name="replicaAvailabilityZones")
    def replica_availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "replica_availability_zones")

    @replica_availability_zones.setter
    def replica_availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "replica_availability_zones", value)

    @_builtins.property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "replica_count")

    @replica_count.setter
    def replica_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replica_count", value)

    @_builtins.property
    @pulumi.getter(name="replicaOutpostArns")
    def replica_outpost_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "replica_outpost_arns")

    @replica_outpost_arns.setter
    def replica_outpost_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "replica_outpost_arns", value)

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slots", value)


if not MYPY:
    class ReservedCacheNodeRecurringChargeArgsDict(TypedDict):
        recurring_charge_amount: pulumi.Input[_builtins.float]
        recurring_charge_frequency: pulumi.Input[_builtins.str]
elif False:
    ReservedCacheNodeRecurringChargeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReservedCacheNodeRecurringChargeArgs:
    def __init__(__self__, *,
                 recurring_charge_amount: pulumi.Input[_builtins.float],
                 recurring_charge_frequency: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "recurring_charge_amount", recurring_charge_amount)
        pulumi.set(__self__, "recurring_charge_frequency", recurring_charge_frequency)

    @_builtins.property
    @pulumi.getter(name="recurringChargeAmount")
    def recurring_charge_amount(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "recurring_charge_amount")

    @recurring_charge_amount.setter
    def recurring_charge_amount(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "recurring_charge_amount", value)

    @_builtins.property
    @pulumi.getter(name="recurringChargeFrequency")
    def recurring_charge_frequency(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "recurring_charge_frequency")

    @recurring_charge_frequency.setter
    def recurring_charge_frequency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "recurring_charge_frequency", value)


if not MYPY:
    class ReservedCacheNodeTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ReservedCacheNodeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReservedCacheNodeTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ServerlessCacheCacheUsageLimitsArgsDict(TypedDict):
        data_storage: NotRequired[pulumi.Input['ServerlessCacheCacheUsageLimitsDataStorageArgsDict']]
        ecpu_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerlessCacheCacheUsageLimitsEcpuPerSecondArgsDict']]]]
elif False:
    ServerlessCacheCacheUsageLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheCacheUsageLimitsArgs:
    def __init__(__self__, *,
                 data_storage: Optional[pulumi.Input['ServerlessCacheCacheUsageLimitsDataStorageArgs']] = None,
                 ecpu_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input['ServerlessCacheCacheUsageLimitsEcpuPerSecondArgs']]]] = None):
        if data_storage is not None:
            pulumi.set(__self__, "data_storage", data_storage)
        if ecpu_per_seconds is not None:
            pulumi.set(__self__, "ecpu_per_seconds", ecpu_per_seconds)

    @_builtins.property
    @pulumi.getter(name="dataStorage")
    def data_storage(self) -> Optional[pulumi.Input['ServerlessCacheCacheUsageLimitsDataStorageArgs']]:
        return pulumi.get(self, "data_storage")

    @data_storage.setter
    def data_storage(self, value: Optional[pulumi.Input['ServerlessCacheCacheUsageLimitsDataStorageArgs']]):
        pulumi.set(self, "data_storage", value)

    @_builtins.property
    @pulumi.getter(name="ecpuPerSeconds")
    def ecpu_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerlessCacheCacheUsageLimitsEcpuPerSecondArgs']]]]:
        return pulumi.get(self, "ecpu_per_seconds")

    @ecpu_per_seconds.setter
    def ecpu_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerlessCacheCacheUsageLimitsEcpuPerSecondArgs']]]]):
        pulumi.set(self, "ecpu_per_seconds", value)


if not MYPY:
    class ServerlessCacheCacheUsageLimitsDataStorageArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        minimum: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ServerlessCacheCacheUsageLimitsDataStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheCacheUsageLimitsDataStorageArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "unit", unit)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ServerlessCacheCacheUsageLimitsEcpuPerSecondArgsDict(TypedDict):
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        minimum: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ServerlessCacheCacheUsageLimitsEcpuPerSecondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheCacheUsageLimitsEcpuPerSecondArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None):
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ServerlessCacheEndpointArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    ServerlessCacheEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheEndpointArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ServerlessCacheReaderEndpointArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    ServerlessCacheReaderEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheReaderEndpointArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ServerlessCacheTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ServerlessCacheTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class UserAuthenticationModeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        password_count: NotRequired[pulumi.Input[_builtins.int]]
        passwords: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    UserAuthenticationModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAuthenticationModeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 password_count: Optional[pulumi.Input[_builtins.int]] = None,
                 passwords: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "type", type)
        if password_count is not None:
            pulumi.set(__self__, "password_count", password_count)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="passwordCount")
    def password_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "password_count")

    @password_count.setter
    def password_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "password_count", value)

    @_builtins.property
    @pulumi.getter
    def passwords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "passwords")

    @passwords.setter
    def passwords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "passwords", value)


if not MYPY:
    class GetUserAuthenticationModeArgsDict(TypedDict):
        password_count: NotRequired[_builtins.int]
        type: NotRequired[_builtins.str]
elif False:
    GetUserAuthenticationModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAuthenticationModeArgs:
    def __init__(__self__, *,
                 password_count: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        if password_count is not None:
            pulumi.set(__self__, "password_count", password_count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="passwordCount")
    def password_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "password_count")

    @password_count.setter
    def password_count(self, value: Optional[_builtins.int]):
        pulumi.set(self, "password_count", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


