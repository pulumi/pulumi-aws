# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import pulumi
import pulumi.runtime

class GetLoadBalancerResult(object):
    """
    A collection of values returned by getLoadBalancer.
    """
    def __init__(__self__, access_logs=None, availability_zones=None, connection_draining=None, connection_draining_timeout=None, cross_zone_load_balancing=None, dns_name=None, health_check=None, idle_timeout=None, instances=None, internal=None, listeners=None, security_groups=None, source_security_group=None, source_security_group_id=None, subnets=None, tags=None, zone_id=None):
        if not access_logs:
            raise TypeError('Missing required argument access_logs')
        elif not isinstance(access_logs, dict):
            raise TypeError('Expected argument access_logs to be a dict')
        __self__.access_logs = access_logs
        if not availability_zones:
            raise TypeError('Missing required argument availability_zones')
        elif not isinstance(availability_zones, list):
            raise TypeError('Expected argument availability_zones to be a list')
        __self__.availability_zones = availability_zones
        if not connection_draining:
            raise TypeError('Missing required argument connection_draining')
        elif not isinstance(connection_draining, bool):
            raise TypeError('Expected argument connection_draining to be a bool')
        __self__.connection_draining = connection_draining
        if not connection_draining_timeout:
            raise TypeError('Missing required argument connection_draining_timeout')
        elif not isinstance(connection_draining_timeout, int):
            raise TypeError('Expected argument connection_draining_timeout to be a int')
        __self__.connection_draining_timeout = connection_draining_timeout
        if not cross_zone_load_balancing:
            raise TypeError('Missing required argument cross_zone_load_balancing')
        elif not isinstance(cross_zone_load_balancing, bool):
            raise TypeError('Expected argument cross_zone_load_balancing to be a bool')
        __self__.cross_zone_load_balancing = cross_zone_load_balancing
        if not dns_name:
            raise TypeError('Missing required argument dns_name')
        elif not isinstance(dns_name, basestring):
            raise TypeError('Expected argument dns_name to be a basestring')
        __self__.dns_name = dns_name
        if not health_check:
            raise TypeError('Missing required argument health_check')
        elif not isinstance(health_check, dict):
            raise TypeError('Expected argument health_check to be a dict')
        __self__.health_check = health_check
        if not idle_timeout:
            raise TypeError('Missing required argument idle_timeout')
        elif not isinstance(idle_timeout, int):
            raise TypeError('Expected argument idle_timeout to be a int')
        __self__.idle_timeout = idle_timeout
        if not instances:
            raise TypeError('Missing required argument instances')
        elif not isinstance(instances, list):
            raise TypeError('Expected argument instances to be a list')
        __self__.instances = instances
        if not internal:
            raise TypeError('Missing required argument internal')
        elif not isinstance(internal, bool):
            raise TypeError('Expected argument internal to be a bool')
        __self__.internal = internal
        if not listeners:
            raise TypeError('Missing required argument listeners')
        elif not isinstance(listeners, list):
            raise TypeError('Expected argument listeners to be a list')
        __self__.listeners = listeners
        if not security_groups:
            raise TypeError('Missing required argument security_groups')
        elif not isinstance(security_groups, list):
            raise TypeError('Expected argument security_groups to be a list')
        __self__.security_groups = security_groups
        if not source_security_group:
            raise TypeError('Missing required argument source_security_group')
        elif not isinstance(source_security_group, basestring):
            raise TypeError('Expected argument source_security_group to be a basestring')
        __self__.source_security_group = source_security_group
        if not source_security_group_id:
            raise TypeError('Missing required argument source_security_group_id')
        elif not isinstance(source_security_group_id, basestring):
            raise TypeError('Expected argument source_security_group_id to be a basestring')
        __self__.source_security_group_id = source_security_group_id
        if not subnets:
            raise TypeError('Missing required argument subnets')
        elif not isinstance(subnets, list):
            raise TypeError('Expected argument subnets to be a list')
        __self__.subnets = subnets
        if not tags:
            raise TypeError('Missing required argument tags')
        elif not isinstance(tags, dict):
            raise TypeError('Expected argument tags to be a dict')
        __self__.tags = tags
        if not zone_id:
            raise TypeError('Missing required argument zone_id')
        elif not isinstance(zone_id, basestring):
            raise TypeError('Expected argument zone_id to be a basestring')
        __self__.zone_id = zone_id

def get_load_balancer(name=None, tags=None):
    """
    Provides information about a "classic" Elastic Load Balancer (ELB).
    See [LB Data Source](/docs/providers/aws/d/lb.html) if you are looking for "v2"
    Application Load Balancer (ALB) or Network Load Balancer (NLB).
    
    This data source can prove useful when a module accepts an LB as an input
    variable and needs to, for example, determine the security groups associated
    with it, etc.
    """
    __args__ = dict()

    __args__['name'] = name
    __args__['tags'] = tags
    __ret__ = pulumi.runtime.invoke('aws:elasticloadbalancing/getLoadBalancer:getLoadBalancer', __args__)

    return GetLoadBalancerResult(
        access_logs=__ret__['accessLogs'],
        availability_zones=__ret__['availabilityZones'],
        connection_draining=__ret__['connectionDraining'],
        connection_draining_timeout=__ret__['connectionDrainingTimeout'],
        cross_zone_load_balancing=__ret__['crossZoneLoadBalancing'],
        dns_name=__ret__['dnsName'],
        health_check=__ret__['healthCheck'],
        idle_timeout=__ret__['idleTimeout'],
        instances=__ret__['instances'],
        internal=__ret__['internal'],
        listeners=__ret__['listeners'],
        security_groups=__ret__['securityGroups'],
        source_security_group=__ret__['sourceSecurityGroup'],
        source_security_group_id=__ret__['sourceSecurityGroupId'],
        subnets=__ret__['subnets'],
        tags=__ret__['tags'],
        zone_id=__ret__['zoneId'])
