# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AssociationOutputLocationArgs',
    'AssociationOutputLocationArgsDict',
    'AssociationTargetArgs',
    'AssociationTargetArgsDict',
    'ContactsRotationRecurrenceArgs',
    'ContactsRotationRecurrenceArgsDict',
    'ContactsRotationRecurrenceDailySettingArgs',
    'ContactsRotationRecurrenceDailySettingArgsDict',
    'ContactsRotationRecurrenceMonthlySettingArgs',
    'ContactsRotationRecurrenceMonthlySettingArgsDict',
    'ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs',
    'ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict',
    'ContactsRotationRecurrenceShiftCoverageArgs',
    'ContactsRotationRecurrenceShiftCoverageArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict',
    'ContactsRotationRecurrenceWeeklySettingArgs',
    'ContactsRotationRecurrenceWeeklySettingArgsDict',
    'ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs',
    'ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict',
    'DocumentAttachmentsSourceArgs',
    'DocumentAttachmentsSourceArgsDict',
    'DocumentParameterArgs',
    'DocumentParameterArgsDict',
    'MaintenanceWindowTargetTargetArgs',
    'MaintenanceWindowTargetTargetArgsDict',
    'MaintenanceWindowTaskTargetArgs',
    'MaintenanceWindowTaskTargetArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict',
    'PatchBaselineApprovalRuleArgs',
    'PatchBaselineApprovalRuleArgsDict',
    'PatchBaselineApprovalRulePatchFilterArgs',
    'PatchBaselineApprovalRulePatchFilterArgsDict',
    'PatchBaselineGlobalFilterArgs',
    'PatchBaselineGlobalFilterArgsDict',
    'PatchBaselineSourceArgs',
    'PatchBaselineSourceArgsDict',
    'QuicksetupConfigurationManagerConfigurationDefinitionArgs',
    'QuicksetupConfigurationManagerConfigurationDefinitionArgsDict',
    'QuicksetupConfigurationManagerStatusSummaryArgs',
    'QuicksetupConfigurationManagerStatusSummaryArgsDict',
    'QuicksetupConfigurationManagerTimeoutsArgs',
    'QuicksetupConfigurationManagerTimeoutsArgsDict',
    'ResourceDataSyncS3DestinationArgs',
    'ResourceDataSyncS3DestinationArgsDict',
    'GetInstancesFilterArgs',
    'GetInstancesFilterArgsDict',
    'GetMaintenanceWindowsFilterArgs',
    'GetMaintenanceWindowsFilterArgsDict',
    'GetPatchBaselinesFilterArgs',
    'GetPatchBaselinesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AssociationOutputLocationArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[str]
        """
        The S3 bucket name.
        """
        s3_key_prefix: NotRequired[pulumi.Input[str]]
        """
        The S3 bucket prefix. Results stored in the root if not configured.
        """
        s3_region: NotRequired[pulumi.Input[str]]
        """
        The S3 bucket region.

        Targets specify what instance IDs or tags to apply the document to and has these keys:
        """
elif False:
    AssociationOutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationOutputLocationArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[str],
                 s3_key_prefix: Optional[pulumi.Input[str]] = None,
                 s3_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_bucket_name: The S3 bucket name.
        :param pulumi.Input[str] s3_key_prefix: The S3 bucket prefix. Results stored in the root if not configured.
        :param pulumi.Input[str] s3_region: The S3 bucket region.
               
               Targets specify what instance IDs or tags to apply the document to and has these keys:
        """
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)
        if s3_region is not None:
            pulumi.set(__self__, "s3_region", s3_region)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The S3 bucket name.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 bucket prefix. Results stored in the root if not configured.
        """
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key_prefix", value)

    @property
    @pulumi.getter(name="s3Region")
    def s3_region(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 bucket region.

        Targets specify what instance IDs or tags to apply the document to and has these keys:
        """
        return pulumi.get(self, "s3_region")

    @s3_region.setter
    def s3_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_region", value)


if not MYPY:
    class AssociationTargetArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Either `InstanceIds` or `tag:Tag Name` to specify an EC2 tag.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of instance IDs or tag values. AWS currently limits this list size to one value.
        """
elif False:
    AssociationTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: Either `InstanceIds` or `tag:Tag Name` to specify an EC2 tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of instance IDs or tag values. AWS currently limits this list size to one value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Either `InstanceIds` or `tag:Tag Name` to specify an EC2 tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of instance IDs or tag values. AWS currently limits this list size to one value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ContactsRotationRecurrenceArgsDict(TypedDict):
        number_of_on_calls: pulumi.Input[int]
        """
        (Required) The number of contacts, or shift team members designated to be on call concurrently during a shift.
        """
        recurrence_multiplier: pulumi.Input[int]
        """
        (Required) The number of days, weeks, or months a single rotation lasts.
        """
        daily_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgsDict']]]]
        monthly_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgsDict']]]]
        """
        (Optional) Information about on-call rotations that recur monthly. See Monthly Settings for more details.
        """
        shift_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgsDict']]]]
        """
        (Optional) Information about the days of the week that the on-call rotation coverage includes. See Shift Coverages for more details.
        """
        weekly_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgsDict']]]]
        """
        (Optional) Information about on-call rotations that recur weekly. See Weekly Settings for more details.
        """
elif False:
    ContactsRotationRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceArgs:
    def __init__(__self__, *,
                 number_of_on_calls: pulumi.Input[int],
                 recurrence_multiplier: pulumi.Input[int],
                 daily_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]] = None,
                 monthly_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]] = None,
                 shift_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]] = None,
                 weekly_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]] = None):
        """
        :param pulumi.Input[int] number_of_on_calls: (Required) The number of contacts, or shift team members designated to be on call concurrently during a shift.
        :param pulumi.Input[int] recurrence_multiplier: (Required) The number of days, weeks, or months a single rotation lasts.
        :param pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]] monthly_settings: (Optional) Information about on-call rotations that recur monthly. See Monthly Settings for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]] shift_coverages: (Optional) Information about the days of the week that the on-call rotation coverage includes. See Shift Coverages for more details.
        :param pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]] weekly_settings: (Optional) Information about on-call rotations that recur weekly. See Weekly Settings for more details.
        """
        pulumi.set(__self__, "number_of_on_calls", number_of_on_calls)
        pulumi.set(__self__, "recurrence_multiplier", recurrence_multiplier)
        if daily_settings is not None:
            pulumi.set(__self__, "daily_settings", daily_settings)
        if monthly_settings is not None:
            pulumi.set(__self__, "monthly_settings", monthly_settings)
        if shift_coverages is not None:
            pulumi.set(__self__, "shift_coverages", shift_coverages)
        if weekly_settings is not None:
            pulumi.set(__self__, "weekly_settings", weekly_settings)

    @property
    @pulumi.getter(name="numberOfOnCalls")
    def number_of_on_calls(self) -> pulumi.Input[int]:
        """
        (Required) The number of contacts, or shift team members designated to be on call concurrently during a shift.
        """
        return pulumi.get(self, "number_of_on_calls")

    @number_of_on_calls.setter
    def number_of_on_calls(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_on_calls", value)

    @property
    @pulumi.getter(name="recurrenceMultiplier")
    def recurrence_multiplier(self) -> pulumi.Input[int]:
        """
        (Required) The number of days, weeks, or months a single rotation lasts.
        """
        return pulumi.get(self, "recurrence_multiplier")

    @recurrence_multiplier.setter
    def recurrence_multiplier(self, value: pulumi.Input[int]):
        pulumi.set(self, "recurrence_multiplier", value)

    @property
    @pulumi.getter(name="dailySettings")
    def daily_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]]:
        return pulumi.get(self, "daily_settings")

    @daily_settings.setter
    def daily_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]]):
        pulumi.set(self, "daily_settings", value)

    @property
    @pulumi.getter(name="monthlySettings")
    def monthly_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]]:
        """
        (Optional) Information about on-call rotations that recur monthly. See Monthly Settings for more details.
        """
        return pulumi.get(self, "monthly_settings")

    @monthly_settings.setter
    def monthly_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]]):
        pulumi.set(self, "monthly_settings", value)

    @property
    @pulumi.getter(name="shiftCoverages")
    def shift_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]]:
        """
        (Optional) Information about the days of the week that the on-call rotation coverage includes. See Shift Coverages for more details.
        """
        return pulumi.get(self, "shift_coverages")

    @shift_coverages.setter
    def shift_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]]):
        pulumi.set(self, "shift_coverages", value)

    @property
    @pulumi.getter(name="weeklySettings")
    def weekly_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]]:
        """
        (Optional) Information about on-call rotations that recur weekly. See Weekly Settings for more details.
        """
        return pulumi.get(self, "weekly_settings")

    @weekly_settings.setter
    def weekly_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]]):
        pulumi.set(self, "weekly_settings", value)


if not MYPY:
    class ContactsRotationRecurrenceDailySettingArgsDict(TypedDict):
        hour_of_day: pulumi.Input[int]
        """
        (Required) The hour of the day.
        """
        minute_of_hour: pulumi.Input[int]
        """
        (Required) The minutes of the hour.
        """
elif False:
    ContactsRotationRecurrenceDailySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceDailySettingArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[int],
                 minute_of_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hour_of_day: (Required) The hour of the day.
        :param pulumi.Input[int] minute_of_hour: (Required) The minutes of the hour.
        """
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[int]:
        """
        (Required) The hour of the day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[int]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[int]:
        """
        (Required) The minutes of the hour.
        """
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceMonthlySettingArgsDict(TypedDict):
        day_of_month: pulumi.Input[int]
        """
        (Required) The day of the month when monthly recurring on-call rotations begin.
        """
        hand_off_time: NotRequired[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict']]
        """
        (Required) The hand off time. See Hand Off Time for more details.
        """
elif False:
    ContactsRotationRecurrenceMonthlySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceMonthlySettingArgs:
    def __init__(__self__, *,
                 day_of_month: pulumi.Input[int],
                 hand_off_time: Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']] = None):
        """
        :param pulumi.Input[int] day_of_month: (Required) The day of the month when monthly recurring on-call rotations begin.
        :param pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs'] hand_off_time: (Required) The hand off time. See Hand Off Time for more details.
        """
        pulumi.set(__self__, "day_of_month", day_of_month)
        if hand_off_time is not None:
            pulumi.set(__self__, "hand_off_time", hand_off_time)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[int]:
        """
        (Required) The day of the month when monthly recurring on-call rotations begin.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[int]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="handOffTime")
    def hand_off_time(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']]:
        """
        (Required) The hand off time. See Hand Off Time for more details.
        """
        return pulumi.get(self, "hand_off_time")

    @hand_off_time.setter
    def hand_off_time(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']]):
        pulumi.set(self, "hand_off_time", value)


if not MYPY:
    class ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict(TypedDict):
        hour_of_day: pulumi.Input[int]
        """
        (Required) The hour of the day.
        """
        minute_of_hour: pulumi.Input[int]
        """
        (Required) The minutes of the hour.
        """
elif False:
    ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[int],
                 minute_of_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hour_of_day: (Required) The hour of the day.
        :param pulumi.Input[int] minute_of_hour: (Required) The minutes of the hour.
        """
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[int]:
        """
        (Required) The hour of the day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[int]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[int]:
        """
        (Required) The minutes of the hour.
        """
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageArgsDict(TypedDict):
        map_block_key: pulumi.Input[str]
        coverage_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict']]]]
        """
        (Required) Information about when an on-call shift begins and ends. See Coverage Times for more details.
        """
elif False:
    ContactsRotationRecurrenceShiftCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[str],
                 coverage_times: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]] coverage_times: (Required) Information about when an on-call shift begins and ends. See Coverage Times for more details.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        if coverage_times is not None:
            pulumi.set(__self__, "coverage_times", coverage_times)

    @property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "map_block_key", value)

    @property
    @pulumi.getter(name="coverageTimes")
    def coverage_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]]:
        """
        (Required) Information about when an on-call shift begins and ends. See Coverage Times for more details.
        """
        return pulumi.get(self, "coverage_times")

    @coverage_times.setter
    def coverage_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]]):
        pulumi.set(self, "coverage_times", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict']]
        """
        (Required) The end time of the on-call shift. See Hand Off Time for more details.
        """
        start: NotRequired[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict']]
        """
        (Required) The start time of the on-call shift. See Hand Off Time for more details.
        """
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']] = None,
                 start: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']] = None):
        """
        :param pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs'] end: (Required) The end time of the on-call shift. See Hand Off Time for more details.
        :param pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs'] start: (Required) The start time of the on-call shift. See Hand Off Time for more details.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']]:
        """
        (Required) The end time of the on-call shift. See Hand Off Time for more details.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']]:
        """
        (Required) The start time of the on-call shift. See Hand Off Time for more details.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']]):
        pulumi.set(self, "start", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict(TypedDict):
        hour_of_day: pulumi.Input[int]
        """
        (Required) The hour of the day.
        """
        minute_of_hour: pulumi.Input[int]
        """
        (Required) The minutes of the hour.
        """
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[int],
                 minute_of_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hour_of_day: (Required) The hour of the day.
        :param pulumi.Input[int] minute_of_hour: (Required) The minutes of the hour.
        """
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[int]:
        """
        (Required) The hour of the day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[int]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[int]:
        """
        (Required) The minutes of the hour.
        """
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict(TypedDict):
        hour_of_day: pulumi.Input[int]
        """
        (Required) The hour of the day.
        """
        minute_of_hour: pulumi.Input[int]
        """
        (Required) The minutes of the hour.
        """
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[int],
                 minute_of_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hour_of_day: (Required) The hour of the day.
        :param pulumi.Input[int] minute_of_hour: (Required) The minutes of the hour.
        """
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[int]:
        """
        (Required) The hour of the day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[int]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[int]:
        """
        (Required) The minutes of the hour.
        """
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceWeeklySettingArgsDict(TypedDict):
        day_of_week: pulumi.Input[str]
        """
        (Required) The day of the week when the shift coverage occurs.
        """
        hand_off_time: NotRequired[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict']]
        """
        (Required) The hand off time. See Hand Off Time for more details.
        """
elif False:
    ContactsRotationRecurrenceWeeklySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceWeeklySettingArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 hand_off_time: Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']] = None):
        """
        :param pulumi.Input[str] day_of_week: (Required) The day of the week when the shift coverage occurs.
        :param pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs'] hand_off_time: (Required) The hand off time. See Hand Off Time for more details.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        if hand_off_time is not None:
            pulumi.set(__self__, "hand_off_time", hand_off_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        """
        (Required) The day of the week when the shift coverage occurs.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="handOffTime")
    def hand_off_time(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']]:
        """
        (Required) The hand off time. See Hand Off Time for more details.
        """
        return pulumi.get(self, "hand_off_time")

    @hand_off_time.setter
    def hand_off_time(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']]):
        pulumi.set(self, "hand_off_time", value)


if not MYPY:
    class ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict(TypedDict):
        hour_of_day: pulumi.Input[int]
        """
        (Required) The hour of the day.
        """
        minute_of_hour: pulumi.Input[int]
        """
        (Required) The minutes of the hour.
        """
elif False:
    ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[int],
                 minute_of_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hour_of_day: (Required) The hour of the day.
        :param pulumi.Input[int] minute_of_hour: (Required) The minutes of the hour.
        """
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[int]:
        """
        (Required) The hour of the day.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[int]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[int]:
        """
        (Required) The minutes of the hour.
        """
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class DocumentAttachmentsSourceArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of a key-value pair that identifies the location of an attachment to the document. Valid values: `SourceUrl`, `S3FileUrl`, `AttachmentReference`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The value of a key-value pair that identifies the location of an attachment to the document. The argument format is a list of a single string that depends on the type of key you specify - see the [API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_AttachmentsSource.html) for details.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the document attachment file.
        """
elif False:
    DocumentAttachmentsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentAttachmentsSourceArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of a key-value pair that identifies the location of an attachment to the document. Valid values: `SourceUrl`, `S3FileUrl`, `AttachmentReference`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The value of a key-value pair that identifies the location of an attachment to the document. The argument format is a list of a single string that depends on the type of key you specify - see the [API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_AttachmentsSource.html) for details.
        :param pulumi.Input[str] name: The name of the document attachment file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of a key-value pair that identifies the location of an attachment to the document. Valid values: `SourceUrl`, `S3FileUrl`, `AttachmentReference`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The value of a key-value pair that identifies the location of an attachment to the document. The argument format is a list of a single string that depends on the type of key you specify - see the [API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_AttachmentsSource.html) for details.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the document attachment file.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DocumentParameterArgsDict(TypedDict):
        default_value: NotRequired[pulumi.Input[str]]
        """
        If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the document.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of parameter. Valid values: `String`, `StringList`.
        """
elif False:
    DocumentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentParameterArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_value: If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        :param pulumi.Input[str] description: A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        :param pulumi.Input[str] name: The name of the document.
        :param pulumi.Input[str] type: The type of parameter. Valid values: `String`, `StringList`.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the document.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of parameter. Valid values: `String`, `StringList`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MaintenanceWindowTargetTargetArgsDict(TypedDict):
        key: pulumi.Input[str]
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MaintenanceWindowTargetTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTargetTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTargetArgsDict(TypedDict):
        key: pulumi.Input[str]
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The array of strings.
        """
elif False:
    MaintenanceWindowTaskTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The array of strings.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The array of strings.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersArgsDict(TypedDict):
        automation_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict']]
        """
        The parameters for an AUTOMATION task type. Documented below.
        """
        lambda_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict']]
        """
        The parameters for a LAMBDA task type. Documented below.
        """
        run_command_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict']]
        """
        The parameters for a RUN_COMMAND task type. Documented below.
        """
        step_functions_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict']]
        """
        The parameters for a STEP_FUNCTIONS task type. Documented below.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersArgs:
    def __init__(__self__, *,
                 automation_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']] = None,
                 lambda_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']] = None,
                 run_command_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']] = None,
                 step_functions_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']] = None):
        """
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs'] automation_parameters: The parameters for an AUTOMATION task type. Documented below.
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs'] lambda_parameters: The parameters for a LAMBDA task type. Documented below.
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs'] run_command_parameters: The parameters for a RUN_COMMAND task type. Documented below.
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs'] step_functions_parameters: The parameters for a STEP_FUNCTIONS task type. Documented below.
        """
        if automation_parameters is not None:
            pulumi.set(__self__, "automation_parameters", automation_parameters)
        if lambda_parameters is not None:
            pulumi.set(__self__, "lambda_parameters", lambda_parameters)
        if run_command_parameters is not None:
            pulumi.set(__self__, "run_command_parameters", run_command_parameters)
        if step_functions_parameters is not None:
            pulumi.set(__self__, "step_functions_parameters", step_functions_parameters)

    @property
    @pulumi.getter(name="automationParameters")
    def automation_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']]:
        """
        The parameters for an AUTOMATION task type. Documented below.
        """
        return pulumi.get(self, "automation_parameters")

    @automation_parameters.setter
    def automation_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']]):
        pulumi.set(self, "automation_parameters", value)

    @property
    @pulumi.getter(name="lambdaParameters")
    def lambda_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']]:
        """
        The parameters for a LAMBDA task type. Documented below.
        """
        return pulumi.get(self, "lambda_parameters")

    @lambda_parameters.setter
    def lambda_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']]):
        pulumi.set(self, "lambda_parameters", value)

    @property
    @pulumi.getter(name="runCommandParameters")
    def run_command_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']]:
        """
        The parameters for a RUN_COMMAND task type. Documented below.
        """
        return pulumi.get(self, "run_command_parameters")

    @run_command_parameters.setter
    def run_command_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']]):
        pulumi.set(self, "run_command_parameters", value)

    @property
    @pulumi.getter(name="stepFunctionsParameters")
    def step_functions_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']]:
        """
        The parameters for a STEP_FUNCTIONS task type. Documented below.
        """
        return pulumi.get(self, "step_functions_parameters")

    @step_functions_parameters.setter
    def step_functions_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']]):
        pulumi.set(self, "step_functions_parameters", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict(TypedDict):
        document_version: NotRequired[pulumi.Input[str]]
        """
        The version of an Automation document to use during task execution.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict']]]]
        """
        The parameters for the RUN_COMMAND task execution. Documented below.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs:
    def __init__(__self__, *,
                 document_version: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] document_version: The version of an Automation document to use during task execution.
        :param pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]] parameters: The parameters for the RUN_COMMAND task execution. Documented below.
        """
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of an Automation document to use during task execution.
        """
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_version", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]]:
        """
        The parameters for the RUN_COMMAND task execution. Documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The parameter name.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The array of strings.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The parameter name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The array of strings.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The array of strings.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict(TypedDict):
        client_context: NotRequired[pulumi.Input[str]]
        """
        Pass client-specific information to the Lambda function that you are invoking.
        """
        payload: NotRequired[pulumi.Input[str]]
        """
        JSON to provide to your Lambda function as input.
        """
        qualifier: NotRequired[pulumi.Input[str]]
        """
        Specify a Lambda function version or alias name.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs:
    def __init__(__self__, *,
                 client_context: Optional[pulumi.Input[str]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 qualifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_context: Pass client-specific information to the Lambda function that you are invoking.
        :param pulumi.Input[str] payload: JSON to provide to your Lambda function as input.
        :param pulumi.Input[str] qualifier: Specify a Lambda function version or alias name.
        """
        if client_context is not None:
            pulumi.set(__self__, "client_context", client_context)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)

    @property
    @pulumi.getter(name="clientContext")
    def client_context(self) -> Optional[pulumi.Input[str]]:
        """
        Pass client-specific information to the Lambda function that you are invoking.
        """
        return pulumi.get(self, "client_context")

    @client_context.setter
    def client_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_context", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        JSON to provide to your Lambda function as input.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def qualifier(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Lambda function version or alias name.
        """
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "qualifier", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict(TypedDict):
        cloudwatch_config: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict']]
        """
        Configuration options for sending command output to CloudWatch Logs. Documented below.
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Information about the command(s) to execute.
        """
        document_hash: NotRequired[pulumi.Input[str]]
        """
        The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        """
        document_hash_type: NotRequired[pulumi.Input[str]]
        """
        SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: `Sha256` and `Sha1`
        """
        document_version: NotRequired[pulumi.Input[str]]
        """
        The version of an Automation document to use during task execution.
        """
        notification_config: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict']]
        """
        Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
        """
        output_s3_bucket: NotRequired[pulumi.Input[str]]
        """
        The name of the Amazon S3 bucket.
        """
        output_s3_key_prefix: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 bucket subfolder.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict']]]]
        """
        The parameters for the RUN_COMMAND task execution. Documented below.
        """
        service_role_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        If this time is reached and the command has not already started executing, it doesn't run.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs:
    def __init__(__self__, *,
                 cloudwatch_config: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 document_hash: Optional[pulumi.Input[str]] = None,
                 document_hash_type: Optional[pulumi.Input[str]] = None,
                 document_version: Optional[pulumi.Input[str]] = None,
                 notification_config: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']] = None,
                 output_s3_bucket: Optional[pulumi.Input[str]] = None,
                 output_s3_key_prefix: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]] = None,
                 service_role_arn: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs'] cloudwatch_config: Configuration options for sending command output to CloudWatch Logs. Documented below.
        :param pulumi.Input[str] comment: Information about the command(s) to execute.
        :param pulumi.Input[str] document_hash: The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        :param pulumi.Input[str] document_hash_type: SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: `Sha256` and `Sha1`
        :param pulumi.Input[str] document_version: The version of an Automation document to use during task execution.
        :param pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs'] notification_config: Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
        :param pulumi.Input[str] output_s3_bucket: The name of the Amazon S3 bucket.
        :param pulumi.Input[str] output_s3_key_prefix: The Amazon S3 bucket subfolder.
        :param pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]] parameters: The parameters for the RUN_COMMAND task execution. Documented below.
        :param pulumi.Input[str] service_role_arn: The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        :param pulumi.Input[int] timeout_seconds: If this time is reached and the command has not already started executing, it doesn't run.
        """
        if cloudwatch_config is not None:
            pulumi.set(__self__, "cloudwatch_config", cloudwatch_config)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if document_hash is not None:
            pulumi.set(__self__, "document_hash", document_hash)
        if document_hash_type is not None:
            pulumi.set(__self__, "document_hash_type", document_hash_type)
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if notification_config is not None:
            pulumi.set(__self__, "notification_config", notification_config)
        if output_s3_bucket is not None:
            pulumi.set(__self__, "output_s3_bucket", output_s3_bucket)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_role_arn is not None:
            pulumi.set(__self__, "service_role_arn", service_role_arn)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="cloudwatchConfig")
    def cloudwatch_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']]:
        """
        Configuration options for sending command output to CloudWatch Logs. Documented below.
        """
        return pulumi.get(self, "cloudwatch_config")

    @cloudwatch_config.setter
    def cloudwatch_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']]):
        pulumi.set(self, "cloudwatch_config", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Information about the command(s) to execute.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="documentHash")
    def document_hash(self) -> Optional[pulumi.Input[str]]:
        """
        The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        """
        return pulumi.get(self, "document_hash")

    @document_hash.setter
    def document_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_hash", value)

    @property
    @pulumi.getter(name="documentHashType")
    def document_hash_type(self) -> Optional[pulumi.Input[str]]:
        """
        SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: `Sha256` and `Sha1`
        """
        return pulumi.get(self, "document_hash_type")

    @document_hash_type.setter
    def document_hash_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_hash_type", value)

    @property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of an Automation document to use during task execution.
        """
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_version", value)

    @property
    @pulumi.getter(name="notificationConfig")
    def notification_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']]:
        """
        Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
        """
        return pulumi.get(self, "notification_config")

    @notification_config.setter
    def notification_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']]):
        pulumi.set(self, "notification_config", value)

    @property
    @pulumi.getter(name="outputS3Bucket")
    def output_s3_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "output_s3_bucket")

    @output_s3_bucket.setter
    def output_s3_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_s3_bucket", value)

    @property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 bucket subfolder.
        """
        return pulumi.get(self, "output_s3_key_prefix")

    @output_s3_key_prefix.setter
    def output_s3_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_s3_key_prefix", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]]:
        """
        The parameters for the RUN_COMMAND task execution. Documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="serviceRoleArn")
    def service_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for maintenance window Run Command tasks.
        """
        return pulumi.get(self, "service_role_arn")

    @service_role_arn.setter
    def service_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_role_arn", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If this time is reached and the command has not already started executing, it doesn't run.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict(TypedDict):
        cloudwatch_log_group_name: NotRequired[pulumi.Input[str]]
        """
        The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
        """
        cloudwatch_output_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables Systems Manager to send command output to CloudWatch Logs.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_log_group_name: Optional[pulumi.Input[str]] = None,
                 cloudwatch_output_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cloudwatch_log_group_name: The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
        :param pulumi.Input[bool] cloudwatch_output_enabled: Enables Systems Manager to send command output to CloudWatch Logs.
        """
        if cloudwatch_log_group_name is not None:
            pulumi.set(__self__, "cloudwatch_log_group_name", cloudwatch_log_group_name)
        if cloudwatch_output_enabled is not None:
            pulumi.set(__self__, "cloudwatch_output_enabled", cloudwatch_output_enabled)

    @property
    @pulumi.getter(name="cloudwatchLogGroupName")
    def cloudwatch_log_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
        """
        return pulumi.get(self, "cloudwatch_log_group_name")

    @cloudwatch_log_group_name.setter
    def cloudwatch_log_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudwatch_log_group_name", value)

    @property
    @pulumi.getter(name="cloudwatchOutputEnabled")
    def cloudwatch_output_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Systems Manager to send command output to CloudWatch Logs.
        """
        return pulumi.get(self, "cloudwatch_output_enabled")

    @cloudwatch_output_enabled.setter
    def cloudwatch_output_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloudwatch_output_enabled", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict(TypedDict):
        notification_arn: NotRequired[pulumi.Input[str]]
        """
        An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
        """
        notification_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The different events for which you can receive notifications. Valid values: `All`, `InProgress`, `Success`, `TimedOut`, `Cancelled`, and `Failed`
        """
        notification_type: NotRequired[pulumi.Input[str]]
        """
        When specified with `Command`, receive notification when the status of a command changes. When specified with `Invocation`, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: `Command` and `Invocation`
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs:
    def __init__(__self__, *,
                 notification_arn: Optional[pulumi.Input[str]] = None,
                 notification_events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 notification_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notification_arn: An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_events: The different events for which you can receive notifications. Valid values: `All`, `InProgress`, `Success`, `TimedOut`, `Cancelled`, and `Failed`
        :param pulumi.Input[str] notification_type: When specified with `Command`, receive notification when the status of a command changes. When specified with `Invocation`, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: `Command` and `Invocation`
        """
        if notification_arn is not None:
            pulumi.set(__self__, "notification_arn", notification_arn)
        if notification_events is not None:
            pulumi.set(__self__, "notification_events", notification_events)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)

    @property
    @pulumi.getter(name="notificationArn")
    def notification_arn(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
        """
        return pulumi.get(self, "notification_arn")

    @notification_arn.setter
    def notification_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notification_arn", value)

    @property
    @pulumi.getter(name="notificationEvents")
    def notification_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The different events for which you can receive notifications. Valid values: `All`, `InProgress`, `Success`, `TimedOut`, `Cancelled`, and `Failed`
        """
        return pulumi.get(self, "notification_events")

    @notification_events.setter
    def notification_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notification_events", value)

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[pulumi.Input[str]]:
        """
        When specified with `Command`, receive notification when the status of a command changes. When specified with `Invocation`, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: `Command` and `Invocation`
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notification_type", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The parameter name.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The array of strings.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The parameter name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The array of strings.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The array of strings.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict(TypedDict):
        input: NotRequired[pulumi.Input[str]]
        """
        The inputs for the STEP_FUNCTION task.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the STEP_FUNCTION task.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs:
    def __init__(__self__, *,
                 input: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] input: The inputs for the STEP_FUNCTION task.
        :param pulumi.Input[str] name: The name of the STEP_FUNCTION task.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input[str]]:
        """
        The inputs for the STEP_FUNCTION task.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the STEP_FUNCTION task.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PatchBaselineApprovalRuleArgsDict(TypedDict):
        patch_filters: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgsDict']]]
        """
        Patch filter group that defines the criteria for the rule. Up to 5 patch filters can be specified per approval rule using Key/Value pairs. Valid combinations of these Keys and the `operating_system` value can be found in the [SSM DescribePatchProperties API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchProperties.html). Valid Values are exact values for the patch property given as the key, or a wildcard `*`, which matches all values. `PATCH_SET` defaults to `OS` if unspecified
        """
        approve_after_days: NotRequired[pulumi.Input[int]]
        """
        Number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline. Valid Range: 0 to 360. Conflicts with `approve_until_date`.
        """
        approve_until_date: NotRequired[pulumi.Input[str]]
        """
        Cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approve_after_days`
        """
        compliance_level: NotRequired[pulumi.Input[str]]
        """
        Compliance level for patches approved by this rule. Valid values are `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `INFORMATIONAL`, and `UNSPECIFIED`. The default value is `UNSPECIFIED`.
        """
        enable_non_security: NotRequired[pulumi.Input[bool]]
        """
        Boolean enabling the application of non-security updates. The default value is `false`. Valid for Linux instances only.
        """
elif False:
    PatchBaselineApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineApprovalRuleArgs:
    def __init__(__self__, *,
                 patch_filters: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]],
                 approve_after_days: Optional[pulumi.Input[int]] = None,
                 approve_until_date: Optional[pulumi.Input[str]] = None,
                 compliance_level: Optional[pulumi.Input[str]] = None,
                 enable_non_security: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]] patch_filters: Patch filter group that defines the criteria for the rule. Up to 5 patch filters can be specified per approval rule using Key/Value pairs. Valid combinations of these Keys and the `operating_system` value can be found in the [SSM DescribePatchProperties API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchProperties.html). Valid Values are exact values for the patch property given as the key, or a wildcard `*`, which matches all values. `PATCH_SET` defaults to `OS` if unspecified
        :param pulumi.Input[int] approve_after_days: Number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline. Valid Range: 0 to 360. Conflicts with `approve_until_date`.
        :param pulumi.Input[str] approve_until_date: Cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approve_after_days`
        :param pulumi.Input[str] compliance_level: Compliance level for patches approved by this rule. Valid values are `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `INFORMATIONAL`, and `UNSPECIFIED`. The default value is `UNSPECIFIED`.
        :param pulumi.Input[bool] enable_non_security: Boolean enabling the application of non-security updates. The default value is `false`. Valid for Linux instances only.
        """
        pulumi.set(__self__, "patch_filters", patch_filters)
        if approve_after_days is not None:
            pulumi.set(__self__, "approve_after_days", approve_after_days)
        if approve_until_date is not None:
            pulumi.set(__self__, "approve_until_date", approve_until_date)
        if compliance_level is not None:
            pulumi.set(__self__, "compliance_level", compliance_level)
        if enable_non_security is not None:
            pulumi.set(__self__, "enable_non_security", enable_non_security)

    @property
    @pulumi.getter(name="patchFilters")
    def patch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]]:
        """
        Patch filter group that defines the criteria for the rule. Up to 5 patch filters can be specified per approval rule using Key/Value pairs. Valid combinations of these Keys and the `operating_system` value can be found in the [SSM DescribePatchProperties API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchProperties.html). Valid Values are exact values for the patch property given as the key, or a wildcard `*`, which matches all values. `PATCH_SET` defaults to `OS` if unspecified
        """
        return pulumi.get(self, "patch_filters")

    @patch_filters.setter
    def patch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]]):
        pulumi.set(self, "patch_filters", value)

    @property
    @pulumi.getter(name="approveAfterDays")
    def approve_after_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline. Valid Range: 0 to 360. Conflicts with `approve_until_date`.
        """
        return pulumi.get(self, "approve_after_days")

    @approve_after_days.setter
    def approve_after_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "approve_after_days", value)

    @property
    @pulumi.getter(name="approveUntilDate")
    def approve_until_date(self) -> Optional[pulumi.Input[str]]:
        """
        Cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as `YYYY-MM-DD`. Conflicts with `approve_after_days`
        """
        return pulumi.get(self, "approve_until_date")

    @approve_until_date.setter
    def approve_until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "approve_until_date", value)

    @property
    @pulumi.getter(name="complianceLevel")
    def compliance_level(self) -> Optional[pulumi.Input[str]]:
        """
        Compliance level for patches approved by this rule. Valid values are `CRITICAL`, `HIGH`, `MEDIUM`, `LOW`, `INFORMATIONAL`, and `UNSPECIFIED`. The default value is `UNSPECIFIED`.
        """
        return pulumi.get(self, "compliance_level")

    @compliance_level.setter
    def compliance_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_level", value)

    @property
    @pulumi.getter(name="enableNonSecurity")
    def enable_non_security(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean enabling the application of non-security updates. The default value is `false`. Valid for Linux instances only.
        """
        return pulumi.get(self, "enable_non_security")

    @enable_non_security.setter
    def enable_non_security(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_non_security", value)


if not MYPY:
    class PatchBaselineApprovalRulePatchFilterArgsDict(TypedDict):
        key: pulumi.Input[str]
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    PatchBaselineApprovalRulePatchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineApprovalRulePatchFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PatchBaselineGlobalFilterArgsDict(TypedDict):
        key: pulumi.Input[str]
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    PatchBaselineGlobalFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineGlobalFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PatchBaselineSourceArgsDict(TypedDict):
        configuration: pulumi.Input[str]
        """
        Value of the yum repo configuration. For information about other options available for your yum repository configuration, see the [`dnf.conf` documentation](https://man7.org/linux/man-pages/man5/dnf.conf.5.html)
        """
        name: pulumi.Input[str]
        """
        Name specified to identify the patch source.
        """
        products: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specific operating system versions a patch repository applies to, such as `"Ubuntu16.04"`, `"AmazonLinux2016.09"`, `"RedhatEnterpriseLinux7.2"` or `"Suse12.7"`. For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html).
        """
elif False:
    PatchBaselineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineSourceArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input[str],
                 name: pulumi.Input[str],
                 products: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] configuration: Value of the yum repo configuration. For information about other options available for your yum repository configuration, see the [`dnf.conf` documentation](https://man7.org/linux/man-pages/man5/dnf.conf.5.html)
        :param pulumi.Input[str] name: Name specified to identify the patch source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Specific operating system versions a patch repository applies to, such as `"Ubuntu16.04"`, `"AmazonLinux2016.09"`, `"RedhatEnterpriseLinux7.2"` or `"Suse12.7"`. For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html).
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "products", products)

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input[str]:
        """
        Value of the yum repo configuration. For information about other options available for your yum repository configuration, see the [`dnf.conf` documentation](https://man7.org/linux/man-pages/man5/dnf.conf.5.html)
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input[str]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name specified to identify the patch source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def products(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specific operating system versions a patch repository applies to, such as `"Ubuntu16.04"`, `"AmazonLinux2016.09"`, `"RedhatEnterpriseLinux7.2"` or `"Suse12.7"`. For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html).
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class QuicksetupConfigurationManagerConfigurationDefinitionArgsDict(TypedDict):
        parameters: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Parameters for the configuration definition type. Parameters for configuration definitions vary based the configuration type. See the [AWS API documentation](https://docs.aws.amazon.com/quick-setup/latest/APIReference/API_ConfigurationDefinitionInput.html) for a complete list of parameters for each configuration type.
        """
        type: pulumi.Input[str]
        """
        Type of the Quick Setup configuration.
        """
        id: NotRequired[pulumi.Input[str]]
        local_deployment_administration_role_arn: NotRequired[pulumi.Input[str]]
        local_deployment_execution_role_name: NotRequired[pulumi.Input[str]]
        """
        Name of the IAM role used to deploy local configurations.
        """
        type_version: NotRequired[pulumi.Input[str]]
        """
        Version of the Quick Setup type to use.
        """
elif False:
    QuicksetupConfigurationManagerConfigurationDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerConfigurationDefinitionArgs:
    def __init__(__self__, *,
                 parameters: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 local_deployment_administration_role_arn: Optional[pulumi.Input[str]] = None,
                 local_deployment_execution_role_name: Optional[pulumi.Input[str]] = None,
                 type_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: Parameters for the configuration definition type. Parameters for configuration definitions vary based the configuration type. See the [AWS API documentation](https://docs.aws.amazon.com/quick-setup/latest/APIReference/API_ConfigurationDefinitionInput.html) for a complete list of parameters for each configuration type.
        :param pulumi.Input[str] type: Type of the Quick Setup configuration.
        :param pulumi.Input[str] local_deployment_execution_role_name: Name of the IAM role used to deploy local configurations.
        :param pulumi.Input[str] type_version: Version of the Quick Setup type to use.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if local_deployment_administration_role_arn is not None:
            pulumi.set(__self__, "local_deployment_administration_role_arn", local_deployment_administration_role_arn)
        if local_deployment_execution_role_name is not None:
            pulumi.set(__self__, "local_deployment_execution_role_name", local_deployment_execution_role_name)
        if type_version is not None:
            pulumi.set(__self__, "type_version", type_version)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Parameters for the configuration definition type. Parameters for configuration definitions vary based the configuration type. See the [AWS API documentation](https://docs.aws.amazon.com/quick-setup/latest/APIReference/API_ConfigurationDefinitionInput.html) for a complete list of parameters for each configuration type.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the Quick Setup configuration.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="localDeploymentAdministrationRoleArn")
    def local_deployment_administration_role_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_deployment_administration_role_arn")

    @local_deployment_administration_role_arn.setter
    def local_deployment_administration_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_deployment_administration_role_arn", value)

    @property
    @pulumi.getter(name="localDeploymentExecutionRoleName")
    def local_deployment_execution_role_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IAM role used to deploy local configurations.
        """
        return pulumi.get(self, "local_deployment_execution_role_name")

    @local_deployment_execution_role_name.setter
    def local_deployment_execution_role_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_deployment_execution_role_name", value)

    @property
    @pulumi.getter(name="typeVersion")
    def type_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the Quick Setup type to use.
        """
        return pulumi.get(self, "type_version")

    @type_version.setter
    def type_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_version", value)


if not MYPY:
    class QuicksetupConfigurationManagerStatusSummaryArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        Current status.
        """
        status_message: pulumi.Input[str]
        """
        When applicable, returns an informational message relevant to the current status and status type of the status summary object.
        """
        status_type: pulumi.Input[str]
        """
        Type of a status summary.
        """
elif False:
    QuicksetupConfigurationManagerStatusSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerStatusSummaryArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 status_message: pulumi.Input[str],
                 status_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: Current status.
        :param pulumi.Input[str] status_message: When applicable, returns an informational message relevant to the current status and status type of the status summary object.
        :param pulumi.Input[str] status_type: Type of a status summary.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "status_type", status_type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Current status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[str]:
        """
        When applicable, returns an informational message relevant to the current status and status type of the status summary object.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_message", value)

    @property
    @pulumi.getter(name="statusType")
    def status_type(self) -> pulumi.Input[str]:
        """
        Type of a status summary.
        """
        return pulumi.get(self, "status_type")

    @status_type.setter
    def status_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_type", value)


if not MYPY:
    class QuicksetupConfigurationManagerTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    QuicksetupConfigurationManagerTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ResourceDataSyncS3DestinationArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Name of S3 bucket where the aggregated data is stored.
        """
        region: pulumi.Input[str]
        """
        Region with the bucket targeted by the Resource Data Sync.
        """
        kms_key_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of an encryption key for a destination in Amazon S3.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix for the bucket.
        """
        sync_format: NotRequired[pulumi.Input[str]]
        """
        A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
        """
elif False:
    ResourceDataSyncS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDataSyncS3DestinationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 region: pulumi.Input[str],
                 kms_key_arn: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 sync_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Name of S3 bucket where the aggregated data is stored.
        :param pulumi.Input[str] region: Region with the bucket targeted by the Resource Data Sync.
        :param pulumi.Input[str] kms_key_arn: ARN of an encryption key for a destination in Amazon S3.
        :param pulumi.Input[str] prefix: Prefix for the bucket.
        :param pulumi.Input[str] sync_format: A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "region", region)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if sync_format is not None:
            pulumi.set(__self__, "sync_format", sync_format)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Name of S3 bucket where the aggregated data is stored.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Region with the bucket targeted by the Resource Data Sync.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of an encryption key for a destination in Amazon S3.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix for the bucket.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="syncFormat")
    def sync_format(self) -> Optional[pulumi.Input[str]]:
        """
        A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
        """
        return pulumi.get(self, "sync_format")

    @sync_format.setter
    def sync_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sync_format", value)


if not MYPY:
    class GetInstancesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the filter field. Valid values can be found in the [SSM InstanceInformationStringFilter API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_InstanceInformationStringFilter.html).
        """
        values: Sequence[str]
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
elif False:
    GetInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [SSM InstanceInformationStringFilter API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_InstanceInformationStringFilter.html).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [SSM InstanceInformationStringFilter API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_InstanceInformationStringFilter.html).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetMaintenanceWindowsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the filter field. Valid values can be found in the [SSM DescribeMaintenanceWindows API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribeMaintenanceWindows.html#API_DescribeMaintenanceWindows_RequestSyntax).
        """
        values: Sequence[str]
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
elif False:
    GetMaintenanceWindowsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceWindowsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Name of the filter field. Valid values can be found in the [SSM DescribeMaintenanceWindows API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribeMaintenanceWindows.html#API_DescribeMaintenanceWindows_RequestSyntax).
        :param Sequence[str] values: Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the filter field. Valid values can be found in the [SSM DescribeMaintenanceWindows API Reference](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribeMaintenanceWindows.html#API_DescribeMaintenanceWindows_RequestSyntax).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Set of values that are accepted for the given filter field. Results will be selected if any given value matches.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPatchBaselinesFilterArgsDict(TypedDict):
        key: str
        """
        Filter key. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for valid values.
        """
        values: Sequence[str]
        """
        Filter values. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for example values.
        """
elif False:
    GetPatchBaselinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPatchBaselinesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: Filter key. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for valid values.
        :param Sequence[str] values: Filter values. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for example values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter key. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for valid values.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Filter values. See the [AWS SSM documentation](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_DescribePatchBaselines.html) for example values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


