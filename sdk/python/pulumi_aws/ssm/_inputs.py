# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AssociationOutputLocationArgs',
    'AssociationOutputLocationArgsDict',
    'AssociationTargetArgs',
    'AssociationTargetArgsDict',
    'ContactsRotationRecurrenceArgs',
    'ContactsRotationRecurrenceArgsDict',
    'ContactsRotationRecurrenceDailySettingArgs',
    'ContactsRotationRecurrenceDailySettingArgsDict',
    'ContactsRotationRecurrenceMonthlySettingArgs',
    'ContactsRotationRecurrenceMonthlySettingArgsDict',
    'ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs',
    'ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict',
    'ContactsRotationRecurrenceShiftCoverageArgs',
    'ContactsRotationRecurrenceShiftCoverageArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs',
    'ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict',
    'ContactsRotationRecurrenceWeeklySettingArgs',
    'ContactsRotationRecurrenceWeeklySettingArgsDict',
    'ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs',
    'ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict',
    'DocumentAttachmentsSourceArgs',
    'DocumentAttachmentsSourceArgsDict',
    'DocumentParameterArgs',
    'DocumentParameterArgsDict',
    'MaintenanceWindowTargetTargetArgs',
    'MaintenanceWindowTargetTargetArgsDict',
    'MaintenanceWindowTaskTargetArgs',
    'MaintenanceWindowTaskTargetArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs',
    'MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs',
    'MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict',
    'PatchBaselineApprovalRuleArgs',
    'PatchBaselineApprovalRuleArgsDict',
    'PatchBaselineApprovalRulePatchFilterArgs',
    'PatchBaselineApprovalRulePatchFilterArgsDict',
    'PatchBaselineGlobalFilterArgs',
    'PatchBaselineGlobalFilterArgsDict',
    'PatchBaselineSourceArgs',
    'PatchBaselineSourceArgsDict',
    'QuicksetupConfigurationManagerConfigurationDefinitionArgs',
    'QuicksetupConfigurationManagerConfigurationDefinitionArgsDict',
    'QuicksetupConfigurationManagerStatusSummaryArgs',
    'QuicksetupConfigurationManagerStatusSummaryArgsDict',
    'QuicksetupConfigurationManagerTimeoutsArgs',
    'QuicksetupConfigurationManagerTimeoutsArgsDict',
    'ResourceDataSyncS3DestinationArgs',
    'ResourceDataSyncS3DestinationArgsDict',
    'GetInstancesFilterArgs',
    'GetInstancesFilterArgsDict',
    'GetMaintenanceWindowsFilterArgs',
    'GetMaintenanceWindowsFilterArgsDict',
    'GetPatchBaselinesFilterArgs',
    'GetPatchBaselinesFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AssociationOutputLocationArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[_builtins.str]
        s3_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        s3_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AssociationOutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationOutputLocationArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[_builtins.str],
                 s3_key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)
        if s3_region is not None:
            pulumi.set(__self__, "s3_region", s3_region)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="s3Region")
    def s3_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_region")

    @s3_region.setter
    def s3_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_region", value)


if not MYPY:
    class AssociationTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    AssociationTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ContactsRotationRecurrenceArgsDict(TypedDict):
        number_of_on_calls: pulumi.Input[_builtins.int]
        recurrence_multiplier: pulumi.Input[_builtins.int]
        daily_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgsDict']]]]
        monthly_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgsDict']]]]
        shift_coverages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgsDict']]]]
        weekly_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgsDict']]]]
elif False:
    ContactsRotationRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceArgs:
    def __init__(__self__, *,
                 number_of_on_calls: pulumi.Input[_builtins.int],
                 recurrence_multiplier: pulumi.Input[_builtins.int],
                 daily_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]] = None,
                 monthly_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]] = None,
                 shift_coverages: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]] = None,
                 weekly_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]] = None):
        pulumi.set(__self__, "number_of_on_calls", number_of_on_calls)
        pulumi.set(__self__, "recurrence_multiplier", recurrence_multiplier)
        if daily_settings is not None:
            pulumi.set(__self__, "daily_settings", daily_settings)
        if monthly_settings is not None:
            pulumi.set(__self__, "monthly_settings", monthly_settings)
        if shift_coverages is not None:
            pulumi.set(__self__, "shift_coverages", shift_coverages)
        if weekly_settings is not None:
            pulumi.set(__self__, "weekly_settings", weekly_settings)

    @_builtins.property
    @pulumi.getter(name="numberOfOnCalls")
    def number_of_on_calls(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "number_of_on_calls")

    @number_of_on_calls.setter
    def number_of_on_calls(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number_of_on_calls", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceMultiplier")
    def recurrence_multiplier(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "recurrence_multiplier")

    @recurrence_multiplier.setter
    def recurrence_multiplier(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recurrence_multiplier", value)

    @_builtins.property
    @pulumi.getter(name="dailySettings")
    def daily_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]]:
        return pulumi.get(self, "daily_settings")

    @daily_settings.setter
    def daily_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceDailySettingArgs']]]]):
        pulumi.set(self, "daily_settings", value)

    @_builtins.property
    @pulumi.getter(name="monthlySettings")
    def monthly_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]]:
        return pulumi.get(self, "monthly_settings")

    @monthly_settings.setter
    def monthly_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceMonthlySettingArgs']]]]):
        pulumi.set(self, "monthly_settings", value)

    @_builtins.property
    @pulumi.getter(name="shiftCoverages")
    def shift_coverages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]]:
        return pulumi.get(self, "shift_coverages")

    @shift_coverages.setter
    def shift_coverages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageArgs']]]]):
        pulumi.set(self, "shift_coverages", value)

    @_builtins.property
    @pulumi.getter(name="weeklySettings")
    def weekly_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]]:
        return pulumi.get(self, "weekly_settings")

    @weekly_settings.setter
    def weekly_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceWeeklySettingArgs']]]]):
        pulumi.set(self, "weekly_settings", value)


if not MYPY:
    class ContactsRotationRecurrenceDailySettingArgsDict(TypedDict):
        hour_of_day: pulumi.Input[_builtins.int]
        minute_of_hour: pulumi.Input[_builtins.int]
elif False:
    ContactsRotationRecurrenceDailySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceDailySettingArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[_builtins.int],
                 minute_of_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hour_of_day", value)

    @_builtins.property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceMonthlySettingArgsDict(TypedDict):
        day_of_month: pulumi.Input[_builtins.int]
        hand_off_time: NotRequired[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict']]
elif False:
    ContactsRotationRecurrenceMonthlySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceMonthlySettingArgs:
    def __init__(__self__, *,
                 day_of_month: pulumi.Input[_builtins.int],
                 hand_off_time: Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']] = None):
        pulumi.set(__self__, "day_of_month", day_of_month)
        if hand_off_time is not None:
            pulumi.set(__self__, "hand_off_time", hand_off_time)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day_of_month", value)

    @_builtins.property
    @pulumi.getter(name="handOffTime")
    def hand_off_time(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']]:
        return pulumi.get(self, "hand_off_time")

    @hand_off_time.setter
    def hand_off_time(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs']]):
        pulumi.set(self, "hand_off_time", value)


if not MYPY:
    class ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict(TypedDict):
        hour_of_day: pulumi.Input[_builtins.int]
        minute_of_hour: pulumi.Input[_builtins.int]
elif False:
    ContactsRotationRecurrenceMonthlySettingHandOffTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceMonthlySettingHandOffTimeArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[_builtins.int],
                 minute_of_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hour_of_day", value)

    @_builtins.property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageArgsDict(TypedDict):
        map_block_key: pulumi.Input[_builtins.str]
        coverage_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict']]]]
elif False:
    ContactsRotationRecurrenceShiftCoverageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[_builtins.str],
                 coverage_times: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]] = None):
        pulumi.set(__self__, "map_block_key", map_block_key)
        if coverage_times is not None:
            pulumi.set(__self__, "coverage_times", coverage_times)

    @_builtins.property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "map_block_key", value)

    @_builtins.property
    @pulumi.getter(name="coverageTimes")
    def coverage_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]]:
        return pulumi.get(self, "coverage_times")

    @coverage_times.setter
    def coverage_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs']]]]):
        pulumi.set(self, "coverage_times", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict(TypedDict):
        end: NotRequired[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict']]
        start: NotRequired[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict']]
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']] = None,
                 start: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']] = None):
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs']]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs']]):
        pulumi.set(self, "start", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict(TypedDict):
        hour_of_day: pulumi.Input[_builtins.int]
        minute_of_hour: pulumi.Input[_builtins.int]
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeEndArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[_builtins.int],
                 minute_of_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hour_of_day", value)

    @_builtins.property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict(TypedDict):
        hour_of_day: pulumi.Input[_builtins.int]
        minute_of_hour: pulumi.Input[_builtins.int]
elif False:
    ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceShiftCoverageCoverageTimeStartArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[_builtins.int],
                 minute_of_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hour_of_day", value)

    @_builtins.property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class ContactsRotationRecurrenceWeeklySettingArgsDict(TypedDict):
        day_of_week: pulumi.Input[_builtins.str]
        hand_off_time: NotRequired[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict']]
elif False:
    ContactsRotationRecurrenceWeeklySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceWeeklySettingArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[_builtins.str],
                 hand_off_time: Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        if hand_off_time is not None:
            pulumi.set(__self__, "hand_off_time", hand_off_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter(name="handOffTime")
    def hand_off_time(self) -> Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']]:
        return pulumi.get(self, "hand_off_time")

    @hand_off_time.setter
    def hand_off_time(self, value: Optional[pulumi.Input['ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs']]):
        pulumi.set(self, "hand_off_time", value)


if not MYPY:
    class ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict(TypedDict):
        hour_of_day: pulumi.Input[_builtins.int]
        minute_of_hour: pulumi.Input[_builtins.int]
elif False:
    ContactsRotationRecurrenceWeeklySettingHandOffTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContactsRotationRecurrenceWeeklySettingHandOffTimeArgs:
    def __init__(__self__, *,
                 hour_of_day: pulumi.Input[_builtins.int],
                 minute_of_hour: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "minute_of_hour", minute_of_hour)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hour_of_day", value)

    @_builtins.property
    @pulumi.getter(name="minuteOfHour")
    def minute_of_hour(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minute_of_hour")

    @minute_of_hour.setter
    def minute_of_hour(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minute_of_hour", value)


if not MYPY:
    class DocumentAttachmentsSourceArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DocumentAttachmentsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentAttachmentsSourceArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DocumentParameterArgsDict(TypedDict):
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DocumentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentParameterArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MaintenanceWindowTargetTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MaintenanceWindowTargetTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTargetTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MaintenanceWindowTaskTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersArgsDict(TypedDict):
        automation_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict']]
        lambda_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict']]
        run_command_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict']]
        step_functions_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict']]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersArgs:
    def __init__(__self__, *,
                 automation_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']] = None,
                 lambda_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']] = None,
                 run_command_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']] = None,
                 step_functions_parameters: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']] = None):
        if automation_parameters is not None:
            pulumi.set(__self__, "automation_parameters", automation_parameters)
        if lambda_parameters is not None:
            pulumi.set(__self__, "lambda_parameters", lambda_parameters)
        if run_command_parameters is not None:
            pulumi.set(__self__, "run_command_parameters", run_command_parameters)
        if step_functions_parameters is not None:
            pulumi.set(__self__, "step_functions_parameters", step_functions_parameters)

    @_builtins.property
    @pulumi.getter(name="automationParameters")
    def automation_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']]:
        return pulumi.get(self, "automation_parameters")

    @automation_parameters.setter
    def automation_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs']]):
        pulumi.set(self, "automation_parameters", value)

    @_builtins.property
    @pulumi.getter(name="lambdaParameters")
    def lambda_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']]:
        return pulumi.get(self, "lambda_parameters")

    @lambda_parameters.setter
    def lambda_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs']]):
        pulumi.set(self, "lambda_parameters", value)

    @_builtins.property
    @pulumi.getter(name="runCommandParameters")
    def run_command_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']]:
        return pulumi.get(self, "run_command_parameters")

    @run_command_parameters.setter
    def run_command_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs']]):
        pulumi.set(self, "run_command_parameters", value)

    @_builtins.property
    @pulumi.getter(name="stepFunctionsParameters")
    def step_functions_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']]:
        return pulumi.get(self, "step_functions_parameters")

    @step_functions_parameters.setter
    def step_functions_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs']]):
        pulumi.set(self, "step_functions_parameters", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict(TypedDict):
        document_version: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict']]]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersArgs:
    def __init__(__self__, *,
                 document_version: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]] = None):
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_version", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersAutomationParametersParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict(TypedDict):
        client_context: NotRequired[pulumi.Input[_builtins.str]]
        payload: NotRequired[pulumi.Input[_builtins.str]]
        qualifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersLambdaParametersArgs:
    def __init__(__self__, *,
                 client_context: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifier: Optional[pulumi.Input[_builtins.str]] = None):
        if client_context is not None:
            pulumi.set(__self__, "client_context", client_context)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)

    @_builtins.property
    @pulumi.getter(name="clientContext")
    def client_context(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_context")

    @client_context.setter
    def client_context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_context", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "qualifier", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict(TypedDict):
        cloudwatch_config: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict']]
        comment: NotRequired[pulumi.Input[_builtins.str]]
        document_hash: NotRequired[pulumi.Input[_builtins.str]]
        document_hash_type: NotRequired[pulumi.Input[_builtins.str]]
        document_version: NotRequired[pulumi.Input[_builtins.str]]
        notification_config: NotRequired[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict']]
        output_s3_bucket: NotRequired[pulumi.Input[_builtins.str]]
        output_s3_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict']]]]
        service_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersArgs:
    def __init__(__self__, *,
                 cloudwatch_config: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 document_hash: Optional[pulumi.Input[_builtins.str]] = None,
                 document_hash_type: Optional[pulumi.Input[_builtins.str]] = None,
                 document_version: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_config: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']] = None,
                 output_s3_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 output_s3_key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]] = None,
                 service_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if cloudwatch_config is not None:
            pulumi.set(__self__, "cloudwatch_config", cloudwatch_config)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if document_hash is not None:
            pulumi.set(__self__, "document_hash", document_hash)
        if document_hash_type is not None:
            pulumi.set(__self__, "document_hash_type", document_hash_type)
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if notification_config is not None:
            pulumi.set(__self__, "notification_config", notification_config)
        if output_s3_bucket is not None:
            pulumi.set(__self__, "output_s3_bucket", output_s3_bucket)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_role_arn is not None:
            pulumi.set(__self__, "service_role_arn", service_role_arn)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="cloudwatchConfig")
    def cloudwatch_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']]:
        return pulumi.get(self, "cloudwatch_config")

    @cloudwatch_config.setter
    def cloudwatch_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs']]):
        pulumi.set(self, "cloudwatch_config", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="documentHash")
    def document_hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "document_hash")

    @document_hash.setter
    def document_hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_hash", value)

    @_builtins.property
    @pulumi.getter(name="documentHashType")
    def document_hash_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "document_hash_type")

    @document_hash_type.setter
    def document_hash_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_hash_type", value)

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_version", value)

    @_builtins.property
    @pulumi.getter(name="notificationConfig")
    def notification_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']]:
        return pulumi.get(self, "notification_config")

    @notification_config.setter
    def notification_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs']]):
        pulumi.set(self, "notification_config", value)

    @_builtins.property
    @pulumi.getter(name="outputS3Bucket")
    def output_s3_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "output_s3_bucket")

    @output_s3_bucket.setter
    def output_s3_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "output_s3_key_prefix")

    @output_s3_key_prefix.setter
    def output_s3_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_key_prefix", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="serviceRoleArn")
    def service_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "service_role_arn")

    @service_role_arn.setter
    def service_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict(TypedDict):
        cloudwatch_log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        cloudwatch_output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersCloudwatchConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cloudwatch_output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if cloudwatch_log_group_name is not None:
            pulumi.set(__self__, "cloudwatch_log_group_name", cloudwatch_log_group_name)
        if cloudwatch_output_enabled is not None:
            pulumi.set(__self__, "cloudwatch_output_enabled", cloudwatch_output_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogGroupName")
    def cloudwatch_log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cloudwatch_log_group_name")

    @cloudwatch_log_group_name.setter
    def cloudwatch_log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloudwatch_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="cloudwatchOutputEnabled")
    def cloudwatch_output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cloudwatch_output_enabled")

    @cloudwatch_output_enabled.setter
    def cloudwatch_output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloudwatch_output_enabled", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict(TypedDict):
        notification_arn: NotRequired[pulumi.Input[_builtins.str]]
        notification_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        notification_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersNotificationConfigArgs:
    def __init__(__self__, *,
                 notification_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 notification_type: Optional[pulumi.Input[_builtins.str]] = None):
        if notification_arn is not None:
            pulumi.set(__self__, "notification_arn", notification_arn)
        if notification_events is not None:
            pulumi.set(__self__, "notification_events", notification_events)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)

    @_builtins.property
    @pulumi.getter(name="notificationArn")
    def notification_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "notification_arn")

    @notification_arn.setter
    def notification_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notification_arn", value)

    @_builtins.property
    @pulumi.getter(name="notificationEvents")
    def notification_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "notification_events")

    @notification_events.setter
    def notification_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "notification_events", value)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notification_type", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersRunCommandParametersParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict(TypedDict):
        input: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersStepFunctionsParametersArgs:
    def __init__(__self__, *,
                 input: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if input is not None:
            pulumi.set(__self__, "input", input)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PatchBaselineApprovalRuleArgsDict(TypedDict):
        patch_filters: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgsDict']]]
        approve_after_days: NotRequired[pulumi.Input[_builtins.int]]
        approve_until_date: NotRequired[pulumi.Input[_builtins.str]]
        compliance_level: NotRequired[pulumi.Input[_builtins.str]]
        enable_non_security: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PatchBaselineApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineApprovalRuleArgs:
    def __init__(__self__, *,
                 patch_filters: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]],
                 approve_after_days: Optional[pulumi.Input[_builtins.int]] = None,
                 approve_until_date: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_level: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_non_security: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "patch_filters", patch_filters)
        if approve_after_days is not None:
            pulumi.set(__self__, "approve_after_days", approve_after_days)
        if approve_until_date is not None:
            pulumi.set(__self__, "approve_until_date", approve_until_date)
        if compliance_level is not None:
            pulumi.set(__self__, "compliance_level", compliance_level)
        if enable_non_security is not None:
            pulumi.set(__self__, "enable_non_security", enable_non_security)

    @_builtins.property
    @pulumi.getter(name="patchFilters")
    def patch_filters(self) -> pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]]:
        return pulumi.get(self, "patch_filters")

    @patch_filters.setter
    def patch_filters(self, value: pulumi.Input[Sequence[pulumi.Input['PatchBaselineApprovalRulePatchFilterArgs']]]):
        pulumi.set(self, "patch_filters", value)

    @_builtins.property
    @pulumi.getter(name="approveAfterDays")
    def approve_after_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "approve_after_days")

    @approve_after_days.setter
    def approve_after_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "approve_after_days", value)

    @_builtins.property
    @pulumi.getter(name="approveUntilDate")
    def approve_until_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "approve_until_date")

    @approve_until_date.setter
    def approve_until_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approve_until_date", value)

    @_builtins.property
    @pulumi.getter(name="complianceLevel")
    def compliance_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "compliance_level")

    @compliance_level.setter
    def compliance_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compliance_level", value)

    @_builtins.property
    @pulumi.getter(name="enableNonSecurity")
    def enable_non_security(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_non_security")

    @enable_non_security.setter
    def enable_non_security(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_non_security", value)


if not MYPY:
    class PatchBaselineApprovalRulePatchFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PatchBaselineApprovalRulePatchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineApprovalRulePatchFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PatchBaselineGlobalFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PatchBaselineGlobalFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineGlobalFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PatchBaselineSourceArgsDict(TypedDict):
        configuration: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        products: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PatchBaselineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineSourceArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 products: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class QuicksetupConfigurationManagerConfigurationDefinitionArgsDict(TypedDict):
        parameters: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        type: pulumi.Input[_builtins.str]
        id: NotRequired[pulumi.Input[_builtins.str]]
        local_deployment_administration_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        local_deployment_execution_role_name: NotRequired[pulumi.Input[_builtins.str]]
        type_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    QuicksetupConfigurationManagerConfigurationDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerConfigurationDefinitionArgs:
    def __init__(__self__, *,
                 parameters: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 local_deployment_administration_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 local_deployment_execution_role_name: Optional[pulumi.Input[_builtins.str]] = None,
                 type_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if local_deployment_administration_role_arn is not None:
            pulumi.set(__self__, "local_deployment_administration_role_arn", local_deployment_administration_role_arn)
        if local_deployment_execution_role_name is not None:
            pulumi.set(__self__, "local_deployment_execution_role_name", local_deployment_execution_role_name)
        if type_version is not None:
            pulumi.set(__self__, "type_version", type_version)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="localDeploymentAdministrationRoleArn")
    def local_deployment_administration_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_deployment_administration_role_arn")

    @local_deployment_administration_role_arn.setter
    def local_deployment_administration_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_deployment_administration_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="localDeploymentExecutionRoleName")
    def local_deployment_execution_role_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_deployment_execution_role_name")

    @local_deployment_execution_role_name.setter
    def local_deployment_execution_role_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_deployment_execution_role_name", value)

    @_builtins.property
    @pulumi.getter(name="typeVersion")
    def type_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type_version")

    @type_version.setter
    def type_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type_version", value)


if not MYPY:
    class QuicksetupConfigurationManagerStatusSummaryArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        status_message: pulumi.Input[_builtins.str]
        status_type: pulumi.Input[_builtins.str]
elif False:
    QuicksetupConfigurationManagerStatusSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerStatusSummaryArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 status_message: pulumi.Input[_builtins.str],
                 status_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "status_type", status_type)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_message", value)

    @_builtins.property
    @pulumi.getter(name="statusType")
    def status_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_type")

    @status_type.setter
    def status_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_type", value)


if not MYPY:
    class QuicksetupConfigurationManagerTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    QuicksetupConfigurationManagerTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuicksetupConfigurationManagerTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ResourceDataSyncS3DestinationArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        region: pulumi.Input[_builtins.str]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        sync_format: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResourceDataSyncS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDataSyncS3DestinationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_format: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "region", region)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if sync_format is not None:
            pulumi.set(__self__, "sync_format", sync_format)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="syncFormat")
    def sync_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sync_format")

    @sync_format.setter
    def sync_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sync_format", value)


if not MYPY:
    class GetInstancesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetInstancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetMaintenanceWindowsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetMaintenanceWindowsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceWindowsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPatchBaselinesFilterArgsDict(TypedDict):
        key: _builtins.str
        values: Sequence[_builtins.str]
elif False:
    GetPatchBaselinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPatchBaselinesFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


