# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CapacityProviderAutoScalingGroupProviderArgs',
    'CapacityProviderAutoScalingGroupProviderArgsDict',
    'CapacityProviderAutoScalingGroupProviderManagedScalingArgs',
    'CapacityProviderAutoScalingGroupProviderManagedScalingArgsDict',
    'CapacityProviderManagedInstancesProviderArgs',
    'CapacityProviderManagedInstancesProviderArgsDict',
    'CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgs',
    'CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgsDict',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgs',
    'CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgsDict',
    'ClusterCapacityProvidersDefaultCapacityProviderStrategyArgs',
    'ClusterCapacityProvidersDefaultCapacityProviderStrategyArgsDict',
    'ClusterConfigurationArgs',
    'ClusterConfigurationArgsDict',
    'ClusterConfigurationExecuteCommandConfigurationArgs',
    'ClusterConfigurationExecuteCommandConfigurationArgsDict',
    'ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgs',
    'ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgsDict',
    'ClusterConfigurationManagedStorageConfigurationArgs',
    'ClusterConfigurationManagedStorageConfigurationArgsDict',
    'ClusterServiceConnectDefaultsArgs',
    'ClusterServiceConnectDefaultsArgsDict',
    'ClusterSettingArgs',
    'ClusterSettingArgsDict',
    'ExpressGatewayServiceIngressPathArgs',
    'ExpressGatewayServiceIngressPathArgsDict',
    'ExpressGatewayServiceNetworkConfigurationArgs',
    'ExpressGatewayServiceNetworkConfigurationArgsDict',
    'ExpressGatewayServicePrimaryContainerArgs',
    'ExpressGatewayServicePrimaryContainerArgsDict',
    'ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgs',
    'ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgsDict',
    'ExpressGatewayServicePrimaryContainerEnvironmentArgs',
    'ExpressGatewayServicePrimaryContainerEnvironmentArgsDict',
    'ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgs',
    'ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgsDict',
    'ExpressGatewayServicePrimaryContainerSecretArgs',
    'ExpressGatewayServicePrimaryContainerSecretArgsDict',
    'ExpressGatewayServiceScalingTargetArgs',
    'ExpressGatewayServiceScalingTargetArgsDict',
    'ExpressGatewayServiceTimeoutsArgs',
    'ExpressGatewayServiceTimeoutsArgsDict',
    'ServiceAlarmsArgs',
    'ServiceAlarmsArgsDict',
    'ServiceCapacityProviderStrategyArgs',
    'ServiceCapacityProviderStrategyArgsDict',
    'ServiceDeploymentCircuitBreakerArgs',
    'ServiceDeploymentCircuitBreakerArgsDict',
    'ServiceDeploymentConfigurationArgs',
    'ServiceDeploymentConfigurationArgsDict',
    'ServiceDeploymentConfigurationCanaryConfigurationArgs',
    'ServiceDeploymentConfigurationCanaryConfigurationArgsDict',
    'ServiceDeploymentConfigurationLifecycleHookArgs',
    'ServiceDeploymentConfigurationLifecycleHookArgsDict',
    'ServiceDeploymentConfigurationLinearConfigurationArgs',
    'ServiceDeploymentConfigurationLinearConfigurationArgsDict',
    'ServiceDeploymentControllerArgs',
    'ServiceDeploymentControllerArgsDict',
    'ServiceLoadBalancerArgs',
    'ServiceLoadBalancerArgsDict',
    'ServiceLoadBalancerAdvancedConfigurationArgs',
    'ServiceLoadBalancerAdvancedConfigurationArgsDict',
    'ServiceNetworkConfigurationArgs',
    'ServiceNetworkConfigurationArgsDict',
    'ServiceOrderedPlacementStrategyArgs',
    'ServiceOrderedPlacementStrategyArgsDict',
    'ServicePlacementConstraintArgs',
    'ServicePlacementConstraintArgsDict',
    'ServiceServiceConnectConfigurationArgs',
    'ServiceServiceConnectConfigurationArgsDict',
    'ServiceServiceConnectConfigurationLogConfigurationArgs',
    'ServiceServiceConnectConfigurationLogConfigurationArgsDict',
    'ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgs',
    'ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgsDict',
    'ServiceServiceConnectConfigurationServiceArgs',
    'ServiceServiceConnectConfigurationServiceArgsDict',
    'ServiceServiceConnectConfigurationServiceClientAliasArgs',
    'ServiceServiceConnectConfigurationServiceClientAliasArgsDict',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgs',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgsDict',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgs',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgsDict',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgs',
    'ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgsDict',
    'ServiceServiceConnectConfigurationServiceTimeoutArgs',
    'ServiceServiceConnectConfigurationServiceTimeoutArgsDict',
    'ServiceServiceConnectConfigurationServiceTlsArgs',
    'ServiceServiceConnectConfigurationServiceTlsArgsDict',
    'ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgs',
    'ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgsDict',
    'ServiceServiceRegistriesArgs',
    'ServiceServiceRegistriesArgsDict',
    'ServiceVolumeConfigurationArgs',
    'ServiceVolumeConfigurationArgsDict',
    'ServiceVolumeConfigurationManagedEbsVolumeArgs',
    'ServiceVolumeConfigurationManagedEbsVolumeArgsDict',
    'ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgs',
    'ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgsDict',
    'ServiceVpcLatticeConfigurationArgs',
    'ServiceVpcLatticeConfigurationArgsDict',
    'TaskDefinitionEphemeralStorageArgs',
    'TaskDefinitionEphemeralStorageArgsDict',
    'TaskDefinitionPlacementConstraintArgs',
    'TaskDefinitionPlacementConstraintArgsDict',
    'TaskDefinitionProxyConfigurationArgs',
    'TaskDefinitionProxyConfigurationArgsDict',
    'TaskDefinitionRuntimePlatformArgs',
    'TaskDefinitionRuntimePlatformArgsDict',
    'TaskDefinitionVolumeArgs',
    'TaskDefinitionVolumeArgsDict',
    'TaskDefinitionVolumeDockerVolumeConfigurationArgs',
    'TaskDefinitionVolumeDockerVolumeConfigurationArgsDict',
    'TaskDefinitionVolumeEfsVolumeConfigurationArgs',
    'TaskDefinitionVolumeEfsVolumeConfigurationArgsDict',
    'TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs',
    'TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgsDict',
    'TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgs',
    'TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgsDict',
    'TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgs',
    'TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgsDict',
    'TaskSetCapacityProviderStrategyArgs',
    'TaskSetCapacityProviderStrategyArgsDict',
    'TaskSetLoadBalancerArgs',
    'TaskSetLoadBalancerArgsDict',
    'TaskSetNetworkConfigurationArgs',
    'TaskSetNetworkConfigurationArgsDict',
    'TaskSetScaleArgs',
    'TaskSetScaleArgsDict',
    'TaskSetServiceRegistriesArgs',
    'TaskSetServiceRegistriesArgsDict',
    'GetTaskExecutionCapacityProviderStrategyArgs',
    'GetTaskExecutionCapacityProviderStrategyArgsDict',
    'GetTaskExecutionNetworkConfigurationArgs',
    'GetTaskExecutionNetworkConfigurationArgsDict',
    'GetTaskExecutionOverridesArgs',
    'GetTaskExecutionOverridesArgsDict',
    'GetTaskExecutionOverridesContainerOverrideArgs',
    'GetTaskExecutionOverridesContainerOverrideArgsDict',
    'GetTaskExecutionOverridesContainerOverrideEnvironmentArgs',
    'GetTaskExecutionOverridesContainerOverrideEnvironmentArgsDict',
    'GetTaskExecutionOverridesContainerOverrideResourceRequirementArgs',
    'GetTaskExecutionOverridesContainerOverrideResourceRequirementArgsDict',
    'GetTaskExecutionPlacementConstraintArgs',
    'GetTaskExecutionPlacementConstraintArgsDict',
    'GetTaskExecutionPlacementStrategyArgs',
    'GetTaskExecutionPlacementStrategyArgsDict',
]

MYPY = False

if not MYPY:
    class CapacityProviderAutoScalingGroupProviderArgsDict(TypedDict):
        auto_scaling_group_arn: pulumi.Input[_builtins.str]
        managed_draining: NotRequired[pulumi.Input[_builtins.str]]
        managed_scaling: NotRequired[pulumi.Input['CapacityProviderAutoScalingGroupProviderManagedScalingArgsDict']]
        managed_termination_protection: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CapacityProviderAutoScalingGroupProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderAutoScalingGroupProviderArgs:
    def __init__(__self__, *,
                 auto_scaling_group_arn: pulumi.Input[_builtins.str],
                 managed_draining: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_scaling: Optional[pulumi.Input['CapacityProviderAutoScalingGroupProviderManagedScalingArgs']] = None,
                 managed_termination_protection: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "auto_scaling_group_arn", auto_scaling_group_arn)
        if managed_draining is not None:
            pulumi.set(__self__, "managed_draining", managed_draining)
        if managed_scaling is not None:
            pulumi.set(__self__, "managed_scaling", managed_scaling)
        if managed_termination_protection is not None:
            pulumi.set(__self__, "managed_termination_protection", managed_termination_protection)

    @_builtins.property
    @pulumi.getter(name="autoScalingGroupArn")
    def auto_scaling_group_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "auto_scaling_group_arn")

    @auto_scaling_group_arn.setter
    def auto_scaling_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auto_scaling_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="managedDraining")
    def managed_draining(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "managed_draining")

    @managed_draining.setter
    def managed_draining(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_draining", value)

    @_builtins.property
    @pulumi.getter(name="managedScaling")
    def managed_scaling(self) -> Optional[pulumi.Input['CapacityProviderAutoScalingGroupProviderManagedScalingArgs']]:
        return pulumi.get(self, "managed_scaling")

    @managed_scaling.setter
    def managed_scaling(self, value: Optional[pulumi.Input['CapacityProviderAutoScalingGroupProviderManagedScalingArgs']]):
        pulumi.set(self, "managed_scaling", value)

    @_builtins.property
    @pulumi.getter(name="managedTerminationProtection")
    def managed_termination_protection(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "managed_termination_protection")

    @managed_termination_protection.setter
    def managed_termination_protection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "managed_termination_protection", value)


if not MYPY:
    class CapacityProviderAutoScalingGroupProviderManagedScalingArgsDict(TypedDict):
        instance_warmup_period: NotRequired[pulumi.Input[_builtins.int]]
        maximum_scaling_step_size: NotRequired[pulumi.Input[_builtins.int]]
        minimum_scaling_step_size: NotRequired[pulumi.Input[_builtins.int]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        target_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderAutoScalingGroupProviderManagedScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderAutoScalingGroupProviderManagedScalingArgs:
    def __init__(__self__, *,
                 instance_warmup_period: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_scaling_step_size: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_scaling_step_size: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 target_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        if instance_warmup_period is not None:
            pulumi.set(__self__, "instance_warmup_period", instance_warmup_period)
        if maximum_scaling_step_size is not None:
            pulumi.set(__self__, "maximum_scaling_step_size", maximum_scaling_step_size)
        if minimum_scaling_step_size is not None:
            pulumi.set(__self__, "minimum_scaling_step_size", minimum_scaling_step_size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceWarmupPeriod")
    def instance_warmup_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_warmup_period")

    @instance_warmup_period.setter
    def instance_warmup_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_warmup_period", value)

    @_builtins.property
    @pulumi.getter(name="maximumScalingStepSize")
    def maximum_scaling_step_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_scaling_step_size")

    @maximum_scaling_step_size.setter
    def maximum_scaling_step_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_scaling_step_size", value)

    @_builtins.property
    @pulumi.getter(name="minimumScalingStepSize")
    def minimum_scaling_step_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "minimum_scaling_step_size")

    @minimum_scaling_step_size.setter
    def minimum_scaling_step_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_scaling_step_size", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "target_capacity")

    @target_capacity.setter
    def target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_capacity", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderArgsDict(TypedDict):
        infrastructure_role_arn: pulumi.Input[_builtins.str]
        instance_launch_template: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgsDict']
        infrastructure_optimization: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgsDict']]
        propagate_tags: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CapacityProviderManagedInstancesProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderArgs:
    def __init__(__self__, *,
                 infrastructure_role_arn: pulumi.Input[_builtins.str],
                 instance_launch_template: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgs'],
                 infrastructure_optimization: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgs']] = None,
                 propagate_tags: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "infrastructure_role_arn", infrastructure_role_arn)
        pulumi.set(__self__, "instance_launch_template", instance_launch_template)
        if infrastructure_optimization is not None:
            pulumi.set(__self__, "infrastructure_optimization", infrastructure_optimization)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)

    @_builtins.property
    @pulumi.getter(name="infrastructureRoleArn")
    def infrastructure_role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "infrastructure_role_arn")

    @infrastructure_role_arn.setter
    def infrastructure_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "infrastructure_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="instanceLaunchTemplate")
    def instance_launch_template(self) -> pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgs']:
        return pulumi.get(self, "instance_launch_template")

    @instance_launch_template.setter
    def instance_launch_template(self, value: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgs']):
        pulumi.set(self, "instance_launch_template", value)

    @_builtins.property
    @pulumi.getter(name="infrastructureOptimization")
    def infrastructure_optimization(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgs']]:
        return pulumi.get(self, "infrastructure_optimization")

    @infrastructure_optimization.setter
    def infrastructure_optimization(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgs']]):
        pulumi.set(self, "infrastructure_optimization", value)

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "propagate_tags", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgsDict(TypedDict):
        scale_in_after: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInfrastructureOptimizationArgs:
    def __init__(__self__, *,
                 scale_in_after: Optional[pulumi.Input[_builtins.int]] = None):
        if scale_in_after is not None:
            pulumi.set(__self__, "scale_in_after", scale_in_after)

    @_builtins.property
    @pulumi.getter(name="scaleInAfter")
    def scale_in_after(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "scale_in_after")

    @scale_in_after.setter
    def scale_in_after(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "scale_in_after", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgsDict(TypedDict):
        ec2_instance_profile_arn: pulumi.Input[_builtins.str]
        network_configuration: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgsDict']
        capacity_option_type: NotRequired[pulumi.Input[_builtins.str]]
        instance_requirements: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgsDict']]
        monitoring: NotRequired[pulumi.Input[_builtins.str]]
        storage_configuration: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgsDict']]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateArgs:
    def __init__(__self__, *,
                 ec2_instance_profile_arn: pulumi.Input[_builtins.str],
                 network_configuration: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgs'],
                 capacity_option_type: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_requirements: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs']] = None,
                 monitoring: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_configuration: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgs']] = None):
        pulumi.set(__self__, "ec2_instance_profile_arn", ec2_instance_profile_arn)
        pulumi.set(__self__, "network_configuration", network_configuration)
        if capacity_option_type is not None:
            pulumi.set(__self__, "capacity_option_type", capacity_option_type)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if storage_configuration is not None:
            pulumi.set(__self__, "storage_configuration", storage_configuration)

    @_builtins.property
    @pulumi.getter(name="ec2InstanceProfileArn")
    def ec2_instance_profile_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ec2_instance_profile_arn")

    @ec2_instance_profile_arn.setter
    def ec2_instance_profile_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ec2_instance_profile_arn", value)

    @_builtins.property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgs']:
        return pulumi.get(self, "network_configuration")

    @network_configuration.setter
    def network_configuration(self, value: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgs']):
        pulumi.set(self, "network_configuration", value)

    @_builtins.property
    @pulumi.getter(name="capacityOptionType")
    def capacity_option_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "capacity_option_type")

    @capacity_option_type.setter
    def capacity_option_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capacity_option_type", value)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs']]:
        return pulumi.get(self, "instance_requirements")

    @instance_requirements.setter
    def instance_requirements(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs']]):
        pulumi.set(self, "instance_requirements", value)

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitoring", value)

    @_builtins.property
    @pulumi.getter(name="storageConfiguration")
    def storage_configuration(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgs']]:
        return pulumi.get(self, "storage_configuration")

    @storage_configuration.setter
    def storage_configuration(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgs']]):
        pulumi.set(self, "storage_configuration", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgsDict(TypedDict):
        memory_mib: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgsDict']
        vcpu_count: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgsDict']
        accelerator_count: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgsDict']]
        accelerator_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        accelerator_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        accelerator_total_memory_mib: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgsDict']]
        accelerator_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allowed_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        bare_metal: NotRequired[pulumi.Input[_builtins.str]]
        baseline_ebs_bandwidth_mbps: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgsDict']]
        burstable_performance: NotRequired[pulumi.Input[_builtins.str]]
        cpu_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        instance_generations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        local_storage: NotRequired[pulumi.Input[_builtins.str]]
        local_storage_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        max_spot_price_as_percentage_of_optimal_on_demand_price: NotRequired[pulumi.Input[_builtins.int]]
        memory_gib_per_vcpu: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgsDict']]
        network_bandwidth_gbps: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgsDict']]
        network_interface_count: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgsDict']]
        on_demand_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        require_hibernate_support: NotRequired[pulumi.Input[_builtins.bool]]
        spot_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        total_local_storage_gb: NotRequired[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgsDict']]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs:
    def __init__(__self__, *,
                 memory_mib: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs'],
                 vcpu_count: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs'],
                 accelerator_count: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs']] = None,
                 accelerator_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 accelerator_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 accelerator_total_memory_mib: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs']] = None,
                 accelerator_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bare_metal: Optional[pulumi.Input[_builtins.str]] = None,
                 baseline_ebs_bandwidth_mbps: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs']] = None,
                 burstable_performance: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_generations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_storage: Optional[pulumi.Input[_builtins.str]] = None,
                 local_storage_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_gib_per_vcpu: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs']] = None,
                 network_bandwidth_gbps: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs']] = None,
                 network_interface_count: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs']] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 require_hibernate_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 total_local_storage_gb: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs']] = None):
        pulumi.set(__self__, "memory_mib", memory_mib)
        pulumi.set(__self__, "vcpu_count", vcpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs']:
        return pulumi.get(self, "memory_mib")

    @memory_mib.setter
    def memory_mib(self, value: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs']):
        pulumi.set(self, "memory_mib", value)

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs']:
        return pulumi.get(self, "vcpu_count")

    @vcpu_count.setter
    def vcpu_count(self, value: pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs']):
        pulumi.set(self, "vcpu_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs']]:
        return pulumi.get(self, "accelerator_count")

    @accelerator_count.setter
    def accelerator_count(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs']]):
        pulumi.set(self, "accelerator_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @accelerator_manufacturers.setter
    def accelerator_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "accelerator_names")

    @accelerator_names.setter
    def accelerator_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_names", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs']]:
        return pulumi.get(self, "accelerator_total_memory_mib")

    @accelerator_total_memory_mib.setter
    def accelerator_total_memory_mib(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs']]):
        pulumi.set(self, "accelerator_total_memory_mib", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "accelerator_types")

    @accelerator_types.setter
    def accelerator_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_types", value)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bare_metal")

    @bare_metal.setter
    def bare_metal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bare_metal", value)

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs']]:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @baseline_ebs_bandwidth_mbps.setter
    def baseline_ebs_bandwidth_mbps(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs']]):
        pulumi.set(self, "baseline_ebs_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "burstable_performance")

    @burstable_performance.setter
    def burstable_performance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "burstable_performance", value)

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "cpu_manufacturers")

    @cpu_manufacturers.setter
    def cpu_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cpu_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "instance_generations")

    @instance_generations.setter
    def instance_generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "instance_generations", value)

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_storage")

    @local_storage.setter
    def local_storage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_storage", value)

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "local_storage_types")

    @local_storage_types.setter
    def local_storage_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "local_storage_types", value)

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @max_spot_price_as_percentage_of_optimal_on_demand_price.setter
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_spot_price_as_percentage_of_optimal_on_demand_price", value)

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs']]:
        return pulumi.get(self, "memory_gib_per_vcpu")

    @memory_gib_per_vcpu.setter
    def memory_gib_per_vcpu(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs']]):
        pulumi.set(self, "memory_gib_per_vcpu", value)

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs']]:
        return pulumi.get(self, "network_bandwidth_gbps")

    @network_bandwidth_gbps.setter
    def network_bandwidth_gbps(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs']]):
        pulumi.set(self, "network_bandwidth_gbps", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs']]:
        return pulumi.get(self, "network_interface_count")

    @network_interface_count.setter
    def network_interface_count(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs']]):
        pulumi.set(self, "network_interface_count", value)

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @on_demand_max_price_percentage_over_lowest_price.setter
    def on_demand_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "require_hibernate_support")

    @require_hibernate_support.setter
    def require_hibernate_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_hibernate_support", value)

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @spot_max_price_percentage_over_lowest_price.setter
    def spot_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs']]:
        return pulumi.get(self, "total_local_storage_gb")

    @total_local_storage_gb.setter
    def total_local_storage_gb(self, value: Optional[pulumi.Input['CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs']]):
        pulumi.set(self, "total_local_storage_gb", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        min: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        min: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        min: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        min: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        min: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        min: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        min: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgsDict(TypedDict):
        storage_size_gib: pulumi.Input[_builtins.int]
elif False:
    CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateStorageConfigurationArgs:
    def __init__(__self__, *,
                 storage_size_gib: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "storage_size_gib", storage_size_gib)

    @_builtins.property
    @pulumi.getter(name="storageSizeGib")
    def storage_size_gib(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "storage_size_gib")

    @storage_size_gib.setter
    def storage_size_gib(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_size_gib", value)


if not MYPY:
    class ClusterCapacityProvidersDefaultCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: pulumi.Input[_builtins.str]
        base: NotRequired[pulumi.Input[_builtins.int]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ClusterCapacityProvidersDefaultCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCapacityProvidersDefaultCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[_builtins.str],
                 base: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ClusterConfigurationArgsDict(TypedDict):
        execute_command_configuration: NotRequired[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationArgsDict']]
        managed_storage_configuration: NotRequired[pulumi.Input['ClusterConfigurationManagedStorageConfigurationArgsDict']]
elif False:
    ClusterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationArgs:
    def __init__(__self__, *,
                 execute_command_configuration: Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationArgs']] = None,
                 managed_storage_configuration: Optional[pulumi.Input['ClusterConfigurationManagedStorageConfigurationArgs']] = None):
        if execute_command_configuration is not None:
            pulumi.set(__self__, "execute_command_configuration", execute_command_configuration)
        if managed_storage_configuration is not None:
            pulumi.set(__self__, "managed_storage_configuration", managed_storage_configuration)

    @_builtins.property
    @pulumi.getter(name="executeCommandConfiguration")
    def execute_command_configuration(self) -> Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationArgs']]:
        return pulumi.get(self, "execute_command_configuration")

    @execute_command_configuration.setter
    def execute_command_configuration(self, value: Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationArgs']]):
        pulumi.set(self, "execute_command_configuration", value)

    @_builtins.property
    @pulumi.getter(name="managedStorageConfiguration")
    def managed_storage_configuration(self) -> Optional[pulumi.Input['ClusterConfigurationManagedStorageConfigurationArgs']]:
        return pulumi.get(self, "managed_storage_configuration")

    @managed_storage_configuration.setter
    def managed_storage_configuration(self, value: Optional[pulumi.Input['ClusterConfigurationManagedStorageConfigurationArgs']]):
        pulumi.set(self, "managed_storage_configuration", value)


if not MYPY:
    class ClusterConfigurationExecuteCommandConfigurationArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        log_configuration: NotRequired[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgsDict']]
        logging: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterConfigurationExecuteCommandConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationExecuteCommandConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_configuration: Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgs']] = None,
                 logging: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if log_configuration is not None:
            pulumi.set(__self__, "log_configuration", log_configuration)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="logConfiguration")
    def log_configuration(self) -> Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgs']]:
        return pulumi.get(self, "log_configuration")

    @log_configuration.setter
    def log_configuration(self, value: Optional[pulumi.Input['ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgs']]):
        pulumi.set(self, "log_configuration", value)

    @_builtins.property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logging", value)


if not MYPY:
    class ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgsDict(TypedDict):
        cloud_watch_encryption_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        cloud_watch_log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        s3_bucket_encryption_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        s3_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationExecuteCommandConfigurationLogConfigurationArgs:
    def __init__(__self__, *,
                 cloud_watch_encryption_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 cloud_watch_log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_bucket_encryption_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_key_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        if cloud_watch_encryption_enabled is not None:
            pulumi.set(__self__, "cloud_watch_encryption_enabled", cloud_watch_encryption_enabled)
        if cloud_watch_log_group_name is not None:
            pulumi.set(__self__, "cloud_watch_log_group_name", cloud_watch_log_group_name)
        if s3_bucket_encryption_enabled is not None:
            pulumi.set(__self__, "s3_bucket_encryption_enabled", s3_bucket_encryption_enabled)
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @_builtins.property
    @pulumi.getter(name="cloudWatchEncryptionEnabled")
    def cloud_watch_encryption_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cloud_watch_encryption_enabled")

    @cloud_watch_encryption_enabled.setter
    def cloud_watch_encryption_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloud_watch_encryption_enabled", value)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogGroupName")
    def cloud_watch_log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cloud_watch_log_group_name")

    @cloud_watch_log_group_name.setter
    def cloud_watch_log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_watch_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketEncryptionEnabled")
    def s3_bucket_encryption_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "s3_bucket_encryption_enabled")

    @s3_bucket_encryption_enabled.setter
    def s3_bucket_encryption_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "s3_bucket_encryption_enabled", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key_prefix", value)


if not MYPY:
    class ClusterConfigurationManagedStorageConfigurationArgsDict(TypedDict):
        fargate_ephemeral_storage_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterConfigurationManagedStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigurationManagedStorageConfigurationArgs:
    def __init__(__self__, *,
                 fargate_ephemeral_storage_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        if fargate_ephemeral_storage_kms_key_id is not None:
            pulumi.set(__self__, "fargate_ephemeral_storage_kms_key_id", fargate_ephemeral_storage_kms_key_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="fargateEphemeralStorageKmsKeyId")
    def fargate_ephemeral_storage_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fargate_ephemeral_storage_kms_key_id")

    @fargate_ephemeral_storage_kms_key_id.setter
    def fargate_ephemeral_storage_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fargate_ephemeral_storage_kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ClusterServiceConnectDefaultsArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
elif False:
    ClusterServiceConnectDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServiceConnectDefaultsArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ClusterSettingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    ClusterSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ExpressGatewayServiceIngressPathArgsDict(TypedDict):
        access_type: pulumi.Input[_builtins.str]
        endpoint: pulumi.Input[_builtins.str]
elif False:
    ExpressGatewayServiceIngressPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServiceIngressPathArgs:
    def __init__(__self__, *,
                 access_type: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_type", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class ExpressGatewayServiceNetworkConfigurationArgsDict(TypedDict):
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ExpressGatewayServiceNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServiceNetworkConfigurationArgs:
    def __init__(__self__, *,
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ExpressGatewayServicePrimaryContainerArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        aws_logs_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgsDict']]]]
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        container_port: NotRequired[pulumi.Input[_builtins.int]]
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerEnvironmentArgsDict']]]]
        repository_credentials: NotRequired[pulumi.Input['ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgsDict']]
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerSecretArgsDict']]]]
elif False:
    ExpressGatewayServicePrimaryContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServicePrimaryContainerArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 aws_logs_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgs']]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 container_port: Optional[pulumi.Input[_builtins.int]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerEnvironmentArgs']]]] = None,
                 repository_credentials: Optional[pulumi.Input['ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgs']] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerSecretArgs']]]] = None):
        pulumi.set(__self__, "image", image)
        if aws_logs_configurations is not None:
            pulumi.set(__self__, "aws_logs_configurations", aws_logs_configurations)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if repository_credentials is not None:
            pulumi.set(__self__, "repository_credentials", repository_credentials)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="awsLogsConfigurations")
    def aws_logs_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgs']]]]:
        return pulumi.get(self, "aws_logs_configurations")

    @aws_logs_configurations.setter
    def aws_logs_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgs']]]]):
        pulumi.set(self, "aws_logs_configurations", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerEnvironmentArgs']]]]:
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerEnvironmentArgs']]]]):
        pulumi.set(self, "environments", value)

    @_builtins.property
    @pulumi.getter(name="repositoryCredentials")
    def repository_credentials(self) -> Optional[pulumi.Input['ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgs']]:
        return pulumi.get(self, "repository_credentials")

    @repository_credentials.setter
    def repository_credentials(self, value: Optional[pulumi.Input['ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgs']]):
        pulumi.set(self, "repository_credentials", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerSecretArgs']]]]:
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExpressGatewayServicePrimaryContainerSecretArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgsDict(TypedDict):
        log_group: pulumi.Input[_builtins.str]
        log_stream_prefix: pulumi.Input[_builtins.str]
elif False:
    ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServicePrimaryContainerAwsLogsConfigurationArgs:
    def __init__(__self__, *,
                 log_group: pulumi.Input[_builtins.str],
                 log_stream_prefix: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "log_group", log_group)
        pulumi.set(__self__, "log_stream_prefix", log_stream_prefix)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="logStreamPrefix")
    def log_stream_prefix(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_stream_prefix")

    @log_stream_prefix.setter
    def log_stream_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_prefix", value)


if not MYPY:
    class ExpressGatewayServicePrimaryContainerEnvironmentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    ExpressGatewayServicePrimaryContainerEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServicePrimaryContainerEnvironmentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgsDict(TypedDict):
        credentials_parameter: pulumi.Input[_builtins.str]
elif False:
    ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServicePrimaryContainerRepositoryCredentialsArgs:
    def __init__(__self__, *,
                 credentials_parameter: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "credentials_parameter", credentials_parameter)

    @_builtins.property
    @pulumi.getter(name="credentialsParameter")
    def credentials_parameter(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "credentials_parameter")

    @credentials_parameter.setter
    def credentials_parameter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_parameter", value)


if not MYPY:
    class ExpressGatewayServicePrimaryContainerSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value_from: pulumi.Input[_builtins.str]
elif False:
    ExpressGatewayServicePrimaryContainerSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServicePrimaryContainerSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value_from: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_from", value)


if not MYPY:
    class ExpressGatewayServiceScalingTargetArgsDict(TypedDict):
        auto_scaling_metric: pulumi.Input[_builtins.str]
        auto_scaling_target_value: pulumi.Input[_builtins.int]
        max_task_count: pulumi.Input[_builtins.int]
        min_task_count: pulumi.Input[_builtins.int]
elif False:
    ExpressGatewayServiceScalingTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServiceScalingTargetArgs:
    def __init__(__self__, *,
                 auto_scaling_metric: pulumi.Input[_builtins.str],
                 auto_scaling_target_value: pulumi.Input[_builtins.int],
                 max_task_count: pulumi.Input[_builtins.int],
                 min_task_count: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "auto_scaling_metric", auto_scaling_metric)
        pulumi.set(__self__, "auto_scaling_target_value", auto_scaling_target_value)
        pulumi.set(__self__, "max_task_count", max_task_count)
        pulumi.set(__self__, "min_task_count", min_task_count)

    @_builtins.property
    @pulumi.getter(name="autoScalingMetric")
    def auto_scaling_metric(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "auto_scaling_metric")

    @auto_scaling_metric.setter
    def auto_scaling_metric(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auto_scaling_metric", value)

    @_builtins.property
    @pulumi.getter(name="autoScalingTargetValue")
    def auto_scaling_target_value(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "auto_scaling_target_value")

    @auto_scaling_target_value.setter
    def auto_scaling_target_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "auto_scaling_target_value", value)

    @_builtins.property
    @pulumi.getter(name="maxTaskCount")
    def max_task_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_task_count")

    @max_task_count.setter
    def max_task_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_task_count", value)

    @_builtins.property
    @pulumi.getter(name="minTaskCount")
    def min_task_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min_task_count")

    @min_task_count.setter
    def min_task_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_task_count", value)


if not MYPY:
    class ExpressGatewayServiceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ExpressGatewayServiceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressGatewayServiceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ServiceAlarmsArgsDict(TypedDict):
        alarm_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        enable: pulumi.Input[_builtins.bool]
        rollback: pulumi.Input[_builtins.bool]
elif False:
    ServiceAlarmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAlarmsArgs:
    def __init__(__self__, *,
                 alarm_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 enable: pulumi.Input[_builtins.bool],
                 rollback: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "alarm_names", alarm_names)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "rollback", rollback)

    @_builtins.property
    @pulumi.getter(name="alarmNames")
    def alarm_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "alarm_names")

    @alarm_names.setter
    def alarm_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "alarm_names", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def rollback(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "rollback")

    @rollback.setter
    def rollback(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "rollback", value)


if not MYPY:
    class ServiceCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: pulumi.Input[_builtins.str]
        base: NotRequired[pulumi.Input[_builtins.int]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ServiceCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[_builtins.str],
                 base: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServiceDeploymentCircuitBreakerArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        rollback: pulumi.Input[_builtins.bool]
elif False:
    ServiceDeploymentCircuitBreakerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentCircuitBreakerArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool],
                 rollback: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "rollback", rollback)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def rollback(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "rollback")

    @rollback.setter
    def rollback(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "rollback", value)


if not MYPY:
    class ServiceDeploymentConfigurationArgsDict(TypedDict):
        bake_time_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        canary_configuration: NotRequired[pulumi.Input['ServiceDeploymentConfigurationCanaryConfigurationArgsDict']]
        lifecycle_hooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceDeploymentConfigurationLifecycleHookArgsDict']]]]
        linear_configuration: NotRequired[pulumi.Input['ServiceDeploymentConfigurationLinearConfigurationArgsDict']]
        strategy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceDeploymentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentConfigurationArgs:
    def __init__(__self__, *,
                 bake_time_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 canary_configuration: Optional[pulumi.Input['ServiceDeploymentConfigurationCanaryConfigurationArgs']] = None,
                 lifecycle_hooks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDeploymentConfigurationLifecycleHookArgs']]]] = None,
                 linear_configuration: Optional[pulumi.Input['ServiceDeploymentConfigurationLinearConfigurationArgs']] = None,
                 strategy: Optional[pulumi.Input[_builtins.str]] = None):
        if bake_time_in_minutes is not None:
            pulumi.set(__self__, "bake_time_in_minutes", bake_time_in_minutes)
        if canary_configuration is not None:
            pulumi.set(__self__, "canary_configuration", canary_configuration)
        if lifecycle_hooks is not None:
            pulumi.set(__self__, "lifecycle_hooks", lifecycle_hooks)
        if linear_configuration is not None:
            pulumi.set(__self__, "linear_configuration", linear_configuration)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="bakeTimeInMinutes")
    def bake_time_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bake_time_in_minutes")

    @bake_time_in_minutes.setter
    def bake_time_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bake_time_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="canaryConfiguration")
    def canary_configuration(self) -> Optional[pulumi.Input['ServiceDeploymentConfigurationCanaryConfigurationArgs']]:
        return pulumi.get(self, "canary_configuration")

    @canary_configuration.setter
    def canary_configuration(self, value: Optional[pulumi.Input['ServiceDeploymentConfigurationCanaryConfigurationArgs']]):
        pulumi.set(self, "canary_configuration", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleHooks")
    def lifecycle_hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDeploymentConfigurationLifecycleHookArgs']]]]:
        return pulumi.get(self, "lifecycle_hooks")

    @lifecycle_hooks.setter
    def lifecycle_hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDeploymentConfigurationLifecycleHookArgs']]]]):
        pulumi.set(self, "lifecycle_hooks", value)

    @_builtins.property
    @pulumi.getter(name="linearConfiguration")
    def linear_configuration(self) -> Optional[pulumi.Input['ServiceDeploymentConfigurationLinearConfigurationArgs']]:
        return pulumi.get(self, "linear_configuration")

    @linear_configuration.setter
    def linear_configuration(self, value: Optional[pulumi.Input['ServiceDeploymentConfigurationLinearConfigurationArgs']]):
        pulumi.set(self, "linear_configuration", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ServiceDeploymentConfigurationCanaryConfigurationArgsDict(TypedDict):
        canary_bake_time_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        canary_percent: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    ServiceDeploymentConfigurationCanaryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentConfigurationCanaryConfigurationArgs:
    def __init__(__self__, *,
                 canary_bake_time_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 canary_percent: Optional[pulumi.Input[_builtins.float]] = None):
        if canary_bake_time_in_minutes is not None:
            pulumi.set(__self__, "canary_bake_time_in_minutes", canary_bake_time_in_minutes)
        if canary_percent is not None:
            pulumi.set(__self__, "canary_percent", canary_percent)

    @_builtins.property
    @pulumi.getter(name="canaryBakeTimeInMinutes")
    def canary_bake_time_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "canary_bake_time_in_minutes")

    @canary_bake_time_in_minutes.setter
    def canary_bake_time_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canary_bake_time_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="canaryPercent")
    def canary_percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "canary_percent")

    @canary_percent.setter
    def canary_percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "canary_percent", value)


if not MYPY:
    class ServiceDeploymentConfigurationLifecycleHookArgsDict(TypedDict):
        hook_target_arn: pulumi.Input[_builtins.str]
        lifecycle_stages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        role_arn: pulumi.Input[_builtins.str]
        hook_details: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceDeploymentConfigurationLifecycleHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentConfigurationLifecycleHookArgs:
    def __init__(__self__, *,
                 hook_target_arn: pulumi.Input[_builtins.str],
                 lifecycle_stages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 role_arn: pulumi.Input[_builtins.str],
                 hook_details: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "hook_target_arn", hook_target_arn)
        pulumi.set(__self__, "lifecycle_stages", lifecycle_stages)
        pulumi.set(__self__, "role_arn", role_arn)
        if hook_details is not None:
            pulumi.set(__self__, "hook_details", hook_details)

    @_builtins.property
    @pulumi.getter(name="hookTargetArn")
    def hook_target_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hook_target_arn")

    @hook_target_arn.setter
    def hook_target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hook_target_arn", value)

    @_builtins.property
    @pulumi.getter(name="lifecycleStages")
    def lifecycle_stages(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "lifecycle_stages")

    @lifecycle_stages.setter
    def lifecycle_stages(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "lifecycle_stages", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="hookDetails")
    def hook_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hook_details")

    @hook_details.setter
    def hook_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hook_details", value)


if not MYPY:
    class ServiceDeploymentConfigurationLinearConfigurationArgsDict(TypedDict):
        step_bake_time_in_minutes: NotRequired[pulumi.Input[_builtins.str]]
        step_percent: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    ServiceDeploymentConfigurationLinearConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentConfigurationLinearConfigurationArgs:
    def __init__(__self__, *,
                 step_bake_time_in_minutes: Optional[pulumi.Input[_builtins.str]] = None,
                 step_percent: Optional[pulumi.Input[_builtins.float]] = None):
        if step_bake_time_in_minutes is not None:
            pulumi.set(__self__, "step_bake_time_in_minutes", step_bake_time_in_minutes)
        if step_percent is not None:
            pulumi.set(__self__, "step_percent", step_percent)

    @_builtins.property
    @pulumi.getter(name="stepBakeTimeInMinutes")
    def step_bake_time_in_minutes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "step_bake_time_in_minutes")

    @step_bake_time_in_minutes.setter
    def step_bake_time_in_minutes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_bake_time_in_minutes", value)

    @_builtins.property
    @pulumi.getter(name="stepPercent")
    def step_percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "step_percent")

    @step_percent.setter
    def step_percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "step_percent", value)


if not MYPY:
    class ServiceDeploymentControllerArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceDeploymentControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDeploymentControllerArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceLoadBalancerArgsDict(TypedDict):
        container_name: pulumi.Input[_builtins.str]
        container_port: pulumi.Input[_builtins.int]
        advanced_configuration: NotRequired[pulumi.Input['ServiceLoadBalancerAdvancedConfigurationArgsDict']]
        elb_name: NotRequired[pulumi.Input[_builtins.str]]
        target_group_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceLoadBalancerArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[_builtins.str],
                 container_port: pulumi.Input[_builtins.int],
                 advanced_configuration: Optional[pulumi.Input['ServiceLoadBalancerAdvancedConfigurationArgs']] = None,
                 elb_name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_group_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "container_port", container_port)
        if advanced_configuration is not None:
            pulumi.set(__self__, "advanced_configuration", advanced_configuration)
        if elb_name is not None:
            pulumi.set(__self__, "elb_name", elb_name)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter(name="advancedConfiguration")
    def advanced_configuration(self) -> Optional[pulumi.Input['ServiceLoadBalancerAdvancedConfigurationArgs']]:
        return pulumi.get(self, "advanced_configuration")

    @advanced_configuration.setter
    def advanced_configuration(self, value: Optional[pulumi.Input['ServiceLoadBalancerAdvancedConfigurationArgs']]):
        pulumi.set(self, "advanced_configuration", value)

    @_builtins.property
    @pulumi.getter(name="elbName")
    def elb_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "elb_name")

    @elb_name.setter
    def elb_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "elb_name", value)

    @_builtins.property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_group_arn")

    @target_group_arn.setter
    def target_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_group_arn", value)


if not MYPY:
    class ServiceLoadBalancerAdvancedConfigurationArgsDict(TypedDict):
        alternate_target_group_arn: pulumi.Input[_builtins.str]
        production_listener_rule: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        test_listener_rule: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceLoadBalancerAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceLoadBalancerAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 alternate_target_group_arn: pulumi.Input[_builtins.str],
                 production_listener_rule: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 test_listener_rule: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "alternate_target_group_arn", alternate_target_group_arn)
        pulumi.set(__self__, "production_listener_rule", production_listener_rule)
        pulumi.set(__self__, "role_arn", role_arn)
        if test_listener_rule is not None:
            pulumi.set(__self__, "test_listener_rule", test_listener_rule)

    @_builtins.property
    @pulumi.getter(name="alternateTargetGroupArn")
    def alternate_target_group_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "alternate_target_group_arn")

    @alternate_target_group_arn.setter
    def alternate_target_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alternate_target_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="productionListenerRule")
    def production_listener_rule(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "production_listener_rule")

    @production_listener_rule.setter
    def production_listener_rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "production_listener_rule", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="testListenerRule")
    def test_listener_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "test_listener_rule")

    @test_listener_rule.setter
    def test_listener_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_listener_rule", value)


if not MYPY:
    class ServiceNetworkConfigurationArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        assign_public_ip: NotRequired[pulumi.Input[_builtins.bool]]
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ServiceNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 assign_public_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class ServiceOrderedPlacementStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        field: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceOrderedPlacementStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceOrderedPlacementStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 field: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class ServicePlacementConstraintArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        expression: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServicePlacementConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementConstraintArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class ServiceServiceConnectConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        log_configuration: NotRequired[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationArgsDict']]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceArgsDict']]]]
elif False:
    ServiceServiceConnectConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 log_configuration: Optional[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationArgs']] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceArgs']]]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if log_configuration is not None:
            pulumi.set(__self__, "log_configuration", log_configuration)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="logConfiguration")
    def log_configuration(self) -> Optional[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationArgs']]:
        return pulumi.get(self, "log_configuration")

    @log_configuration.setter
    def log_configuration(self, value: Optional[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationArgs']]):
        pulumi.set(self, "log_configuration", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceArgs']]]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceArgs']]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class ServiceServiceConnectConfigurationLogConfigurationArgsDict(TypedDict):
        log_driver: pulumi.Input[_builtins.str]
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        secret_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgsDict']]]]
elif False:
    ServiceServiceConnectConfigurationLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationLogConfigurationArgs:
    def __init__(__self__, *,
                 log_driver: pulumi.Input[_builtins.str],
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 secret_options: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgs']]]] = None):
        pulumi.set(__self__, "log_driver", log_driver)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if secret_options is not None:
            pulumi.set(__self__, "secret_options", secret_options)

    @_builtins.property
    @pulumi.getter(name="logDriver")
    def log_driver(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_driver")

    @log_driver.setter
    def log_driver(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_driver", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter(name="secretOptions")
    def secret_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgs']]]]:
        return pulumi.get(self, "secret_options")

    @secret_options.setter
    def secret_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgs']]]]):
        pulumi.set(self, "secret_options", value)


if not MYPY:
    class ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value_from: pulumi.Input[_builtins.str]
elif False:
    ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationLogConfigurationSecretOptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value_from: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_from", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceArgsDict(TypedDict):
        port_name: pulumi.Input[_builtins.str]
        client_alias: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasArgsDict']]]]
        discovery_name: NotRequired[pulumi.Input[_builtins.str]]
        ingress_port_override: NotRequired[pulumi.Input[_builtins.int]]
        timeout: NotRequired[pulumi.Input['ServiceServiceConnectConfigurationServiceTimeoutArgsDict']]
        tls: NotRequired[pulumi.Input['ServiceServiceConnectConfigurationServiceTlsArgsDict']]
elif False:
    ServiceServiceConnectConfigurationServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceArgs:
    def __init__(__self__, *,
                 port_name: pulumi.Input[_builtins.str],
                 client_alias: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasArgs']]]] = None,
                 discovery_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ingress_port_override: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTimeoutArgs']] = None,
                 tls: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTlsArgs']] = None):
        pulumi.set(__self__, "port_name", port_name)
        if client_alias is not None:
            pulumi.set(__self__, "client_alias", client_alias)
        if discovery_name is not None:
            pulumi.set(__self__, "discovery_name", discovery_name)
        if ingress_port_override is not None:
            pulumi.set(__self__, "ingress_port_override", ingress_port_override)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "port_name")

    @port_name.setter
    def port_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port_name", value)

    @_builtins.property
    @pulumi.getter(name="clientAlias")
    def client_alias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasArgs']]]]:
        return pulumi.get(self, "client_alias")

    @client_alias.setter
    def client_alias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasArgs']]]]):
        pulumi.set(self, "client_alias", value)

    @_builtins.property
    @pulumi.getter(name="discoveryName")
    def discovery_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "discovery_name")

    @discovery_name.setter
    def discovery_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_name", value)

    @_builtins.property
    @pulumi.getter(name="ingressPortOverride")
    def ingress_port_override(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ingress_port_override")

    @ingress_port_override.setter
    def ingress_port_override(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ingress_port_override", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTimeoutArgs']]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTimeoutArgs']]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTlsArgs']]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceClientAliasArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        dns_name: NotRequired[pulumi.Input[_builtins.str]]
        test_traffic_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgsDict']]]]
elif False:
    ServiceServiceConnectConfigurationServiceClientAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceClientAliasArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 dns_name: Optional[pulumi.Input[_builtins.str]] = None,
                 test_traffic_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgs']]]] = None):
        pulumi.set(__self__, "port", port)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if test_traffic_rules is not None:
            pulumi.set(__self__, "test_traffic_rules", test_traffic_rules)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @_builtins.property
    @pulumi.getter(name="testTrafficRules")
    def test_traffic_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgs']]]]:
        return pulumi.get(self, "test_traffic_rules")

    @test_traffic_rules.setter
    def test_traffic_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgs']]]]):
        pulumi.set(self, "test_traffic_rules", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgsDict(TypedDict):
        header: NotRequired[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgsDict']]
elif False:
    ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgs']] = None):
        if header is not None:
            pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgs']]):
        pulumi.set(self, "header", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgsDict']
elif False:
    ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgs']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgsDict(TypedDict):
        exact: pulumi.Input[_builtins.str]
elif False:
    ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceClientAliasTestTrafficRuleHeaderValueArgs:
    def __init__(__self__, *,
                 exact: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "exact", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceTimeoutArgsDict(TypedDict):
        idle_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        per_request_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ServiceServiceConnectConfigurationServiceTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceTimeoutArgs:
    def __init__(__self__, *,
                 idle_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 per_request_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if idle_timeout_seconds is not None:
            pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        if per_request_timeout_seconds is not None:
            pulumi.set(__self__, "per_request_timeout_seconds", per_request_timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "idle_timeout_seconds")

    @idle_timeout_seconds.setter
    def idle_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="perRequestTimeoutSeconds")
    def per_request_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "per_request_timeout_seconds")

    @per_request_timeout_seconds.setter
    def per_request_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_request_timeout_seconds", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceTlsArgsDict(TypedDict):
        issuer_cert_authority: pulumi.Input['ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgsDict']
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceServiceConnectConfigurationServiceTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceTlsArgs:
    def __init__(__self__, *,
                 issuer_cert_authority: pulumi.Input['ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgs'],
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "issuer_cert_authority", issuer_cert_authority)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="issuerCertAuthority")
    def issuer_cert_authority(self) -> pulumi.Input['ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgs']:
        return pulumi.get(self, "issuer_cert_authority")

    @issuer_cert_authority.setter
    def issuer_cert_authority(self, value: pulumi.Input['ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgs']):
        pulumi.set(self, "issuer_cert_authority", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgsDict(TypedDict):
        aws_pca_authority_arn: pulumi.Input[_builtins.str]
elif False:
    ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceConnectConfigurationServiceTlsIssuerCertAuthorityArgs:
    def __init__(__self__, *,
                 aws_pca_authority_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "aws_pca_authority_arn", aws_pca_authority_arn)

    @_builtins.property
    @pulumi.getter(name="awsPcaAuthorityArn")
    def aws_pca_authority_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "aws_pca_authority_arn")

    @aws_pca_authority_arn.setter
    def aws_pca_authority_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "aws_pca_authority_arn", value)


if not MYPY:
    class ServiceServiceRegistriesArgsDict(TypedDict):
        registry_arn: pulumi.Input[_builtins.str]
        container_name: NotRequired[pulumi.Input[_builtins.str]]
        container_port: NotRequired[pulumi.Input[_builtins.int]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ServiceServiceRegistriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceServiceRegistriesArgs:
    def __init__(__self__, *,
                 registry_arn: pulumi.Input[_builtins.str],
                 container_name: Optional[pulumi.Input[_builtins.str]] = None,
                 container_port: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "registry_arn", registry_arn)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="registryArn")
    def registry_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "registry_arn")

    @registry_arn.setter
    def registry_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_arn", value)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ServiceVolumeConfigurationArgsDict(TypedDict):
        managed_ebs_volume: pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeArgsDict']
        name: pulumi.Input[_builtins.str]
elif False:
    ServiceVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVolumeConfigurationArgs:
    def __init__(__self__, *,
                 managed_ebs_volume: pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeArgs'],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "managed_ebs_volume", managed_ebs_volume)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="managedEbsVolume")
    def managed_ebs_volume(self) -> pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeArgs']:
        return pulumi.get(self, "managed_ebs_volume")

    @managed_ebs_volume.setter
    def managed_ebs_volume(self, value: pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeArgs']):
        pulumi.set(self, "managed_ebs_volume", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ServiceVolumeConfigurationManagedEbsVolumeArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        file_system_type: NotRequired[pulumi.Input[_builtins.str]]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        size_in_gb: NotRequired[pulumi.Input[_builtins.int]]
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        tag_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgsDict']]]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        volume_initialization_rate: NotRequired[pulumi.Input[_builtins.int]]
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceVolumeConfigurationManagedEbsVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVolumeConfigurationManagedEbsVolumeArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 file_system_type: Optional[pulumi.Input[_builtins.str]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 size_in_gb: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgs']]]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_initialization_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if file_system_type is not None:
            pulumi.set(__self__, "file_system_type", file_system_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemType")
    def file_system_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_system_type")

    @file_system_type.setter
    def file_system_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_system_type", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size_in_gb", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgs']]]]:
        return pulumi.get(self, "tag_specifications")

    @tag_specifications.setter
    def tag_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgs']]]]):
        pulumi.set(self, "tag_specifications", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "volume_initialization_rate")

    @volume_initialization_rate.setter
    def volume_initialization_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_initialization_rate", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgsDict(TypedDict):
        resource_type: pulumi.Input[_builtins.str]
        propagate_tags: NotRequired[pulumi.Input[_builtins.str]]
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVolumeConfigurationManagedEbsVolumeTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[_builtins.str],
                 propagate_tags: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "resource_type", resource_type)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "propagate_tags", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ServiceVpcLatticeConfigurationArgsDict(TypedDict):
        port_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        target_group_arn: pulumi.Input[_builtins.str]
elif False:
    ServiceVpcLatticeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVpcLatticeConfigurationArgs:
    def __init__(__self__, *,
                 port_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 target_group_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_group_arn", target_group_arn)

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "port_name")

    @port_name.setter
    def port_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "port_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_group_arn")

    @target_group_arn.setter
    def target_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_group_arn", value)


if not MYPY:
    class TaskDefinitionEphemeralStorageArgsDict(TypedDict):
        size_in_gib: pulumi.Input[_builtins.int]
elif False:
    TaskDefinitionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size_in_gib: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "size_in_gib", size_in_gib)

    @_builtins.property
    @pulumi.getter(name="sizeInGib")
    def size_in_gib(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size_in_gib")

    @size_in_gib.setter
    def size_in_gib(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size_in_gib", value)


if not MYPY:
    class TaskDefinitionPlacementConstraintArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        expression: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionPlacementConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionPlacementConstraintArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class TaskDefinitionProxyConfigurationArgsDict(TypedDict):
        container_name: pulumi.Input[_builtins.str]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionProxyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionProxyConfigurationArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[_builtins.str],
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "container_name", container_name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TaskDefinitionRuntimePlatformArgsDict(TypedDict):
        cpu_architecture: NotRequired[pulumi.Input[_builtins.str]]
        operating_system_family: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionRuntimePlatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionRuntimePlatformArgs:
    def __init__(__self__, *,
                 cpu_architecture: Optional[pulumi.Input[_builtins.str]] = None,
                 operating_system_family: Optional[pulumi.Input[_builtins.str]] = None):
        if cpu_architecture is not None:
            pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        if operating_system_family is not None:
            pulumi.set(__self__, "operating_system_family", operating_system_family)

    @_builtins.property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cpu_architecture")

    @cpu_architecture.setter
    def cpu_architecture(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_architecture", value)

    @_builtins.property
    @pulumi.getter(name="operatingSystemFamily")
    def operating_system_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operating_system_family")

    @operating_system_family.setter
    def operating_system_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operating_system_family", value)


if not MYPY:
    class TaskDefinitionVolumeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        configure_at_launch: NotRequired[pulumi.Input[_builtins.bool]]
        docker_volume_configuration: NotRequired[pulumi.Input['TaskDefinitionVolumeDockerVolumeConfigurationArgsDict']]
        efs_volume_configuration: NotRequired[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationArgsDict']]
        fsx_windows_file_server_volume_configuration: NotRequired[pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgsDict']]
        host_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 configure_at_launch: Optional[pulumi.Input[_builtins.bool]] = None,
                 docker_volume_configuration: Optional[pulumi.Input['TaskDefinitionVolumeDockerVolumeConfigurationArgs']] = None,
                 efs_volume_configuration: Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationArgs']] = None,
                 fsx_windows_file_server_volume_configuration: Optional[pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgs']] = None,
                 host_path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if configure_at_launch is not None:
            pulumi.set(__self__, "configure_at_launch", configure_at_launch)
        if docker_volume_configuration is not None:
            pulumi.set(__self__, "docker_volume_configuration", docker_volume_configuration)
        if efs_volume_configuration is not None:
            pulumi.set(__self__, "efs_volume_configuration", efs_volume_configuration)
        if fsx_windows_file_server_volume_configuration is not None:
            pulumi.set(__self__, "fsx_windows_file_server_volume_configuration", fsx_windows_file_server_volume_configuration)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="configureAtLaunch")
    def configure_at_launch(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "configure_at_launch")

    @configure_at_launch.setter
    def configure_at_launch(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "configure_at_launch", value)

    @_builtins.property
    @pulumi.getter(name="dockerVolumeConfiguration")
    def docker_volume_configuration(self) -> Optional[pulumi.Input['TaskDefinitionVolumeDockerVolumeConfigurationArgs']]:
        return pulumi.get(self, "docker_volume_configuration")

    @docker_volume_configuration.setter
    def docker_volume_configuration(self, value: Optional[pulumi.Input['TaskDefinitionVolumeDockerVolumeConfigurationArgs']]):
        pulumi.set(self, "docker_volume_configuration", value)

    @_builtins.property
    @pulumi.getter(name="efsVolumeConfiguration")
    def efs_volume_configuration(self) -> Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationArgs']]:
        return pulumi.get(self, "efs_volume_configuration")

    @efs_volume_configuration.setter
    def efs_volume_configuration(self, value: Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationArgs']]):
        pulumi.set(self, "efs_volume_configuration", value)

    @_builtins.property
    @pulumi.getter(name="fsxWindowsFileServerVolumeConfiguration")
    def fsx_windows_file_server_volume_configuration(self) -> Optional[pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgs']]:
        return pulumi.get(self, "fsx_windows_file_server_volume_configuration")

    @fsx_windows_file_server_volume_configuration.setter
    def fsx_windows_file_server_volume_configuration(self, value: Optional[pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgs']]):
        pulumi.set(self, "fsx_windows_file_server_volume_configuration", value)

    @_builtins.property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "host_path")

    @host_path.setter
    def host_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_path", value)


if not MYPY:
    class TaskDefinitionVolumeDockerVolumeConfigurationArgsDict(TypedDict):
        autoprovision: NotRequired[pulumi.Input[_builtins.bool]]
        driver: NotRequired[pulumi.Input[_builtins.str]]
        driver_opts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        scope: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionVolumeDockerVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeDockerVolumeConfigurationArgs:
    def __init__(__self__, *,
                 autoprovision: Optional[pulumi.Input[_builtins.bool]] = None,
                 driver: Optional[pulumi.Input[_builtins.str]] = None,
                 driver_opts: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        if autoprovision is not None:
            pulumi.set(__self__, "autoprovision", autoprovision)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_opts is not None:
            pulumi.set(__self__, "driver_opts", driver_opts)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def autoprovision(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "autoprovision")

    @autoprovision.setter
    def autoprovision(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "autoprovision", value)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "driver", value)

    @_builtins.property
    @pulumi.getter(name="driverOpts")
    def driver_opts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "driver_opts")

    @driver_opts.setter
    def driver_opts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "driver_opts", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class TaskDefinitionVolumeEfsVolumeConfigurationArgsDict(TypedDict):
        file_system_id: pulumi.Input[_builtins.str]
        authorization_config: NotRequired[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgsDict']]
        root_directory: NotRequired[pulumi.Input[_builtins.str]]
        transit_encryption: NotRequired[pulumi.Input[_builtins.str]]
        transit_encryption_port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TaskDefinitionVolumeEfsVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeEfsVolumeConfigurationArgs:
    def __init__(__self__, *,
                 file_system_id: pulumi.Input[_builtins.str],
                 authorization_config: Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs']] = None,
                 root_directory: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_encryption: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_encryption_port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "file_system_id", file_system_id)
        if authorization_config is not None:
            pulumi.set(__self__, "authorization_config", authorization_config)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)
        if transit_encryption is not None:
            pulumi.set(__self__, "transit_encryption", transit_encryption)
        if transit_encryption_port is not None:
            pulumi.set(__self__, "transit_encryption_port", transit_encryption_port)

    @_builtins.property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_system_id", value)

    @_builtins.property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs']]:
        return pulumi.get(self, "authorization_config")

    @authorization_config.setter
    def authorization_config(self, value: Optional[pulumi.Input['TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs']]):
        pulumi.set(self, "authorization_config", value)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_directory", value)

    @_builtins.property
    @pulumi.getter(name="transitEncryption")
    def transit_encryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "transit_encryption")

    @transit_encryption.setter
    def transit_encryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_encryption", value)

    @_builtins.property
    @pulumi.getter(name="transitEncryptionPort")
    def transit_encryption_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "transit_encryption_port")

    @transit_encryption_port.setter
    def transit_encryption_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "transit_encryption_port", value)


if not MYPY:
    class TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgsDict(TypedDict):
        access_point_id: NotRequired[pulumi.Input[_builtins.str]]
        iam: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs:
    def __init__(__self__, *,
                 access_point_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iam: Optional[pulumi.Input[_builtins.str]] = None):
        if access_point_id is not None:
            pulumi.set(__self__, "access_point_id", access_point_id)
        if iam is not None:
            pulumi.set(__self__, "iam", iam)

    @_builtins.property
    @pulumi.getter(name="accessPointId")
    def access_point_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_point_id")

    @access_point_id.setter
    def access_point_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_point_id", value)

    @_builtins.property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam", value)


if not MYPY:
    class TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgsDict(TypedDict):
        authorization_config: pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgsDict']
        file_system_id: pulumi.Input[_builtins.str]
        root_directory: pulumi.Input[_builtins.str]
elif False:
    TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationArgs:
    def __init__(__self__, *,
                 authorization_config: pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgs'],
                 file_system_id: pulumi.Input[_builtins.str],
                 root_directory: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "authorization_config", authorization_config)
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "root_directory", root_directory)

    @_builtins.property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgs']:
        return pulumi.get(self, "authorization_config")

    @authorization_config.setter
    def authorization_config(self, value: pulumi.Input['TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgs']):
        pulumi.set(self, "authorization_config", value)

    @_builtins.property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_system_id", value)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "root_directory", value)


if not MYPY:
    class TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgsDict(TypedDict):
        credentials_parameter: pulumi.Input[_builtins.str]
        domain: pulumi.Input[_builtins.str]
elif False:
    TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskDefinitionVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfigArgs:
    def __init__(__self__, *,
                 credentials_parameter: pulumi.Input[_builtins.str],
                 domain: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "credentials_parameter", credentials_parameter)
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter(name="credentialsParameter")
    def credentials_parameter(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "credentials_parameter")

    @credentials_parameter.setter
    def credentials_parameter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_parameter", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class TaskSetCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: pulumi.Input[_builtins.str]
        weight: pulumi.Input[_builtins.int]
        base: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TaskSetCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSetCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int],
                 base: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        pulumi.set(__self__, "weight", weight)
        if base is not None:
            pulumi.set(__self__, "base", base)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base", value)


if not MYPY:
    class TaskSetLoadBalancerArgsDict(TypedDict):
        container_name: pulumi.Input[_builtins.str]
        container_port: NotRequired[pulumi.Input[_builtins.int]]
        load_balancer_name: NotRequired[pulumi.Input[_builtins.str]]
        target_group_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TaskSetLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSetLoadBalancerArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[_builtins.str],
                 container_port: Optional[pulumi.Input[_builtins.int]] = None,
                 load_balancer_name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_group_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "load_balancer_name")

    @load_balancer_name.setter
    def load_balancer_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_balancer_name", value)

    @_builtins.property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_group_arn")

    @target_group_arn.setter
    def target_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_group_arn", value)


if not MYPY:
    class TaskSetNetworkConfigurationArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        assign_public_ip: NotRequired[pulumi.Input[_builtins.bool]]
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    TaskSetNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSetNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 assign_public_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class TaskSetScaleArgsDict(TypedDict):
        unit: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    TaskSetScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSetScaleArgs:
    def __init__(__self__, *,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TaskSetServiceRegistriesArgsDict(TypedDict):
        registry_arn: pulumi.Input[_builtins.str]
        container_name: NotRequired[pulumi.Input[_builtins.str]]
        container_port: NotRequired[pulumi.Input[_builtins.int]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TaskSetServiceRegistriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskSetServiceRegistriesArgs:
    def __init__(__self__, *,
                 registry_arn: pulumi.Input[_builtins.str],
                 container_name: Optional[pulumi.Input[_builtins.str]] = None,
                 container_port: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "registry_arn", registry_arn)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="registryArn")
    def registry_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "registry_arn")

    @registry_arn.setter
    def registry_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_arn", value)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetTaskExecutionCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: _builtins.str
        base: NotRequired[_builtins.int]
        weight: NotRequired[_builtins.int]
elif False:
    GetTaskExecutionCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: _builtins.str,
                 base: Optional[_builtins.int] = None,
                 weight: Optional[_builtins.int] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> _builtins.str:
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: _builtins.str):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[_builtins.int]):
        pulumi.set(self, "base", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GetTaskExecutionNetworkConfigurationArgsDict(TypedDict):
        subnets: Sequence[_builtins.str]
        assign_public_ip: NotRequired[_builtins.bool]
        security_groups: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTaskExecutionNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: Sequence[_builtins.str],
                 assign_public_ip: Optional[_builtins.bool] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class GetTaskExecutionOverridesArgsDict(TypedDict):
        container_overrides: NotRequired[Sequence['GetTaskExecutionOverridesContainerOverrideArgsDict']]
        cpu: NotRequired[_builtins.str]
        execution_role_arn: NotRequired[_builtins.str]
        memory: NotRequired[_builtins.str]
        task_role_arn: NotRequired[_builtins.str]
elif False:
    GetTaskExecutionOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionOverridesArgs:
    def __init__(__self__, *,
                 container_overrides: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideArgs']] = None,
                 cpu: Optional[_builtins.str] = None,
                 execution_role_arn: Optional[_builtins.str] = None,
                 memory: Optional[_builtins.str] = None,
                 task_role_arn: Optional[_builtins.str] = None):
        if container_overrides is not None:
            pulumi.set(__self__, "container_overrides", container_overrides)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if execution_role_arn is not None:
            pulumi.set(__self__, "execution_role_arn", execution_role_arn)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if task_role_arn is not None:
            pulumi.set(__self__, "task_role_arn", task_role_arn)

    @_builtins.property
    @pulumi.getter(name="containerOverrides")
    def container_overrides(self) -> Optional[Sequence['GetTaskExecutionOverridesContainerOverrideArgs']]:
        return pulumi.get(self, "container_overrides")

    @container_overrides.setter
    def container_overrides(self, value: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideArgs']]):
        pulumi.set(self, "container_overrides", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="executionRoleArn")
    def execution_role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "execution_role_arn")

    @execution_role_arn.setter
    def execution_role_arn(self, value: Optional[_builtins.str]):
        pulumi.set(self, "execution_role_arn", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter(name="taskRoleArn")
    def task_role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "task_role_arn")

    @task_role_arn.setter
    def task_role_arn(self, value: Optional[_builtins.str]):
        pulumi.set(self, "task_role_arn", value)


if not MYPY:
    class GetTaskExecutionOverridesContainerOverrideArgsDict(TypedDict):
        name: _builtins.str
        commands: NotRequired[Sequence[_builtins.str]]
        cpu: NotRequired[_builtins.int]
        environments: NotRequired[Sequence['GetTaskExecutionOverridesContainerOverrideEnvironmentArgsDict']]
        memory: NotRequired[_builtins.int]
        memory_reservation: NotRequired[_builtins.int]
        resource_requirements: NotRequired[Sequence['GetTaskExecutionOverridesContainerOverrideResourceRequirementArgsDict']]
elif False:
    GetTaskExecutionOverridesContainerOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionOverridesContainerOverrideArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 cpu: Optional[_builtins.int] = None,
                 environments: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideEnvironmentArgs']] = None,
                 memory: Optional[_builtins.int] = None,
                 memory_reservation: Optional[_builtins.int] = None,
                 resource_requirements: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideResourceRequirementArgs']] = None):
        pulumi.set(__self__, "name", name)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if memory_reservation is not None:
            pulumi.set(__self__, "memory_reservation", memory_reservation)
        if resource_requirements is not None:
            pulumi.set(__self__, "resource_requirements", resource_requirements)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[_builtins.int]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[Sequence['GetTaskExecutionOverridesContainerOverrideEnvironmentArgs']]:
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideEnvironmentArgs']]):
        pulumi.set(self, "environments", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[_builtins.int]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter(name="memoryReservation")
    def memory_reservation(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory_reservation")

    @memory_reservation.setter
    def memory_reservation(self, value: Optional[_builtins.int]):
        pulumi.set(self, "memory_reservation", value)

    @_builtins.property
    @pulumi.getter(name="resourceRequirements")
    def resource_requirements(self) -> Optional[Sequence['GetTaskExecutionOverridesContainerOverrideResourceRequirementArgs']]:
        return pulumi.get(self, "resource_requirements")

    @resource_requirements.setter
    def resource_requirements(self, value: Optional[Sequence['GetTaskExecutionOverridesContainerOverrideResourceRequirementArgs']]):
        pulumi.set(self, "resource_requirements", value)


if not MYPY:
    class GetTaskExecutionOverridesContainerOverrideEnvironmentArgsDict(TypedDict):
        key: _builtins.str
        value: _builtins.str
elif False:
    GetTaskExecutionOverridesContainerOverrideEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionOverridesContainerOverrideEnvironmentArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetTaskExecutionOverridesContainerOverrideResourceRequirementArgsDict(TypedDict):
        type: _builtins.str
        value: _builtins.str
elif False:
    GetTaskExecutionOverridesContainerOverrideResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionOverridesContainerOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetTaskExecutionPlacementConstraintArgsDict(TypedDict):
        type: _builtins.str
        expression: NotRequired[_builtins.str]
elif False:
    GetTaskExecutionPlacementConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionPlacementConstraintArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 expression: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[_builtins.str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class GetTaskExecutionPlacementStrategyArgsDict(TypedDict):
        type: _builtins.str
        field: NotRequired[_builtins.str]
elif False:
    GetTaskExecutionPlacementStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTaskExecutionPlacementStrategyArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 field: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[_builtins.str]):
        pulumi.set(self, "field", value)


