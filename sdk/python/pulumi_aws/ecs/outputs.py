# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'CapacityProviderAutoScalingGroupProvider',
    'CapacityProviderAutoScalingGroupProviderManagedScaling',
    'ClusterDefaultCapacityProviderStrategy',
    'ClusterSetting',
    'ServiceCapacityProviderStrategy',
    'ServiceDeploymentController',
    'ServiceLoadBalancer',
    'ServiceNetworkConfiguration',
    'ServiceOrderedPlacementStrategy',
    'ServicePlacementConstraint',
    'ServiceServiceRegistries',
    'TaskDefinitionInferenceAccelerator',
    'TaskDefinitionPlacementConstraint',
    'TaskDefinitionProxyConfiguration',
    'TaskDefinitionVolume',
    'TaskDefinitionVolumeDockerVolumeConfiguration',
    'TaskDefinitionVolumeEfsVolumeConfiguration',
    'TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig',
    'GetClusterSettingResult',
]

@pulumi.output_type
class CapacityProviderAutoScalingGroupProvider(dict):
    def __init__(__self__, *,
                 auto_scaling_group_arn: str,
                 managed_scaling: Optional['outputs.CapacityProviderAutoScalingGroupProviderManagedScaling'] = None,
                 managed_termination_protection: Optional[str] = None):
        """
        :param str auto_scaling_group_arn: - The Amazon Resource Name (ARN) of the associated auto scaling group.
        :param 'CapacityProviderAutoScalingGroupProviderManagedScalingArgs' managed_scaling: - Nested argument defining the parameters of the auto scaling. Defined below.
        :param str managed_termination_protection: - Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are `ENABLED` and `DISABLED`.
        """
        pulumi.set(__self__, "auto_scaling_group_arn", auto_scaling_group_arn)
        if managed_scaling is not None:
            pulumi.set(__self__, "managed_scaling", managed_scaling)
        if managed_termination_protection is not None:
            pulumi.set(__self__, "managed_termination_protection", managed_termination_protection)

    @property
    @pulumi.getter(name="autoScalingGroupArn")
    def auto_scaling_group_arn(self) -> str:
        """
        - The Amazon Resource Name (ARN) of the associated auto scaling group.
        """
        return pulumi.get(self, "auto_scaling_group_arn")

    @property
    @pulumi.getter(name="managedScaling")
    def managed_scaling(self) -> Optional['outputs.CapacityProviderAutoScalingGroupProviderManagedScaling']:
        """
        - Nested argument defining the parameters of the auto scaling. Defined below.
        """
        return pulumi.get(self, "managed_scaling")

    @property
    @pulumi.getter(name="managedTerminationProtection")
    def managed_termination_protection(self) -> Optional[str]:
        """
        - Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are `ENABLED` and `DISABLED`.
        """
        return pulumi.get(self, "managed_termination_protection")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CapacityProviderAutoScalingGroupProviderManagedScaling(dict):
    def __init__(__self__, *,
                 maximum_scaling_step_size: Optional[int] = None,
                 minimum_scaling_step_size: Optional[int] = None,
                 status: Optional[str] = None,
                 target_capacity: Optional[int] = None):
        """
        :param int maximum_scaling_step_size: The maximum step adjustment size. A number between 1 and 10,000.
        :param int minimum_scaling_step_size: The minimum step adjustment size. A number between 1 and 10,000.
        :param str status: Whether auto scaling is managed by ECS. Valid values are `ENABLED` and `DISABLED`.
        :param int target_capacity: The target utilization for the capacity provider. A number between 1 and 100.
        """
        if maximum_scaling_step_size is not None:
            pulumi.set(__self__, "maximum_scaling_step_size", maximum_scaling_step_size)
        if minimum_scaling_step_size is not None:
            pulumi.set(__self__, "minimum_scaling_step_size", minimum_scaling_step_size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @property
    @pulumi.getter(name="maximumScalingStepSize")
    def maximum_scaling_step_size(self) -> Optional[int]:
        """
        The maximum step adjustment size. A number between 1 and 10,000.
        """
        return pulumi.get(self, "maximum_scaling_step_size")

    @property
    @pulumi.getter(name="minimumScalingStepSize")
    def minimum_scaling_step_size(self) -> Optional[int]:
        """
        The minimum step adjustment size. A number between 1 and 10,000.
        """
        return pulumi.get(self, "minimum_scaling_step_size")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Whether auto scaling is managed by ECS. Valid values are `ENABLED` and `DISABLED`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[int]:
        """
        The target utilization for the capacity provider. A number between 1 and 100.
        """
        return pulumi.get(self, "target_capacity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterDefaultCapacityProviderStrategy(dict):
    def __init__(__self__, *,
                 capacity_provider: str,
                 base: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str capacity_provider: The short name of the capacity provider.
        :param int base: The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
        :param int weight: The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        The short name of the capacity provider.
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def base(self) -> Optional[int]:
        """
        The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the setting to manage. Valid values: `containerInsights`.
        :param str value: The value to assign to the setting. Value values are `enabled` and `disabled`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the setting to manage. Valid values: `containerInsights`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value to assign to the setting. Value values are `enabled` and `disabled`.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceCapacityProviderStrategy(dict):
    def __init__(__self__, *,
                 capacity_provider: str,
                 base: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str capacity_provider: The short name of the capacity provider.
        :param int base: The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
        :param int weight: The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        The short name of the capacity provider.
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def base(self) -> Optional[int]:
        """
        The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDeploymentController(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`, `EXTERNAL`. Default: `ECS`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`, `EXTERNAL`. Default: `ECS`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceLoadBalancer(dict):
    def __init__(__self__, *,
                 container_name: str,
                 container_port: int,
                 elb_name: Optional[str] = None,
                 target_group_arn: Optional[str] = None):
        """
        :param str container_name: The name of the container to associate with the load balancer (as it appears in a container definition).
        :param int container_port: The port on the container to associate with the load balancer.
        :param str elb_name: The name of the ELB (Classic) to associate with the service.
        :param str target_group_arn: The ARN of the Load Balancer target group to associate with the service.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "container_port", container_port)
        if elb_name is not None:
            pulumi.set(__self__, "elb_name", elb_name)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The name of the container to associate with the load balancer (as it appears in a container definition).
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        The port on the container to associate with the load balancer.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="elbName")
    def elb_name(self) -> Optional[str]:
        """
        The name of the ELB (Classic) to associate with the service.
        """
        return pulumi.get(self, "elb_name")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The ARN of the Load Balancer target group to associate with the service.
        """
        return pulumi.get(self, "target_group_arn")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceNetworkConfiguration(dict):
    def __init__(__self__, *,
                 subnets: Sequence[str],
                 assign_public_ip: Optional[bool] = None,
                 security_groups: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] subnets: The subnets associated with the task or service.
        :param bool assign_public_ip: Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
        :param Sequence[str] security_groups: The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
        """
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        The subnets associated with the task or service.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
        """
        return pulumi.get(self, "security_groups")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceOrderedPlacementStrategy(dict):
    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None):
        """
        :param str type: The type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        :param str field: For the `spread` placement strategy, valid values are `instanceId` (or `host`,
               which has the same effect), or any platform or custom attribute that is applied to a container instance.
               For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
               needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        For the `spread` placement strategy, valid values are `instanceId` (or `host`,
        which has the same effect), or any platform or custom attribute that is applied to a container instance.
        For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
        needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
        """
        return pulumi.get(self, "field")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServicePlacementConstraint(dict):
    def __init__(__self__, *,
                 type: str,
                 expression: Optional[str] = None):
        """
        :param str type: The type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
        :param str expression: Cluster Query Language expression to apply to the constraint. Does not need to be specified
               for the `distinctInstance` type.
               For more information, see [Cluster Query Language in the Amazon EC2 Container
               Service Developer
               Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified
        for the `distinctInstance` type.
        For more information, see [Cluster Query Language in the Amazon EC2 Container
        Service Developer
        Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceServiceRegistries(dict):
    def __init__(__self__, *,
                 registry_arn: str,
                 container_name: Optional[str] = None,
                 container_port: Optional[int] = None,
                 port: Optional[int] = None):
        """
        :param str registry_arn: The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
        :param str container_name: The container name value, already specified in the task definition, to be used for your service discovery service.
        :param int container_port: The port value, already specified in the task definition, to be used for your service discovery service.
        :param int port: The port value used if your Service Discovery service specified an SRV record.
        """
        pulumi.set(__self__, "registry_arn", registry_arn)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="registryArn")
    def registry_arn(self) -> str:
        """
        The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
        """
        return pulumi.get(self, "registry_arn")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The container name value, already specified in the task definition, to be used for your service discovery service.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        """
        The port value, already specified in the task definition, to be used for your service discovery service.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port value used if your Service Discovery service specified an SRV record.
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionInferenceAccelerator(dict):
    def __init__(__self__, *,
                 device_name: str,
                 device_type: str):
        """
        :param str device_name: The Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
        :param str device_type: The Elastic Inference accelerator type to use.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "device_type", device_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        The Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> str:
        """
        The Elastic Inference accelerator type to use.
        """
        return pulumi.get(self, "device_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionPlacementConstraint(dict):
    def __init__(__self__, *,
                 type: str,
                 expression: Optional[str] = None):
        """
        :param str type: The proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
        :param str expression: Cluster Query Language expression to apply to the constraint.
               For more information, see [Cluster Query Language in the Amazon EC2 Container
               Service Developer
               Guide](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Cluster Query Language expression to apply to the constraint.
        For more information, see [Cluster Query Language in the Amazon EC2 Container
        Service Developer
        Guide](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionProxyConfiguration(dict):
    def __init__(__self__, *,
                 container_name: str,
                 properties: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        """
        :param str container_name: The name of the container that will serve as the App Mesh proxy.
        :param Mapping[str, str] properties: The set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
        :param str type: The proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
        """
        pulumi.set(__self__, "container_name", container_name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        The name of the container that will serve as the App Mesh proxy.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The proxy type. The default value is `APPMESH`. The only supported value is `APPMESH`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionVolume(dict):
    def __init__(__self__, *,
                 name: str,
                 docker_volume_configuration: Optional['outputs.TaskDefinitionVolumeDockerVolumeConfiguration'] = None,
                 efs_volume_configuration: Optional['outputs.TaskDefinitionVolumeEfsVolumeConfiguration'] = None,
                 host_path: Optional[str] = None):
        """
        :param str name: The name of the volume. This name is referenced in the `sourceVolume`
               parameter of container definition in the `mountPoints` section.
        :param 'TaskDefinitionVolumeDockerVolumeConfigurationArgs' docker_volume_configuration: Used to configure a docker volume
        :param 'TaskDefinitionVolumeEfsVolumeConfigurationArgs' efs_volume_configuration: Used to configure a EFS volume.
        :param str host_path: The path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
        """
        pulumi.set(__self__, "name", name)
        if docker_volume_configuration is not None:
            pulumi.set(__self__, "docker_volume_configuration", docker_volume_configuration)
        if efs_volume_configuration is not None:
            pulumi.set(__self__, "efs_volume_configuration", efs_volume_configuration)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the volume. This name is referenced in the `sourceVolume`
        parameter of container definition in the `mountPoints` section.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dockerVolumeConfiguration")
    def docker_volume_configuration(self) -> Optional['outputs.TaskDefinitionVolumeDockerVolumeConfiguration']:
        """
        Used to configure a docker volume
        """
        return pulumi.get(self, "docker_volume_configuration")

    @property
    @pulumi.getter(name="efsVolumeConfiguration")
    def efs_volume_configuration(self) -> Optional['outputs.TaskDefinitionVolumeEfsVolumeConfiguration']:
        """
        Used to configure a EFS volume.
        """
        return pulumi.get(self, "efs_volume_configuration")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional[str]:
        """
        The path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
        """
        return pulumi.get(self, "host_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionVolumeDockerVolumeConfiguration(dict):
    def __init__(__self__, *,
                 autoprovision: Optional[bool] = None,
                 driver: Optional[str] = None,
                 driver_opts: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 scope: Optional[str] = None):
        """
        :param bool autoprovision: If this value is `true`, the Docker volume is created if it does not already exist. *Note*: This field is only used if the scope is `shared`.
        :param str driver: The Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
        :param Mapping[str, str] driver_opts: A map of Docker driver specific options.
        :param Mapping[str, str] labels: A map of custom metadata to add to your Docker volume.
        :param str scope: The scope for the Docker volume, which determines its lifecycle, either `task` or `shared`.  Docker volumes that are scoped to a `task` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as `shared` persist after the task stops.
        """
        if autoprovision is not None:
            pulumi.set(__self__, "autoprovision", autoprovision)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_opts is not None:
            pulumi.set(__self__, "driver_opts", driver_opts)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def autoprovision(self) -> Optional[bool]:
        """
        If this value is `true`, the Docker volume is created if it does not already exist. *Note*: This field is only used if the scope is `shared`.
        """
        return pulumi.get(self, "autoprovision")

    @property
    @pulumi.getter
    def driver(self) -> Optional[str]:
        """
        The Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="driverOpts")
    def driver_opts(self) -> Optional[Mapping[str, str]]:
        """
        A map of Docker driver specific options.
        """
        return pulumi.get(self, "driver_opts")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of custom metadata to add to your Docker volume.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope for the Docker volume, which determines its lifecycle, either `task` or `shared`.  Docker volumes that are scoped to a `task` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as `shared` persist after the task stops.
        """
        return pulumi.get(self, "scope")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionVolumeEfsVolumeConfiguration(dict):
    def __init__(__self__, *,
                 file_system_id: str,
                 authorization_config: Optional['outputs.TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig'] = None,
                 root_directory: Optional[str] = None,
                 transit_encryption: Optional[str] = None,
                 transit_encryption_port: Optional[int] = None):
        """
        :param str file_system_id: The ID of the EFS File System.
        :param 'TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfigArgs' authorization_config: The authorization configuration details for the Amazon EFS file system.
        :param str root_directory: The directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using `authorization_config`.
        :param str transit_encryption: Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
        :param int transit_encryption_port: The port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        if authorization_config is not None:
            pulumi.set(__self__, "authorization_config", authorization_config)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)
        if transit_encryption is not None:
            pulumi.set(__self__, "transit_encryption", transit_encryption)
        if transit_encryption_port is not None:
            pulumi.set(__self__, "transit_encryption_port", transit_encryption_port)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        The ID of the EFS File System.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> Optional['outputs.TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig']:
        """
        The authorization configuration details for the Amazon EFS file system.
        """
        return pulumi.get(self, "authorization_config")

    @property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[str]:
        """
        The directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using `authorization_config`.
        """
        return pulumi.get(self, "root_directory")

    @property
    @pulumi.getter(name="transitEncryption")
    def transit_encryption(self) -> Optional[str]:
        """
        Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
        """
        return pulumi.get(self, "transit_encryption")

    @property
    @pulumi.getter(name="transitEncryptionPort")
    def transit_encryption_port(self) -> Optional[int]:
        """
        The port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
        """
        return pulumi.get(self, "transit_encryption_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TaskDefinitionVolumeEfsVolumeConfigurationAuthorizationConfig(dict):
    def __init__(__self__, *,
                 access_point_id: Optional[str] = None,
                 iam: Optional[str] = None):
        """
        :param str access_point_id: The access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
        :param str iam: Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
        """
        if access_point_id is not None:
            pulumi.set(__self__, "access_point_id", access_point_id)
        if iam is not None:
            pulumi.set(__self__, "iam", iam)

    @property
    @pulumi.getter(name="accessPointId")
    def access_point_id(self) -> Optional[str]:
        """
        The access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
        """
        return pulumi.get(self, "access_point_id")

    @property
    @pulumi.getter
    def iam(self) -> Optional[str]:
        """
        Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: `ENABLED`, `DISABLED`. If this parameter is omitted, the default value of `DISABLED` is used.
        """
        return pulumi.get(self, "iam")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GetClusterSettingResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


