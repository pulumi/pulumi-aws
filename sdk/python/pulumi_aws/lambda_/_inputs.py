# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasRoutingConfigArgs',
    'AliasRoutingConfigArgsDict',
    'CapacityProviderCapacityProviderScalingConfigArgs',
    'CapacityProviderCapacityProviderScalingConfigArgsDict',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict',
    'CapacityProviderInstanceRequirementArgs',
    'CapacityProviderInstanceRequirementArgsDict',
    'CapacityProviderPermissionsConfigArgs',
    'CapacityProviderPermissionsConfigArgsDict',
    'CapacityProviderTimeoutsArgs',
    'CapacityProviderTimeoutsArgsDict',
    'CapacityProviderVpcConfigArgs',
    'CapacityProviderVpcConfigArgsDict',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigAllowedPublishersArgsDict',
    'CodeSigningConfigPoliciesArgs',
    'CodeSigningConfigPoliciesArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigArgsDict',
    'EventSourceMappingDestinationConfigOnFailureArgs',
    'EventSourceMappingDestinationConfigOnFailureArgsDict',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgsDict',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaArgsDict',
    'EventSourceMappingFilterCriteriaFilterArgs',
    'EventSourceMappingFilterCriteriaFilterArgsDict',
    'EventSourceMappingMetricsConfigArgs',
    'EventSourceMappingMetricsConfigArgsDict',
    'EventSourceMappingProvisionedPollerConfigArgs',
    'EventSourceMappingProvisionedPollerConfigArgsDict',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingScalingConfigArgsDict',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedEventSourceArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'EventSourceMappingSourceAccessConfigurationArgsDict',
    'FunctionCapacityProviderConfigArgs',
    'FunctionCapacityProviderConfigArgsDict',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict',
    'FunctionDeadLetterConfigArgs',
    'FunctionDeadLetterConfigArgsDict',
    'FunctionDurableConfigArgs',
    'FunctionDurableConfigArgsDict',
    'FunctionEnvironmentArgs',
    'FunctionEnvironmentArgsDict',
    'FunctionEphemeralStorageArgs',
    'FunctionEphemeralStorageArgsDict',
    'FunctionEventInvokeConfigDestinationConfigArgs',
    'FunctionEventInvokeConfigDestinationConfigArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict',
    'FunctionFileSystemConfigArgs',
    'FunctionFileSystemConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionLoggingConfigArgs',
    'FunctionLoggingConfigArgsDict',
    'FunctionSnapStartArgs',
    'FunctionSnapStartArgsDict',
    'FunctionTenancyConfigArgs',
    'FunctionTenancyConfigArgsDict',
    'FunctionTracingConfigArgs',
    'FunctionTracingConfigArgsDict',
    'FunctionUrlCorsArgs',
    'FunctionUrlCorsArgsDict',
    'FunctionVpcConfigArgs',
    'FunctionVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AliasRoutingConfigArgsDict(TypedDict):
        additional_version_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]
        """
        Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
elif False:
    AliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]] additional_version_weights: Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]:
        """
        Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class CapacityProviderCapacityProviderScalingConfigArgsDict(TypedDict):
        max_vcpu_count: pulumi.Input[_builtins.int]
        scaling_mode: pulumi.Input[_builtins.str]
        """
        The scaling mode for the Capacity Provider. Valid values are `AUTO` and `MANUAL`. Defaults to `AUTO`.
        """
        scaling_policies: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict']]]
        """
        List of scaling policies. See Scaling Policies below.
        """
elif False:
    CapacityProviderCapacityProviderScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderCapacityProviderScalingConfigArgs:
    def __init__(__self__, *,
                 max_vcpu_count: pulumi.Input[_builtins.int],
                 scaling_mode: pulumi.Input[_builtins.str],
                 scaling_policies: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]):
        """
        :param pulumi.Input[_builtins.str] scaling_mode: The scaling mode for the Capacity Provider. Valid values are `AUTO` and `MANUAL`. Defaults to `AUTO`.
        :param pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]] scaling_policies: List of scaling policies. See Scaling Policies below.
        """
        pulumi.set(__self__, "max_vcpu_count", max_vcpu_count)
        pulumi.set(__self__, "scaling_mode", scaling_mode)
        pulumi.set(__self__, "scaling_policies", scaling_policies)

    @_builtins.property
    @pulumi.getter(name="maxVcpuCount")
    def max_vcpu_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_vcpu_count")

    @max_vcpu_count.setter
    def max_vcpu_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_vcpu_count", value)

    @_builtins.property
    @pulumi.getter(name="scalingMode")
    def scaling_mode(self) -> pulumi.Input[_builtins.str]:
        """
        The scaling mode for the Capacity Provider. Valid values are `AUTO` and `MANUAL`. Defaults to `AUTO`.
        """
        return pulumi.get(self, "scaling_mode")

    @scaling_mode.setter
    def scaling_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scaling_mode", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]:
        """
        List of scaling policies. See Scaling Policies below.
        """
        return pulumi.get(self, "scaling_policies")

    @scaling_policies.setter
    def scaling_policies(self, value: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]):
        pulumi.set(self, "scaling_policies", value)


if not MYPY:
    class CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict(TypedDict):
        predefined_metric_type: pulumi.Input[_builtins.str]
        """
        The predefined metric type for the scaling policy. Valid values are `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION`.
        """
        target_value: pulumi.Input[_builtins.float]
        """
        The target value for the scaling policy.
        """
elif False:
    CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs:
    def __init__(__self__, *,
                 predefined_metric_type: pulumi.Input[_builtins.str],
                 target_value: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.str] predefined_metric_type: The predefined metric type for the scaling policy. Valid values are `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION`.
        :param pulumi.Input[_builtins.float] target_value: The target value for the scaling policy.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> pulumi.Input[_builtins.str]:
        """
        The predefined metric type for the scaling policy. Valid values are `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION`.
        """
        return pulumi.get(self, "predefined_metric_type")

    @predefined_metric_type.setter
    def predefined_metric_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "predefined_metric_type", value)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> pulumi.Input[_builtins.float]:
        """
        The target value for the scaling policy.
        """
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "target_value", value)


if not MYPY:
    class CapacityProviderInstanceRequirementArgsDict(TypedDict):
        allowed_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of allowed instance types.
        """
        architectures: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of CPU architectures. Valid values are `X86_64` and `ARM64`.
        """
        excluded_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of excluded instance types.
        """
elif False:
    CapacityProviderInstanceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderInstanceRequirementArgs:
    def __init__(__self__, *,
                 allowed_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 architectures: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 excluded_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_instance_types: List of allowed instance types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] architectures: List of CPU architectures. Valid values are `X86_64` and `ARM64`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_instance_types: List of excluded instance types.
        """
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "architectures", architectures)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of allowed instance types.
        """
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of CPU architectures. Valid values are `X86_64` and `ARM64`.
        """
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "architectures", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of excluded instance types.
        """
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "excluded_instance_types", value)


if not MYPY:
    class CapacityProviderPermissionsConfigArgsDict(TypedDict):
        capacity_provider_operator_role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the IAM role that allows Lambda to manage the Capacity Provider.
        """
elif False:
    CapacityProviderPermissionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderPermissionsConfigArgs:
    def __init__(__self__, *,
                 capacity_provider_operator_role_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] capacity_provider_operator_role_arn: The ARN of the IAM role that allows Lambda to manage the Capacity Provider.
        """
        pulumi.set(__self__, "capacity_provider_operator_role_arn", capacity_provider_operator_role_arn)

    @_builtins.property
    @pulumi.getter(name="capacityProviderOperatorRoleArn")
    def capacity_provider_operator_role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the IAM role that allows Lambda to manage the Capacity Provider.
        """
        return pulumi.get(self, "capacity_provider_operator_role_arn")

    @capacity_provider_operator_role_arn.setter
    def capacity_provider_operator_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider_operator_role_arn", value)


if not MYPY:
    class CapacityProviderTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CapacityProviderTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CapacityProviderVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of security group IDs for the VPC.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of subnet IDs for the VPC.
        """
elif False:
    CapacityProviderVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: List of security group IDs for the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: List of subnet IDs for the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of security group IDs for the VPC.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of subnet IDs for the VPC.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class CodeSigningConfigAllowedPublishersArgsDict(TypedDict):
        signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
elif False:
    CodeSigningConfigAllowedPublishersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] signing_profile_version_arns: Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


if not MYPY:
    class CodeSigningConfigPoliciesArgsDict(TypedDict):
        untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
elif False:
    CodeSigningConfigPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input[_builtins.str]:
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict']]
        """
        Block for a Kafka schema registry setting. See below.
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        :param pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs'] schema_registry_config: Block for a Kafka schema registry setting. See below.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]:
        """
        Block for a Kafka schema registry setting. See below.
        """
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict(TypedDict):
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict']]]]
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        event_record_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        schema_registry_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        schema_validation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict']]]]
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs:
    def __init__(__self__, *,
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]] = None,
                 event_record_format: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_validation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]] access_configs: Configuration block for authentication Lambda uses to access the schema registry.
        :param pulumi.Input[_builtins.str] event_record_format: Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        :param pulumi.Input[_builtins.str] schema_registry_uri: URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]] schema_validation_configs: Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]:
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        return pulumi.get(self, "event_record_format")

    @event_record_format.setter
    def event_record_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_record_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        return pulumi.get(self, "schema_registry_uri")

    @schema_registry_uri.setter
    def schema_registry_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_registry_uri", value)

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]:
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        return pulumi.get(self, "schema_validation_configs")

    @schema_validation_configs.setter
    def schema_validation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]):
        pulumi.set(self, "schema_validation_configs", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication type Lambda uses to access the schema registry.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Authentication type Lambda uses to access the schema registry.
        :param pulumi.Input[_builtins.str] uri: URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication type Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict(TypedDict):
        attribute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute: Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class EventSourceMappingDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgsDict']]
        """
        Destination configuration for failed invocations. See below.
        """
elif False:
    EventSourceMappingDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None):
        """
        :param pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs'] on_failure: Destination configuration for failed invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]:
        """
        Destination configuration for failed invocations. See below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


if not MYPY:
    class EventSourceMappingDestinationConfigOnFailureArgsDict(TypedDict):
        destination_arn: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource, or `kafka://your-topic-name` for Amazon MSK and self-managed Apache Kafka destinations.
        """
elif False:
    EventSourceMappingDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination_arn: ARN of the destination resource, or `kafka://your-topic-name` for Amazon MSK and self-managed Apache Kafka destinations.
        """
        pulumi.set(__self__, "destination_arn", destination_arn)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource, or `kafka://your-topic-name` for Amazon MSK and self-managed Apache Kafka destinations.
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)


if not MYPY:
    class EventSourceMappingDocumentDbEventSourceConfigArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        Name of the database to consume within the DocumentDB cluster.
        """
        collection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        full_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
elif False:
    EventSourceMappingDocumentDbEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 collection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 full_document: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_name: Name of the database to consume within the DocumentDB cluster.
        :param pulumi.Input[_builtins.str] collection_name: Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param pulumi.Input[_builtins.str] full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_document", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgsDict']]]]
        """
        Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
elif False:
    EventSourceMappingFilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]] filters: Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]:
        """
        Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaFilterArgsDict(TypedDict):
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
elif False:
    EventSourceMappingFilterCriteriaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pattern: Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class EventSourceMappingMetricsConfigArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
elif False:
    EventSourceMappingMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingMetricsConfigArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class EventSourceMappingProvisionedPollerConfigArgsDict(TypedDict):
        maximum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        minimum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        poller_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the provisioned poller group used to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        """
elif False:
    EventSourceMappingProvisionedPollerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingProvisionedPollerConfigArgs:
    def __init__(__self__, *,
                 maximum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 poller_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] maximum_pollers: Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        :param pulumi.Input[_builtins.int] minimum_pollers: Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        :param pulumi.Input[_builtins.str] poller_group_name: The name of the provisioned poller group used to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        """
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)
        if poller_group_name is not None:
            pulumi.set(__self__, "poller_group_name", poller_group_name)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        return pulumi.get(self, "maximum_pollers")

    @maximum_pollers.setter
    def maximum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        return pulumi.get(self, "minimum_pollers")

    @minimum_pollers.setter
    def minimum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="pollerGroupName")
    def poller_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the provisioned poller group used to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        """
        return pulumi.get(self, "poller_group_name")

    @poller_group_name.setter
    def poller_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "poller_group_name", value)


if not MYPY:
    class EventSourceMappingScalingConfigArgsDict(TypedDict):
        maximum_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
elif False:
    EventSourceMappingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] maximum_concurrency: Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_concurrency", value)


if not MYPY:
    class EventSourceMappingSelfManagedEventSourceArgsDict(TypedDict):
        endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
elif False:
    EventSourceMappingSelfManagedEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] endpoints: Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict']]
        """
        Block for a Kafka schema registry setting. See below.
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        :param pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs'] schema_registry_config: Block for a Kafka schema registry setting. See below.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]:
        """
        Block for a Kafka schema registry setting. See below.
        """
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict(TypedDict):
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict']]]]
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        event_record_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        schema_registry_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        schema_validation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict']]]]
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs:
    def __init__(__self__, *,
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]] = None,
                 event_record_format: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_validation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]] access_configs: Configuration block for authentication Lambda uses to access the schema registry.
        :param pulumi.Input[_builtins.str] event_record_format: Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        :param pulumi.Input[_builtins.str] schema_registry_uri: URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]] schema_validation_configs: Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]:
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        return pulumi.get(self, "event_record_format")

    @event_record_format.setter
    def event_record_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_record_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        return pulumi.get(self, "schema_registry_uri")

    @schema_registry_uri.setter
    def schema_registry_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_registry_uri", value)

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]:
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        return pulumi.get(self, "schema_validation_configs")

    @schema_validation_configs.setter
    def schema_validation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]):
        pulumi.set(self, "schema_validation_configs", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication type Lambda uses to access the schema registry.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Authentication type Lambda uses to access the schema registry.
        :param pulumi.Input[_builtins.str] uri: URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication type Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict(TypedDict):
        attribute: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute: Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class EventSourceMappingSourceAccessConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        uri: pulumi.Input[_builtins.str]
        """
        URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
elif False:
    EventSourceMappingSourceAccessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        :param pulumi.Input[_builtins.str] uri: URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class FunctionCapacityProviderConfigArgsDict(TypedDict):
        lambda_managed_instances_capacity_provider_config: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict']
        """
        Configuration block for Lambda Managed Instances Capacity Provider. See below.
        """
elif False:
    FunctionCapacityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCapacityProviderConfigArgs:
    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_config: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']):
        """
        :param pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs'] lambda_managed_instances_capacity_provider_config: Configuration block for Lambda Managed Instances Capacity Provider. See below.
        """
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_config", lambda_managed_instances_capacity_provider_config)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfig")
    def lambda_managed_instances_capacity_provider_config(self) -> pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']:
        """
        Configuration block for Lambda Managed Instances Capacity Provider. See below.
        """
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_config")

    @lambda_managed_instances_capacity_provider_config.setter
    def lambda_managed_instances_capacity_provider_config(self, value: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']):
        pulumi.set(self, "lambda_managed_instances_capacity_provider_config", value)


if not MYPY:
    class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict(TypedDict):
        capacity_provider_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Capacity Provider.
        """
        execution_environment_memory_gib_per_vcpu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Memory GiB per vCPU for the execution environment.
        """
        per_execution_environment_max_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum concurrency per execution environment.
        """
elif False:
    FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs:
    def __init__(__self__, *,
                 capacity_provider_arn: pulumi.Input[_builtins.str],
                 execution_environment_memory_gib_per_vcpu: Optional[pulumi.Input[_builtins.float]] = None,
                 per_execution_environment_max_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_provider_arn: ARN of the Capacity Provider.
        :param pulumi.Input[_builtins.float] execution_environment_memory_gib_per_vcpu: Memory GiB per vCPU for the execution environment.
        :param pulumi.Input[_builtins.int] per_execution_environment_max_concurrency: Maximum concurrency per execution environment.
        """
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        if execution_environment_memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        if per_execution_environment_max_concurrency is not None:
            pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Capacity Provider.
        """
        return pulumi.get(self, "capacity_provider_arn")

    @capacity_provider_arn.setter
    def capacity_provider_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider_arn", value)

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Memory GiB per vCPU for the execution environment.
        """
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @execution_environment_memory_gib_per_vcpu.setter
    def execution_environment_memory_gib_per_vcpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "execution_environment_memory_gib_per_vcpu", value)

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum concurrency per execution environment.
        """
        return pulumi.get(self, "per_execution_environment_max_concurrency")

    @per_execution_environment_max_concurrency.setter
    def per_execution_environment_max_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_execution_environment_max_concurrency", value)


if not MYPY:
    class FunctionDeadLetterConfigArgsDict(TypedDict):
        target_arn: pulumi.Input[_builtins.str]
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
elif False:
    FunctionDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class FunctionDurableConfigArgsDict(TypedDict):
        execution_timeout: pulumi.Input[_builtins.int]
        """
        Maximum execution time in seconds for the durable function. Valid value between 1 and 31622400 (366 days).
        """
        retention_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days to retain the function's execution state. Valid value between 1 and 90. If not specified, the function's execution state is not retained. Defaults to 14.
        """
elif False:
    FunctionDurableConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDurableConfigArgs:
    def __init__(__self__, *,
                 execution_timeout: pulumi.Input[_builtins.int],
                 retention_period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] execution_timeout: Maximum execution time in seconds for the durable function. Valid value between 1 and 31622400 (366 days).
        :param pulumi.Input[_builtins.int] retention_period: Number of days to retain the function's execution state. Valid value between 1 and 90. If not specified, the function's execution state is not retained. Defaults to 14.
        """
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum execution time in seconds for the durable function. Valid value between 1 and 31622400 (366 days).
        """
        return pulumi.get(self, "execution_timeout")

    @execution_timeout.setter
    def execution_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "execution_timeout", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days to retain the function's execution state. Valid value between 1 and 90. If not specified, the function's execution state is not retained. Defaults to 14.
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_period", value)


if not MYPY:
    class FunctionEnvironmentArgsDict(TypedDict):
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of environment variables available to your Lambda function during execution.
        """
elif False:
    FunctionEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] variables: Map of environment variables available to your Lambda function during execution.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of environment variables available to your Lambda function during execution.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FunctionEphemeralStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
elif False:
    FunctionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict']]
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below.
        """
        on_success: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict']]
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Configuration block with destination configuration for failed asynchronous invocations. See below.
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionFileSystemConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Amazon EFS Access Point.
        """
        local_mount_path: pulumi.Input[_builtins.str]
        """
        Path where the function can access the file system. Must start with `/mnt/`.
        """
elif False:
    FunctionFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 local_mount_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Amazon EFS Access Point.
        :param pulumi.Input[_builtins.str] local_mount_path: Path where the function can access the file system. Must start with `/mnt/`.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Amazon EFS Access Point.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Path where the function can access the file system. Must start with `/mnt/`.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Parameters to pass to the container image.
        """
        entry_points: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Entry point to your application.
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Working directory for the container image.
        """
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Parameters to pass to the container image.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entry_points: Entry point to your application.
        :param pulumi.Input[_builtins.str] working_directory: Working directory for the container image.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Parameters to pass to the container image.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Entry point to your application.
        """
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entry_points", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Working directory for the container image.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class FunctionLoggingConfigArgsDict(TypedDict):
        log_format: pulumi.Input[_builtins.str]
        """
        Log format. Valid values: `Text`, `JSON`.
        """
        application_log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        """
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        CloudWatch log group where logs are sent.
        """
        system_log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
elif False:
    FunctionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLoggingConfigArgs:
    def __init__(__self__, *,
                 log_format: pulumi.Input[_builtins.str],
                 application_log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None,
                 system_log_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_format: Log format. Valid values: `Text`, `JSON`.
        :param pulumi.Input[_builtins.str] application_log_level: Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        :param pulumi.Input[_builtins.str] log_group: CloudWatch log group where logs are sent.
        :param pulumi.Input[_builtins.str] system_log_level: Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[_builtins.str]:
        """
        Log format. Valid values: `Text`, `JSON`.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        """
        return pulumi.get(self, "application_log_level")

    @application_log_level.setter
    def application_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_log_level", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CloudWatch log group where logs are sent.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        return pulumi.get(self, "system_log_level")

    @system_log_level.setter
    def system_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "system_log_level", value)


if not MYPY:
    class FunctionSnapStartArgsDict(TypedDict):
        apply_on: pulumi.Input[_builtins.str]
        """
        When to apply snap start optimization. Valid value: `PublishedVersions`.
        """
        optimization_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
elif False:
    FunctionSnapStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input[_builtins.str],
                 optimization_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apply_on: When to apply snap start optimization. Valid value: `PublishedVersions`.
        :param pulumi.Input[_builtins.str] optimization_status: Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input[_builtins.str]:
        """
        When to apply snap start optimization. Valid value: `PublishedVersions`.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "apply_on", value)

    @_builtins.property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        return pulumi.get(self, "optimization_status")

    @optimization_status.setter
    def optimization_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "optimization_status", value)


if not MYPY:
    class FunctionTenancyConfigArgsDict(TypedDict):
        tenant_isolation_mode: pulumi.Input[_builtins.str]
        """
        Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
elif False:
    FunctionTenancyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTenancyConfigArgs:
    def __init__(__self__, *,
                 tenant_isolation_mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tenant_isolation_mode: Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        return pulumi.get(self, "tenant_isolation_mode")

    @tenant_isolation_mode.setter
    def tenant_isolation_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_isolation_mode", value)


if not MYPY:
    class FunctionTracingConfigArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
elif False:
    FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FunctionUrlCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow cookies or other credentials in requests to the function URL.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP headers that origins can include in requests to the function URL.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP methods that are allowed when calling the function URL.
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Origins that can access the function URL.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
elif False:
    FunctionUrlCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionUrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether to allow cookies or other credentials in requests to the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: HTTP headers that origins can include in requests to the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: HTTP methods that are allowed when calling the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_origins: Origins that can access the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: HTTP headers in your function response that you want to expose to origins that call the function URL.
        :param pulumi.Input[_builtins.int] max_age: Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow cookies or other credentials in requests to the function URL.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers that origins can include in requests to the function URL.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP methods that are allowed when calling the function URL.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Origins that can access the function URL.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class FunctionVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of security group IDs associated with the Lambda function.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of subnet IDs associated with the Lambda function.
        """
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the VPC.
        """
elif False:
    FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[_builtins.bool]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: List of security group IDs associated with the Lambda function.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: List of subnet IDs associated with the Lambda function.
        :param pulumi.Input[_builtins.bool] ipv6_allowed_for_dual_stack: Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        :param pulumi.Input[_builtins.str] vpc_id: ID of the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


