# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasRoutingConfigArgs',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigPoliciesArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigOnFailureArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaFilterArgs',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'FunctionDeadLetterConfigArgs',
    'FunctionEnvironmentArgs',
    'FunctionEphemeralStorageArgs',
    'FunctionEventInvokeConfigDestinationConfigArgs',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionFileSystemConfigArgs',
    'FunctionImageConfigArgs',
    'FunctionSnapStartArgs',
    'FunctionTracingConfigArgs',
    'FunctionUrlCorsArgs',
    'FunctionVpcConfigArgs',
]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] additional_version_weights: A map that defines the proportion of events that should be sent to different versions of a lambda function.
        """
        AliasRoutingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_version_weights=additional_version_weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_version_weights is None and 'additionalVersionWeights' in kwargs:
            additional_version_weights = kwargs['additionalVersionWeights']

        if additional_version_weights is not None:
            _setter("additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A map that defines the proportion of events that should be sent to different versions of a lambda function.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "additional_version_weights", value)


@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] signing_profile_version_arns: The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        CodeSigningConfigAllowedPublishersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            signing_profile_version_arns=signing_profile_version_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             signing_profile_version_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if signing_profile_version_arns is None and 'signingProfileVersionArns' in kwargs:
            signing_profile_version_arns = kwargs['signingProfileVersionArns']
        if signing_profile_version_arns is None:
            raise TypeError("Missing 'signing_profile_version_arns' argument")

        _setter("signing_profile_version_arns", signing_profile_version_arns)

    @property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


@pulumi.input_type
class CodeSigningConfigPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input[str]):
        """
        :param pulumi.Input[str] untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        CodeSigningConfigPoliciesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            untrusted_artifact_on_deployment=untrusted_artifact_on_deployment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             untrusted_artifact_on_deployment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if untrusted_artifact_on_deployment is None and 'untrustedArtifactOnDeployment' in kwargs:
            untrusted_artifact_on_deployment = kwargs['untrustedArtifactOnDeployment']
        if untrusted_artifact_on_deployment is None:
            raise TypeError("Missing 'untrusted_artifact_on_deployment' argument")

        _setter("untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input[str]:
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group_id: A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group_id=consumer_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if consumer_group_id is None and 'consumerGroupId' in kwargs:
            consumer_group_id = kwargs['consumerGroupId']

        if consumer_group_id is not None:
            _setter("consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None):
        """
        :param pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs'] on_failure: The destination configuration for failed invocations. Detailed below.
        """
        EventSourceMappingDestinationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_failure=on_failure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if on_failure is None and 'onFailure' in kwargs:
            on_failure = kwargs['onFailure']

        if on_failure is not None:
            _setter("on_failure", on_failure)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]:
        """
        The destination configuration for failed invocations. Detailed below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


@pulumi.input_type
class EventSourceMappingDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_arn: The Amazon Resource Name (ARN) of the destination resource.
        """
        EventSourceMappingDestinationConfigOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_arn=destination_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_arn is None and 'destinationArn' in kwargs:
            destination_arn = kwargs['destinationArn']
        if destination_arn is None:
            raise TypeError("Missing 'destination_arn' argument")

        _setter("destination_arn", destination_arn)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)


@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 collection_name: Optional[pulumi.Input[str]] = None,
                 full_document: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database to consume within the DocumentDB cluster.
        :param pulumi.Input[str] collection_name: The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param pulumi.Input[str] full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        EventSourceMappingDocumentDbEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            collection_name=collection_name,
            full_document=full_document,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[pulumi.Input[str]] = None,
             collection_name: Optional[pulumi.Input[str]] = None,
             full_document: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if collection_name is None and 'collectionName' in kwargs:
            collection_name = kwargs['collectionName']
        if full_document is None and 'fullDocument' in kwargs:
            full_document = kwargs['fullDocument']

        _setter("database_name", database_name)
        if collection_name is not None:
            _setter("collection_name", collection_name)
        if full_document is not None:
            _setter("full_document", full_document)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_document", value)


@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]] filters: A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
        """
        EventSourceMappingFilterCriteriaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if filters is not None:
            _setter("filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]:
        """
        A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class EventSourceMappingFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pattern: A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        EventSourceMappingFilterCriteriaFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pattern=pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pattern: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if pattern is not None:
            _setter("pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] maximum_concurrency: Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between `2` and `1000`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
        """
        EventSourceMappingScalingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_concurrency=maximum_concurrency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_concurrency: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_concurrency is None and 'maximumConcurrency' in kwargs:
            maximum_concurrency = kwargs['maximumConcurrency']

        if maximum_concurrency is not None:
            _setter("maximum_concurrency", maximum_concurrency)

    @property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be between `2` and `1000`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_concurrency", value)


@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] endpoints: A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        EventSourceMappingSelfManagedEventSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoints=endpoints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoints: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoints is None:
            raise TypeError("Missing 'endpoints' argument")

        _setter("endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "endpoints", value)


@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group_id: A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        EventSourceMappingSelfManagedKafkaEventSourceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group_id=consumer_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if consumer_group_id is None and 'consumerGroupId' in kwargs:
            consumer_group_id = kwargs['consumerGroupId']

        if consumer_group_id is not None:
            _setter("consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of this configuration.  For Self Managed Kafka you will need to supply blocks for type `VPC_SUBNET` and `VPC_SECURITY_GROUP`.
        :param pulumi.Input[str] uri: The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        EventSourceMappingSourceAccessConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("type", type)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of this configuration.  For Self Managed Kafka you will need to supply blocks for type `VPC_SUBNET` and `VPC_SECURITY_GROUP`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
        """
        FunctionDeadLetterConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_arn=target_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_arn is None and 'targetArn' in kwargs:
            target_arn = kwargs['targetArn']
        if target_arn is None:
            raise TypeError("Missing 'target_arn' argument")

        _setter("target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)


@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] variables: Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
        """
        FunctionEnvironmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] size: The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeral_storage` value defaults to `512`MB and the maximum supported value is `10240`MB.
        """
        FunctionEphemeralStorageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if size is not None:
            _setter("size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeral_storage` value defaults to `512`MB and the maximum supported value is `10240`MB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Configuration block with destination configuration for failed asynchronous invocations. See below for details.
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Configuration block with destination configuration for successful asynchronous invocations. See below for details.
        """
        FunctionEventInvokeConfigDestinationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_failure=on_failure,
            on_success=on_success,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
             on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if on_failure is None and 'onFailure' in kwargs:
            on_failure = kwargs['onFailure']
        if on_success is None and 'onSuccess' in kwargs:
            on_success = kwargs['onSuccess']

        if on_failure is not None:
            _setter("on_failure", on_failure)
        if on_success is not None:
            _setter("on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below for details.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below for details.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        FunctionEventInvokeConfigDestinationConfigOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        FunctionEventInvokeConfigDestinationConfigOnSuccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 local_mount_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
        :param pulumi.Input[str] local_mount_path: Path where the function can access the file system, starting with /mnt/.
        """
        FunctionFileSystemConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            local_mount_path=local_mount_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[pulumi.Input[str]] = None,
             local_mount_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if local_mount_path is None and 'localMountPath' in kwargs:
            local_mount_path = kwargs['localMountPath']
        if local_mount_path is None:
            raise TypeError("Missing 'local_mount_path' argument")

        _setter("arn", arn)
        _setter("local_mount_path", local_mount_path)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[str]:
        """
        Path where the function can access the file system, starting with /mnt/.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_path", value)


@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 working_directory: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Parameters that you want to pass in with `entry_point`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] entry_points: Entry point to your application, which is typically the location of the runtime executable.
        :param pulumi.Input[str] working_directory: Working directory.
        """
        FunctionImageConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            entry_points=entry_points,
            working_directory=working_directory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             working_directory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entry_points is None and 'entryPoints' in kwargs:
            entry_points = kwargs['entryPoints']
        if working_directory is None and 'workingDirectory' in kwargs:
            working_directory = kwargs['workingDirectory']

        if commands is not None:
            _setter("commands", commands)
        if entry_points is not None:
            _setter("entry_points", entry_points)
        if working_directory is not None:
            _setter("working_directory", working_directory)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters that you want to pass in with `entry_point`.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Entry point to your application, which is typically the location of the runtime executable.
        """
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "entry_points", value)

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[str]]:
        """
        Working directory.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "working_directory", value)


@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input[str],
                 optimization_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_on: Conditions where snap start is enabled. Valid values are `PublishedVersions`.
        """
        FunctionSnapStartArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_on=apply_on,
            optimization_status=optimization_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_on: Optional[pulumi.Input[str]] = None,
             optimization_status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if apply_on is None and 'applyOn' in kwargs:
            apply_on = kwargs['applyOn']
        if apply_on is None:
            raise TypeError("Missing 'apply_on' argument")
        if optimization_status is None and 'optimizationStatus' in kwargs:
            optimization_status = kwargs['optimizationStatus']

        _setter("apply_on", apply_on)
        if optimization_status is not None:
            _setter("optimization_status", optimization_status)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input[str]:
        """
        Conditions where snap start is enabled. Valid values are `PublishedVersions`.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input[str]):
        pulumi.set(self, "apply_on", value)

    @property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "optimization_status")

    @optimization_status.setter
    def optimization_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "optimization_status", value)


@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
        """
        FunctionTracingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class FunctionUrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_origins: The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The HTTP headers in your function response that you want to expose to origins that call the function URL.
        :param pulumi.Input[int] max_age: The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
        """
        FunctionUrlCorsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[pulumi.Input[bool]] = None,
             allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_credentials is None and 'allowCredentials' in kwargs:
            allow_credentials = kwargs['allowCredentials']
        if allow_headers is None and 'allowHeaders' in kwargs:
            allow_headers = kwargs['allowHeaders']
        if allow_methods is None and 'allowMethods' in kwargs:
            allow_methods = kwargs['allowMethods']
        if allow_origins is None and 'allowOrigins' in kwargs:
            allow_origins = kwargs['allowOrigins']
        if expose_headers is None and 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if max_age is None and 'maxAge' in kwargs:
            max_age = kwargs['maxAge']

        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allow_headers is not None:
            _setter("allow_headers", allow_headers)
        if allow_methods is not None:
            _setter("allow_methods", allow_methods)
        if allow_origins is not None:
            _setter("allow_origins", allow_origins)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: List of security group IDs associated with the Lambda function.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: List of subnet IDs associated with the Lambda function.
        """
        FunctionVpcConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             vpc_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if security_group_ids is None and 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if security_group_ids is None:
            raise TypeError("Missing 'security_group_ids' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']

        _setter("security_group_ids", security_group_ids)
        _setter("subnet_ids", subnet_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


