# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasRoutingConfigArgs',
    'AliasRoutingConfigArgsDict',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigAllowedPublishersArgsDict',
    'CodeSigningConfigPoliciesArgs',
    'CodeSigningConfigPoliciesArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigArgsDict',
    'EventSourceMappingDestinationConfigOnFailureArgs',
    'EventSourceMappingDestinationConfigOnFailureArgsDict',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgsDict',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaArgsDict',
    'EventSourceMappingFilterCriteriaFilterArgs',
    'EventSourceMappingFilterCriteriaFilterArgsDict',
    'EventSourceMappingMetricsConfigArgs',
    'EventSourceMappingMetricsConfigArgsDict',
    'EventSourceMappingProvisionedPollerConfigArgs',
    'EventSourceMappingProvisionedPollerConfigArgsDict',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingScalingConfigArgsDict',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedEventSourceArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'EventSourceMappingSourceAccessConfigurationArgsDict',
    'FunctionDeadLetterConfigArgs',
    'FunctionDeadLetterConfigArgsDict',
    'FunctionEnvironmentArgs',
    'FunctionEnvironmentArgsDict',
    'FunctionEphemeralStorageArgs',
    'FunctionEphemeralStorageArgsDict',
    'FunctionEventInvokeConfigDestinationConfigArgs',
    'FunctionEventInvokeConfigDestinationConfigArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict',
    'FunctionFileSystemConfigArgs',
    'FunctionFileSystemConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionLoggingConfigArgs',
    'FunctionLoggingConfigArgsDict',
    'FunctionSnapStartArgs',
    'FunctionSnapStartArgsDict',
    'FunctionTracingConfigArgs',
    'FunctionTracingConfigArgsDict',
    'FunctionUrlCorsArgs',
    'FunctionUrlCorsArgsDict',
    'FunctionVpcConfigArgs',
    'FunctionVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AliasRoutingConfigArgsDict(TypedDict):
        additional_version_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A map that defines the proportion of events that should be sent to different versions of a lambda function.
        """
elif False:
    AliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] additional_version_weights: A map that defines the proportion of events that should be sent to different versions of a lambda function.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A map that defines the proportion of events that should be sent to different versions of a lambda function.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class CodeSigningConfigAllowedPublishersArgsDict(TypedDict):
        signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
elif False:
    CodeSigningConfigAllowedPublishersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] signing_profile_version_arns: The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


if not MYPY:
    class CodeSigningConfigPoliciesArgsDict(TypedDict):
        untrusted_artifact_on_deployment: pulumi.Input[str]
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
elif False:
    CodeSigningConfigPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input[str]):
        """
        :param pulumi.Input[str] untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input[str]:
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to Enforce, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to Warn, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[str]]
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group_id: A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


if not MYPY:
    class EventSourceMappingDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgsDict']]
        """
        The destination configuration for failed invocations. Detailed below.
        """
elif False:
    EventSourceMappingDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None):
        """
        :param pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs'] on_failure: The destination configuration for failed invocations. Detailed below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]:
        """
        The destination configuration for failed invocations. Detailed below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


if not MYPY:
    class EventSourceMappingDestinationConfigOnFailureArgsDict(TypedDict):
        destination_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
elif False:
    EventSourceMappingDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_arn: The Amazon Resource Name (ARN) of the destination resource.
        """
        pulumi.set(__self__, "destination_arn", destination_arn)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the destination resource.
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)


if not MYPY:
    class EventSourceMappingDocumentDbEventSourceConfigArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database to consume within the DocumentDB cluster.
        """
        collection_name: NotRequired[pulumi.Input[str]]
        """
        The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        full_document: NotRequired[pulumi.Input[str]]
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
elif False:
    EventSourceMappingDocumentDbEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 collection_name: Optional[pulumi.Input[str]] = None,
                 full_document: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database to consume within the DocumentDB cluster.
        :param pulumi.Input[str] collection_name: The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param pulumi.Input[str] full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input[str]]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_document", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgsDict']]]]
        """
        A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
        """
elif False:
    EventSourceMappingFilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]] filters: A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]:
        """
        A set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. Detailed below.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaFilterArgsDict(TypedDict):
        pattern: NotRequired[pulumi.Input[str]]
        """
        A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
elif False:
    EventSourceMappingFilterCriteriaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pattern: A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        A filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class EventSourceMappingMetricsConfigArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
elif False:
    EventSourceMappingMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingMetricsConfigArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metrics: A list containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class EventSourceMappingProvisionedPollerConfigArgsDict(TypedDict):
        maximum_pollers: NotRequired[pulumi.Input[int]]
        """
        The maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        minimum_pollers: NotRequired[pulumi.Input[int]]
        """
        The minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
elif False:
    EventSourceMappingProvisionedPollerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingProvisionedPollerConfigArgs:
    def __init__(__self__, *,
                 maximum_pollers: Optional[pulumi.Input[int]] = None,
                 minimum_pollers: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] maximum_pollers: The maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        :param pulumi.Input[int] minimum_pollers: The minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)

    @property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        return pulumi.get(self, "maximum_pollers")

    @maximum_pollers.setter
    def maximum_pollers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_pollers", value)

    @property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        return pulumi.get(self, "minimum_pollers")

    @minimum_pollers.setter
    def minimum_pollers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_pollers", value)


if not MYPY:
    class EventSourceMappingScalingConfigArgsDict(TypedDict):
        maximum_concurrency: NotRequired[pulumi.Input[int]]
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to `2`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
elif False:
    EventSourceMappingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] maximum_concurrency: Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to `2`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to `2`. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_concurrency", value)


if not MYPY:
    class EventSourceMappingSelfManagedEventSourceArgsDict(TypedDict):
        endpoints: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
elif False:
    EventSourceMappingSelfManagedEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] endpoints: A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A map of endpoints for the self managed source.  For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[str]]
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group_id: A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)


if not MYPY:
    class EventSourceMappingSourceAccessConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        uri: pulumi.Input[str]
        """
        The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
elif False:
    EventSourceMappingSourceAccessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        :param pulumi.Input[str] uri: The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI for this configuration.  For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute.  For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class FunctionDeadLetterConfigArgsDict(TypedDict):
        target_arn: pulumi.Input[str]
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
        """
elif False:
    FunctionDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
        """
        pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails. If this option is used, the function's IAM role must be granted suitable access to write to the target object, which means allowing either the `sns:Publish` or `sqs:SendMessage` action on this ARN, depending on which service is targeted.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class FunctionEnvironmentArgsDict(TypedDict):
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
        """
elif False:
    FunctionEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] variables: Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of environment variables that are accessible from the function code during execution. If provided at least one key must be present.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FunctionEphemeralStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeral_storage` value defaults to `512`MB and the maximum supported value is `10240`MB.
        """
elif False:
    FunctionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] size: The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeral_storage` value defaults to `512`MB and the maximum supported value is `10240`MB.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the Lambda function Ephemeral storage(`/tmp`) represented in MB. The minimum supported `ephemeral_storage` value defaults to `512`MB and the maximum supported value is `10240`MB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict']]
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below for details.
        """
        on_success: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict']]
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below for details.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Configuration block with destination configuration for failed asynchronous invocations. See below for details.
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Configuration block with destination configuration for successful asynchronous invocations. See below for details.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below for details.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below for details.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionFileSystemConfigArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
        """
        local_mount_path: pulumi.Input[str]
        """
        Path where the function can access the file system, starting with /mnt/.
        """
elif False:
    FunctionFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 local_mount_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
        :param pulumi.Input[str] local_mount_path: Path where the function can access the file system, starting with /mnt/.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[str]:
        """
        Path where the function can access the file system, starting with /mnt/.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_path", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameters that you want to pass in with `entry_point`.
        """
        entry_points: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Entry point to your application, which is typically the location of the runtime executable.
        """
        working_directory: NotRequired[pulumi.Input[str]]
        """
        Working directory.
        """
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 working_directory: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Parameters that you want to pass in with `entry_point`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] entry_points: Entry point to your application, which is typically the location of the runtime executable.
        :param pulumi.Input[str] working_directory: Working directory.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters that you want to pass in with `entry_point`.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Entry point to your application, which is typically the location of the runtime executable.
        """
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "entry_points", value)

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[str]]:
        """
        Working directory.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class FunctionLoggingConfigArgsDict(TypedDict):
        log_format: pulumi.Input[str]
        """
        select between `Text` and structured `JSON` format for your function's logs.
        """
        application_log_level: NotRequired[pulumi.Input[str]]
        """
        for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
        """
        log_group: NotRequired[pulumi.Input[str]]
        """
        the CloudWatch log group your function sends logs to.
        """
        system_log_level: NotRequired[pulumi.Input[str]]
        """
        for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as `ERROR`, `DEBUG`, or `INFO`.
        """
elif False:
    FunctionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLoggingConfigArgs:
    def __init__(__self__, *,
                 log_format: pulumi.Input[str],
                 application_log_level: Optional[pulumi.Input[str]] = None,
                 log_group: Optional[pulumi.Input[str]] = None,
                 system_log_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_format: select between `Text` and structured `JSON` format for your function's logs.
        :param pulumi.Input[str] application_log_level: for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
        :param pulumi.Input[str] log_group: the CloudWatch log group your function sends logs to.
        :param pulumi.Input[str] system_log_level: for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as `ERROR`, `DEBUG`, or `INFO`.
        """
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[str]:
        """
        select between `Text` and structured `JSON` format for your function's logs.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_format", value)

    @property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[pulumi.Input[str]]:
        """
        for JSON structured logs, choose the detail level of the logs your application sends to CloudWatch when using supported logging libraries.
        """
        return pulumi.get(self, "application_log_level")

    @application_log_level.setter
    def application_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_log_level", value)

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[str]]:
        """
        the CloudWatch log group your function sends logs to.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group", value)

    @property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[pulumi.Input[str]]:
        """
        for JSON structured logs, choose the detail level of the Lambda platform event logs sent to CloudWatch, such as `ERROR`, `DEBUG`, or `INFO`.
        """
        return pulumi.get(self, "system_log_level")

    @system_log_level.setter
    def system_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "system_log_level", value)


if not MYPY:
    class FunctionSnapStartArgsDict(TypedDict):
        apply_on: pulumi.Input[str]
        """
        Conditions where snap start is enabled. Valid values are `PublishedVersions`.
        """
        optimization_status: NotRequired[pulumi.Input[str]]
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
elif False:
    FunctionSnapStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input[str],
                 optimization_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_on: Conditions where snap start is enabled. Valid values are `PublishedVersions`.
        :param pulumi.Input[str] optimization_status: Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input[str]:
        """
        Conditions where snap start is enabled. Valid values are `PublishedVersions`.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input[str]):
        pulumi.set(self, "apply_on", value)

    @property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[pulumi.Input[str]]:
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        return pulumi.get(self, "optimization_status")

    @optimization_status.setter
    def optimization_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "optimization_status", value)


if not MYPY:
    class FunctionTracingConfigArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
        """
elif False:
    FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`. If `PassThrough`, Lambda will only trace the request from an upstream service if it contains a tracing header with "sampled=1". If `Active`, Lambda will respect any tracing header it receives from an upstream service. If no tracing header is received, Lambda will call X-Ray for a tracing decision.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FunctionUrlCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
        """
elif False:
    FunctionUrlCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionUrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_origins: The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The HTTP headers in your function response that you want to expose to origins that call the function URL.
        :param pulumi.Input[int] max_age: The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow cookies or other credentials in requests to the function URL. The default is `false`.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers that origins can include in requests to the function URL. For example: `["date", "keep-alive", "x-custom-header"]`.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP methods that are allowed when calling the function URL. For example: `["GET", "POST", "DELETE"]`, or the wildcard character (`["*"]`).
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The origins that can access the function URL. You can list any number of specific origins (or the wildcard character (`"*"`)), separated by a comma. For example: `["https://www.example.com", "http://localhost:60905"]`.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time, in seconds, that web browsers can cache results of a preflight request. By default, this is set to `0`, which means that the browser doesn't cache results. The maximum value is `86400`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class FunctionVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of security group IDs associated with the Lambda function.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of subnet IDs associated with the Lambda function.
        """
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[bool]]
        """
        Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is `false`.
        """
        vpc_id: NotRequired[pulumi.Input[str]]
        """
        ID of the VPC.
        """
elif False:
    FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[bool]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: List of security group IDs associated with the Lambda function.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: List of subnet IDs associated with the Lambda function.
        :param pulumi.Input[bool] ipv6_allowed_for_dual_stack: Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is `false`.
        :param pulumi.Input[str] vpc_id: ID of the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Default is `false`.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


