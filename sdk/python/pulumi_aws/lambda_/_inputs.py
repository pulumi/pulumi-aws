# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasRoutingConfigArgs',
    'AliasRoutingConfigArgsDict',
    'CapacityProviderCapacityProviderScalingConfigArgs',
    'CapacityProviderCapacityProviderScalingConfigArgsDict',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict',
    'CapacityProviderInstanceRequirementArgs',
    'CapacityProviderInstanceRequirementArgsDict',
    'CapacityProviderPermissionsConfigArgs',
    'CapacityProviderPermissionsConfigArgsDict',
    'CapacityProviderTimeoutsArgs',
    'CapacityProviderTimeoutsArgsDict',
    'CapacityProviderVpcConfigArgs',
    'CapacityProviderVpcConfigArgsDict',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigAllowedPublishersArgsDict',
    'CodeSigningConfigPoliciesArgs',
    'CodeSigningConfigPoliciesArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigArgsDict',
    'EventSourceMappingDestinationConfigOnFailureArgs',
    'EventSourceMappingDestinationConfigOnFailureArgsDict',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgsDict',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaArgsDict',
    'EventSourceMappingFilterCriteriaFilterArgs',
    'EventSourceMappingFilterCriteriaFilterArgsDict',
    'EventSourceMappingMetricsConfigArgs',
    'EventSourceMappingMetricsConfigArgsDict',
    'EventSourceMappingProvisionedPollerConfigArgs',
    'EventSourceMappingProvisionedPollerConfigArgsDict',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingScalingConfigArgsDict',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedEventSourceArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'EventSourceMappingSourceAccessConfigurationArgsDict',
    'FunctionCapacityProviderConfigArgs',
    'FunctionCapacityProviderConfigArgsDict',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict',
    'FunctionDeadLetterConfigArgs',
    'FunctionDeadLetterConfigArgsDict',
    'FunctionDurableConfigArgs',
    'FunctionDurableConfigArgsDict',
    'FunctionEnvironmentArgs',
    'FunctionEnvironmentArgsDict',
    'FunctionEphemeralStorageArgs',
    'FunctionEphemeralStorageArgsDict',
    'FunctionEventInvokeConfigDestinationConfigArgs',
    'FunctionEventInvokeConfigDestinationConfigArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict',
    'FunctionFileSystemConfigArgs',
    'FunctionFileSystemConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionLoggingConfigArgs',
    'FunctionLoggingConfigArgsDict',
    'FunctionSnapStartArgs',
    'FunctionSnapStartArgsDict',
    'FunctionTenancyConfigArgs',
    'FunctionTenancyConfigArgsDict',
    'FunctionTracingConfigArgs',
    'FunctionTracingConfigArgsDict',
    'FunctionUrlCorsArgs',
    'FunctionUrlCorsArgsDict',
    'FunctionVpcConfigArgs',
    'FunctionVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AliasRoutingConfigArgsDict(TypedDict):
        additional_version_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]
elif False:
    AliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]] = None):
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]:
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class CapacityProviderCapacityProviderScalingConfigArgsDict(TypedDict):
        max_vcpu_count: pulumi.Input[_builtins.int]
        scaling_mode: pulumi.Input[_builtins.str]
        scaling_policies: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict']]]
elif False:
    CapacityProviderCapacityProviderScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderCapacityProviderScalingConfigArgs:
    def __init__(__self__, *,
                 max_vcpu_count: pulumi.Input[_builtins.int],
                 scaling_mode: pulumi.Input[_builtins.str],
                 scaling_policies: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]):
        pulumi.set(__self__, "max_vcpu_count", max_vcpu_count)
        pulumi.set(__self__, "scaling_mode", scaling_mode)
        pulumi.set(__self__, "scaling_policies", scaling_policies)

    @_builtins.property
    @pulumi.getter(name="maxVcpuCount")
    def max_vcpu_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_vcpu_count")

    @max_vcpu_count.setter
    def max_vcpu_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_vcpu_count", value)

    @_builtins.property
    @pulumi.getter(name="scalingMode")
    def scaling_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scaling_mode")

    @scaling_mode.setter
    def scaling_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scaling_mode", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]:
        return pulumi.get(self, "scaling_policies")

    @scaling_policies.setter
    def scaling_policies(self, value: pulumi.Input[Sequence[pulumi.Input['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs']]]):
        pulumi.set(self, "scaling_policies", value)


if not MYPY:
    class CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict(TypedDict):
        predefined_metric_type: pulumi.Input[_builtins.str]
        target_value: pulumi.Input[_builtins.float]
elif False:
    CapacityProviderCapacityProviderScalingConfigScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs:
    def __init__(__self__, *,
                 predefined_metric_type: pulumi.Input[_builtins.str],
                 target_value: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "predefined_metric_type")

    @predefined_metric_type.setter
    def predefined_metric_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "predefined_metric_type", value)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "target_value", value)


if not MYPY:
    class CapacityProviderInstanceRequirementArgsDict(TypedDict):
        allowed_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        architectures: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        excluded_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    CapacityProviderInstanceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderInstanceRequirementArgs:
    def __init__(__self__, *,
                 allowed_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 architectures: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 excluded_instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "architectures", architectures)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "architectures", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "excluded_instance_types", value)


if not MYPY:
    class CapacityProviderPermissionsConfigArgsDict(TypedDict):
        capacity_provider_operator_role_arn: pulumi.Input[_builtins.str]
elif False:
    CapacityProviderPermissionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderPermissionsConfigArgs:
    def __init__(__self__, *,
                 capacity_provider_operator_role_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "capacity_provider_operator_role_arn", capacity_provider_operator_role_arn)

    @_builtins.property
    @pulumi.getter(name="capacityProviderOperatorRoleArn")
    def capacity_provider_operator_role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider_operator_role_arn")

    @capacity_provider_operator_role_arn.setter
    def capacity_provider_operator_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider_operator_role_arn", value)


if not MYPY:
    class CapacityProviderTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CapacityProviderTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CapacityProviderVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    CapacityProviderVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityProviderVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class CodeSigningConfigAllowedPublishersArgsDict(TypedDict):
        signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    CodeSigningConfigAllowedPublishersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


if not MYPY:
    class CodeSigningConfigPoliciesArgsDict(TypedDict):
        untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]
elif False:
    CodeSigningConfigPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict']]
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']] = None):
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]:
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict(TypedDict):
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict']]]]
        event_record_format: NotRequired[pulumi.Input[_builtins.str]]
        schema_registry_uri: NotRequired[pulumi.Input[_builtins.str]]
        schema_validation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict']]]]
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs:
    def __init__(__self__, *,
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]] = None,
                 event_record_format: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_validation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]] = None):
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]:
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_record_format")

    @event_record_format.setter
    def event_record_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_record_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema_registry_uri")

    @schema_registry_uri.setter
    def schema_registry_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_registry_uri", value)

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]:
        return pulumi.get(self, "schema_validation_configs")

    @schema_validation_configs.setter
    def schema_validation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]):
        pulumi.set(self, "schema_validation_configs", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        uri: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict(TypedDict):
        attribute: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[_builtins.str]] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class EventSourceMappingDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgsDict']]
elif False:
    EventSourceMappingDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None):
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


if not MYPY:
    class EventSourceMappingDestinationConfigOnFailureArgsDict(TypedDict):
        destination_arn: pulumi.Input[_builtins.str]
elif False:
    EventSourceMappingDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination_arn", destination_arn)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)


if not MYPY:
    class EventSourceMappingDocumentDbEventSourceConfigArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        collection_name: NotRequired[pulumi.Input[_builtins.str]]
        full_document: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingDocumentDbEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 collection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 full_document: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_document", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgsDict']]]]
elif False:
    EventSourceMappingFilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaFilterArgsDict(TypedDict):
        pattern: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingFilterCriteriaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None):
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class EventSourceMappingMetricsConfigArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    EventSourceMappingMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingMetricsConfigArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class EventSourceMappingProvisionedPollerConfigArgsDict(TypedDict):
        maximum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        minimum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        poller_group_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingProvisionedPollerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingProvisionedPollerConfigArgs:
    def __init__(__self__, *,
                 maximum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 poller_group_name: Optional[pulumi.Input[_builtins.str]] = None):
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)
        if poller_group_name is not None:
            pulumi.set(__self__, "poller_group_name", poller_group_name)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_pollers")

    @maximum_pollers.setter
    def maximum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "minimum_pollers")

    @minimum_pollers.setter
    def minimum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="pollerGroupName")
    def poller_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "poller_group_name")

    @poller_group_name.setter
    def poller_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "poller_group_name", value)


if not MYPY:
    class EventSourceMappingScalingConfigArgsDict(TypedDict):
        maximum_concurrency: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    EventSourceMappingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_concurrency", value)


if not MYPY:
    class EventSourceMappingSelfManagedEventSourceArgsDict(TypedDict):
        endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
elif False:
    EventSourceMappingSelfManagedEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        schema_registry_config: NotRequired[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict']]
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_config: Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']] = None):
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]:
        return pulumi.get(self, "schema_registry_config")

    @schema_registry_config.setter
    def schema_registry_config(self, value: Optional[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs']]):
        pulumi.set(self, "schema_registry_config", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict(TypedDict):
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict']]]]
        event_record_format: NotRequired[pulumi.Input[_builtins.str]]
        schema_registry_uri: NotRequired[pulumi.Input[_builtins.str]]
        schema_validation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict']]]]
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs:
    def __init__(__self__, *,
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]] = None,
                 event_record_format: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_registry_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_validation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]] = None):
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]:
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_record_format")

    @event_record_format.setter
    def event_record_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_record_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema_registry_uri")

    @schema_registry_uri.setter
    def schema_registry_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_registry_uri", value)

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]:
        return pulumi.get(self, "schema_validation_configs")

    @schema_validation_configs.setter
    def schema_validation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs']]]]):
        pulumi.set(self, "schema_validation_configs", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        uri: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict(TypedDict):
        attribute: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[_builtins.str]] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute", value)


if not MYPY:
    class EventSourceMappingSourceAccessConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        uri: pulumi.Input[_builtins.str]
elif False:
    EventSourceMappingSourceAccessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class FunctionCapacityProviderConfigArgsDict(TypedDict):
        lambda_managed_instances_capacity_provider_config: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict']
elif False:
    FunctionCapacityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCapacityProviderConfigArgs:
    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_config: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']):
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_config", lambda_managed_instances_capacity_provider_config)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfig")
    def lambda_managed_instances_capacity_provider_config(self) -> pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']:
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_config")

    @lambda_managed_instances_capacity_provider_config.setter
    def lambda_managed_instances_capacity_provider_config(self, value: pulumi.Input['FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs']):
        pulumi.set(self, "lambda_managed_instances_capacity_provider_config", value)


if not MYPY:
    class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict(TypedDict):
        capacity_provider_arn: pulumi.Input[_builtins.str]
        execution_environment_memory_gib_per_vcpu: NotRequired[pulumi.Input[_builtins.float]]
        per_execution_environment_max_concurrency: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs:
    def __init__(__self__, *,
                 capacity_provider_arn: pulumi.Input[_builtins.str],
                 execution_environment_memory_gib_per_vcpu: Optional[pulumi.Input[_builtins.float]] = None,
                 per_execution_environment_max_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        if execution_environment_memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        if per_execution_environment_max_concurrency is not None:
            pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider_arn")

    @capacity_provider_arn.setter
    def capacity_provider_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider_arn", value)

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @execution_environment_memory_gib_per_vcpu.setter
    def execution_environment_memory_gib_per_vcpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "execution_environment_memory_gib_per_vcpu", value)

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "per_execution_environment_max_concurrency")

    @per_execution_environment_max_concurrency.setter
    def per_execution_environment_max_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_execution_environment_max_concurrency", value)


if not MYPY:
    class FunctionDeadLetterConfigArgsDict(TypedDict):
        target_arn: pulumi.Input[_builtins.str]
elif False:
    FunctionDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class FunctionDurableConfigArgsDict(TypedDict):
        execution_timeout: pulumi.Input[_builtins.int]
        retention_period: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FunctionDurableConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDurableConfigArgs:
    def __init__(__self__, *,
                 execution_timeout: pulumi.Input[_builtins.int],
                 retention_period: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "execution_timeout")

    @execution_timeout.setter
    def execution_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "execution_timeout", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_period", value)


if not MYPY:
    class FunctionEnvironmentArgsDict(TypedDict):
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    FunctionEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FunctionEphemeralStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FunctionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict']]
        on_success: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict']]
elif False:
    FunctionEventInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]:
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
elif False:
    FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
elif False:
    FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionFileSystemConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        local_mount_path: pulumi.Input[_builtins.str]
elif False:
    FunctionFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 local_mount_path: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        entry_points: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entry_points", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class FunctionLoggingConfigArgsDict(TypedDict):
        log_format: pulumi.Input[_builtins.str]
        application_log_level: NotRequired[pulumi.Input[_builtins.str]]
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        system_log_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLoggingConfigArgs:
    def __init__(__self__, *,
                 log_format: pulumi.Input[_builtins.str],
                 application_log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None,
                 system_log_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "application_log_level")

    @application_log_level.setter
    def application_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_log_level", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "system_log_level")

    @system_log_level.setter
    def system_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "system_log_level", value)


if not MYPY:
    class FunctionSnapStartArgsDict(TypedDict):
        apply_on: pulumi.Input[_builtins.str]
        optimization_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionSnapStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input[_builtins.str],
                 optimization_status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "apply_on", value)

    @_builtins.property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "optimization_status")

    @optimization_status.setter
    def optimization_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "optimization_status", value)


if not MYPY:
    class FunctionTenancyConfigArgsDict(TypedDict):
        tenant_isolation_mode: pulumi.Input[_builtins.str]
elif False:
    FunctionTenancyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTenancyConfigArgs:
    def __init__(__self__, *,
                 tenant_isolation_mode: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "tenant_isolation_mode")

    @tenant_isolation_mode.setter
    def tenant_isolation_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_isolation_mode", value)


if not MYPY:
    class FunctionTracingConfigArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
elif False:
    FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FunctionUrlCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        max_age: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FunctionUrlCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionUrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class FunctionVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[_builtins.bool]]
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[_builtins.bool]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


