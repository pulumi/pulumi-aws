# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AliasRoutingConfigArgs',
    'AliasRoutingConfigArgsDict',
    'CodeSigningConfigAllowedPublishersArgs',
    'CodeSigningConfigAllowedPublishersArgsDict',
    'CodeSigningConfigPoliciesArgs',
    'CodeSigningConfigPoliciesArgsDict',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingDestinationConfigArgs',
    'EventSourceMappingDestinationConfigArgsDict',
    'EventSourceMappingDestinationConfigOnFailureArgs',
    'EventSourceMappingDestinationConfigOnFailureArgsDict',
    'EventSourceMappingDocumentDbEventSourceConfigArgs',
    'EventSourceMappingDocumentDbEventSourceConfigArgsDict',
    'EventSourceMappingFilterCriteriaArgs',
    'EventSourceMappingFilterCriteriaArgsDict',
    'EventSourceMappingFilterCriteriaFilterArgs',
    'EventSourceMappingFilterCriteriaFilterArgsDict',
    'EventSourceMappingMetricsConfigArgs',
    'EventSourceMappingMetricsConfigArgsDict',
    'EventSourceMappingProvisionedPollerConfigArgs',
    'EventSourceMappingProvisionedPollerConfigArgsDict',
    'EventSourceMappingScalingConfigArgs',
    'EventSourceMappingScalingConfigArgsDict',
    'EventSourceMappingSelfManagedEventSourceArgs',
    'EventSourceMappingSelfManagedEventSourceArgsDict',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgs',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict',
    'EventSourceMappingSourceAccessConfigurationArgs',
    'EventSourceMappingSourceAccessConfigurationArgsDict',
    'FunctionDeadLetterConfigArgs',
    'FunctionDeadLetterConfigArgsDict',
    'FunctionEnvironmentArgs',
    'FunctionEnvironmentArgsDict',
    'FunctionEphemeralStorageArgs',
    'FunctionEphemeralStorageArgsDict',
    'FunctionEventInvokeConfigDestinationConfigArgs',
    'FunctionEventInvokeConfigDestinationConfigArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgs',
    'FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs',
    'FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict',
    'FunctionFileSystemConfigArgs',
    'FunctionFileSystemConfigArgsDict',
    'FunctionImageConfigArgs',
    'FunctionImageConfigArgsDict',
    'FunctionLoggingConfigArgs',
    'FunctionLoggingConfigArgsDict',
    'FunctionSnapStartArgs',
    'FunctionSnapStartArgsDict',
    'FunctionTracingConfigArgs',
    'FunctionTracingConfigArgsDict',
    'FunctionUrlCorsArgs',
    'FunctionUrlCorsArgsDict',
    'FunctionVpcConfigArgs',
    'FunctionVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AliasRoutingConfigArgsDict(TypedDict):
        additional_version_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]
        """
        Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
elif False:
    AliasRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AliasRoutingConfigArgs:
    def __init__(__self__, *,
                 additional_version_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]] additional_version_weights: Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]:
        """
        Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "additional_version_weights", value)


if not MYPY:
    class CodeSigningConfigAllowedPublishersArgsDict(TypedDict):
        signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
elif False:
    CodeSigningConfigAllowedPublishersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigAllowedPublishersArgs:
    def __init__(__self__, *,
                 signing_profile_version_arns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] signing_profile_version_arns: Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        return pulumi.get(self, "signing_profile_version_arns")

    @signing_profile_version_arns.setter
    def signing_profile_version_arns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "signing_profile_version_arns", value)


if not MYPY:
    class CodeSigningConfigPoliciesArgsDict(TypedDict):
        untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
elif False:
    CodeSigningConfigPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSigningConfigPoliciesArgs:
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> pulumi.Input[_builtins.str]:
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")

    @untrusted_artifact_on_deployment.setter
    def untrusted_artifact_on_deployment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "untrusted_artifact_on_deployment", value)


if not MYPY:
    class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
elif False:
    EventSourceMappingAmazonManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)


if not MYPY:
    class EventSourceMappingDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgsDict']]
        """
        Destination configuration for failed invocations. See below.
        """
elif False:
    EventSourceMappingDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']] = None):
        """
        :param pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs'] on_failure: Destination configuration for failed invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]:
        """
        Destination configuration for failed invocations. See below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['EventSourceMappingDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)


if not MYPY:
    class EventSourceMappingDestinationConfigOnFailureArgsDict(TypedDict):
        destination_arn: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource.
        """
elif False:
    EventSourceMappingDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination_arn: ARN of the destination resource.
        """
        pulumi.set(__self__, "destination_arn", destination_arn)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource.
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)


if not MYPY:
    class EventSourceMappingDocumentDbEventSourceConfigArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        Name of the database to consume within the DocumentDB cluster.
        """
        collection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        full_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
elif False:
    EventSourceMappingDocumentDbEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingDocumentDbEventSourceConfigArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 collection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 full_document: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_name: Name of the database to consume within the DocumentDB cluster.
        :param pulumi.Input[_builtins.str] collection_name: Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param pulumi.Input[_builtins.str] full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        return pulumi.get(self, "full_document")

    @full_document.setter
    def full_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_document", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgsDict']]]]
        """
        Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
elif False:
    EventSourceMappingFilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]] filters: Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]:
        """
        Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventSourceMappingFilterCriteriaFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class EventSourceMappingFilterCriteriaFilterArgsDict(TypedDict):
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
elif False:
    EventSourceMappingFilterCriteriaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingFilterCriteriaFilterArgs:
    def __init__(__self__, *,
                 pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pattern: Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class EventSourceMappingMetricsConfigArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
elif False:
    EventSourceMappingMetricsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingMetricsConfigArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class EventSourceMappingProvisionedPollerConfigArgsDict(TypedDict):
        maximum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        minimum_pollers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
elif False:
    EventSourceMappingProvisionedPollerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingProvisionedPollerConfigArgs:
    def __init__(__self__, *,
                 maximum_pollers: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum_pollers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] maximum_pollers: Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        :param pulumi.Input[_builtins.int] minimum_pollers: Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        return pulumi.get(self, "maximum_pollers")

    @maximum_pollers.setter
    def maximum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_pollers", value)

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        return pulumi.get(self, "minimum_pollers")

    @minimum_pollers.setter
    def minimum_pollers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_pollers", value)


if not MYPY:
    class EventSourceMappingScalingConfigArgsDict(TypedDict):
        maximum_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
elif False:
    EventSourceMappingScalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingScalingConfigArgs:
    def __init__(__self__, *,
                 maximum_concurrency: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] maximum_concurrency: Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        return pulumi.get(self, "maximum_concurrency")

    @maximum_concurrency.setter
    def maximum_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_concurrency", value)


if not MYPY:
    class EventSourceMappingSelfManagedEventSourceArgsDict(TypedDict):
        endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
elif False:
    EventSourceMappingSelfManagedEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedEventSourceArgs:
    def __init__(__self__, *,
                 endpoints: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] endpoints: Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict(TypedDict):
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
elif False:
    EventSourceMappingSelfManagedKafkaEventSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigArgs:
    def __init__(__self__, *,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)


if not MYPY:
    class EventSourceMappingSourceAccessConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        uri: pulumi.Input[_builtins.str]
        """
        URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
elif False:
    EventSourceMappingSourceAccessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSourceMappingSourceAccessConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        :param pulumi.Input[_builtins.str] uri: URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class FunctionDeadLetterConfigArgsDict(TypedDict):
        target_arn: pulumi.Input[_builtins.str]
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
elif False:
    FunctionDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionDeadLetterConfigArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class FunctionEnvironmentArgsDict(TypedDict):
        variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of environment variables available to your Lambda function during execution.
        """
elif False:
    FunctionEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEnvironmentArgs:
    def __init__(__self__, *,
                 variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] variables: Map of environment variables available to your Lambda function during execution.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of environment variables available to your Lambda function during execution.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class FunctionEphemeralStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
elif False:
    FunctionEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEphemeralStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict']]
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below.
        """
        on_success: NotRequired[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict']]
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']] = None):
        """
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs'] on_failure: Configuration block with destination configuration for failed asynchronous invocations. See below.
        :param pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs'] on_success: Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['FunctionEventInvokeConfigDestinationConfigOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
elif False:
    FunctionEventInvokeConfigDestinationConfigOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventInvokeConfigDestinationConfigOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class FunctionFileSystemConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Amazon EFS Access Point.
        """
        local_mount_path: pulumi.Input[_builtins.str]
        """
        Path where the function can access the file system. Must start with `/mnt/`.
        """
elif False:
    FunctionFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFileSystemConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 local_mount_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Amazon EFS Access Point.
        :param pulumi.Input[_builtins.str] local_mount_path: Path where the function can access the file system. Must start with `/mnt/`.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Amazon EFS Access Point.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Path where the function can access the file system. Must start with `/mnt/`.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)


if not MYPY:
    class FunctionImageConfigArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Parameters to pass to the container image.
        """
        entry_points: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Entry point to your application.
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Working directory for the container image.
        """
elif False:
    FunctionImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionImageConfigArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 entry_points: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Parameters to pass to the container image.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entry_points: Entry point to your application.
        :param pulumi.Input[_builtins.str] working_directory: Working directory for the container image.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Parameters to pass to the container image.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Entry point to your application.
        """
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "entry_points", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Working directory for the container image.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class FunctionLoggingConfigArgsDict(TypedDict):
        log_format: pulumi.Input[_builtins.str]
        """
        Log format. Valid values: `Text`, `JSON`.
        """
        application_log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        """
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        CloudWatch log group where logs are sent.
        """
        system_log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
elif False:
    FunctionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionLoggingConfigArgs:
    def __init__(__self__, *,
                 log_format: pulumi.Input[_builtins.str],
                 application_log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None,
                 system_log_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_format: Log format. Valid values: `Text`, `JSON`.
        :param pulumi.Input[_builtins.str] application_log_level: Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        :param pulumi.Input[_builtins.str] log_group: CloudWatch log group where logs are sent.
        :param pulumi.Input[_builtins.str] system_log_level: Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[_builtins.str]:
        """
        Log format. Valid values: `Text`, `JSON`.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        """
        return pulumi.get(self, "application_log_level")

    @application_log_level.setter
    def application_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_log_level", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CloudWatch log group where logs are sent.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        return pulumi.get(self, "system_log_level")

    @system_log_level.setter
    def system_log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "system_log_level", value)


if not MYPY:
    class FunctionSnapStartArgsDict(TypedDict):
        apply_on: pulumi.Input[_builtins.str]
        """
        When to apply snap start optimization. Valid value: `PublishedVersions`.
        """
        optimization_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
elif False:
    FunctionSnapStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSnapStartArgs:
    def __init__(__self__, *,
                 apply_on: pulumi.Input[_builtins.str],
                 optimization_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apply_on: When to apply snap start optimization. Valid value: `PublishedVersions`.
        :param pulumi.Input[_builtins.str] optimization_status: Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> pulumi.Input[_builtins.str]:
        """
        When to apply snap start optimization. Valid value: `PublishedVersions`.
        """
        return pulumi.get(self, "apply_on")

    @apply_on.setter
    def apply_on(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "apply_on", value)

    @_builtins.property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        return pulumi.get(self, "optimization_status")

    @optimization_status.setter
    def optimization_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "optimization_status", value)


if not MYPY:
    class FunctionTracingConfigArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
elif False:
    FunctionTracingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionTracingConfigArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FunctionUrlCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow cookies or other credentials in requests to the function URL.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP headers that origins can include in requests to the function URL.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP methods that are allowed when calling the function URL.
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Origins that can access the function URL.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
elif False:
    FunctionUrlCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionUrlCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether to allow cookies or other credentials in requests to the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: HTTP headers that origins can include in requests to the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: HTTP methods that are allowed when calling the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_origins: Origins that can access the function URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: HTTP headers in your function response that you want to expose to origins that call the function URL.
        :param pulumi.Input[_builtins.int] max_age: Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow cookies or other credentials in requests to the function URL.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers that origins can include in requests to the function URL.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP methods that are allowed when calling the function URL.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Origins that can access the function URL.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class FunctionVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of security group IDs associated with the Lambda function.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of subnet IDs associated with the Lambda function.
        """
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the VPC.
        """
elif False:
    FunctionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[_builtins.bool]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: List of security group IDs associated with the Lambda function.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: List of subnet IDs associated with the Lambda function.
        :param pulumi.Input[_builtins.bool] ipv6_allowed_for_dual_stack: Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        :param pulumi.Input[_builtins.str] vpc_id: ID of the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


