# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AliasRoutingConfig',
    'CapacityProviderCapacityProviderScalingConfig',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicy',
    'CapacityProviderInstanceRequirement',
    'CapacityProviderPermissionsConfig',
    'CapacityProviderTimeouts',
    'CapacityProviderVpcConfig',
    'CodeSigningConfigAllowedPublishers',
    'CodeSigningConfigPolicies',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig',
    'EventSourceMappingDestinationConfig',
    'EventSourceMappingDestinationConfigOnFailure',
    'EventSourceMappingDocumentDbEventSourceConfig',
    'EventSourceMappingFilterCriteria',
    'EventSourceMappingFilterCriteriaFilter',
    'EventSourceMappingMetricsConfig',
    'EventSourceMappingProvisionedPollerConfig',
    'EventSourceMappingScalingConfig',
    'EventSourceMappingSelfManagedEventSource',
    'EventSourceMappingSelfManagedKafkaEventSourceConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig',
    'EventSourceMappingSourceAccessConfiguration',
    'FunctionCapacityProviderConfig',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig',
    'FunctionDeadLetterConfig',
    'FunctionDurableConfig',
    'FunctionEnvironment',
    'FunctionEphemeralStorage',
    'FunctionEventInvokeConfigDestinationConfig',
    'FunctionEventInvokeConfigDestinationConfigOnFailure',
    'FunctionEventInvokeConfigDestinationConfigOnSuccess',
    'FunctionFileSystemConfig',
    'FunctionImageConfig',
    'FunctionLoggingConfig',
    'FunctionSnapStart',
    'FunctionTenancyConfig',
    'FunctionTracingConfig',
    'FunctionUrlCors',
    'FunctionVpcConfig',
    'GetCodeSigningConfigAllowedPublisherResult',
    'GetCodeSigningConfigPolicyResult',
    'GetFunctionCapacityProviderConfigResult',
    'GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult',
    'GetFunctionDeadLetterConfigResult',
    'GetFunctionDurableConfigResult',
    'GetFunctionEnvironmentResult',
    'GetFunctionEphemeralStorageResult',
    'GetFunctionFileSystemConfigResult',
    'GetFunctionLoggingConfigResult',
    'GetFunctionTenancyConfigResult',
    'GetFunctionTracingConfigResult',
    'GetFunctionUrlCorResult',
    'GetFunctionVpcConfigResult',
]

@pulumi.output_type
class AliasRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVersionWeights":
            suggest = "additional_version_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_version_weights: Optional[Mapping[str, _builtins.float]] = None):
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[Mapping[str, _builtins.float]]:
        return pulumi.get(self, "additional_version_weights")


@pulumi.output_type
class CapacityProviderCapacityProviderScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVcpuCount":
            suggest = "max_vcpu_count"
        elif key == "scalingMode":
            suggest = "scaling_mode"
        elif key == "scalingPolicies":
            suggest = "scaling_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderCapacityProviderScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderCapacityProviderScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderCapacityProviderScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vcpu_count: _builtins.int,
                 scaling_mode: _builtins.str,
                 scaling_policies: Sequence['outputs.CapacityProviderCapacityProviderScalingConfigScalingPolicy']):
        pulumi.set(__self__, "max_vcpu_count", max_vcpu_count)
        pulumi.set(__self__, "scaling_mode", scaling_mode)
        pulumi.set(__self__, "scaling_policies", scaling_policies)

    @_builtins.property
    @pulumi.getter(name="maxVcpuCount")
    def max_vcpu_count(self) -> _builtins.int:
        return pulumi.get(self, "max_vcpu_count")

    @_builtins.property
    @pulumi.getter(name="scalingMode")
    def scaling_mode(self) -> _builtins.str:
        return pulumi.get(self, "scaling_mode")

    @_builtins.property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> Sequence['outputs.CapacityProviderCapacityProviderScalingConfigScalingPolicy']:
        return pulumi.get(self, "scaling_policies")


@pulumi.output_type
class CapacityProviderCapacityProviderScalingConfigScalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderCapacityProviderScalingConfigScalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderCapacityProviderScalingConfigScalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderCapacityProviderScalingConfigScalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 target_value: _builtins.float):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> _builtins.float:
        return pulumi.get(self, "target_value")


@pulumi.output_type
class CapacityProviderInstanceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderInstanceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderInstanceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderInstanceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_instance_types: Sequence[_builtins.str],
                 architectures: Sequence[_builtins.str],
                 excluded_instance_types: Sequence[_builtins.str]):
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "architectures", architectures)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "architectures")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "excluded_instance_types")


@pulumi.output_type
class CapacityProviderPermissionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviderOperatorRoleArn":
            suggest = "capacity_provider_operator_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderPermissionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderPermissionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderPermissionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider_operator_role_arn: _builtins.str):
        pulumi.set(__self__, "capacity_provider_operator_role_arn", capacity_provider_operator_role_arn)

    @_builtins.property
    @pulumi.getter(name="capacityProviderOperatorRoleArn")
    def capacity_provider_operator_role_arn(self) -> _builtins.str:
        return pulumi.get(self, "capacity_provider_operator_role_arn")


@pulumi.output_type
class CapacityProviderTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CapacityProviderVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str]):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class CodeSigningConfigAllowedPublishers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingProfileVersionArns":
            suggest = "signing_profile_version_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigAllowedPublishers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 signing_profile_version_arns: Sequence[_builtins.str]):
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signing_profile_version_arns")


@pulumi.output_type
class CodeSigningConfigPolicies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untrustedArtifactOnDeployment":
            suggest = "untrusted_artifact_on_deployment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigPolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigPolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigPolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: _builtins.str):
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> _builtins.str:
        return pulumi.get(self, "untrusted_artifact_on_deployment")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingAmazonManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[_builtins.str] = None,
                 schema_registry_config: Optional['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig'] = None):
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "consumer_group_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig']:
        return pulumi.get(self, "schema_registry_config")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "eventRecordFormat":
            suggest = "event_record_format"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"
        elif key == "schemaValidationConfigs":
            suggest = "schema_validation_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']] = None,
                 event_record_format: Optional[_builtins.str] = None,
                 schema_registry_uri: Optional[_builtins.str] = None,
                 schema_validation_configs: Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']] = None):
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_record_format")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_registry_uri")

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']]:
        return pulumi.get(self, "schema_validation_configs")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig(dict):
    def __init__(__self__, *,
                 attribute: Optional[_builtins.str] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attribute")


@pulumi.output_type
class EventSourceMappingDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.EventSourceMappingDestinationConfigOnFailure'] = None):
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.EventSourceMappingDestinationConfigOnFailure']:
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class EventSourceMappingDestinationConfigOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDestinationConfigOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDestinationConfigOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDestinationConfigOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_arn: _builtins.str):
        pulumi.set(__self__, "destination_arn", destination_arn)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> _builtins.str:
        return pulumi.get(self, "destination_arn")


@pulumi.output_type
class EventSourceMappingDocumentDbEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "collectionName":
            suggest = "collection_name"
        elif key == "fullDocument":
            suggest = "full_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDocumentDbEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDocumentDbEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDocumentDbEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 collection_name: Optional[_builtins.str] = None,
                 full_document: Optional[_builtins.str] = None):
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "full_document")


@pulumi.output_type
class EventSourceMappingFilterCriteria(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.EventSourceMappingFilterCriteriaFilter']] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.EventSourceMappingFilterCriteriaFilter']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class EventSourceMappingFilterCriteriaFilter(dict):
    def __init__(__self__, *,
                 pattern: Optional[_builtins.str] = None):
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern")


@pulumi.output_type
class EventSourceMappingMetricsConfig(dict):
    def __init__(__self__, *,
                 metrics: Sequence[_builtins.str]):
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class EventSourceMappingProvisionedPollerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumPollers":
            suggest = "maximum_pollers"
        elif key == "minimumPollers":
            suggest = "minimum_pollers"
        elif key == "pollerGroupName":
            suggest = "poller_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingProvisionedPollerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingProvisionedPollerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingProvisionedPollerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_pollers: Optional[_builtins.int] = None,
                 minimum_pollers: Optional[_builtins.int] = None,
                 poller_group_name: Optional[_builtins.str] = None):
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)
        if poller_group_name is not None:
            pulumi.set(__self__, "poller_group_name", poller_group_name)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_pollers")

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minimum_pollers")

    @_builtins.property
    @pulumi.getter(name="pollerGroupName")
    def poller_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "poller_group_name")


@pulumi.output_type
class EventSourceMappingScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumConcurrency":
            suggest = "maximum_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_concurrency: Optional[_builtins.int] = None):
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_concurrency")


@pulumi.output_type
class EventSourceMappingSelfManagedEventSource(dict):
    def __init__(__self__, *,
                 endpoints: Mapping[str, _builtins.str]):
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSelfManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[_builtins.str] = None,
                 schema_registry_config: Optional['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig'] = None):
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "consumer_group_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig']:
        return pulumi.get(self, "schema_registry_config")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "eventRecordFormat":
            suggest = "event_record_format"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"
        elif key == "schemaValidationConfigs":
            suggest = "schema_validation_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']] = None,
                 event_record_format: Optional[_builtins.str] = None,
                 schema_registry_uri: Optional[_builtins.str] = None,
                 schema_validation_configs: Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']] = None):
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_record_format")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_registry_uri")

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']]:
        return pulumi.get(self, "schema_validation_configs")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig(dict):
    def __init__(__self__, *,
                 attribute: Optional[_builtins.str] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "attribute")


@pulumi.output_type
class EventSourceMappingSourceAccessConfiguration(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 uri: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class FunctionCapacityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaManagedInstancesCapacityProviderConfig":
            suggest = "lambda_managed_instances_capacity_provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCapacityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCapacityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCapacityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_config: 'outputs.FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig'):
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_config", lambda_managed_instances_capacity_provider_config)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfig")
    def lambda_managed_instances_capacity_provider_config(self) -> 'outputs.FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig':
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_config")


@pulumi.output_type
class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviderArn":
            suggest = "capacity_provider_arn"
        elif key == "executionEnvironmentMemoryGibPerVcpu":
            suggest = "execution_environment_memory_gib_per_vcpu"
        elif key == "perExecutionEnvironmentMaxConcurrency":
            suggest = "per_execution_environment_max_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider_arn: _builtins.str,
                 execution_environment_memory_gib_per_vcpu: Optional[_builtins.float] = None,
                 per_execution_environment_max_concurrency: Optional[_builtins.int] = None):
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        if execution_environment_memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        if per_execution_environment_max_concurrency is not None:
            pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> _builtins.str:
        return pulumi.get(self, "capacity_provider_arn")

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "per_execution_environment_max_concurrency")


@pulumi.output_type
class FunctionDeadLetterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionDeadLetterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: _builtins.str):
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class FunctionDurableConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionTimeout":
            suggest = "execution_timeout"
        elif key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionDurableConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionDurableConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionDurableConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_timeout: _builtins.int,
                 retention_period: Optional[_builtins.int] = None):
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> _builtins.int:
        return pulumi.get(self, "execution_timeout")

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class FunctionEnvironment(dict):
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, _builtins.str]] = None):
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "variables")


@pulumi.output_type
class FunctionEphemeralStorage(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onSuccess":
            suggest = "on_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionEventInvokeConfigDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionEventInvokeConfigDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionEventInvokeConfigDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnFailure'] = None,
                 on_success: Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnSuccess'] = None):
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnFailure']:
        return pulumi.get(self, "on_failure")

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnSuccess']:
        return pulumi.get(self, "on_success")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfigOnFailure(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfigOnSuccess(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class FunctionFileSystemConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountPath":
            suggest = "local_mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionFileSystemConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 local_mount_path: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class FunctionImageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoints":
            suggest = "entry_points"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionImageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 entry_points: Optional[Sequence[_builtins.str]] = None,
                 working_directory: Optional[_builtins.str] = None):
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "entry_points")

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class FunctionLoggingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logFormat":
            suggest = "log_format"
        elif key == "applicationLogLevel":
            suggest = "application_log_level"
        elif key == "logGroup":
            suggest = "log_group"
        elif key == "systemLogLevel":
            suggest = "system_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_format: _builtins.str,
                 application_log_level: Optional[_builtins.str] = None,
                 log_group: Optional[_builtins.str] = None,
                 system_log_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_log_level")

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group")

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "system_log_level")


@pulumi.output_type
class FunctionSnapStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"
        elif key == "optimizationStatus":
            suggest = "optimization_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionSnapStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: _builtins.str,
                 optimization_status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> _builtins.str:
        return pulumi.get(self, "apply_on")

    @_builtins.property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "optimization_status")


@pulumi.output_type
class FunctionTenancyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantIsolationMode":
            suggest = "tenant_isolation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTenancyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTenancyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTenancyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tenant_isolation_mode: _builtins.str):
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> _builtins.str:
        return pulumi.get(self, "tenant_isolation_mode")


@pulumi.output_type
class FunctionTracingConfig(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


@pulumi.output_type
class FunctionUrlCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionUrlCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionUrlCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionUrlCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class FunctionVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "ipv6AllowedForDualStack":
            suggest = "ipv6_allowed_for_dual_stack"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 ipv6_allowed_for_dual_stack: Optional[_builtins.bool] = None,
                 vpc_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetCodeSigningConfigAllowedPublisherResult(dict):
    def __init__(__self__, *,
                 signing_profile_version_arns: Sequence[_builtins.str]):
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "signing_profile_version_arns")


@pulumi.output_type
class GetCodeSigningConfigPolicyResult(dict):
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: _builtins.str):
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> _builtins.str:
        return pulumi.get(self, "untrusted_artifact_on_deployment")


@pulumi.output_type
class GetFunctionCapacityProviderConfigResult(dict):
    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_configs: Sequence['outputs.GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult']):
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_configs", lambda_managed_instances_capacity_provider_configs)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfigs")
    def lambda_managed_instances_capacity_provider_configs(self) -> Sequence['outputs.GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult']:
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_configs")


@pulumi.output_type
class GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult(dict):
    def __init__(__self__, *,
                 capacity_provider_arn: _builtins.str,
                 execution_environment_memory_gib_per_vcpu: _builtins.float,
                 per_execution_environment_max_concurrency: _builtins.int):
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> _builtins.str:
        return pulumi.get(self, "capacity_provider_arn")

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> _builtins.float:
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> _builtins.int:
        return pulumi.get(self, "per_execution_environment_max_concurrency")


@pulumi.output_type
class GetFunctionDeadLetterConfigResult(dict):
    def __init__(__self__, *,
                 target_arn: _builtins.str):
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class GetFunctionDurableConfigResult(dict):
    def __init__(__self__, *,
                 execution_timeout: _builtins.int,
                 retention_period: _builtins.int):
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> _builtins.int:
        return pulumi.get(self, "execution_timeout")

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> _builtins.int:
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class GetFunctionEnvironmentResult(dict):
    def __init__(__self__, *,
                 variables: Mapping[str, _builtins.str]):
        pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetFunctionEphemeralStorageResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetFunctionFileSystemConfigResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 local_mount_path: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class GetFunctionLoggingConfigResult(dict):
    def __init__(__self__, *,
                 application_log_level: _builtins.str,
                 log_format: _builtins.str,
                 log_group: _builtins.str,
                 system_log_level: _builtins.str):
        pulumi.set(__self__, "application_log_level", application_log_level)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_group", log_group)
        pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> _builtins.str:
        return pulumi.get(self, "application_log_level")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> _builtins.str:
        return pulumi.get(self, "log_group")

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> _builtins.str:
        return pulumi.get(self, "system_log_level")


@pulumi.output_type
class GetFunctionTenancyConfigResult(dict):
    def __init__(__self__, *,
                 tenant_isolation_mode: _builtins.str):
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> _builtins.str:
        return pulumi.get(self, "tenant_isolation_mode")


@pulumi.output_type
class GetFunctionTracingConfigResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetFunctionUrlCorResult(dict):
    def __init__(__self__, *,
                 allow_credentials: _builtins.bool,
                 allow_headers: Sequence[_builtins.str],
                 allow_methods: Sequence[_builtins.str],
                 allow_origins: Sequence[_builtins.str],
                 expose_headers: Sequence[_builtins.str],
                 max_age: _builtins.int):
        pulumi.set(__self__, "allow_credentials", allow_credentials)
        pulumi.set(__self__, "allow_headers", allow_headers)
        pulumi.set(__self__, "allow_methods", allow_methods)
        pulumi.set(__self__, "allow_origins", allow_origins)
        pulumi.set(__self__, "expose_headers", expose_headers)
        pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> _builtins.bool:
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> _builtins.int:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetFunctionVpcConfigResult(dict):
    def __init__(__self__, *,
                 ipv6_allowed_for_dual_stack: _builtins.bool,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> _builtins.bool:
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


