# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AliasRoutingConfig',
    'CapacityProviderCapacityProviderScalingConfig',
    'CapacityProviderCapacityProviderScalingConfigScalingPolicy',
    'CapacityProviderInstanceRequirement',
    'CapacityProviderPermissionsConfig',
    'CapacityProviderTimeouts',
    'CapacityProviderVpcConfig',
    'CodeSigningConfigAllowedPublishers',
    'CodeSigningConfigPolicies',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig',
    'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig',
    'EventSourceMappingDestinationConfig',
    'EventSourceMappingDestinationConfigOnFailure',
    'EventSourceMappingDocumentDbEventSourceConfig',
    'EventSourceMappingFilterCriteria',
    'EventSourceMappingFilterCriteriaFilter',
    'EventSourceMappingMetricsConfig',
    'EventSourceMappingProvisionedPollerConfig',
    'EventSourceMappingScalingConfig',
    'EventSourceMappingSelfManagedEventSource',
    'EventSourceMappingSelfManagedKafkaEventSourceConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig',
    'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig',
    'EventSourceMappingSourceAccessConfiguration',
    'FunctionCapacityProviderConfig',
    'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig',
    'FunctionDeadLetterConfig',
    'FunctionDurableConfig',
    'FunctionEnvironment',
    'FunctionEphemeralStorage',
    'FunctionEventInvokeConfigDestinationConfig',
    'FunctionEventInvokeConfigDestinationConfigOnFailure',
    'FunctionEventInvokeConfigDestinationConfigOnSuccess',
    'FunctionFileSystemConfig',
    'FunctionImageConfig',
    'FunctionLoggingConfig',
    'FunctionSnapStart',
    'FunctionTenancyConfig',
    'FunctionTracingConfig',
    'FunctionUrlCors',
    'FunctionVpcConfig',
    'GetCodeSigningConfigAllowedPublisherResult',
    'GetCodeSigningConfigPolicyResult',
    'GetFunctionCapacityProviderConfigResult',
    'GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult',
    'GetFunctionDeadLetterConfigResult',
    'GetFunctionDurableConfigResult',
    'GetFunctionEnvironmentResult',
    'GetFunctionEphemeralStorageResult',
    'GetFunctionFileSystemConfigResult',
    'GetFunctionLoggingConfigResult',
    'GetFunctionTenancyConfigResult',
    'GetFunctionTracingConfigResult',
    'GetFunctionUrlCorResult',
    'GetFunctionVpcConfigResult',
]

@pulumi.output_type
class AliasRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVersionWeights":
            suggest = "additional_version_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_version_weights: Optional[Mapping[str, _builtins.float]] = None):
        """
        :param Mapping[str, _builtins.float] additional_version_weights: Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[Mapping[str, _builtins.float]]:
        """
        Map that defines the proportion of events that should be sent to different versions of a Lambda function.
        """
        return pulumi.get(self, "additional_version_weights")


@pulumi.output_type
class CapacityProviderCapacityProviderScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVcpuCount":
            suggest = "max_vcpu_count"
        elif key == "scalingMode":
            suggest = "scaling_mode"
        elif key == "scalingPolicies":
            suggest = "scaling_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderCapacityProviderScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderCapacityProviderScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderCapacityProviderScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vcpu_count: _builtins.int,
                 scaling_mode: _builtins.str,
                 scaling_policies: Sequence['outputs.CapacityProviderCapacityProviderScalingConfigScalingPolicy']):
        """
        :param _builtins.str scaling_mode: The scaling mode for the Capacity Provider. Valid values are `AUTO` and `MANUAL`. Defaults to `AUTO`.
        :param Sequence['CapacityProviderCapacityProviderScalingConfigScalingPolicyArgs'] scaling_policies: List of scaling policies. See Scaling Policies below.
        """
        pulumi.set(__self__, "max_vcpu_count", max_vcpu_count)
        pulumi.set(__self__, "scaling_mode", scaling_mode)
        pulumi.set(__self__, "scaling_policies", scaling_policies)

    @_builtins.property
    @pulumi.getter(name="maxVcpuCount")
    def max_vcpu_count(self) -> _builtins.int:
        return pulumi.get(self, "max_vcpu_count")

    @_builtins.property
    @pulumi.getter(name="scalingMode")
    def scaling_mode(self) -> _builtins.str:
        """
        The scaling mode for the Capacity Provider. Valid values are `AUTO` and `MANUAL`. Defaults to `AUTO`.
        """
        return pulumi.get(self, "scaling_mode")

    @_builtins.property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> Sequence['outputs.CapacityProviderCapacityProviderScalingConfigScalingPolicy']:
        """
        List of scaling policies. See Scaling Policies below.
        """
        return pulumi.get(self, "scaling_policies")


@pulumi.output_type
class CapacityProviderCapacityProviderScalingConfigScalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderCapacityProviderScalingConfigScalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderCapacityProviderScalingConfigScalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderCapacityProviderScalingConfigScalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 target_value: _builtins.float):
        """
        :param _builtins.str predefined_metric_type: The predefined metric type for the scaling policy. Valid values are `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION`.
        :param _builtins.float target_value: The target value for the scaling policy.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        """
        The predefined metric type for the scaling policy. Valid values are `LAMBDA_PROVISIONED_CONCURRENCY_UTILIZATION`.
        """
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> _builtins.float:
        """
        The target value for the scaling policy.
        """
        return pulumi.get(self, "target_value")


@pulumi.output_type
class CapacityProviderInstanceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderInstanceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderInstanceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderInstanceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_instance_types: Sequence[_builtins.str],
                 architectures: Sequence[_builtins.str],
                 excluded_instance_types: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allowed_instance_types: List of allowed instance types.
        :param Sequence[_builtins.str] architectures: List of CPU architectures. Valid values are `X86_64` and `ARM64`.
        :param Sequence[_builtins.str] excluded_instance_types: List of excluded instance types.
        """
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "architectures", architectures)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[_builtins.str]:
        """
        List of allowed instance types.
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter
    def architectures(self) -> Sequence[_builtins.str]:
        """
        List of CPU architectures. Valid values are `X86_64` and `ARM64`.
        """
        return pulumi.get(self, "architectures")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[_builtins.str]:
        """
        List of excluded instance types.
        """
        return pulumi.get(self, "excluded_instance_types")


@pulumi.output_type
class CapacityProviderPermissionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviderOperatorRoleArn":
            suggest = "capacity_provider_operator_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderPermissionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderPermissionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderPermissionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider_operator_role_arn: _builtins.str):
        """
        :param _builtins.str capacity_provider_operator_role_arn: The ARN of the IAM role that allows Lambda to manage the Capacity Provider.
        """
        pulumi.set(__self__, "capacity_provider_operator_role_arn", capacity_provider_operator_role_arn)

    @_builtins.property
    @pulumi.getter(name="capacityProviderOperatorRoleArn")
    def capacity_provider_operator_role_arn(self) -> _builtins.str:
        """
        The ARN of the IAM role that allows Lambda to manage the Capacity Provider.
        """
        return pulumi.get(self, "capacity_provider_operator_role_arn")


@pulumi.output_type
class CapacityProviderTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CapacityProviderVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] security_group_ids: List of security group IDs for the VPC.
        :param Sequence[_builtins.str] subnet_ids: List of subnet IDs for the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        List of security group IDs for the VPC.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        List of subnet IDs for the VPC.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class CodeSigningConfigAllowedPublishers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingProfileVersionArns":
            suggest = "signing_profile_version_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigAllowedPublishers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigAllowedPublishers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 signing_profile_version_arns: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] signing_profile_version_arns: Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> Sequence[_builtins.str]:
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package. Maximum of 20 signing profiles.
        """
        return pulumi.get(self, "signing_profile_version_arns")


@pulumi.output_type
class CodeSigningConfigPolicies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untrustedArtifactOnDeployment":
            suggest = "untrusted_artifact_on_deployment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeSigningConfigPolicies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeSigningConfigPolicies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeSigningConfigPolicies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: _builtins.str):
        """
        :param _builtins.str untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> _builtins.str:
        """
        Code signing configuration policy for deployment validation failure. If you set the policy to `Enforce`, Lambda blocks the deployment request if code-signing validation checks fail. If you set the policy to `Warn`, Lambda allows the deployment and creates a CloudWatch log. Valid values: `Warn`, `Enforce`. Default value: `Warn`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingAmazonManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[_builtins.str] = None,
                 schema_registry_config: Optional['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig'] = None):
        """
        :param _builtins.str consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        :param 'EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigArgs' schema_registry_config: Block for a Kafka schema registry setting. See below.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[_builtins.str]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [AmazonManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_AmazonManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig']:
        """
        Block for a Kafka schema registry setting. See below.
        """
        return pulumi.get(self, "schema_registry_config")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "eventRecordFormat":
            suggest = "event_record_format"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"
        elif key == "schemaValidationConfigs":
            suggest = "schema_validation_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']] = None,
                 event_record_format: Optional[_builtins.str] = None,
                 schema_registry_uri: Optional[_builtins.str] = None,
                 schema_validation_configs: Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']] = None):
        """
        :param Sequence['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs'] access_configs: Configuration block for authentication Lambda uses to access the schema registry.
        :param _builtins.str event_record_format: Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        :param _builtins.str schema_registry_uri: URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        :param Sequence['EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs'] schema_validation_configs: Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']]:
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[_builtins.str]:
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        return pulumi.get(self, "event_record_format")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[_builtins.str]:
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        return pulumi.get(self, "schema_registry_uri")

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[Sequence['outputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']]:
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        return pulumi.get(self, "schema_validation_configs")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Authentication type Lambda uses to access the schema registry.
        :param _builtins.str uri: URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Authentication type Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EventSourceMappingAmazonManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig(dict):
    def __init__(__self__, *,
                 attribute: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[_builtins.str]:
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class EventSourceMappingDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.EventSourceMappingDestinationConfigOnFailure'] = None):
        """
        :param 'EventSourceMappingDestinationConfigOnFailureArgs' on_failure: Destination configuration for failed invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.EventSourceMappingDestinationConfigOnFailure']:
        """
        Destination configuration for failed invocations. See below.
        """
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class EventSourceMappingDestinationConfigOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDestinationConfigOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDestinationConfigOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDestinationConfigOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_arn: _builtins.str):
        """
        :param _builtins.str destination_arn: ARN of the destination resource, or `kafka://your-topic-name` for Amazon MSK and self-managed Apache Kafka destinations.
        """
        pulumi.set(__self__, "destination_arn", destination_arn)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> _builtins.str:
        """
        ARN of the destination resource, or `kafka://your-topic-name` for Amazon MSK and self-managed Apache Kafka destinations.
        """
        return pulumi.get(self, "destination_arn")


@pulumi.output_type
class EventSourceMappingDocumentDbEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "collectionName":
            suggest = "collection_name"
        elif key == "fullDocument":
            suggest = "full_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingDocumentDbEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingDocumentDbEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingDocumentDbEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 collection_name: Optional[_builtins.str] = None,
                 full_document: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: Name of the database to consume within the DocumentDB cluster.
        :param _builtins.str collection_name: Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        :param _builtins.str full_document: Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if full_document is not None:
            pulumi.set(__self__, "full_document", full_document)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Name of the database to consume within the DocumentDB cluster.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        """
        Name of the collection to consume within the database. If you do not specify a collection, Lambda consumes all collections.
        """
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="fullDocument")
    def full_document(self) -> Optional[_builtins.str]:
        """
        Determines what DocumentDB sends to your event stream during document update operations. If set to `UpdateLookup`, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes. Valid values: `UpdateLookup`, `Default`.
        """
        return pulumi.get(self, "full_document")


@pulumi.output_type
class EventSourceMappingFilterCriteria(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.EventSourceMappingFilterCriteriaFilter']] = None):
        """
        :param Sequence['EventSourceMappingFilterCriteriaFilterArgs'] filters: Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.EventSourceMappingFilterCriteriaFilter']]:
        """
        Set of up to 5 filter. If an event satisfies at least one, Lambda sends the event to the function or adds it to the next batch. See below.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class EventSourceMappingFilterCriteriaFilter(dict):
    def __init__(__self__, *,
                 pattern: Optional[_builtins.str] = None):
        """
        :param _builtins.str pattern: Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        """
        Filter pattern up to 4096 characters. See [Filter Rule Syntax](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-syntax).
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class EventSourceMappingMetricsConfig(dict):
    def __init__(__self__, *,
                 metrics: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] metrics: List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence[_builtins.str]:
        """
        List containing the metrics to be produced by the event source mapping. Valid values: `EventCount`.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class EventSourceMappingProvisionedPollerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumPollers":
            suggest = "maximum_pollers"
        elif key == "minimumPollers":
            suggest = "minimum_pollers"
        elif key == "pollerGroupName":
            suggest = "poller_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingProvisionedPollerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingProvisionedPollerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingProvisionedPollerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_pollers: Optional[_builtins.int] = None,
                 minimum_pollers: Optional[_builtins.int] = None,
                 poller_group_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int maximum_pollers: Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        :param _builtins.int minimum_pollers: Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        :param _builtins.str poller_group_name: The name of the provisioned poller group used to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        """
        if maximum_pollers is not None:
            pulumi.set(__self__, "maximum_pollers", maximum_pollers)
        if minimum_pollers is not None:
            pulumi.set(__self__, "minimum_pollers", minimum_pollers)
        if poller_group_name is not None:
            pulumi.set(__self__, "poller_group_name", poller_group_name)

    @_builtins.property
    @pulumi.getter(name="maximumPollers")
    def maximum_pollers(self) -> Optional[_builtins.int]:
        """
        Maximum number of event pollers this event source can scale up to. The range is between 1 and 2000.
        """
        return pulumi.get(self, "maximum_pollers")

    @_builtins.property
    @pulumi.getter(name="minimumPollers")
    def minimum_pollers(self) -> Optional[_builtins.int]:
        """
        Minimum number of event pollers this event source can scale down to. The range is between 1 and 200.
        """
        return pulumi.get(self, "minimum_pollers")

    @_builtins.property
    @pulumi.getter(name="pollerGroupName")
    def poller_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the provisioned poller group used to group multiple ESMs within the event source's VPC to share Event Poller Unit (EPU) capacity. You can use this option to optimize Provisioned mode costs for your ESMs. You can group up to 100 ESMs per poller group and aggregate maximum pollers across all ESMs in a group cannot exceed 2000.
        """
        return pulumi.get(self, "poller_group_name")


@pulumi.output_type
class EventSourceMappingScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumConcurrency":
            suggest = "maximum_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.int maximum_concurrency: Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        if maximum_concurrency is not None:
            pulumi.set(__self__, "maximum_concurrency", maximum_concurrency)

    @_builtins.property
    @pulumi.getter(name="maximumConcurrency")
    def maximum_concurrency(self) -> Optional[_builtins.int]:
        """
        Limits the number of concurrent instances that the Amazon SQS event source can invoke. Must be greater than or equal to 2. See [Configuring maximum concurrency for Amazon SQS event sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency). You need to raise a [Service Quota Ticket](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) to increase the concurrency beyond 1000.
        """
        return pulumi.get(self, "maximum_concurrency")


@pulumi.output_type
class EventSourceMappingSelfManagedEventSource(dict):
    def __init__(__self__, *,
                 endpoints: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] endpoints: Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Mapping[str, _builtins.str]:
        """
        Map of endpoints for the self managed source. For Kafka self-managed sources, the key should be `KAFKA_BOOTSTRAP_SERVERS` and the value should be a string with a comma separated list of broker endpoints.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "schemaRegistryConfig":
            suggest = "schema_registry_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSelfManagedKafkaEventSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group_id: Optional[_builtins.str] = None,
                 schema_registry_config: Optional['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig'] = None):
        """
        :param _builtins.str consumer_group_id: Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        :param 'EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigArgs' schema_registry_config: Block for a Kafka schema registry setting. See below.
        """
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if schema_registry_config is not None:
            pulumi.set(__self__, "schema_registry_config", schema_registry_config)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[_builtins.str]:
        """
        Kafka consumer group ID between 1 and 200 characters for use when creating this event source mapping. If one is not specified, this value will be automatically generated. See [SelfManagedKafkaEventSourceConfig Syntax](https://docs.aws.amazon.com/lambda/latest/dg/API_SelfManagedKafkaEventSourceConfig.html).
        """
        return pulumi.get(self, "consumer_group_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConfig")
    def schema_registry_config(self) -> Optional['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig']:
        """
        Block for a Kafka schema registry setting. See below.
        """
        return pulumi.get(self, "schema_registry_config")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "eventRecordFormat":
            suggest = "event_record_format"
        elif key == "schemaRegistryUri":
            suggest = "schema_registry_uri"
        elif key == "schemaValidationConfigs":
            suggest = "schema_validation_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_configs: Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']] = None,
                 event_record_format: Optional[_builtins.str] = None,
                 schema_registry_uri: Optional[_builtins.str] = None,
                 schema_validation_configs: Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']] = None):
        """
        :param Sequence['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfigArgs'] access_configs: Configuration block for authentication Lambda uses to access the schema registry.
        :param _builtins.str event_record_format: Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        :param _builtins.str schema_registry_uri: URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        :param Sequence['EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfigArgs'] schema_validation_configs: Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if event_record_format is not None:
            pulumi.set(__self__, "event_record_format", event_record_format)
        if schema_registry_uri is not None:
            pulumi.set(__self__, "schema_registry_uri", schema_registry_uri)
        if schema_validation_configs is not None:
            pulumi.set(__self__, "schema_validation_configs", schema_validation_configs)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig']]:
        """
        Configuration block for authentication Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="eventRecordFormat")
    def event_record_format(self) -> Optional[_builtins.str]:
        """
        Record format that Lambda delivers to the function after schema validation. Valid values: `JSON`, `SOURCE`.
        """
        return pulumi.get(self, "event_record_format")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUri")
    def schema_registry_uri(self) -> Optional[_builtins.str]:
        """
        URI of the schema registry. For AWS Glue schema registries, use the ARN of the registry. For Confluent schema registries, use the registry URL.
        """
        return pulumi.get(self, "schema_registry_uri")

    @_builtins.property
    @pulumi.getter(name="schemaValidationConfigs")
    def schema_validation_configs(self) -> Optional[Sequence['outputs.EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig']]:
        """
        Repeatable block that defines schema validation settings. These specify the message attributes that Lambda should validate and filter using the schema registry.
        """
        return pulumi.get(self, "schema_validation_configs")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigAccessConfig(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Authentication type Lambda uses to access the schema registry.
        :param _builtins.str uri: URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Authentication type Lambda uses to access the schema registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        URI of the secret (Secrets Manager secret ARN) used to authenticate with the schema registry.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class EventSourceMappingSelfManagedKafkaEventSourceConfigSchemaRegistryConfigSchemaValidationConfig(dict):
    def __init__(__self__, *,
                 attribute: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> Optional[_builtins.str]:
        """
        Message attribute to validate. Valid values: `KEY`, `VALUE`.
        """
        return pulumi.get(self, "attribute")


@pulumi.output_type
class EventSourceMappingSourceAccessConfiguration(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 uri: _builtins.str):
        """
        :param _builtins.str type: Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        :param _builtins.str uri: URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of authentication protocol, VPC components, or virtual host for your event source. For valid values, refer to the [AWS documentation](https://docs.aws.amazon.com/lambda/latest/api/API_SourceAccessConfiguration.html).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        URI for this configuration. For type `VPC_SUBNET` the value should be `subnet:subnet_id` where `subnet_id` is the value you would find in an ec2.Subnet resource's id attribute. For type `VPC_SECURITY_GROUP` the value should be `security_group:security_group_id` where `security_group_id` is the value you would find in an ec2.SecurityGroup resource's id attribute.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class FunctionCapacityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaManagedInstancesCapacityProviderConfig":
            suggest = "lambda_managed_instances_capacity_provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCapacityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCapacityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCapacityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_config: 'outputs.FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig'):
        """
        :param 'FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs' lambda_managed_instances_capacity_provider_config: Configuration block for Lambda Managed Instances Capacity Provider. See below.
        """
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_config", lambda_managed_instances_capacity_provider_config)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfig")
    def lambda_managed_instances_capacity_provider_config(self) -> 'outputs.FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig':
        """
        Configuration block for Lambda Managed Instances Capacity Provider. See below.
        """
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_config")


@pulumi.output_type
class FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviderArn":
            suggest = "capacity_provider_arn"
        elif key == "executionEnvironmentMemoryGibPerVcpu":
            suggest = "execution_environment_memory_gib_per_vcpu"
        elif key == "perExecutionEnvironmentMaxConcurrency":
            suggest = "per_execution_environment_max_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider_arn: _builtins.str,
                 execution_environment_memory_gib_per_vcpu: Optional[_builtins.float] = None,
                 per_execution_environment_max_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.str capacity_provider_arn: ARN of the Capacity Provider.
        :param _builtins.float execution_environment_memory_gib_per_vcpu: Memory GiB per vCPU for the execution environment.
        :param _builtins.int per_execution_environment_max_concurrency: Maximum concurrency per execution environment.
        """
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        if execution_environment_memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        if per_execution_environment_max_concurrency is not None:
            pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> _builtins.str:
        """
        ARN of the Capacity Provider.
        """
        return pulumi.get(self, "capacity_provider_arn")

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> Optional[_builtins.float]:
        """
        Memory GiB per vCPU for the execution environment.
        """
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> Optional[_builtins.int]:
        """
        Maximum concurrency per execution environment.
        """
        return pulumi.get(self, "per_execution_environment_max_concurrency")


@pulumi.output_type
class FunctionDeadLetterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionDeadLetterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionDeadLetterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: _builtins.str):
        """
        :param _builtins.str target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class FunctionDurableConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionTimeout":
            suggest = "execution_timeout"
        elif key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionDurableConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionDurableConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionDurableConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_timeout: _builtins.int,
                 retention_period: Optional[_builtins.int] = None):
        """
        :param _builtins.int execution_timeout: Maximum execution time in seconds for the durable function. Valid value between 1 and 31622400 (366 days).
        :param _builtins.int retention_period: Number of days to retain the function's execution state. Valid value between 1 and 90. If not specified, the function's execution state is not retained. Defaults to 14.
        """
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> _builtins.int:
        """
        Maximum execution time in seconds for the durable function. Valid value between 1 and 31622400 (366 days).
        """
        return pulumi.get(self, "execution_timeout")

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[_builtins.int]:
        """
        Number of days to retain the function's execution state. Valid value between 1 and 90. If not specified, the function's execution state is not retained. Defaults to 14.
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class FunctionEnvironment(dict):
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] variables: Map of environment variables available to your Lambda function during execution.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of environment variables available to your Lambda function during execution.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class FunctionEphemeralStorage(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Amount of ephemeral storage (`/tmp`) in MB. Valid between 512 MB and 10,240 MB (10 GB).
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onSuccess":
            suggest = "on_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionEventInvokeConfigDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionEventInvokeConfigDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionEventInvokeConfigDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnFailure'] = None,
                 on_success: Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnSuccess'] = None):
        """
        :param 'FunctionEventInvokeConfigDestinationConfigOnFailureArgs' on_failure: Configuration block with destination configuration for failed asynchronous invocations. See below.
        :param 'FunctionEventInvokeConfigDestinationConfigOnSuccessArgs' on_success: Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnFailure']:
        """
        Configuration block with destination configuration for failed asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_failure")

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional['outputs.FunctionEventInvokeConfigDestinationConfigOnSuccess']:
        """
        Configuration block with destination configuration for successful asynchronous invocations. See below.
        """
        return pulumi.get(self, "on_success")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfigOnFailure(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class FunctionEventInvokeConfigDestinationConfigOnSuccess(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        ARN of the destination resource. See the [Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations) for acceptable resource types and associated IAM permissions.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class FunctionFileSystemConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountPath":
            suggest = "local_mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionFileSystemConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionFileSystemConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 local_mount_path: _builtins.str):
        """
        :param _builtins.str arn: ARN of the Amazon EFS Access Point.
        :param _builtins.str local_mount_path: Path where the function can access the file system. Must start with `/mnt/`.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Amazon EFS Access Point.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> _builtins.str:
        """
        Path where the function can access the file system. Must start with `/mnt/`.
        """
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class FunctionImageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoints":
            suggest = "entry_points"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionImageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionImageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 entry_points: Optional[Sequence[_builtins.str]] = None,
                 working_directory: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] commands: Parameters to pass to the container image.
        :param Sequence[_builtins.str] entry_points: Entry point to your application.
        :param _builtins.str working_directory: Working directory for the container image.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameters to pass to the container image.
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[Sequence[_builtins.str]]:
        """
        Entry point to your application.
        """
        return pulumi.get(self, "entry_points")

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[_builtins.str]:
        """
        Working directory for the container image.
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class FunctionLoggingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logFormat":
            suggest = "log_format"
        elif key == "applicationLogLevel":
            suggest = "application_log_level"
        elif key == "logGroup":
            suggest = "log_group"
        elif key == "systemLogLevel":
            suggest = "system_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_format: _builtins.str,
                 application_log_level: Optional[_builtins.str] = None,
                 log_group: Optional[_builtins.str] = None,
                 system_log_level: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_format: Log format. Valid values: `Text`, `JSON`.
        :param _builtins.str application_log_level: Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        :param _builtins.str log_group: CloudWatch log group where logs are sent.
        :param _builtins.str system_log_level: Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        pulumi.set(__self__, "log_format", log_format)
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        """
        Log format. Valid values: `Text`, `JSON`.
        """
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[_builtins.str]:
        """
        Detail level of application logs. Valid values: `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.
        """
        return pulumi.get(self, "application_log_level")

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[_builtins.str]:
        """
        CloudWatch log group where logs are sent.
        """
        return pulumi.get(self, "log_group")

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[_builtins.str]:
        """
        Detail level of Lambda platform logs. Valid values: `DEBUG`, `INFO`, `WARN`.
        """
        return pulumi.get(self, "system_log_level")


@pulumi.output_type
class FunctionSnapStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"
        elif key == "optimizationStatus":
            suggest = "optimization_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionSnapStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionSnapStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: _builtins.str,
                 optimization_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str apply_on: When to apply snap start optimization. Valid value: `PublishedVersions`.
        :param _builtins.str optimization_status: Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @_builtins.property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> _builtins.str:
        """
        When to apply snap start optimization. Valid value: `PublishedVersions`.
        """
        return pulumi.get(self, "apply_on")

    @_builtins.property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[_builtins.str]:
        """
        Optimization status of the snap start configuration. Valid values are `On` and `Off`.
        """
        return pulumi.get(self, "optimization_status")


@pulumi.output_type
class FunctionTenancyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantIsolationMode":
            suggest = "tenant_isolation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTenancyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTenancyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTenancyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tenant_isolation_mode: _builtins.str):
        """
        :param _builtins.str tenant_isolation_mode: Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> _builtins.str:
        """
        Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        return pulumi.get(self, "tenant_isolation_mode")


@pulumi.output_type
class FunctionTracingConfig(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        X-Ray tracing mode. Valid values: `Active`, `PassThrough`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class FunctionUrlCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionUrlCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionUrlCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionUrlCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool allow_credentials: Whether to allow cookies or other credentials in requests to the function URL.
        :param Sequence[_builtins.str] allow_headers: HTTP headers that origins can include in requests to the function URL.
        :param Sequence[_builtins.str] allow_methods: HTTP methods that are allowed when calling the function URL.
        :param Sequence[_builtins.str] allow_origins: Origins that can access the function URL.
        :param Sequence[_builtins.str] expose_headers: HTTP headers in your function response that you want to expose to origins that call the function URL.
        :param _builtins.int max_age: Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether to allow cookies or other credentials in requests to the function URL.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        HTTP headers that origins can include in requests to the function URL.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        HTTP methods that are allowed when calling the function URL.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[_builtins.str]]:
        """
        Origins that can access the function URL.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        HTTP headers in your function response that you want to expose to origins that call the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request. Maximum value is `86400`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class FunctionVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "ipv6AllowedForDualStack":
            suggest = "ipv6_allowed_for_dual_stack"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 ipv6_allowed_for_dual_stack: Optional[_builtins.bool] = None,
                 vpc_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] security_group_ids: List of security group IDs associated with the Lambda function.
        :param Sequence[_builtins.str] subnet_ids: List of subnet IDs associated with the Lambda function.
        :param _builtins.bool ipv6_allowed_for_dual_stack: Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        :param _builtins.str vpc_id: ID of the VPC.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[_builtins.bool]:
        """
        Whether to allow outbound IPv6 traffic on VPC functions connected to dual-stack subnets. Default: `false`.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        """
        ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetCodeSigningConfigAllowedPublisherResult(dict):
    def __init__(__self__, *,
                 signing_profile_version_arns: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] signing_profile_version_arns: Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        pulumi.set(__self__, "signing_profile_version_arns", signing_profile_version_arns)

    @_builtins.property
    @pulumi.getter(name="signingProfileVersionArns")
    def signing_profile_version_arns(self) -> Sequence[_builtins.str]:
        """
        Set of ARNs for each of the signing profiles. A signing profile defines a trusted user who can sign a code package.
        """
        return pulumi.get(self, "signing_profile_version_arns")


@pulumi.output_type
class GetCodeSigningConfigPolicyResult(dict):
    def __init__(__self__, *,
                 untrusted_artifact_on_deployment: _builtins.str):
        """
        :param _builtins.str untrusted_artifact_on_deployment: Code signing configuration policy for deployment validation failure. Valid values: `Warn`, `Enforce`.
        """
        pulumi.set(__self__, "untrusted_artifact_on_deployment", untrusted_artifact_on_deployment)

    @_builtins.property
    @pulumi.getter(name="untrustedArtifactOnDeployment")
    def untrusted_artifact_on_deployment(self) -> _builtins.str:
        """
        Code signing configuration policy for deployment validation failure. Valid values: `Warn`, `Enforce`.
        """
        return pulumi.get(self, "untrusted_artifact_on_deployment")


@pulumi.output_type
class GetFunctionCapacityProviderConfigResult(dict):
    def __init__(__self__, *,
                 lambda_managed_instances_capacity_provider_configs: Sequence['outputs.GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult']):
        """
        :param Sequence['GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigArgs'] lambda_managed_instances_capacity_provider_configs: Configuration block for Lambda Managed Instances Capacity Provider.
        """
        pulumi.set(__self__, "lambda_managed_instances_capacity_provider_configs", lambda_managed_instances_capacity_provider_configs)

    @_builtins.property
    @pulumi.getter(name="lambdaManagedInstancesCapacityProviderConfigs")
    def lambda_managed_instances_capacity_provider_configs(self) -> Sequence['outputs.GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult']:
        """
        Configuration block for Lambda Managed Instances Capacity Provider.
        """
        return pulumi.get(self, "lambda_managed_instances_capacity_provider_configs")


@pulumi.output_type
class GetFunctionCapacityProviderConfigLambdaManagedInstancesCapacityProviderConfigResult(dict):
    def __init__(__self__, *,
                 capacity_provider_arn: _builtins.str,
                 execution_environment_memory_gib_per_vcpu: _builtins.float,
                 per_execution_environment_max_concurrency: _builtins.int):
        """
        :param _builtins.str capacity_provider_arn: ARN of the Capacity Provider.
        :param _builtins.float execution_environment_memory_gib_per_vcpu: Memory GiB per vCPU for the execution environment.
        :param _builtins.int per_execution_environment_max_concurrency: Maximum concurrency per execution environment.
        """
        pulumi.set(__self__, "capacity_provider_arn", capacity_provider_arn)
        pulumi.set(__self__, "execution_environment_memory_gib_per_vcpu", execution_environment_memory_gib_per_vcpu)
        pulumi.set(__self__, "per_execution_environment_max_concurrency", per_execution_environment_max_concurrency)

    @_builtins.property
    @pulumi.getter(name="capacityProviderArn")
    def capacity_provider_arn(self) -> _builtins.str:
        """
        ARN of the Capacity Provider.
        """
        return pulumi.get(self, "capacity_provider_arn")

    @_builtins.property
    @pulumi.getter(name="executionEnvironmentMemoryGibPerVcpu")
    def execution_environment_memory_gib_per_vcpu(self) -> _builtins.float:
        """
        Memory GiB per vCPU for the execution environment.
        """
        return pulumi.get(self, "execution_environment_memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="perExecutionEnvironmentMaxConcurrency")
    def per_execution_environment_max_concurrency(self) -> _builtins.int:
        """
        Maximum concurrency per execution environment.
        """
        return pulumi.get(self, "per_execution_environment_max_concurrency")


@pulumi.output_type
class GetFunctionDeadLetterConfigResult(dict):
    def __init__(__self__, *,
                 target_arn: _builtins.str):
        """
        :param _builtins.str target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        pulumi.set(__self__, "target_arn", target_arn)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class GetFunctionDurableConfigResult(dict):
    def __init__(__self__, *,
                 execution_timeout: _builtins.int,
                 retention_period: _builtins.int):
        """
        :param _builtins.int execution_timeout: Maximum execution time in seconds for the durable function.
        :param _builtins.int retention_period: Number of days to retain the function's execution state.
        """
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        pulumi.set(__self__, "retention_period", retention_period)

    @_builtins.property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> _builtins.int:
        """
        Maximum execution time in seconds for the durable function.
        """
        return pulumi.get(self, "execution_timeout")

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> _builtins.int:
        """
        Number of days to retain the function's execution state.
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class GetFunctionEnvironmentResult(dict):
    def __init__(__self__, *,
                 variables: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] variables: Map of environment variables that are accessible from the function code during execution.
        """
        pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Mapping[str, _builtins.str]:
        """
        Map of environment variables that are accessible from the function code during execution.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetFunctionEphemeralStorageResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: Size of the Lambda function ephemeral storage (`/tmp`) in MB.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Size of the Lambda function ephemeral storage (`/tmp`) in MB.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetFunctionFileSystemConfigResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 local_mount_path: _builtins.str):
        """
        :param _builtins.str arn: ARN of the Amazon EFS Access Point that provides access to the file system.
        :param _builtins.str local_mount_path: Path where the function can access the file system, starting with `/mnt/`.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "local_mount_path", local_mount_path)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Amazon EFS Access Point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> _builtins.str:
        """
        Path where the function can access the file system, starting with `/mnt/`.
        """
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class GetFunctionLoggingConfigResult(dict):
    def __init__(__self__, *,
                 application_log_level: _builtins.str,
                 log_format: _builtins.str,
                 log_group: _builtins.str,
                 system_log_level: _builtins.str):
        """
        :param _builtins.str application_log_level: Detail level of the logs your application sends to CloudWatch when using supported logging libraries.
        :param _builtins.str log_format: Format for your function's logs. Valid values: `Text`, `JSON`.
        :param _builtins.str log_group: CloudWatch log group your function sends logs to.
        :param _builtins.str system_log_level: Detail level of the Lambda platform event logs sent to CloudWatch.
        """
        pulumi.set(__self__, "application_log_level", application_log_level)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_group", log_group)
        pulumi.set(__self__, "system_log_level", system_log_level)

    @_builtins.property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> _builtins.str:
        """
        Detail level of the logs your application sends to CloudWatch when using supported logging libraries.
        """
        return pulumi.get(self, "application_log_level")

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> _builtins.str:
        """
        Format for your function's logs. Valid values: `Text`, `JSON`.
        """
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> _builtins.str:
        """
        CloudWatch log group your function sends logs to.
        """
        return pulumi.get(self, "log_group")

    @_builtins.property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> _builtins.str:
        """
        Detail level of the Lambda platform event logs sent to CloudWatch.
        """
        return pulumi.get(self, "system_log_level")


@pulumi.output_type
class GetFunctionTenancyConfigResult(dict):
    def __init__(__self__, *,
                 tenant_isolation_mode: _builtins.str):
        """
        :param _builtins.str tenant_isolation_mode: (Required) Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        pulumi.set(__self__, "tenant_isolation_mode", tenant_isolation_mode)

    @_builtins.property
    @pulumi.getter(name="tenantIsolationMode")
    def tenant_isolation_mode(self) -> _builtins.str:
        """
        (Required) Tenant Isolation Mode. Valid values: `PER_TENANT`.
        """
        return pulumi.get(self, "tenant_isolation_mode")


@pulumi.output_type
class GetFunctionTracingConfigResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Tracing mode. Valid values: `Active`, `PassThrough`.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Tracing mode. Valid values: `Active`, `PassThrough`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetFunctionUrlCorResult(dict):
    def __init__(__self__, *,
                 allow_credentials: _builtins.bool,
                 allow_headers: Sequence[_builtins.str],
                 allow_methods: Sequence[_builtins.str],
                 allow_origins: Sequence[_builtins.str],
                 expose_headers: Sequence[_builtins.str],
                 max_age: _builtins.int):
        """
        :param _builtins.bool allow_credentials: Whether credentials are included in the CORS request.
        :param Sequence[_builtins.str] allow_headers: List of headers that are specified in the Access-Control-Request-Headers header.
        :param Sequence[_builtins.str] allow_methods: List of HTTP methods that are allowed when calling the function URL.
        :param Sequence[_builtins.str] allow_origins: List of origins that are allowed to make requests to the function URL.
        :param Sequence[_builtins.str] expose_headers: List of headers in the response that you want to expose to the origin that called the function URL.
        :param _builtins.int max_age: Maximum amount of time, in seconds, that web browsers can cache results of a preflight request.
        """
        pulumi.set(__self__, "allow_credentials", allow_credentials)
        pulumi.set(__self__, "allow_headers", allow_headers)
        pulumi.set(__self__, "allow_methods", allow_methods)
        pulumi.set(__self__, "allow_origins", allow_origins)
        pulumi.set(__self__, "expose_headers", expose_headers)
        pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> _builtins.bool:
        """
        Whether credentials are included in the CORS request.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Sequence[_builtins.str]:
        """
        List of headers that are specified in the Access-Control-Request-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Sequence[_builtins.str]:
        """
        List of HTTP methods that are allowed when calling the function URL.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Sequence[_builtins.str]:
        """
        List of origins that are allowed to make requests to the function URL.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Sequence[_builtins.str]:
        """
        List of headers in the response that you want to expose to the origin that called the function URL.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> _builtins.int:
        """
        Maximum amount of time, in seconds, that web browsers can cache results of a preflight request.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetFunctionVpcConfigResult(dict):
    def __init__(__self__, *,
                 ipv6_allowed_for_dual_stack: _builtins.bool,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str],
                 vpc_id: _builtins.str):
        """
        :param Sequence[_builtins.str] security_group_ids: List of security group IDs associated with the Lambda function.
        :param Sequence[_builtins.str] subnet_ids: List of subnet IDs associated with the Lambda function.
        :param _builtins.str vpc_id: ID of the VPC.
        """
        pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> _builtins.bool:
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        List of security group IDs associated with the Lambda function.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        List of subnet IDs associated with the Lambda function.
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


