# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'DataSourceDynamodbConfigArgs',
    'DataSourceDynamodbConfigDeltaSyncConfigArgs',
    'DataSourceElasticsearchConfigArgs',
    'DataSourceEventBridgeConfigArgs',
    'DataSourceHttpConfigArgs',
    'DataSourceHttpConfigAuthorizationConfigArgs',
    'DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs',
    'DataSourceLambdaConfigArgs',
    'DataSourceOpensearchserviceConfigArgs',
    'DataSourceRelationalDatabaseConfigArgs',
    'DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs',
    'FunctionRuntimeArgs',
    'FunctionSyncConfigArgs',
    'FunctionSyncConfigLambdaConflictHandlerConfigArgs',
    'GraphQLApiAdditionalAuthenticationProviderArgs',
    'GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs',
    'GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs',
    'GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs',
    'GraphQLApiLambdaAuthorizerConfigArgs',
    'GraphQLApiLogConfigArgs',
    'GraphQLApiOpenidConnectConfigArgs',
    'GraphQLApiUserPoolConfigArgs',
    'ResolverCachingConfigArgs',
    'ResolverPipelineConfigArgs',
    'ResolverRuntimeArgs',
    'ResolverSyncConfigArgs',
    'ResolverSyncConfigLambdaConflictHandlerConfigArgs',
]

@pulumi.input_type
class DataSourceDynamodbConfigArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[str],
                 delta_sync_config: Optional[pulumi.Input['DataSourceDynamodbConfigDeltaSyncConfigArgs']] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 use_caller_credentials: Optional[pulumi.Input[bool]] = None,
                 versioned: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] table_name: Name of the DynamoDB table.
        :param pulumi.Input['DataSourceDynamodbConfigDeltaSyncConfigArgs'] delta_sync_config: The DeltaSyncConfig for a versioned data source. See Delta Sync Config
        :param pulumi.Input[str] region: AWS region of the DynamoDB table. Defaults to current region.
        :param pulumi.Input[bool] use_caller_credentials: Set to `true` to use Amazon Cognito credentials with this data source.
        :param pulumi.Input[bool] versioned: Detects Conflict Detection and Resolution with this data source.
        """
        DataSourceDynamodbConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_name=table_name,
            delta_sync_config=delta_sync_config,
            region=region,
            use_caller_credentials=use_caller_credentials,
            versioned=versioned,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_name: Optional[pulumi.Input[str]] = None,
             delta_sync_config: Optional[pulumi.Input['DataSourceDynamodbConfigDeltaSyncConfigArgs']] = None,
             region: Optional[pulumi.Input[str]] = None,
             use_caller_credentials: Optional[pulumi.Input[bool]] = None,
             versioned: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if delta_sync_config is None and 'deltaSyncConfig' in kwargs:
            delta_sync_config = kwargs['deltaSyncConfig']
        if use_caller_credentials is None and 'useCallerCredentials' in kwargs:
            use_caller_credentials = kwargs['useCallerCredentials']

        _setter("table_name", table_name)
        if delta_sync_config is not None:
            _setter("delta_sync_config", delta_sync_config)
        if region is not None:
            _setter("region", region)
        if use_caller_credentials is not None:
            _setter("use_caller_credentials", use_caller_credentials)
        if versioned is not None:
            _setter("versioned", versioned)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        Name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="deltaSyncConfig")
    def delta_sync_config(self) -> Optional[pulumi.Input['DataSourceDynamodbConfigDeltaSyncConfigArgs']]:
        """
        The DeltaSyncConfig for a versioned data source. See Delta Sync Config
        """
        return pulumi.get(self, "delta_sync_config")

    @delta_sync_config.setter
    def delta_sync_config(self, value: Optional[pulumi.Input['DataSourceDynamodbConfigDeltaSyncConfigArgs']]):
        pulumi.set(self, "delta_sync_config", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region of the DynamoDB table. Defaults to current region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="useCallerCredentials")
    def use_caller_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to `true` to use Amazon Cognito credentials with this data source.
        """
        return pulumi.get(self, "use_caller_credentials")

    @use_caller_credentials.setter
    def use_caller_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_caller_credentials", value)

    @property
    @pulumi.getter
    def versioned(self) -> Optional[pulumi.Input[bool]]:
        """
        Detects Conflict Detection and Resolution with this data source.
        """
        return pulumi.get(self, "versioned")

    @versioned.setter
    def versioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "versioned", value)


@pulumi.input_type
class DataSourceDynamodbConfigDeltaSyncConfigArgs:
    def __init__(__self__, *,
                 delta_sync_table_name: pulumi.Input[str],
                 base_table_ttl: Optional[pulumi.Input[int]] = None,
                 delta_sync_table_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] delta_sync_table_name: The table name.
        :param pulumi.Input[int] base_table_ttl: The number of minutes that an Item is stored in the data source.
        :param pulumi.Input[int] delta_sync_table_ttl: The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        """
        DataSourceDynamodbConfigDeltaSyncConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delta_sync_table_name=delta_sync_table_name,
            base_table_ttl=base_table_ttl,
            delta_sync_table_ttl=delta_sync_table_ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delta_sync_table_name: Optional[pulumi.Input[str]] = None,
             base_table_ttl: Optional[pulumi.Input[int]] = None,
             delta_sync_table_ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delta_sync_table_name is None and 'deltaSyncTableName' in kwargs:
            delta_sync_table_name = kwargs['deltaSyncTableName']
        if delta_sync_table_name is None:
            raise TypeError("Missing 'delta_sync_table_name' argument")
        if base_table_ttl is None and 'baseTableTtl' in kwargs:
            base_table_ttl = kwargs['baseTableTtl']
        if delta_sync_table_ttl is None and 'deltaSyncTableTtl' in kwargs:
            delta_sync_table_ttl = kwargs['deltaSyncTableTtl']

        _setter("delta_sync_table_name", delta_sync_table_name)
        if base_table_ttl is not None:
            _setter("base_table_ttl", base_table_ttl)
        if delta_sync_table_ttl is not None:
            _setter("delta_sync_table_ttl", delta_sync_table_ttl)

    @property
    @pulumi.getter(name="deltaSyncTableName")
    def delta_sync_table_name(self) -> pulumi.Input[str]:
        """
        The table name.
        """
        return pulumi.get(self, "delta_sync_table_name")

    @delta_sync_table_name.setter
    def delta_sync_table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "delta_sync_table_name", value)

    @property
    @pulumi.getter(name="baseTableTtl")
    def base_table_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes that an Item is stored in the data source.
        """
        return pulumi.get(self, "base_table_ttl")

    @base_table_ttl.setter
    def base_table_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_table_ttl", value)

    @property
    @pulumi.getter(name="deltaSyncTableTtl")
    def delta_sync_table_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes that a Delta Sync log entry is stored in the Delta Sync table.
        """
        return pulumi.get(self, "delta_sync_table_ttl")

    @delta_sync_table_ttl.setter
    def delta_sync_table_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delta_sync_table_ttl", value)


@pulumi.input_type
class DataSourceElasticsearchConfigArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: HTTP endpoint of the Elasticsearch domain.
        :param pulumi.Input[str] region: AWS region of Elasticsearch domain. Defaults to current region.
        """
        DataSourceElasticsearchConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")

        _setter("endpoint", endpoint)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        HTTP endpoint of the Elasticsearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region of Elasticsearch domain. Defaults to current region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DataSourceEventBridgeConfigArgs:
    def __init__(__self__, *,
                 event_bus_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] event_bus_arn: ARN for the EventBridge bus.
        """
        DataSourceEventBridgeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_bus_arn=event_bus_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_bus_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if event_bus_arn is None and 'eventBusArn' in kwargs:
            event_bus_arn = kwargs['eventBusArn']
        if event_bus_arn is None:
            raise TypeError("Missing 'event_bus_arn' argument")

        _setter("event_bus_arn", event_bus_arn)

    @property
    @pulumi.getter(name="eventBusArn")
    def event_bus_arn(self) -> pulumi.Input[str]:
        """
        ARN for the EventBridge bus.
        """
        return pulumi.get(self, "event_bus_arn")

    @event_bus_arn.setter
    def event_bus_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_bus_arn", value)


@pulumi.input_type
class DataSourceHttpConfigArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 authorization_config: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigArgs']] = None):
        """
        :param pulumi.Input[str] endpoint: HTTP URL.
        :param pulumi.Input['DataSourceHttpConfigAuthorizationConfigArgs'] authorization_config: Authorization configuration in case the HTTP endpoint requires authorization. See Authorization Config.
        """
        DataSourceHttpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            authorization_config=authorization_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[pulumi.Input[str]] = None,
             authorization_config: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if authorization_config is None and 'authorizationConfig' in kwargs:
            authorization_config = kwargs['authorizationConfig']

        _setter("endpoint", endpoint)
        if authorization_config is not None:
            _setter("authorization_config", authorization_config)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        HTTP URL.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigArgs']]:
        """
        Authorization configuration in case the HTTP endpoint requires authorization. See Authorization Config.
        """
        return pulumi.get(self, "authorization_config")

    @authorization_config.setter
    def authorization_config(self, value: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigArgs']]):
        pulumi.set(self, "authorization_config", value)


@pulumi.input_type
class DataSourceHttpConfigAuthorizationConfigArgs:
    def __init__(__self__, *,
                 authorization_type: Optional[pulumi.Input[str]] = None,
                 aws_iam_config: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs']] = None):
        """
        :param pulumi.Input[str] authorization_type: Authorization type that the HTTP endpoint requires. Default values is `AWS_IAM`.
        :param pulumi.Input['DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs'] aws_iam_config: Identity and Access Management (IAM) settings. See AWS IAM Config.
        """
        DataSourceHttpConfigAuthorizationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_type=authorization_type,
            aws_iam_config=aws_iam_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_type: Optional[pulumi.Input[str]] = None,
             aws_iam_config: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorization_type is None and 'authorizationType' in kwargs:
            authorization_type = kwargs['authorizationType']
        if aws_iam_config is None and 'awsIamConfig' in kwargs:
            aws_iam_config = kwargs['awsIamConfig']

        if authorization_type is not None:
            _setter("authorization_type", authorization_type)
        if aws_iam_config is not None:
            _setter("aws_iam_config", aws_iam_config)

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization type that the HTTP endpoint requires. Default values is `AWS_IAM`.
        """
        return pulumi.get(self, "authorization_type")

    @authorization_type.setter
    def authorization_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_type", value)

    @property
    @pulumi.getter(name="awsIamConfig")
    def aws_iam_config(self) -> Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs']]:
        """
        Identity and Access Management (IAM) settings. See AWS IAM Config.
        """
        return pulumi.get(self, "aws_iam_config")

    @aws_iam_config.setter
    def aws_iam_config(self, value: Optional[pulumi.Input['DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs']]):
        pulumi.set(self, "aws_iam_config", value)


@pulumi.input_type
class DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs:
    def __init__(__self__, *,
                 signing_region: Optional[pulumi.Input[str]] = None,
                 signing_service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] signing_region: Signing Amazon Web Services Region for IAM authorization.
        :param pulumi.Input[str] signing_service_name: Signing service name for IAM authorization.
        """
        DataSourceHttpConfigAuthorizationConfigAwsIamConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            signing_region=signing_region,
            signing_service_name=signing_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             signing_region: Optional[pulumi.Input[str]] = None,
             signing_service_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if signing_region is None and 'signingRegion' in kwargs:
            signing_region = kwargs['signingRegion']
        if signing_service_name is None and 'signingServiceName' in kwargs:
            signing_service_name = kwargs['signingServiceName']

        if signing_region is not None:
            _setter("signing_region", signing_region)
        if signing_service_name is not None:
            _setter("signing_service_name", signing_service_name)

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[pulumi.Input[str]]:
        """
        Signing Amazon Web Services Region for IAM authorization.
        """
        return pulumi.get(self, "signing_region")

    @signing_region.setter
    def signing_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_region", value)

    @property
    @pulumi.getter(name="signingServiceName")
    def signing_service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Signing service name for IAM authorization.
        """
        return pulumi.get(self, "signing_service_name")

    @signing_service_name.setter
    def signing_service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_service_name", value)


@pulumi.input_type
class DataSourceLambdaConfigArgs:
    def __init__(__self__, *,
                 function_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] function_arn: ARN for the Lambda function.
        """
        DataSourceLambdaConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function_arn=function_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if function_arn is None and 'functionArn' in kwargs:
            function_arn = kwargs['functionArn']
        if function_arn is None:
            raise TypeError("Missing 'function_arn' argument")

        _setter("function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[str]:
        """
        ARN for the Lambda function.
        """
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_arn", value)


@pulumi.input_type
class DataSourceOpensearchserviceConfigArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint: HTTP endpoint of the Elasticsearch domain.
        :param pulumi.Input[str] region: AWS region of the DynamoDB table. Defaults to current region.
        """
        DataSourceOpensearchserviceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")

        _setter("endpoint", endpoint)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        HTTP endpoint of the Elasticsearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region of the DynamoDB table. Defaults to current region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DataSourceRelationalDatabaseConfigArgs:
    def __init__(__self__, *,
                 http_endpoint_config: Optional[pulumi.Input['DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs']] = None,
                 source_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs'] http_endpoint_config: Amazon RDS HTTP endpoint configuration. See HTTP Endpoint Config.
        :param pulumi.Input[str] source_type: Source type for the relational database. Valid values: `RDS_HTTP_ENDPOINT`.
        """
        DataSourceRelationalDatabaseConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint_config=http_endpoint_config,
            source_type=source_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint_config: Optional[pulumi.Input['DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs']] = None,
             source_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_endpoint_config is None and 'httpEndpointConfig' in kwargs:
            http_endpoint_config = kwargs['httpEndpointConfig']
        if source_type is None and 'sourceType' in kwargs:
            source_type = kwargs['sourceType']

        if http_endpoint_config is not None:
            _setter("http_endpoint_config", http_endpoint_config)
        if source_type is not None:
            _setter("source_type", source_type)

    @property
    @pulumi.getter(name="httpEndpointConfig")
    def http_endpoint_config(self) -> Optional[pulumi.Input['DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs']]:
        """
        Amazon RDS HTTP endpoint configuration. See HTTP Endpoint Config.
        """
        return pulumi.get(self, "http_endpoint_config")

    @http_endpoint_config.setter
    def http_endpoint_config(self, value: Optional[pulumi.Input['DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs']]):
        pulumi.set(self, "http_endpoint_config", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        Source type for the relational database. Valid values: `RDS_HTTP_ENDPOINT`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs:
    def __init__(__self__, *,
                 aws_secret_store_arn: pulumi.Input[str],
                 db_cluster_identifier: pulumi.Input[str],
                 database_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_secret_store_arn: AWS secret store ARN for database credentials.
        :param pulumi.Input[str] db_cluster_identifier: Amazon RDS cluster identifier.
        :param pulumi.Input[str] database_name: Logical database name.
        :param pulumi.Input[str] region: AWS Region for RDS HTTP endpoint. Defaults to current region.
        :param pulumi.Input[str] schema: Logical schema name.
        """
        DataSourceRelationalDatabaseConfigHttpEndpointConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_secret_store_arn=aws_secret_store_arn,
            db_cluster_identifier=db_cluster_identifier,
            database_name=database_name,
            region=region,
            schema=schema,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_secret_store_arn: Optional[pulumi.Input[str]] = None,
             db_cluster_identifier: Optional[pulumi.Input[str]] = None,
             database_name: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             schema: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_secret_store_arn is None and 'awsSecretStoreArn' in kwargs:
            aws_secret_store_arn = kwargs['awsSecretStoreArn']
        if aws_secret_store_arn is None:
            raise TypeError("Missing 'aws_secret_store_arn' argument")
        if db_cluster_identifier is None and 'dbClusterIdentifier' in kwargs:
            db_cluster_identifier = kwargs['dbClusterIdentifier']
        if db_cluster_identifier is None:
            raise TypeError("Missing 'db_cluster_identifier' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']

        _setter("aws_secret_store_arn", aws_secret_store_arn)
        _setter("db_cluster_identifier", db_cluster_identifier)
        if database_name is not None:
            _setter("database_name", database_name)
        if region is not None:
            _setter("region", region)
        if schema is not None:
            _setter("schema", schema)

    @property
    @pulumi.getter(name="awsSecretStoreArn")
    def aws_secret_store_arn(self) -> pulumi.Input[str]:
        """
        AWS secret store ARN for database credentials.
        """
        return pulumi.get(self, "aws_secret_store_arn")

    @aws_secret_store_arn.setter
    def aws_secret_store_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_secret_store_arn", value)

    @property
    @pulumi.getter(name="dbClusterIdentifier")
    def db_cluster_identifier(self) -> pulumi.Input[str]:
        """
        Amazon RDS cluster identifier.
        """
        return pulumi.get(self, "db_cluster_identifier")

    @db_cluster_identifier.setter
    def db_cluster_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_cluster_identifier", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Logical database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Region for RDS HTTP endpoint. Defaults to current region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        Logical schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class FunctionRuntimeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 runtime_version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
        :param pulumi.Input[str] runtime_version: The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
        """
        FunctionRuntimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']
        if runtime_version is None:
            raise TypeError("Missing 'runtime_version' argument")

        _setter("name", name)
        _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Input[str]:
        """
        The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_version", value)


@pulumi.input_type
class FunctionSyncConfigArgs:
    def __init__(__self__, *,
                 conflict_detection: Optional[pulumi.Input[str]] = None,
                 conflict_handler: Optional[pulumi.Input[str]] = None,
                 lambda_conflict_handler_config: Optional[pulumi.Input['FunctionSyncConfigLambdaConflictHandlerConfigArgs']] = None):
        """
        :param pulumi.Input[str] conflict_detection: Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
        :param pulumi.Input[str] conflict_handler: Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
        :param pulumi.Input['FunctionSyncConfigLambdaConflictHandlerConfigArgs'] lambda_conflict_handler_config: Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
        """
        FunctionSyncConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conflict_detection=conflict_detection,
            conflict_handler=conflict_handler,
            lambda_conflict_handler_config=lambda_conflict_handler_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conflict_detection: Optional[pulumi.Input[str]] = None,
             conflict_handler: Optional[pulumi.Input[str]] = None,
             lambda_conflict_handler_config: Optional[pulumi.Input['FunctionSyncConfigLambdaConflictHandlerConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if conflict_detection is None and 'conflictDetection' in kwargs:
            conflict_detection = kwargs['conflictDetection']
        if conflict_handler is None and 'conflictHandler' in kwargs:
            conflict_handler = kwargs['conflictHandler']
        if lambda_conflict_handler_config is None and 'lambdaConflictHandlerConfig' in kwargs:
            lambda_conflict_handler_config = kwargs['lambdaConflictHandlerConfig']

        if conflict_detection is not None:
            _setter("conflict_detection", conflict_detection)
        if conflict_handler is not None:
            _setter("conflict_handler", conflict_handler)
        if lambda_conflict_handler_config is not None:
            _setter("lambda_conflict_handler_config", lambda_conflict_handler_config)

    @property
    @pulumi.getter(name="conflictDetection")
    def conflict_detection(self) -> Optional[pulumi.Input[str]]:
        """
        Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
        """
        return pulumi.get(self, "conflict_detection")

    @conflict_detection.setter
    def conflict_detection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_detection", value)

    @property
    @pulumi.getter(name="conflictHandler")
    def conflict_handler(self) -> Optional[pulumi.Input[str]]:
        """
        Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
        """
        return pulumi.get(self, "conflict_handler")

    @conflict_handler.setter
    def conflict_handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_handler", value)

    @property
    @pulumi.getter(name="lambdaConflictHandlerConfig")
    def lambda_conflict_handler_config(self) -> Optional[pulumi.Input['FunctionSyncConfigLambdaConflictHandlerConfigArgs']]:
        """
        Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
        """
        return pulumi.get(self, "lambda_conflict_handler_config")

    @lambda_conflict_handler_config.setter
    def lambda_conflict_handler_config(self, value: Optional[pulumi.Input['FunctionSyncConfigLambdaConflictHandlerConfigArgs']]):
        pulumi.set(self, "lambda_conflict_handler_config", value)


@pulumi.input_type
class FunctionSyncConfigLambdaConflictHandlerConfigArgs:
    def __init__(__self__, *,
                 lambda_conflict_handler_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lambda_conflict_handler_arn: ARN for the Lambda function to use as the Conflict Handler.
        """
        FunctionSyncConfigLambdaConflictHandlerConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lambda_conflict_handler_arn=lambda_conflict_handler_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lambda_conflict_handler_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lambda_conflict_handler_arn is None and 'lambdaConflictHandlerArn' in kwargs:
            lambda_conflict_handler_arn = kwargs['lambdaConflictHandlerArn']

        if lambda_conflict_handler_arn is not None:
            _setter("lambda_conflict_handler_arn", lambda_conflict_handler_arn)

    @property
    @pulumi.getter(name="lambdaConflictHandlerArn")
    def lambda_conflict_handler_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN for the Lambda function to use as the Conflict Handler.
        """
        return pulumi.get(self, "lambda_conflict_handler_arn")

    @lambda_conflict_handler_arn.setter
    def lambda_conflict_handler_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lambda_conflict_handler_arn", value)


@pulumi.input_type
class GraphQLApiAdditionalAuthenticationProviderArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input[str],
                 lambda_authorizer_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs']] = None,
                 openid_connect_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs']] = None,
                 user_pool_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs']] = None):
        """
        :param pulumi.Input[str] authentication_type: Authentication type. Valid values: `API_KEY`, `AWS_IAM`, `AMAZON_COGNITO_USER_POOLS`, `OPENID_CONNECT`, `AWS_LAMBDA`
        :param pulumi.Input['GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs'] lambda_authorizer_config: Nested argument containing Lambda authorizer configuration. Defined below.
        :param pulumi.Input['GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs'] openid_connect_config: Nested argument containing OpenID Connect configuration. Defined below.
        :param pulumi.Input['GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs'] user_pool_config: Amazon Cognito User Pool configuration. Defined below.
        """
        GraphQLApiAdditionalAuthenticationProviderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_type=authentication_type,
            lambda_authorizer_config=lambda_authorizer_config,
            openid_connect_config=openid_connect_config,
            user_pool_config=user_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_type: Optional[pulumi.Input[str]] = None,
             lambda_authorizer_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs']] = None,
             openid_connect_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs']] = None,
             user_pool_config: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authentication_type is None and 'authenticationType' in kwargs:
            authentication_type = kwargs['authenticationType']
        if authentication_type is None:
            raise TypeError("Missing 'authentication_type' argument")
        if lambda_authorizer_config is None and 'lambdaAuthorizerConfig' in kwargs:
            lambda_authorizer_config = kwargs['lambdaAuthorizerConfig']
        if openid_connect_config is None and 'openidConnectConfig' in kwargs:
            openid_connect_config = kwargs['openidConnectConfig']
        if user_pool_config is None and 'userPoolConfig' in kwargs:
            user_pool_config = kwargs['userPoolConfig']

        _setter("authentication_type", authentication_type)
        if lambda_authorizer_config is not None:
            _setter("lambda_authorizer_config", lambda_authorizer_config)
        if openid_connect_config is not None:
            _setter("openid_connect_config", openid_connect_config)
        if user_pool_config is not None:
            _setter("user_pool_config", user_pool_config)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input[str]:
        """
        Authentication type. Valid values: `API_KEY`, `AWS_IAM`, `AMAZON_COGNITO_USER_POOLS`, `OPENID_CONNECT`, `AWS_LAMBDA`
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="lambdaAuthorizerConfig")
    def lambda_authorizer_config(self) -> Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs']]:
        """
        Nested argument containing Lambda authorizer configuration. Defined below.
        """
        return pulumi.get(self, "lambda_authorizer_config")

    @lambda_authorizer_config.setter
    def lambda_authorizer_config(self, value: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs']]):
        pulumi.set(self, "lambda_authorizer_config", value)

    @property
    @pulumi.getter(name="openidConnectConfig")
    def openid_connect_config(self) -> Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs']]:
        """
        Nested argument containing OpenID Connect configuration. Defined below.
        """
        return pulumi.get(self, "openid_connect_config")

    @openid_connect_config.setter
    def openid_connect_config(self, value: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs']]):
        pulumi.set(self, "openid_connect_config", value)

    @property
    @pulumi.getter(name="userPoolConfig")
    def user_pool_config(self) -> Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs']]:
        """
        Amazon Cognito User Pool configuration. Defined below.
        """
        return pulumi.get(self, "user_pool_config")

    @user_pool_config.setter
    def user_pool_config(self, value: Optional[pulumi.Input['GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs']]):
        pulumi.set(self, "user_pool_config", value)


@pulumi.input_type
class GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs:
    def __init__(__self__, *,
                 authorizer_uri: pulumi.Input[str],
                 authorizer_result_ttl_in_seconds: Optional[pulumi.Input[int]] = None,
                 identity_validation_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authorizer_uri: ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
        :param pulumi.Input[int] authorizer_result_ttl_in_seconds: Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
        :param pulumi.Input[str] identity_validation_expression: Regular expression for validation of tokens before the Lambda function is called.
        """
        GraphQLApiAdditionalAuthenticationProviderLambdaAuthorizerConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorizer_uri=authorizer_uri,
            authorizer_result_ttl_in_seconds=authorizer_result_ttl_in_seconds,
            identity_validation_expression=identity_validation_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorizer_uri: Optional[pulumi.Input[str]] = None,
             authorizer_result_ttl_in_seconds: Optional[pulumi.Input[int]] = None,
             identity_validation_expression: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorizer_uri is None and 'authorizerUri' in kwargs:
            authorizer_uri = kwargs['authorizerUri']
        if authorizer_uri is None:
            raise TypeError("Missing 'authorizer_uri' argument")
        if authorizer_result_ttl_in_seconds is None and 'authorizerResultTtlInSeconds' in kwargs:
            authorizer_result_ttl_in_seconds = kwargs['authorizerResultTtlInSeconds']
        if identity_validation_expression is None and 'identityValidationExpression' in kwargs:
            identity_validation_expression = kwargs['identityValidationExpression']

        _setter("authorizer_uri", authorizer_uri)
        if authorizer_result_ttl_in_seconds is not None:
            _setter("authorizer_result_ttl_in_seconds", authorizer_result_ttl_in_seconds)
        if identity_validation_expression is not None:
            _setter("identity_validation_expression", identity_validation_expression)

    @property
    @pulumi.getter(name="authorizerUri")
    def authorizer_uri(self) -> pulumi.Input[str]:
        """
        ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
        """
        return pulumi.get(self, "authorizer_uri")

    @authorizer_uri.setter
    def authorizer_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "authorizer_uri", value)

    @property
    @pulumi.getter(name="authorizerResultTtlInSeconds")
    def authorizer_result_ttl_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
        """
        return pulumi.get(self, "authorizer_result_ttl_in_seconds")

    @authorizer_result_ttl_in_seconds.setter
    def authorizer_result_ttl_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "authorizer_result_ttl_in_seconds", value)

    @property
    @pulumi.getter(name="identityValidationExpression")
    def identity_validation_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression for validation of tokens before the Lambda function is called.
        """
        return pulumi.get(self, "identity_validation_expression")

    @identity_validation_expression.setter
    def identity_validation_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_validation_expression", value)


@pulumi.input_type
class GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs:
    def __init__(__self__, *,
                 issuer: pulumi.Input[str],
                 auth_ttl: Optional[pulumi.Input[int]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 iat_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] issuer: Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
        :param pulumi.Input[int] auth_ttl: Number of milliseconds a token is valid after being authenticated.
        :param pulumi.Input[str] client_id: Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
        :param pulumi.Input[int] iat_ttl: Number of milliseconds a token is valid after being issued to a user.
        """
        GraphQLApiAdditionalAuthenticationProviderOpenidConnectConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            issuer=issuer,
            auth_ttl=auth_ttl,
            client_id=client_id,
            iat_ttl=iat_ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             issuer: Optional[pulumi.Input[str]] = None,
             auth_ttl: Optional[pulumi.Input[int]] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             iat_ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if issuer is None:
            raise TypeError("Missing 'issuer' argument")
        if auth_ttl is None and 'authTtl' in kwargs:
            auth_ttl = kwargs['authTtl']
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if iat_ttl is None and 'iatTtl' in kwargs:
            iat_ttl = kwargs['iatTtl']

        _setter("issuer", issuer)
        if auth_ttl is not None:
            _setter("auth_ttl", auth_ttl)
        if client_id is not None:
            _setter("client_id", client_id)
        if iat_ttl is not None:
            _setter("iat_ttl", iat_ttl)

    @property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[str]:
        """
        Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[str]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="authTtl")
    def auth_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds a token is valid after being authenticated.
        """
        return pulumi.get(self, "auth_ttl")

    @auth_ttl.setter
    def auth_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_ttl", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="iatTtl")
    def iat_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds a token is valid after being issued to a user.
        """
        return pulumi.get(self, "iat_ttl")

    @iat_ttl.setter
    def iat_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iat_ttl", value)


@pulumi.input_type
class GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs:
    def __init__(__self__, *,
                 user_pool_id: pulumi.Input[str],
                 app_id_client_regex: Optional[pulumi.Input[str]] = None,
                 aws_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_pool_id: User pool ID.
        :param pulumi.Input[str] app_id_client_regex: Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
        :param pulumi.Input[str] aws_region: AWS region in which the user pool was created.
        """
        GraphQLApiAdditionalAuthenticationProviderUserPoolConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_pool_id=user_pool_id,
            app_id_client_regex=app_id_client_regex,
            aws_region=aws_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_pool_id: Optional[pulumi.Input[str]] = None,
             app_id_client_regex: Optional[pulumi.Input[str]] = None,
             aws_region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_pool_id is None and 'userPoolId' in kwargs:
            user_pool_id = kwargs['userPoolId']
        if user_pool_id is None:
            raise TypeError("Missing 'user_pool_id' argument")
        if app_id_client_regex is None and 'appIdClientRegex' in kwargs:
            app_id_client_regex = kwargs['appIdClientRegex']
        if aws_region is None and 'awsRegion' in kwargs:
            aws_region = kwargs['awsRegion']

        _setter("user_pool_id", user_pool_id)
        if app_id_client_regex is not None:
            _setter("app_id_client_regex", app_id_client_regex)
        if aws_region is not None:
            _setter("aws_region", aws_region)

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> pulumi.Input[str]:
        """
        User pool ID.
        """
        return pulumi.get(self, "user_pool_id")

    @user_pool_id.setter
    def user_pool_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_pool_id", value)

    @property
    @pulumi.getter(name="appIdClientRegex")
    def app_id_client_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
        """
        return pulumi.get(self, "app_id_client_regex")

    @app_id_client_regex.setter
    def app_id_client_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id_client_regex", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region in which the user pool was created.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_region", value)


@pulumi.input_type
class GraphQLApiLambdaAuthorizerConfigArgs:
    def __init__(__self__, *,
                 authorizer_uri: pulumi.Input[str],
                 authorizer_result_ttl_in_seconds: Optional[pulumi.Input[int]] = None,
                 identity_validation_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authorizer_uri: ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
        :param pulumi.Input[int] authorizer_result_ttl_in_seconds: Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
        :param pulumi.Input[str] identity_validation_expression: Regular expression for validation of tokens before the Lambda function is called.
        """
        GraphQLApiLambdaAuthorizerConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorizer_uri=authorizer_uri,
            authorizer_result_ttl_in_seconds=authorizer_result_ttl_in_seconds,
            identity_validation_expression=identity_validation_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorizer_uri: Optional[pulumi.Input[str]] = None,
             authorizer_result_ttl_in_seconds: Optional[pulumi.Input[int]] = None,
             identity_validation_expression: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorizer_uri is None and 'authorizerUri' in kwargs:
            authorizer_uri = kwargs['authorizerUri']
        if authorizer_uri is None:
            raise TypeError("Missing 'authorizer_uri' argument")
        if authorizer_result_ttl_in_seconds is None and 'authorizerResultTtlInSeconds' in kwargs:
            authorizer_result_ttl_in_seconds = kwargs['authorizerResultTtlInSeconds']
        if identity_validation_expression is None and 'identityValidationExpression' in kwargs:
            identity_validation_expression = kwargs['identityValidationExpression']

        _setter("authorizer_uri", authorizer_uri)
        if authorizer_result_ttl_in_seconds is not None:
            _setter("authorizer_result_ttl_in_seconds", authorizer_result_ttl_in_seconds)
        if identity_validation_expression is not None:
            _setter("identity_validation_expression", identity_validation_expression)

    @property
    @pulumi.getter(name="authorizerUri")
    def authorizer_uri(self) -> pulumi.Input[str]:
        """
        ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow `lambda:InvokeFunction` from service principal `appsync.amazonaws.com`.
        """
        return pulumi.get(self, "authorizer_uri")

    @authorizer_uri.setter
    def authorizer_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "authorizer_uri", value)

    @property
    @pulumi.getter(name="authorizerResultTtlInSeconds")
    def authorizer_result_ttl_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a `ttlOverride` key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
        """
        return pulumi.get(self, "authorizer_result_ttl_in_seconds")

    @authorizer_result_ttl_in_seconds.setter
    def authorizer_result_ttl_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "authorizer_result_ttl_in_seconds", value)

    @property
    @pulumi.getter(name="identityValidationExpression")
    def identity_validation_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression for validation of tokens before the Lambda function is called.
        """
        return pulumi.get(self, "identity_validation_expression")

    @identity_validation_expression.setter
    def identity_validation_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_validation_expression", value)


@pulumi.input_type
class GraphQLApiLogConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_logs_role_arn: pulumi.Input[str],
                 field_log_level: pulumi.Input[str],
                 exclude_verbose_content: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cloudwatch_logs_role_arn: Amazon Resource Name of the service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account.
        :param pulumi.Input[str] field_log_level: Field logging level. Valid values: `ALL`, `ERROR`, `NONE`.
        :param pulumi.Input[bool] exclude_verbose_content: Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging  level. Valid values: `true`, `false`. Default value: `false`
        """
        GraphQLApiLogConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_logs_role_arn=cloudwatch_logs_role_arn,
            field_log_level=field_log_level,
            exclude_verbose_content=exclude_verbose_content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_logs_role_arn: Optional[pulumi.Input[str]] = None,
             field_log_level: Optional[pulumi.Input[str]] = None,
             exclude_verbose_content: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_logs_role_arn is None and 'cloudwatchLogsRoleArn' in kwargs:
            cloudwatch_logs_role_arn = kwargs['cloudwatchLogsRoleArn']
        if cloudwatch_logs_role_arn is None:
            raise TypeError("Missing 'cloudwatch_logs_role_arn' argument")
        if field_log_level is None and 'fieldLogLevel' in kwargs:
            field_log_level = kwargs['fieldLogLevel']
        if field_log_level is None:
            raise TypeError("Missing 'field_log_level' argument")
        if exclude_verbose_content is None and 'excludeVerboseContent' in kwargs:
            exclude_verbose_content = kwargs['excludeVerboseContent']

        _setter("cloudwatch_logs_role_arn", cloudwatch_logs_role_arn)
        _setter("field_log_level", field_log_level)
        if exclude_verbose_content is not None:
            _setter("exclude_verbose_content", exclude_verbose_content)

    @property
    @pulumi.getter(name="cloudwatchLogsRoleArn")
    def cloudwatch_logs_role_arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name of the service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account.
        """
        return pulumi.get(self, "cloudwatch_logs_role_arn")

    @cloudwatch_logs_role_arn.setter
    def cloudwatch_logs_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloudwatch_logs_role_arn", value)

    @property
    @pulumi.getter(name="fieldLogLevel")
    def field_log_level(self) -> pulumi.Input[str]:
        """
        Field logging level. Valid values: `ALL`, `ERROR`, `NONE`.
        """
        return pulumi.get(self, "field_log_level")

    @field_log_level.setter
    def field_log_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_log_level", value)

    @property
    @pulumi.getter(name="excludeVerboseContent")
    def exclude_verbose_content(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging  level. Valid values: `true`, `false`. Default value: `false`
        """
        return pulumi.get(self, "exclude_verbose_content")

    @exclude_verbose_content.setter
    def exclude_verbose_content(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_verbose_content", value)


@pulumi.input_type
class GraphQLApiOpenidConnectConfigArgs:
    def __init__(__self__, *,
                 issuer: pulumi.Input[str],
                 auth_ttl: Optional[pulumi.Input[int]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 iat_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] issuer: Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
        :param pulumi.Input[int] auth_ttl: Number of milliseconds a token is valid after being authenticated.
        :param pulumi.Input[str] client_id: Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
        :param pulumi.Input[int] iat_ttl: Number of milliseconds a token is valid after being issued to a user.
        """
        GraphQLApiOpenidConnectConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            issuer=issuer,
            auth_ttl=auth_ttl,
            client_id=client_id,
            iat_ttl=iat_ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             issuer: Optional[pulumi.Input[str]] = None,
             auth_ttl: Optional[pulumi.Input[int]] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             iat_ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if issuer is None:
            raise TypeError("Missing 'issuer' argument")
        if auth_ttl is None and 'authTtl' in kwargs:
            auth_ttl = kwargs['authTtl']
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if iat_ttl is None and 'iatTtl' in kwargs:
            iat_ttl = kwargs['iatTtl']

        _setter("issuer", issuer)
        if auth_ttl is not None:
            _setter("auth_ttl", auth_ttl)
        if client_id is not None:
            _setter("client_id", client_id)
        if iat_ttl is not None:
            _setter("iat_ttl", iat_ttl)

    @property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[str]:
        """
        Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[str]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="authTtl")
    def auth_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds a token is valid after being authenticated.
        """
        return pulumi.get(self, "auth_ttl")

    @auth_ttl.setter
    def auth_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_ttl", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="iatTtl")
    def iat_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds a token is valid after being issued to a user.
        """
        return pulumi.get(self, "iat_ttl")

    @iat_ttl.setter
    def iat_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iat_ttl", value)


@pulumi.input_type
class GraphQLApiUserPoolConfigArgs:
    def __init__(__self__, *,
                 default_action: pulumi.Input[str],
                 user_pool_id: pulumi.Input[str],
                 app_id_client_regex: Optional[pulumi.Input[str]] = None,
                 aws_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_action: Action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration. Valid: `ALLOW` and `DENY`
        :param pulumi.Input[str] user_pool_id: User pool ID.
        :param pulumi.Input[str] app_id_client_regex: Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
        :param pulumi.Input[str] aws_region: AWS region in which the user pool was created.
        """
        GraphQLApiUserPoolConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_action=default_action,
            user_pool_id=user_pool_id,
            app_id_client_regex=app_id_client_regex,
            aws_region=aws_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_action: Optional[pulumi.Input[str]] = None,
             user_pool_id: Optional[pulumi.Input[str]] = None,
             app_id_client_regex: Optional[pulumi.Input[str]] = None,
             aws_region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_action is None and 'defaultAction' in kwargs:
            default_action = kwargs['defaultAction']
        if default_action is None:
            raise TypeError("Missing 'default_action' argument")
        if user_pool_id is None and 'userPoolId' in kwargs:
            user_pool_id = kwargs['userPoolId']
        if user_pool_id is None:
            raise TypeError("Missing 'user_pool_id' argument")
        if app_id_client_regex is None and 'appIdClientRegex' in kwargs:
            app_id_client_regex = kwargs['appIdClientRegex']
        if aws_region is None and 'awsRegion' in kwargs:
            aws_region = kwargs['awsRegion']

        _setter("default_action", default_action)
        _setter("user_pool_id", user_pool_id)
        if app_id_client_regex is not None:
            _setter("app_id_client_regex", app_id_client_regex)
        if aws_region is not None:
            _setter("aws_region", aws_region)

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> pulumi.Input[str]:
        """
        Action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration. Valid: `ALLOW` and `DENY`
        """
        return pulumi.get(self, "default_action")

    @default_action.setter
    def default_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_action", value)

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> pulumi.Input[str]:
        """
        User pool ID.
        """
        return pulumi.get(self, "user_pool_id")

    @user_pool_id.setter
    def user_pool_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_pool_id", value)

    @property
    @pulumi.getter(name="appIdClientRegex")
    def app_id_client_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
        """
        return pulumi.get(self, "app_id_client_regex")

    @app_id_client_regex.setter
    def app_id_client_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id_client_regex", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region in which the user pool was created.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_region", value)


@pulumi.input_type
class ResolverCachingConfigArgs:
    def __init__(__self__, *,
                 caching_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] caching_keys: The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        :param pulumi.Input[int] ttl: The TTL in seconds for a resolver that has caching activated. Valid values are between `1` and `3600` seconds.
        """
        ResolverCachingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caching_keys=caching_keys,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caching_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ttl: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if caching_keys is None and 'cachingKeys' in kwargs:
            caching_keys = kwargs['cachingKeys']

        if caching_keys is not None:
            _setter("caching_keys", caching_keys)
        if ttl is not None:
            _setter("ttl", ttl)

    @property
    @pulumi.getter(name="cachingKeys")
    def caching_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
        """
        return pulumi.get(self, "caching_keys")

    @caching_keys.setter
    def caching_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "caching_keys", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The TTL in seconds for a resolver that has caching activated. Valid values are between `1` and `3600` seconds.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class ResolverPipelineConfigArgs:
    def __init__(__self__, *,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] functions: A list of Function objects.
        """
        ResolverPipelineConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            functions=functions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             functions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if functions is not None:
            _setter("functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of Function objects.
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "functions", value)


@pulumi.input_type
class ResolverRuntimeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 runtime_version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
        :param pulumi.Input[str] runtime_version: The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
        """
        ResolverRuntimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']
        if runtime_version is None:
            raise TypeError("Missing 'runtime_version' argument")

        _setter("name", name)
        _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the runtime to use. Currently, the only allowed value is `APPSYNC_JS`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> pulumi.Input[str]:
        """
        The version of the runtime to use. Currently, the only allowed version is `1.0.0`.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "runtime_version", value)


@pulumi.input_type
class ResolverSyncConfigArgs:
    def __init__(__self__, *,
                 conflict_detection: Optional[pulumi.Input[str]] = None,
                 conflict_handler: Optional[pulumi.Input[str]] = None,
                 lambda_conflict_handler_config: Optional[pulumi.Input['ResolverSyncConfigLambdaConflictHandlerConfigArgs']] = None):
        """
        :param pulumi.Input[str] conflict_detection: Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
        :param pulumi.Input[str] conflict_handler: Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
        :param pulumi.Input['ResolverSyncConfigLambdaConflictHandlerConfigArgs'] lambda_conflict_handler_config: Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
        """
        ResolverSyncConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conflict_detection=conflict_detection,
            conflict_handler=conflict_handler,
            lambda_conflict_handler_config=lambda_conflict_handler_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conflict_detection: Optional[pulumi.Input[str]] = None,
             conflict_handler: Optional[pulumi.Input[str]] = None,
             lambda_conflict_handler_config: Optional[pulumi.Input['ResolverSyncConfigLambdaConflictHandlerConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if conflict_detection is None and 'conflictDetection' in kwargs:
            conflict_detection = kwargs['conflictDetection']
        if conflict_handler is None and 'conflictHandler' in kwargs:
            conflict_handler = kwargs['conflictHandler']
        if lambda_conflict_handler_config is None and 'lambdaConflictHandlerConfig' in kwargs:
            lambda_conflict_handler_config = kwargs['lambdaConflictHandlerConfig']

        if conflict_detection is not None:
            _setter("conflict_detection", conflict_detection)
        if conflict_handler is not None:
            _setter("conflict_handler", conflict_handler)
        if lambda_conflict_handler_config is not None:
            _setter("lambda_conflict_handler_config", lambda_conflict_handler_config)

    @property
    @pulumi.getter(name="conflictDetection")
    def conflict_detection(self) -> Optional[pulumi.Input[str]]:
        """
        Conflict Detection strategy to use. Valid values are `NONE` and `VERSION`.
        """
        return pulumi.get(self, "conflict_detection")

    @conflict_detection.setter
    def conflict_detection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_detection", value)

    @property
    @pulumi.getter(name="conflictHandler")
    def conflict_handler(self) -> Optional[pulumi.Input[str]]:
        """
        Conflict Resolution strategy to perform in the event of a conflict. Valid values are `NONE`, `OPTIMISTIC_CONCURRENCY`, `AUTOMERGE`, and `LAMBDA`.
        """
        return pulumi.get(self, "conflict_handler")

    @conflict_handler.setter
    def conflict_handler(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_handler", value)

    @property
    @pulumi.getter(name="lambdaConflictHandlerConfig")
    def lambda_conflict_handler_config(self) -> Optional[pulumi.Input['ResolverSyncConfigLambdaConflictHandlerConfigArgs']]:
        """
        Lambda Conflict Handler Config when configuring `LAMBDA` as the Conflict Handler. See Lambda Conflict Handler Config.
        """
        return pulumi.get(self, "lambda_conflict_handler_config")

    @lambda_conflict_handler_config.setter
    def lambda_conflict_handler_config(self, value: Optional[pulumi.Input['ResolverSyncConfigLambdaConflictHandlerConfigArgs']]):
        pulumi.set(self, "lambda_conflict_handler_config", value)


@pulumi.input_type
class ResolverSyncConfigLambdaConflictHandlerConfigArgs:
    def __init__(__self__, *,
                 lambda_conflict_handler_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lambda_conflict_handler_arn: ARN for the Lambda function to use as the Conflict Handler.
        """
        ResolverSyncConfigLambdaConflictHandlerConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lambda_conflict_handler_arn=lambda_conflict_handler_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lambda_conflict_handler_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lambda_conflict_handler_arn is None and 'lambdaConflictHandlerArn' in kwargs:
            lambda_conflict_handler_arn = kwargs['lambdaConflictHandlerArn']

        if lambda_conflict_handler_arn is not None:
            _setter("lambda_conflict_handler_arn", lambda_conflict_handler_arn)

    @property
    @pulumi.getter(name="lambdaConflictHandlerArn")
    def lambda_conflict_handler_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN for the Lambda function to use as the Conflict Handler.
        """
        return pulumi.get(self, "lambda_conflict_handler_arn")

    @lambda_conflict_handler_arn.setter
    def lambda_conflict_handler_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lambda_conflict_handler_arn", value)


