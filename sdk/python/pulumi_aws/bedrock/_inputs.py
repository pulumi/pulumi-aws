# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentActionGroupActionGroupExecutorArgs',
    'AgentAgentActionGroupActionGroupExecutorArgsDict',
    'AgentAgentActionGroupApiSchemaArgs',
    'AgentAgentActionGroupApiSchemaArgsDict',
    'AgentAgentActionGroupApiSchemaS3Args',
    'AgentAgentActionGroupApiSchemaS3ArgsDict',
    'AgentAgentActionGroupFunctionSchemaArgs',
    'AgentAgentActionGroupFunctionSchemaArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict',
    'AgentAgentActionGroupTimeoutsArgs',
    'AgentAgentActionGroupTimeoutsArgsDict',
    'AgentAgentAliasRoutingConfigurationArgs',
    'AgentAgentAliasRoutingConfigurationArgsDict',
    'AgentAgentAliasTimeoutsArgs',
    'AgentAgentAliasTimeoutsArgsDict',
    'AgentAgentCollaboratorAgentDescriptorArgs',
    'AgentAgentCollaboratorAgentDescriptorArgsDict',
    'AgentAgentCollaboratorTimeoutsArgs',
    'AgentAgentCollaboratorTimeoutsArgsDict',
    'AgentAgentGuardrailConfigurationArgs',
    'AgentAgentGuardrailConfigurationArgsDict',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgs',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict',
    'AgentAgentMemoryConfigurationArgs',
    'AgentAgentMemoryConfigurationArgsDict',
    'AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs',
    'AgentAgentMemoryConfigurationSessionSummaryConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict',
    'AgentAgentTimeoutsArgs',
    'AgentAgentTimeoutsArgsDict',
    'AgentDataSourceDataSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict',
    'AgentDataSourceServerSideEncryptionConfigurationArgs',
    'AgentDataSourceServerSideEncryptionConfigurationArgsDict',
    'AgentDataSourceTimeoutsArgs',
    'AgentDataSourceTimeoutsArgsDict',
    'AgentDataSourceVectorIngestionConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict',
    'AgentFlowDefinitionArgs',
    'AgentFlowDefinitionArgsDict',
    'AgentFlowDefinitionConnectionArgs',
    'AgentFlowDefinitionConnectionArgsDict',
    'AgentFlowDefinitionConnectionConfigurationArgs',
    'AgentFlowDefinitionConnectionConfigurationArgsDict',
    'AgentFlowDefinitionConnectionConfigurationConditionalArgs',
    'AgentFlowDefinitionConnectionConfigurationConditionalArgsDict',
    'AgentFlowDefinitionConnectionConfigurationDataArgs',
    'AgentFlowDefinitionConnectionConfigurationDataArgsDict',
    'AgentFlowDefinitionNodeArgs',
    'AgentFlowDefinitionNodeArgsDict',
    'AgentFlowDefinitionNodeConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationAgentArgs',
    'AgentFlowDefinitionNodeConfigurationAgentArgsDict',
    'AgentFlowDefinitionNodeConfigurationCollectorArgs',
    'AgentFlowDefinitionNodeConfigurationCollectorArgsDict',
    'AgentFlowDefinitionNodeConfigurationConditionArgs',
    'AgentFlowDefinitionNodeConfigurationConditionArgsDict',
    'AgentFlowDefinitionNodeConfigurationConditionConditionArgs',
    'AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict',
    'AgentFlowDefinitionNodeConfigurationInlineCodeArgs',
    'AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict',
    'AgentFlowDefinitionNodeConfigurationInputArgs',
    'AgentFlowDefinitionNodeConfigurationInputArgsDict',
    'AgentFlowDefinitionNodeConfigurationIteratorArgs',
    'AgentFlowDefinitionNodeConfigurationIteratorArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs',
    'AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict',
    'AgentFlowDefinitionNodeConfigurationLexArgs',
    'AgentFlowDefinitionNodeConfigurationLexArgsDict',
    'AgentFlowDefinitionNodeConfigurationOutputArgs',
    'AgentFlowDefinitionNodeConfigurationOutputArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptArgs',
    'AgentFlowDefinitionNodeConfigurationPromptArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalArgs',
    'AgentFlowDefinitionNodeConfigurationRetrievalArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageArgs',
    'AgentFlowDefinitionNodeConfigurationStorageArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict',
    'AgentFlowDefinitionNodeInputArgs',
    'AgentFlowDefinitionNodeInputArgsDict',
    'AgentFlowDefinitionNodeOutputArgs',
    'AgentFlowDefinitionNodeOutputArgsDict',
    'AgentFlowTimeoutsArgs',
    'AgentFlowTimeoutsArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgsDict',
    'AgentKnowledgeBaseTimeoutsArgs',
    'AgentKnowledgeBaseTimeoutsArgsDict',
    'AgentPromptVariantArgs',
    'AgentPromptVariantArgsDict',
    'AgentPromptVariantGenAiResourceArgs',
    'AgentPromptVariantGenAiResourceArgsDict',
    'AgentPromptVariantGenAiResourceAgentArgs',
    'AgentPromptVariantGenAiResourceAgentArgsDict',
    'AgentPromptVariantInferenceConfigurationArgs',
    'AgentPromptVariantInferenceConfigurationArgsDict',
    'AgentPromptVariantInferenceConfigurationTextArgs',
    'AgentPromptVariantInferenceConfigurationTextArgsDict',
    'AgentPromptVariantMetadataArgs',
    'AgentPromptVariantMetadataArgsDict',
    'AgentPromptVariantTemplateConfigurationArgs',
    'AgentPromptVariantTemplateConfigurationArgsDict',
    'AgentPromptVariantTemplateConfigurationChatArgs',
    'AgentPromptVariantTemplateConfigurationChatArgsDict',
    'AgentPromptVariantTemplateConfigurationChatInputVariableArgs',
    'AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageContentArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatSystemArgs',
    'AgentPromptVariantTemplateConfigurationChatSystemArgsDict',
    'AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict',
    'AgentPromptVariantTemplateConfigurationTextArgs',
    'AgentPromptVariantTemplateConfigurationTextArgsDict',
    'AgentPromptVariantTemplateConfigurationTextCachePointArgs',
    'AgentPromptVariantTemplateConfigurationTextCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationTextInputVariableArgs',
    'AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactArgs',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactArgsDict',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgsDict',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgsDict',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3ArgsDict',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs',
    'AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgsDict',
    'AgentcoreAgentRuntimeAuthorizerConfigurationArgs',
    'AgentcoreAgentRuntimeAuthorizerConfigurationArgsDict',
    'AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs',
    'AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgsDict',
    'AgentcoreAgentRuntimeEndpointTimeoutsArgs',
    'AgentcoreAgentRuntimeEndpointTimeoutsArgsDict',
    'AgentcoreAgentRuntimeLifecycleConfigurationArgs',
    'AgentcoreAgentRuntimeLifecycleConfigurationArgsDict',
    'AgentcoreAgentRuntimeNetworkConfigurationArgs',
    'AgentcoreAgentRuntimeNetworkConfigurationArgsDict',
    'AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs',
    'AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgsDict',
    'AgentcoreAgentRuntimeProtocolConfigurationArgs',
    'AgentcoreAgentRuntimeProtocolConfigurationArgsDict',
    'AgentcoreAgentRuntimeRequestHeaderConfigurationArgs',
    'AgentcoreAgentRuntimeRequestHeaderConfigurationArgsDict',
    'AgentcoreAgentRuntimeTimeoutsArgs',
    'AgentcoreAgentRuntimeTimeoutsArgsDict',
    'AgentcoreAgentRuntimeWorkloadIdentityDetailArgs',
    'AgentcoreAgentRuntimeWorkloadIdentityDetailArgsDict',
    'AgentcoreApiKeyCredentialProviderApiKeySecretArnArgs',
    'AgentcoreApiKeyCredentialProviderApiKeySecretArnArgsDict',
    'AgentcoreBrowserNetworkConfigurationArgs',
    'AgentcoreBrowserNetworkConfigurationArgsDict',
    'AgentcoreBrowserNetworkConfigurationVpcConfigArgs',
    'AgentcoreBrowserNetworkConfigurationVpcConfigArgsDict',
    'AgentcoreBrowserRecordingArgs',
    'AgentcoreBrowserRecordingArgsDict',
    'AgentcoreBrowserRecordingS3LocationArgs',
    'AgentcoreBrowserRecordingS3LocationArgsDict',
    'AgentcoreBrowserTimeoutsArgs',
    'AgentcoreBrowserTimeoutsArgsDict',
    'AgentcoreCodeInterpreterNetworkConfigurationArgs',
    'AgentcoreCodeInterpreterNetworkConfigurationArgsDict',
    'AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs',
    'AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgsDict',
    'AgentcoreCodeInterpreterTimeoutsArgs',
    'AgentcoreCodeInterpreterTimeoutsArgsDict',
    'AgentcoreGatewayAuthorizerConfigurationArgs',
    'AgentcoreGatewayAuthorizerConfigurationArgsDict',
    'AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs',
    'AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgsDict',
    'AgentcoreGatewayInterceptorConfigurationArgs',
    'AgentcoreGatewayInterceptorConfigurationArgsDict',
    'AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs',
    'AgentcoreGatewayInterceptorConfigurationInputConfigurationArgsDict',
    'AgentcoreGatewayInterceptorConfigurationInterceptorArgs',
    'AgentcoreGatewayInterceptorConfigurationInterceptorArgsDict',
    'AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs',
    'AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgsDict',
    'AgentcoreGatewayProtocolConfigurationArgs',
    'AgentcoreGatewayProtocolConfigurationArgsDict',
    'AgentcoreGatewayProtocolConfigurationMcpArgs',
    'AgentcoreGatewayProtocolConfigurationMcpArgsDict',
    'AgentcoreGatewayTargetCredentialProviderConfigurationArgs',
    'AgentcoreGatewayTargetCredentialProviderConfigurationArgsDict',
    'AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs',
    'AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgsDict',
    'AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs',
    'AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgsDict',
    'AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs',
    'AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationArgs',
    'AgentcoreGatewayTargetTargetConfigurationArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args',
    'AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3ArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3Args',
    'AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3ArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgs',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgsDict',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3Args',
    'AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3ArgsDict',
    'AgentcoreGatewayTargetTimeoutsArgs',
    'AgentcoreGatewayTargetTimeoutsArgsDict',
    'AgentcoreGatewayTimeoutsArgs',
    'AgentcoreGatewayTimeoutsArgsDict',
    'AgentcoreGatewayWorkloadIdentityDetailArgs',
    'AgentcoreGatewayWorkloadIdentityDetailArgsDict',
    'AgentcoreMemoryStrategyConfigurationArgs',
    'AgentcoreMemoryStrategyConfigurationArgsDict',
    'AgentcoreMemoryStrategyConfigurationConsolidationArgs',
    'AgentcoreMemoryStrategyConfigurationConsolidationArgsDict',
    'AgentcoreMemoryStrategyConfigurationExtractionArgs',
    'AgentcoreMemoryStrategyConfigurationExtractionArgsDict',
    'AgentcoreMemoryStrategyTimeoutsArgs',
    'AgentcoreMemoryStrategyTimeoutsArgsDict',
    'AgentcoreMemoryTimeoutsArgs',
    'AgentcoreMemoryTimeoutsArgsDict',
    'AgentcoreOauth2CredentialProviderClientSecretArnArgs',
    'AgentcoreOauth2CredentialProviderClientSecretArnArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgsDict',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs',
    'AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict',
    'AgentcoreTokenVaultCmkKmsConfigurationArgs',
    'AgentcoreTokenVaultCmkKmsConfigurationArgsDict',
    'CustomModelOutputDataConfigArgs',
    'CustomModelOutputDataConfigArgsDict',
    'CustomModelTimeoutsArgs',
    'CustomModelTimeoutsArgsDict',
    'CustomModelTrainingDataConfigArgs',
    'CustomModelTrainingDataConfigArgsDict',
    'CustomModelTrainingMetricArgs',
    'CustomModelTrainingMetricArgsDict',
    'CustomModelValidationDataConfigArgs',
    'CustomModelValidationDataConfigArgsDict',
    'CustomModelValidationDataConfigValidatorArgs',
    'CustomModelValidationDataConfigValidatorArgsDict',
    'CustomModelValidationMetricArgs',
    'CustomModelValidationMetricArgsDict',
    'CustomModelVpcConfigArgs',
    'CustomModelVpcConfigArgsDict',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContentPolicyConfigArgsDict',
    'GuardrailContentPolicyConfigFiltersConfigArgs',
    'GuardrailContentPolicyConfigFiltersConfigArgsDict',
    'GuardrailContentPolicyConfigTierConfigArgs',
    'GuardrailContentPolicyConfigTierConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgs',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict',
    'GuardrailCrossRegionConfigArgs',
    'GuardrailCrossRegionConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict',
    'GuardrailTimeoutsArgs',
    'GuardrailTimeoutsArgsDict',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailTopicPolicyConfigArgsDict',
    'GuardrailTopicPolicyConfigTierConfigArgs',
    'GuardrailTopicPolicyConfigTierConfigArgsDict',
    'GuardrailTopicPolicyConfigTopicsConfigArgs',
    'GuardrailTopicPolicyConfigTopicsConfigArgsDict',
    'GuardrailVersionTimeoutsArgs',
    'GuardrailVersionTimeoutsArgsDict',
    'GuardrailWordPolicyConfigArgs',
    'GuardrailWordPolicyConfigArgsDict',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgs',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgsDict',
    'GuardrailWordPolicyConfigWordsConfigArgs',
    'GuardrailWordPolicyConfigWordsConfigArgsDict',
    'InferenceProfileModelArgs',
    'InferenceProfileModelArgsDict',
    'InferenceProfileModelSourceArgs',
    'InferenceProfileModelSourceArgsDict',
    'InferenceProfileTimeoutsArgs',
    'InferenceProfileTimeoutsArgsDict',
    'ProvisionedModelThroughputTimeoutsArgs',
    'ProvisionedModelThroughputTimeoutsArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryArgs',
    'GetAgentAgentVersionsAgentVersionSummaryArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentActionGroupActionGroupExecutorArgsDict(TypedDict):
        custom_control: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        lambda_: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
elif False:
    AgentAgentActionGroupActionGroupExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupActionGroupExecutorArgs:
    def __init__(__self__, *,
                 custom_control: Optional[pulumi.Input[_builtins.str]] = None,
                 lambda_: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param pulumi.Input[_builtins.str] lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_control", value)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaArgsDict(TypedDict):
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        s3: NotRequired[pulumi.Input['AgentAgentActionGroupApiSchemaS3ArgsDict']]
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
elif False:
    AgentAgentActionGroupApiSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaArgs:
    def __init__(__self__, *,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 s3: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']] = None):
        """
        :param pulumi.Input[_builtins.str] payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param pulumi.Input['AgentAgentActionGroupApiSchemaS3Args'] s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaS3ArgsDict(TypedDict):
        s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the S3 bucket.
        """
        s3_object_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 object key containing the resource.
        """
elif False:
    AgentAgentActionGroupApiSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaS3Args:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_object_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] s3_bucket_name: Name of the S3 bucket.
        :param pulumi.Input[_builtins.str] s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_key", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaArgsDict(TypedDict):
        member_functions: NotRequired[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict']]
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaArgs:
    def __init__(__self__, *,
                 member_functions: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']] = None):
        """
        :param pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs'] member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @_builtins.property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")

    @member_functions.setter
    def member_functions(self, value: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]):
        pulumi.set(self, "member_functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict(TypedDict):
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict']]]]
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs:
    def __init__(__self__, *,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]):
        pulumi.set(self, "functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name for the function.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the function and its purpose.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict']]]]
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name for the function.
        :param pulumi.Input[_builtins.str] description: Description of the function and its purpose.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict(TypedDict):
        map_block_key: pulumi.Input[_builtins.str]
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param pulumi.Input[_builtins.str] type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param pulumi.Input[_builtins.str] description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param pulumi.Input[_builtins.bool] required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "map_block_key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentAgentActionGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentActionGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentAliasRoutingConfigurationArgsDict(TypedDict):
        agent_version: pulumi.Input[_builtins.str]
        """
        Version of the agent with which the alias is associated.
        """
        provisioned_throughput: pulumi.Input[_builtins.str]
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
elif False:
    AgentAgentAliasRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[_builtins.str],
                 provisioned_throughput: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_version: Version of the agent with which the alias is associated.
        :param pulumi.Input[_builtins.str] provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_version", value)

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provisioned_throughput", value)


if not MYPY:
    class AgentAgentAliasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentAliasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentCollaboratorAgentDescriptorArgsDict(TypedDict):
        alias_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
elif False:
    AgentAgentCollaboratorAgentDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorAgentDescriptorArgs:
    def __init__(__self__, *,
                 alias_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias_arn: ARN of the Alias of an Agent to use as the collaborator.
        """
        pulumi.set(__self__, "alias_arn", alias_arn)

    @_builtins.property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
        return pulumi.get(self, "alias_arn")

    @alias_arn.setter
    def alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias_arn", value)


if not MYPY:
    class AgentAgentCollaboratorTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentCollaboratorTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        Version of the guardrail.
        """
elif False:
    AgentAgentGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: Unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentKnowledgeBaseAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentMemoryConfigurationArgsDict(TypedDict):
        enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        session_summary_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentMemoryConfigurationSessionSummaryConfigurationArgsDict']]]
        """
        Configuration block for `SESSION_SUMMARY` memory type enabled for the agent. See `session_summary_configuration` Block for details.
        """
        storage_days: pulumi.Input[_builtins.int]
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
elif False:
    AgentAgentMemoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentMemoryConfigurationArgs:
    def __init__(__self__, *,
                 enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 session_summary_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs']]],
                 storage_days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enabled_memory_types: The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs']]] session_summary_configurations: Configuration block for `SESSION_SUMMARY` memory type enabled for the agent. See `session_summary_configuration` Block for details.
        :param pulumi.Input[_builtins.int] storage_days: The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        pulumi.set(__self__, "session_summary_configurations", session_summary_configurations)
        pulumi.set(__self__, "storage_days", storage_days)

    @_builtins.property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        return pulumi.get(self, "enabled_memory_types")

    @enabled_memory_types.setter
    def enabled_memory_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "enabled_memory_types", value)

    @_builtins.property
    @pulumi.getter(name="sessionSummaryConfigurations")
    def session_summary_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs']]]:
        """
        Configuration block for `SESSION_SUMMARY` memory type enabled for the agent. See `session_summary_configuration` Block for details.
        """
        return pulumi.get(self, "session_summary_configurations")

    @session_summary_configurations.setter
    def session_summary_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs']]]):
        pulumi.set(self, "session_summary_configurations", value)

    @_builtins.property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> pulumi.Input[_builtins.int]:
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        return pulumi.get(self, "storage_days")

    @storage_days.setter
    def storage_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_days", value)


if not MYPY:
    class AgentAgentMemoryConfigurationSessionSummaryConfigurationArgsDict(TypedDict):
        max_recent_sessions: pulumi.Input[_builtins.int]
        """
        Maximum number of recent session summaries to include in the agent's prompt context.
        """
elif False:
    AgentAgentMemoryConfigurationSessionSummaryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentMemoryConfigurationSessionSummaryConfigurationArgs:
    def __init__(__self__, *,
                 max_recent_sessions: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_recent_sessions: Maximum number of recent session summaries to include in the agent's prompt context.
        """
        pulumi.set(__self__, "max_recent_sessions", max_recent_sessions)

    @_builtins.property
    @pulumi.getter(name="maxRecentSessions")
    def max_recent_sessions(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of recent session summaries to include in the agent's prompt context.
        """
        return pulumi.get(self, "max_recent_sessions")

    @max_recent_sessions.setter
    def max_recent_sessions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_recent_sessions", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationArgsDict(TypedDict):
        override_lambda: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict']]]
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
elif False:
    AgentAgentPromptOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 override_lambda: pulumi.Input[_builtins.str],
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        """
        :param pulumi.Input[_builtins.str] override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @_builtins.property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "override_lambda", value)

    @_builtins.property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict(TypedDict):
        base_prompt_template: pulumi.Input[_builtins.str]
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict']]]
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        parser_mode: pulumi.Input[_builtins.str]
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_creation_mode: pulumi.Input[_builtins.str]
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_state: pulumi.Input[_builtins.str]
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        prompt_type: pulumi.Input[_builtins.str]
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationArgs:
    def __init__(__self__, *,
                 base_prompt_template: pulumi.Input[_builtins.str],
                 inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]],
                 parser_mode: pulumi.Input[_builtins.str],
                 prompt_creation_mode: pulumi.Input[_builtins.str],
                 prompt_state: pulumi.Input[_builtins.str],
                 prompt_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param pulumi.Input[_builtins.str] parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[_builtins.str] prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[_builtins.str] prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[_builtins.str] prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @_builtins.property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> pulumi.Input[_builtins.str]:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_prompt_template", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @inference_configurations.setter
    def inference_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]):
        pulumi.set(self, "inference_configurations", value)

    @_builtins.property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parser_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_creation_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_state", value)

    @_builtins.property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> pulumi.Input[_builtins.str]:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_type", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict(TypedDict):
        max_length: pulumi.Input[_builtins.int]
        """
        Maximum number of tokens to allow in the generated response.
        """
        stop_sequences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        temperature: pulumi.Input[_builtins.float]
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        top_k: pulumi.Input[_builtins.int]
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        top_p: pulumi.Input[_builtins.float]
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_length: pulumi.Input[_builtins.int],
                 stop_sequences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 temperature: pulumi.Input[_builtins.float],
                 top_k: pulumi.Input[_builtins.int],
                 top_p: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.int] max_length: Maximum number of tokens to allow in the generated response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param pulumi.Input[_builtins.float] temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param pulumi.Input[_builtins.int] top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param pulumi.Input[_builtins.float] top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> pulumi.Input[_builtins.float]:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> pulumi.Input[_builtins.int]:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "top_k", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> pulumi.Input[_builtins.float]:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentAgentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        confluence_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict']]
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        s3_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict']]
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        salesforce_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict']]
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        share_point_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict']]
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        web_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict']]
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 confluence_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']] = None,
                 web_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs'] confluence_configuration: Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs'] s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs'] salesforce_configuration: Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs'] share_point_configuration: Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs'] web_configuration: Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]:
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @_builtins.property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]:
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]:
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @_builtins.property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]:
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        return pulumi.get(self, "web_configuration")

    @web_configuration.setter
    def web_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]):
        pulumi.set(self, "web_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_type: pulumi.Input[_builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input[_builtins.str],
                 host_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[_builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_arn: pulumi.Input[_builtins.str]
        """
        ARN of the bucket that contains the data source.
        """
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bucket account owner ID for the S3 bucket.
        """
        inclusion_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
elif False:
    AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_arn: ARN of the bucket that contains the data source.
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        domain: pulumi.Input[_builtins.str]
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        host_type: pulumi.Input[_builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of one or more SharePoint site URLs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of your Microsoft 365 tenant.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 domain: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input[_builtins.str],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] domain: The domain of your SharePoint instance or site URL/URLs.
        :param pulumi.Input[_builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] site_urls: A list of one or more SharePoint site URLs.
        :param pulumi.Input[_builtins.str] tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "site_urls", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict(TypedDict):
        crawler_limits: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict']]
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope of what is crawled for your URLs.
        """
        user_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 crawler_limits: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']] = None,
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 user_agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs'] crawler_limits: Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclusion_filters: List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_filters: List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        :param pulumi.Input[_builtins.str] scope: Scope of what is crawled for your URLs.
        :param pulumi.Input[_builtins.str] user_agent: String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @_builtins.property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]:
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        return pulumi.get(self, "crawler_limits")

    @crawler_limits.setter
    def crawler_limits(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]):
        pulumi.set(self, "crawler_limits", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope of what is crawled for your URLs.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_agent", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict(TypedDict):
        max_pages: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        rate_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs:
    def __init__(__self__, *,
                 max_pages: Optional[pulumi.Input[_builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_pages: Max number of web pages crawled from your source URLs, up to 25,000 pages.
        :param pulumi.Input[_builtins.int] rate_limit: Max rate at which pages are crawled, up to 300 per minute per host.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        return pulumi.get(self, "max_pages")

    @max_pages.setter
    def max_pages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pages", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict(TypedDict):
        url_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict']]
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 url_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs'] url_configuration: The URL configuration of your web data source. See `url_configuration` block for details.
        """
        if url_configuration is not None:
            pulumi.set(__self__, "url_configuration", url_configuration)

    @_builtins.property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]:
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
        return pulumi.get(self, "url_configuration")

    @url_configuration.setter
    def url_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]):
        pulumi.set(self, "url_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict(TypedDict):
        seed_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict']]]]
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]] seed_urls: List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        if seed_urls is not None:
            pulumi.set(__self__, "seed_urls", seed_urls)

    @_builtins.property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]:
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]):
        pulumi.set(self, "seed_urls", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AgentDataSourceServerSideEncryptionConfigurationArgsDict(TypedDict):
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
elif False:
    AgentDataSourceServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class AgentDataSourceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentDataSourceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationArgsDict(TypedDict):
        chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict']]
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        custom_transformation_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict']]
        """
        Configuration for custom transformation of data source documents.
        """
        parsing_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict']]
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs'] custom_transformation_configuration: Configuration for custom transformation of data source documents.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs'] parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]:
        """
        Configuration for custom transformation of data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @_builtins.property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict(TypedDict):
        chunking_strategy: pulumi.Input[_builtins.str]
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        fixed_size_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        hierarchical_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        semantic_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input[_builtins.str],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input[_builtins.str]:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "chunking_strategy", value)

    @_builtins.property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[_builtins.int]
        """
        Maximum number of tokens to include in a chunk.
        """
        overlap_percentage: pulumi.Input[_builtins.int]
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int],
                 overlap_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to include in a chunk.
        :param pulumi.Input[_builtins.int] overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_percentage", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict(TypedDict):
        level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict']]]
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        overlap_tokens: pulumi.Input[_builtins.int]
        """
        The number of tokens to repeat across chunks in the same layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param pulumi.Input[_builtins.int] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @_builtins.property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @_builtins.property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict(TypedDict):
        breakpoint_percentile_threshold: pulumi.Input[_builtins.int]
        """
        The dissimilarity threshold for splitting chunks.
        """
        buffer_size: pulumi.Input[_builtins.int]
        """
        The buffer size.
        """
        max_token: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens a chunk can contain.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[_builtins.int],
                 buffer_size: pulumi.Input[_builtins.int],
                 max_token: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[_builtins.int] buffer_size: The buffer size.
        :param pulumi.Input[_builtins.int] max_token: The maximum number of tokens a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @_builtins.property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[_builtins.int]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "buffer_size", value)

    @_builtins.property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens a chunk can contain.
        """
        return pulumi.get(self, "max_token")

    @max_token.setter
    def max_token(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_token", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict(TypedDict):
        intermediate_storage: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict']]
        """
        The intermediate storage for custom transformation.
        """
        transformation: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict']]
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']] = None,
                 transformation: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs'] intermediate_storage: The intermediate storage for custom transformation.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs'] transformation: A custom processing step for documents moving through the data source ingestion pipeline.
        """
        if intermediate_storage is not None:
            pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)

    @_builtins.property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]:
        """
        The intermediate storage for custom transformation.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]):
        pulumi.set(self, "intermediate_storage", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]:
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]):
        pulumi.set(self, "transformation", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict(TypedDict):
        s3_location: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict']]
        """
        Configuration block for intermedia S3 storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs'] s3_location: Configuration block for intermedia S3 storage.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]:
        """
        Configuration block for intermedia S3 storage.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        S3 URI for intermediate storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] uri: S3 URI for intermediate storage.
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        S3 URI for intermediate storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict(TypedDict):
        step_to_apply: pulumi.Input[_builtins.str]
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        transformation_function: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict']]
        """
        The lambda function that processes documents.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input[_builtins.str],
                 transformation_function: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] step_to_apply: When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs'] transformation_function: The lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        if transformation_function is not None:
            pulumi.set(__self__, "transformation_function", transformation_function)

    @_builtins.property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input[_builtins.str]:
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_to_apply", value)

    @_builtins.property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]:
        """
        The lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]):
        pulumi.set(self, "transformation_function", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict(TypedDict):
        transformation_lambda_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict']]
        """
        The configuration of the lambda function.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The configuration of the lambda function.
        """
        if transformation_lambda_configuration is not None:
            pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @_builtins.property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]:
        """
        The configuration of the lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]):
        pulumi.set(self, "transformation_lambda_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict(TypedDict):
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the lambda to use for custom transformation.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] lambda_arn: The ARN of the lambda to use for custom transformation.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the lambda to use for custom transformation.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict(TypedDict):
        parsing_strategy: pulumi.Input[_builtins.str]
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict']]
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input[_builtins.str],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input[_builtins.str]:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parsing_strategy", value)

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the model used to parse documents
        """
        parsing_prompt: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict']]
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str],
                 parsing_prompt: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] model_arn: The ARN of the model used to parse documents
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)

    @_builtins.property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict(TypedDict):
        parsing_prompt_string: pulumi.Input[_builtins.str]
        """
        Instructions for interpreting the contents of the document.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_string: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @_builtins.property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> pulumi.Input[_builtins.str]:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")

    @parsing_prompt_string.setter
    def parsing_prompt_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parsing_prompt_string", value)


if not MYPY:
    class AgentFlowDefinitionArgsDict(TypedDict):
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgsDict']]]]
        """
        A list of connection definitions in the flow. See Connection for more information.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgsDict']]]]
        """
        A list of node definitions in the flow. See Node for more information.
        """
elif False:
    AgentFlowDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]] connections: A list of connection definitions in the flow. See Connection for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]] nodes: A list of node definitions in the flow. See Node for more information.
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]]:
        """
        A list of connection definitions in the flow. See Connection for more information.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]]):
        pulumi.set(self, "connections", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]]:
        """
        A list of node definitions in the flow. See Node for more information.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class AgentFlowDefinitionConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the connection that you can reference.
        """
        source: pulumi.Input[_builtins.str]
        """
        The node that the connection starts at.
        """
        target: pulumi.Input[_builtins.str]
        """
        The node that the connection ends at.
        """
        type: pulumi.Input[_builtins.str]
        """
        Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        """
        configuration: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgsDict']]
        """
        Configuration of the connection. See Connection Configuration for more information.
        """
elif False:
    AgentFlowDefinitionConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the connection that you can reference.
        :param pulumi.Input[_builtins.str] source: The node that the connection starts at.
        :param pulumi.Input[_builtins.str] target: The node that the connection ends at.
        :param pulumi.Input[_builtins.str] type: Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs'] configuration: Configuration of the connection. See Connection Configuration for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the connection that you can reference.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        The node that the connection starts at.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        The node that the connection ends at.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']]:
        """
        Configuration of the connection. See Connection Configuration for more information.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']]):
        pulumi.set(self, "configuration", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationArgsDict(TypedDict):
        conditional: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgsDict']]
        """
        The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        """
        data: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgsDict']]
        """
        The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
elif False:
    AgentFlowDefinitionConnectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationArgs:
    def __init__(__self__, *,
                 conditional: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']] = None,
                 data: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs'] conditional: The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs'] data: The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']]:
        """
        The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']]):
        pulumi.set(self, "conditional", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']]:
        """
        The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']]):
        pulumi.set(self, "data", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationConditionalArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionConnectionConfigurationConditionalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationConditionalArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationDataArgsDict(TypedDict):
        source_output: pulumi.Input[_builtins.str]
        """
        The name of the output in the source node that the connection begins from.
        """
        target_input: pulumi.Input[_builtins.str]
        """
        The name of the input in the target node that the connection ends at.
        """
elif False:
    AgentFlowDefinitionConnectionConfigurationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationDataArgs:
    def __init__(__self__, *,
                 source_output: pulumi.Input[_builtins.str],
                 target_input: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] source_output: The name of the output in the source node that the connection begins from.
        :param pulumi.Input[_builtins.str] target_input: The name of the input in the target node that the connection ends at.
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @_builtins.property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the output in the source node that the connection begins from.
        """
        return pulumi.get(self, "source_output")

    @source_output.setter
    def source_output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_output", value)

    @_builtins.property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the input in the target node that the connection ends at.
        """
        return pulumi.get(self, "target_input")

    @target_input.setter
    def target_input(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_input", value)


if not MYPY:
    class AgentFlowDefinitionNodeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the node.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        """
        configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgsDict']]
        """
        Contains configurations for the node. See Node Configuration for more information.
        """
        inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgsDict']]]]
        """
        A list of objects containing information about an input into the node. See Node Input for more information.
        """
        outputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgsDict']]]]
        """
        A list of objects containing information about an output from the node. See Node Output for more information.
        """
elif False:
    AgentFlowDefinitionNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]] = None,
                 outputs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the node.
        :param pulumi.Input[_builtins.str] type: The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs'] configuration: Contains configurations for the node. See Node Configuration for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]] inputs: A list of objects containing information about an input into the node. See Node Input for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]] outputs: A list of objects containing information about an output from the node. See Node Output for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']]:
        """
        Contains configurations for the node. See Node Configuration for more information.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]]:
        """
        A list of objects containing information about an input into the node. See Node Input for more information.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]]:
        """
        A list of objects containing information about an output from the node. See Node Output for more information.
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]]):
        pulumi.set(self, "outputs", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgsDict']]
        """
        Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        """
        collector: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgsDict']]
        """
        Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        """
        condition: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgsDict']]
        inline_code: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict']]
        """
        Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        """
        input: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgsDict']]
        iterator: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgsDict']]
        """
        Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        """
        knowledge_base: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict']]
        """
        Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        """
        lambda_function: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict']]
        """
        Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        """
        lex: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgsDict']]
        """
        Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        """
        output: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgsDict']]
        prompt: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgsDict']]
        """
        Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        """
        retrieval: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgsDict']]
        """
        Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        """
        storage: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgsDict']]
        """
        Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']] = None,
                 collector: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']] = None,
                 condition: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']] = None,
                 inline_code: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']] = None,
                 input: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']] = None,
                 iterator: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']] = None,
                 knowledge_base: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']] = None,
                 lambda_function: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']] = None,
                 lex: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']] = None,
                 output: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']] = None,
                 prompt: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']] = None,
                 retrieval: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']] = None,
                 storage: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs'] agent: Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs'] collector: Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs'] inline_code: Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs'] iterator: Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs'] knowledge_base: Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs'] lambda_function: Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs'] lex: Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs'] prompt: Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs'] retrieval: Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs'] storage: Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if collector is not None:
            pulumi.set(__self__, "collector", collector)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if inline_code is not None:
            pulumi.set(__self__, "inline_code", inline_code)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if iterator is not None:
            pulumi.set(__self__, "iterator", iterator)
        if knowledge_base is not None:
            pulumi.set(__self__, "knowledge_base", knowledge_base)
        if lambda_function is not None:
            pulumi.set(__self__, "lambda_function", lambda_function)
        if lex is not None:
            pulumi.set(__self__, "lex", lex)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if retrieval is not None:
            pulumi.set(__self__, "retrieval", retrieval)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']]:
        """
        Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter
    def collector(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']]:
        """
        Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        """
        return pulumi.get(self, "collector")

    @collector.setter
    def collector(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']]):
        pulumi.set(self, "collector", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']]:
        """
        Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        """
        return pulumi.get(self, "inline_code")

    @inline_code.setter
    def inline_code(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']]):
        pulumi.set(self, "inline_code", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']]:
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def iterator(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']]:
        """
        Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        """
        return pulumi.get(self, "iterator")

    @iterator.setter
    def iterator(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']]):
        pulumi.set(self, "iterator", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']]:
        """
        Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        """
        return pulumi.get(self, "knowledge_base")

    @knowledge_base.setter
    def knowledge_base(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']]):
        pulumi.set(self, "knowledge_base", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']]:
        """
        Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        """
        return pulumi.get(self, "lambda_function")

    @lambda_function.setter
    def lambda_function(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']]):
        pulumi.set(self, "lambda_function", value)

    @_builtins.property
    @pulumi.getter
    def lex(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']]:
        """
        Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        """
        return pulumi.get(self, "lex")

    @lex.setter
    def lex(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']]):
        pulumi.set(self, "lex", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']]:
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']]:
        """
        Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter
    def retrieval(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']]:
        """
        Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        """
        return pulumi.get(self, "retrieval")

    @retrieval.setter
    def retrieval(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']]):
        pulumi.set(self, "retrieval", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']]:
        """
        Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationAgentArgsDict(TypedDict):
        agent_alias_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationAgentArgs:
    def __init__(__self__, *,
                 agent_alias_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_alias_arn: The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
        pulumi.set(__self__, "agent_alias_arn", agent_alias_arn)

    @_builtins.property
    @pulumi.getter(name="agentAliasArn")
    def agent_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
        return pulumi.get(self, "agent_alias_arn")

    @agent_alias_arn.setter
    def agent_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_alias_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationCollectorArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationCollectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationCollectorArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict']]]
elif False:
    AgentFlowDefinitionNodeConfigurationConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]):
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationConditionConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        The code that's executed in your inline code node.
        """
        language: pulumi.Input[_builtins.str]
        """
        The programming language used by your inline code node.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationInlineCodeArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 language: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] code: The code that's executed in your inline code node.
        :param pulumi.Input[_builtins.str] language: The programming language used by your inline code node.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        The code that's executed in your inline code node.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> pulumi.Input[_builtins.str]:
        """
        The programming language used by your inline code node.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationInputArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationInputArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationIteratorArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationIteratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationIteratorArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict(TypedDict):
        knowledge_base_id: pulumi.Input[_builtins.str]
        """
        The unique identifier of the knowledge base to query.
        """
        model_id: pulumi.Input[_builtins.str]
        guardrail_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict']]
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        number_of_results: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs:
    def __init__(__self__, *,
                 knowledge_base_id: pulumi.Input[_builtins.str],
                 model_id: pulumi.Input[_builtins.str],
                 guardrail_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']] = None,
                 number_of_results: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] knowledge_base_id: The unique identifier of the knowledge base to query.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs'] guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        pulumi.set(__self__, "model_id", model_id)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if number_of_results is not None:
            pulumi.set(__self__, "number_of_results", number_of_results)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the knowledge base to query.
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "knowledge_base_id", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']]:
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="numberOfResults")
    def number_of_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "number_of_results")

    @number_of_results.setter
    def number_of_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_results", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        The unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        The version of the guardrail.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: The unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: The version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']] = None):
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict(TypedDict):
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] lambda_arn: The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationLexArgsDict(TypedDict):
        bot_alias_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        """
        locale_id: pulumi.Input[_builtins.str]
        """
        The Region to invoke the Amazon Lex bot in
        """
elif False:
    AgentFlowDefinitionNodeConfigurationLexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationLexArgs:
    def __init__(__self__, *,
                 bot_alias_arn: pulumi.Input[_builtins.str],
                 locale_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bot_alias_arn: The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        :param pulumi.Input[_builtins.str] locale_id: The Region to invoke the Amazon Lex bot in
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        """
        return pulumi.get(self, "bot_alias_arn")

    @bot_alias_arn.setter
    def bot_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bot_alias_arn", value)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Region to invoke the Amazon Lex bot in
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationOutputArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationOutputArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptArgsDict(TypedDict):
        guardrail_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict']]
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        source_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptArgs:
    def __init__(__self__, *,
                 guardrail_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs'] guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']]:
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        The unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        The version of the guardrail.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: The unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: The version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict(TypedDict):
        inline: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict']]
        """
        Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        """
        resource: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict']]
        """
        Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs:
    def __init__(__self__, *,
                 inline: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']] = None,
                 resource: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs'] inline: Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs'] resource: Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
        if inline is not None:
            pulumi.set(__self__, "inline", inline)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']]:
        """
        Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        """
        return pulumi.get(self, "inline")

    @inline.setter
    def inline(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']]):
        pulumi.set(self, "inline", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']]:
        """
        Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict(TypedDict):
        model_id: pulumi.Input[_builtins.str]
        template_type: pulumi.Input[_builtins.str]
        """
        The type of prompt template. Valid values: `TEXT`, `CHAT`.
        """
        additional_model_request_fields: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional fields to be included in the model request for the Prompt node.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        template_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict']]
        """
        Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs:
    def __init__(__self__, *,
                 model_id: pulumi.Input[_builtins.str],
                 template_type: pulumi.Input[_builtins.str],
                 additional_model_request_fields: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']] = None,
                 template_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] template_type: The type of prompt template. Valid values: `TEXT`, `CHAT`.
        :param pulumi.Input[_builtins.str] additional_model_request_fields: Additional fields to be included in the model request for the Prompt node.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs'] template_configuration: Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of prompt template. Valid values: `TEXT`, `CHAT`.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional fields to be included in the model request for the Prompt node.
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']]:
        """
        Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']]):
        pulumi.set(self, "template_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']] = None):
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict(TypedDict):
        chat: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict']]
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs:
    def __init__(__self__, *,
                 chat: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']] = None,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs'] chat: Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        if chat is not None:
            pulumi.set(__self__, "chat", chat)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']]:
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        return pulumi.get(self, "chat")

    @chat.setter
    def chat(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']]):
        pulumi.set(self, "chat", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict']]]]
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict']]]]
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        systems: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict']]]]
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        tool_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict']]
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]] = None,
                 systems: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]] = None,
                 tool_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]] messages: A list of messages in the chat for the prompt. See Message for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]] systems: A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs'] tool_configuration: Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if systems is not None:
            pulumi.set(__self__, "systems", systems)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]]:
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter
    def systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]]:
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        return pulumi.get(self, "systems")

    @systems.setter
    def systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]]):
        pulumi.set(self, "systems", value)

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']]:
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        return pulumi.get(self, "tool_configuration")

    @tool_configuration.setter
    def tool_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']]):
        pulumi.set(self, "tool_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The role that the message belongs to.
        """
        content: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict']]
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] role: The role that the message belongs to.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs'] content: Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        pulumi.set(__self__, "role", role)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the message belongs to.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']]:
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']]):
        pulumi.set(self, "content", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict']]
        text: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text in the system prompt.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input[_builtins.str] text: The text in the system prompt.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text in the system prompt.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict(TypedDict):
        tool_choice: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict']]
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict']]]]
        """
        A list of tools to pass to a model. See Tool for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs:
    def __init__(__self__, *,
                 tool_choice: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs'] tool_choice: Defines which tools the model should request when invoked. See Tool Choice for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]] tools: A list of tools to pass to a model. See Tool for more information.
        """
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']]:
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        return pulumi.get(self, "tool_choice")

    @tool_choice.setter
    def tool_choice(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']]):
        pulumi.set(self, "tool_choice", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]]:
        """
        A list of tools to pass to a model. See Tool for more information.
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]]):
        pulumi.set(self, "tools", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        tool_spec: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict']]
        """
        The specification for the tool. See Tool Specification for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']] = None,
                 tool_spec: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs'] tool_spec: The specification for the tool. See Tool Specification for more information.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if tool_spec is not None:
            pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]:
        """
        The specification for the tool. See Tool Specification for more information.
        """
        return pulumi.get(self, "tool_spec")

    @tool_spec.setter
    def tool_spec(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]):
        pulumi.set(self, "tool_spec", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict(TypedDict):
        any: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict']]
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        auto: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict']]
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        tool: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict']]
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']] = None,
                 auto: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']] = None,
                 tool: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs'] any: Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs'] auto: Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs'] tool: Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]:
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]):
        pulumi.set(self, "any", value)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]:
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        return pulumi.get(self, "auto")

    @auto.setter
    def auto(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]):
        pulumi.set(self, "auto", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]:
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the flow.
        """
        input_schema: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict']]
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_schema: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        :param pulumi.Input[_builtins.str] description: A description for the flow.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs'] input_schema: The input schema of the tool. See Tool Input Schema for more information.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the flow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]:
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]):
        pulumi.set(self, "input_schema", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict(TypedDict):
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON object defining the input schema for the tool.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs:
    def __init__(__self__, *,
                 json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] json: A JSON object defining the input schema for the tool.
        """
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON object defining the input schema for the tool.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict']]
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict']]]]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']] = None,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]] = None):
        pulumi.set(__self__, "text", text)
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict(TypedDict):
        prompt_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the prompt from Prompt management.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs:
    def __init__(__self__, *,
                 prompt_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] prompt_arn: The Amazon Resource Name (ARN) of the prompt from Prompt management.
        """
        pulumi.set(__self__, "prompt_arn", prompt_arn)

    @_builtins.property
    @pulumi.getter(name="promptArn")
    def prompt_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the prompt from Prompt management.
        """
        return pulumi.get(self, "prompt_arn")

    @prompt_arn.setter
    def prompt_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalArgsDict(TypedDict):
        service_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalArgs:
    def __init__(__self__, *,
                 service_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']] = None):
        if service_configuration is not None:
            pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']]:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']]):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']] = None):
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageArgsDict(TypedDict):
        service_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageArgs:
    def __init__(__self__, *,
                 service_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']] = None):
        if service_configuration is not None:
            pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']]:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']]):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']] = None):
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class AgentFlowDefinitionNodeInputArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        type: pulumi.Input[_builtins.str]
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        How input data flows between iterations in a DoWhile loop.
        """
elif False:
    AgentFlowDefinitionNodeInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeInputArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 category: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        :param pulumi.Input[_builtins.str] category: How input data flows between iterations in a DoWhile loop.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if category is not None:
            pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How input data flows between iterations in a DoWhile loop.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)


if not MYPY:
    class AgentFlowDefinitionNodeOutputArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        type: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeOutputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentFlowTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`, `KENDRA`, `SQL`.
        """
        kendra_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgsDict']]
        """
        Settings for an Amazon Kendra knowledge base. See `kendra_knowledge_base_configuration` block for details.
        """
        sql_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgsDict']]
        """
        Configurations for a knowledge base connected to an SQL database. See `sql_knowledge_base_configuration` block for details.
        """
        vector_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict']]
        """
        Details about the model that's used to convert the data source into vector embeddings. See `vector_knowledge_base_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 kendra_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs']] = None,
                 sql_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs']] = None,
                 vector_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`, `KENDRA`, `SQL`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs'] kendra_knowledge_base_configuration: Settings for an Amazon Kendra knowledge base. See `kendra_knowledge_base_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs'] sql_knowledge_base_configuration: Configurations for a knowledge base connected to an SQL database. See `sql_knowledge_base_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Details about the model that's used to convert the data source into vector embeddings. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if kendra_knowledge_base_configuration is not None:
            pulumi.set(__self__, "kendra_knowledge_base_configuration", kendra_knowledge_base_configuration)
        if sql_knowledge_base_configuration is not None:
            pulumi.set(__self__, "sql_knowledge_base_configuration", sql_knowledge_base_configuration)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`, `KENDRA`, `SQL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="kendraKnowledgeBaseConfiguration")
    def kendra_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs']]:
        """
        Settings for an Amazon Kendra knowledge base. See `kendra_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "kendra_knowledge_base_configuration")

    @kendra_knowledge_base_configuration.setter
    def kendra_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "kendra_knowledge_base_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sqlKnowledgeBaseConfiguration")
    def sql_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs']]:
        """
        Configurations for a knowledge base connected to an SQL database. See `sql_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "sql_knowledge_base_configuration")

    @sql_knowledge_base_configuration.setter
    def sql_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "sql_knowledge_base_configuration", value)

    @_builtins.property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]:
        """
        Details about the model that's used to convert the data source into vector embeddings. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgsDict(TypedDict):
        kendra_index_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Amazon Kendra index.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationKendraKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 kendra_index_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] kendra_index_arn: ARN of the Amazon Kendra index.
        """
        pulumi.set(__self__, "kendra_index_arn", kendra_index_arn)

    @_builtins.property
    @pulumi.getter(name="kendraIndexArn")
    def kendra_index_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Amazon Kendra index.
        """
        return pulumi.get(self, "kendra_index_arn")

    @kendra_index_arn.setter
    def kendra_index_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kendra_index_arn", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of SQL database to connect to the knowledge base. Valid values: `REDSHIFT`.
        """
        redshift_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgsDict']]
        """
        Configurations for a knowledge base connected to an Amazon Redshift database. See `redshift_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 redshift_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of SQL database to connect to the knowledge base. Valid values: `REDSHIFT`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs'] redshift_configuration: Configurations for a knowledge base connected to an Amazon Redshift database. See `redshift_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of SQL database to connect to the knowledge base. Valid values: `REDSHIFT`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs']]:
        """
        Configurations for a knowledge base connected to an Amazon Redshift database. See `redshift_configuration` block for details.
        """
        return pulumi.get(self, "redshift_configuration")

    @redshift_configuration.setter
    def redshift_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs']]):
        pulumi.set(self, "redshift_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgsDict(TypedDict):
        query_engine_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgsDict']]
        """
        Configurations for an Amazon Redshift query engine. See `query_engine_configuration` block for details.
        """
        query_generation_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgsDict']]
        """
        Configurations for generating queries. See `query_generation_configuration` block for details.
        """
        storage_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgsDict']]
        """
        Configurations for Amazon Redshift database storage. See `storage_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationArgs:
    def __init__(__self__, *,
                 query_engine_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs']] = None,
                 query_generation_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs']] = None,
                 storage_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs'] query_engine_configuration: Configurations for an Amazon Redshift query engine. See `query_engine_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs'] query_generation_configuration: Configurations for generating queries. See `query_generation_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs'] storage_configuration: Configurations for Amazon Redshift database storage. See `storage_configuration` block for details.
        """
        if query_engine_configuration is not None:
            pulumi.set(__self__, "query_engine_configuration", query_engine_configuration)
        if query_generation_configuration is not None:
            pulumi.set(__self__, "query_generation_configuration", query_generation_configuration)
        if storage_configuration is not None:
            pulumi.set(__self__, "storage_configuration", storage_configuration)

    @_builtins.property
    @pulumi.getter(name="queryEngineConfiguration")
    def query_engine_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs']]:
        """
        Configurations for an Amazon Redshift query engine. See `query_engine_configuration` block for details.
        """
        return pulumi.get(self, "query_engine_configuration")

    @query_engine_configuration.setter
    def query_engine_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs']]):
        pulumi.set(self, "query_engine_configuration", value)

    @_builtins.property
    @pulumi.getter(name="queryGenerationConfiguration")
    def query_generation_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs']]:
        """
        Configurations for generating queries. See `query_generation_configuration` block for details.
        """
        return pulumi.get(self, "query_generation_configuration")

    @query_generation_configuration.setter
    def query_generation_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs']]):
        pulumi.set(self, "query_generation_configuration", value)

    @_builtins.property
    @pulumi.getter(name="storageConfiguration")
    def storage_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs']]:
        """
        Configurations for Amazon Redshift database storage. See `storage_configuration` block for details.
        """
        return pulumi.get(self, "storage_configuration")

    @storage_configuration.setter
    def storage_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs']]):
        pulumi.set(self, "storage_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of query engine. Valid values: `SERVERLESS`, `PROVISIONED`.
        """
        provisioned_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgsDict']]
        """
        Configurations for a provisioned Amazon Redshift query engine. See `provisioned_configuration` block for details.
        """
        serverless_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgsDict']]
        """
        Configurations for a serverless Amazon Redshift query engine. See `serverless_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 provisioned_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs']] = None,
                 serverless_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of query engine. Valid values: `SERVERLESS`, `PROVISIONED`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs'] provisioned_configuration: Configurations for a provisioned Amazon Redshift query engine. See `provisioned_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs'] serverless_configuration: Configurations for a serverless Amazon Redshift query engine. See `serverless_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if provisioned_configuration is not None:
            pulumi.set(__self__, "provisioned_configuration", provisioned_configuration)
        if serverless_configuration is not None:
            pulumi.set(__self__, "serverless_configuration", serverless_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of query engine. Valid values: `SERVERLESS`, `PROVISIONED`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="provisionedConfiguration")
    def provisioned_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs']]:
        """
        Configurations for a provisioned Amazon Redshift query engine. See `provisioned_configuration` block for details.
        """
        return pulumi.get(self, "provisioned_configuration")

    @provisioned_configuration.setter
    def provisioned_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs']]):
        pulumi.set(self, "provisioned_configuration", value)

    @_builtins.property
    @pulumi.getter(name="serverlessConfiguration")
    def serverless_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs']]:
        """
        Configurations for a serverless Amazon Redshift query engine. See `serverless_configuration` block for details.
        """
        return pulumi.get(self, "serverless_configuration")

    @serverless_configuration.setter
    def serverless_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs']]):
        pulumi.set(self, "serverless_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgsDict(TypedDict):
        cluster_identifier: pulumi.Input[_builtins.str]
        """
        ID of the Amazon Redshift cluster.
        """
        auth_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgsDict']]
        """
        Configurations for authentication to Amazon Redshift. See `auth_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationArgs:
    def __init__(__self__, *,
                 cluster_identifier: pulumi.Input[_builtins.str],
                 auth_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_identifier: ID of the Amazon Redshift cluster.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs'] auth_configuration: Configurations for authentication to Amazon Redshift. See `auth_configuration` block for details.
        """
        pulumi.set(__self__, "cluster_identifier", cluster_identifier)
        if auth_configuration is not None:
            pulumi.set(__self__, "auth_configuration", auth_configuration)

    @_builtins.property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the Amazon Redshift cluster.
        """
        return pulumi.get(self, "cluster_identifier")

    @cluster_identifier.setter
    def cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_identifier", value)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs']]:
        """
        Configurations for authentication to Amazon Redshift. See `auth_configuration` block for details.
        """
        return pulumi.get(self, "auth_configuration")

    @auth_configuration.setter
    def auth_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs']]):
        pulumi.set(self, "auth_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        """
        database_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database username for authentication to an Amazon Redshift provisioned data warehouse.
        """
        username_password_secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of a Secrets Manager secret for authentication.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationProvisionedConfigurationAuthConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 database_user: Optional[pulumi.Input[_builtins.str]] = None,
                 username_password_secret_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        :param pulumi.Input[_builtins.str] database_user: Database username for authentication to an Amazon Redshift provisioned data warehouse.
        :param pulumi.Input[_builtins.str] username_password_secret_arn: ARN of a Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if database_user is not None:
            pulumi.set(__self__, "database_user", database_user)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="databaseUser")
    def database_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database username for authentication to an Amazon Redshift provisioned data warehouse.
        """
        return pulumi.get(self, "database_user")

    @database_user.setter
    def database_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_user", value)

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of a Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")

    @username_password_secret_arn.setter
    def username_password_secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_password_secret_arn", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgsDict(TypedDict):
        workgroup_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Amazon Redshift workgroup.
        """
        auth_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgsDict']]
        """
        Configurations for authentication to a Redshift Serverless. See `auth_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationArgs:
    def __init__(__self__, *,
                 workgroup_arn: pulumi.Input[_builtins.str],
                 auth_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] workgroup_arn: ARN of the Amazon Redshift workgroup.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs'] auth_configuration: Configurations for authentication to a Redshift Serverless. See `auth_configuration` block for details.
        """
        pulumi.set(__self__, "workgroup_arn", workgroup_arn)
        if auth_configuration is not None:
            pulumi.set(__self__, "auth_configuration", auth_configuration)

    @_builtins.property
    @pulumi.getter(name="workgroupArn")
    def workgroup_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Amazon Redshift workgroup.
        """
        return pulumi.get(self, "workgroup_arn")

    @workgroup_arn.setter
    def workgroup_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workgroup_arn", value)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs']]:
        """
        Configurations for authentication to a Redshift Serverless. See `auth_configuration` block for details.
        """
        return pulumi.get(self, "auth_configuration")

    @auth_configuration.setter
    def auth_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs']]):
        pulumi.set(self, "auth_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        """
        username_password_secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of a Secrets Manager secret for authentication.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryEngineConfigurationServerlessConfigurationAuthConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 username_password_secret_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        :param pulumi.Input[_builtins.str] username_password_secret_arn: ARN of a Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of authentication to use. Valid values: `IAM`, `USERNAME_PASSWORD`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of a Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")

    @username_password_secret_arn.setter
    def username_password_secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_password_secret_arn", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgsDict(TypedDict):
        execution_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time after which query generation will time out.
        """
        generation_context: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgsDict']]
        """
        Configurations for context to use during query generation. See `generation_context` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationArgs:
    def __init__(__self__, *,
                 execution_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 generation_context: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] execution_timeout_seconds: Time after which query generation will time out.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs'] generation_context: Configurations for context to use during query generation. See `generation_context` block for details.
        """
        if execution_timeout_seconds is not None:
            pulumi.set(__self__, "execution_timeout_seconds", execution_timeout_seconds)
        if generation_context is not None:
            pulumi.set(__self__, "generation_context", generation_context)

    @_builtins.property
    @pulumi.getter(name="executionTimeoutSeconds")
    def execution_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time after which query generation will time out.
        """
        return pulumi.get(self, "execution_timeout_seconds")

    @execution_timeout_seconds.setter
    def execution_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "execution_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="generationContext")
    def generation_context(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs']]:
        """
        Configurations for context to use during query generation. See `generation_context` block for details.
        """
        return pulumi.get(self, "generation_context")

    @generation_context.setter
    def generation_context(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs']]):
        pulumi.set(self, "generation_context", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgsDict(TypedDict):
        curated_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgsDict']]]]
        """
        Information about example queries to help the query engine generate appropriate SQL queries. See `curated_query` block for details.
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgsDict']]]]
        """
        Information about a table in the database. See `table` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextArgs:
    def __init__(__self__, *,
                 curated_queries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs']]]] = None,
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs']]] curated_queries: Information about example queries to help the query engine generate appropriate SQL queries. See `curated_query` block for details.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs']]] tables: Information about a table in the database. See `table` block for details.
        """
        if curated_queries is not None:
            pulumi.set(__self__, "curated_queries", curated_queries)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter(name="curatedQueries")
    def curated_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs']]]]:
        """
        Information about example queries to help the query engine generate appropriate SQL queries. See `curated_query` block for details.
        """
        return pulumi.get(self, "curated_queries")

    @curated_queries.setter
    def curated_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs']]]]):
        pulumi.set(self, "curated_queries", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs']]]]:
        """
        Information about a table in the database. See `table` block for details.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs']]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgsDict(TypedDict):
        natural_language: pulumi.Input[_builtins.str]
        """
        Example natural language query.
        """
        sql: pulumi.Input[_builtins.str]
        """
        SQL equivalent of `natural_language`.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextCuratedQueryArgs:
    def __init__(__self__, *,
                 natural_language: pulumi.Input[_builtins.str],
                 sql: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] natural_language: Example natural language query.
        :param pulumi.Input[_builtins.str] sql: SQL equivalent of `natural_language`.
        """
        pulumi.set(__self__, "natural_language", natural_language)
        pulumi.set(__self__, "sql", sql)

    @_builtins.property
    @pulumi.getter(name="naturalLanguage")
    def natural_language(self) -> pulumi.Input[_builtins.str]:
        """
        Example natural language query.
        """
        return pulumi.get(self, "natural_language")

    @natural_language.setter
    def natural_language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "natural_language", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> pulumi.Input[_builtins.str]:
        """
        SQL equivalent of `natural_language`.
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sql", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the table for which the other fields in this object apply.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgsDict']]]]
        """
        Information about a column in the table. See `column` block for details.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the table that helps the query engine understand the contents of the table.
        """
        inclusion: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to include or exclude the table during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the table for which the other fields in this object apply.
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs']]] columns: Information about a column in the table. See `column` block for details.
        :param pulumi.Input[_builtins.str] description: Description of the table that helps the query engine understand the contents of the table.
        :param pulumi.Input[_builtins.str] inclusion: Whether to include or exclude the table during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        """
        pulumi.set(__self__, "name", name)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the table for which the other fields in this object apply.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs']]]]:
        """
        Information about a column in the table. See `column` block for details.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the table that helps the query engine understand the contents of the table.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to include or exclude the table during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        """
        return pulumi.get(self, "inclusion")

    @inclusion.setter
    def inclusion(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inclusion", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the column that helps the query engine understand the contents of the column.
        """
        inclusion: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to include or exclude the column during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the column for which the other fields in this object apply.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationQueryGenerationConfigurationGenerationContextTableColumnArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the column that helps the query engine understand the contents of the column.
        :param pulumi.Input[_builtins.str] inclusion: Whether to include or exclude the column during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        :param pulumi.Input[_builtins.str] name: Name of the column for which the other fields in this object apply.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the column that helps the query engine understand the contents of the column.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to include or exclude the column during query generation. Valid values `INCLUDE`, `EXCLUDE`.
        """
        return pulumi.get(self, "inclusion")

    @inclusion.setter
    def inclusion(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inclusion", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the column for which the other fields in this object apply.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        """
        aws_data_catalog_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgsDict']]
        """
        Configurations for storage in AWS Glue Data Catalog. See `aws_data_catalog_configuration` block for details.
        """
        redshift_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgsDict']]
        """
        Configurations for storage in Amazon Redshift. See `redshift_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 aws_data_catalog_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs']] = None,
                 redshift_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs'] aws_data_catalog_configuration: Configurations for storage in AWS Glue Data Catalog. See `aws_data_catalog_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs'] redshift_configuration: Configurations for storage in Amazon Redshift. See `redshift_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if aws_data_catalog_configuration is not None:
            pulumi.set(__self__, "aws_data_catalog_configuration", aws_data_catalog_configuration)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="awsDataCatalogConfiguration")
    def aws_data_catalog_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs']]:
        """
        Configurations for storage in AWS Glue Data Catalog. See `aws_data_catalog_configuration` block for details.
        """
        return pulumi.get(self, "aws_data_catalog_configuration")

    @aws_data_catalog_configuration.setter
    def aws_data_catalog_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs']]):
        pulumi.set(self, "aws_data_catalog_configuration", value)

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs']]:
        """
        Configurations for storage in Amazon Redshift. See `redshift_configuration` block for details.
        """
        return pulumi.get(self, "redshift_configuration")

    @redshift_configuration.setter
    def redshift_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs']]):
        pulumi.set(self, "redshift_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgsDict(TypedDict):
        table_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of names of the tables to use.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationAwsDataCatalogConfigurationArgs:
    def __init__(__self__, *,
                 table_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] table_names: List of names of the tables to use.
        """
        pulumi.set(__self__, "table_names", table_names)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of names of the tables to use.
        """
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "table_names", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        Name of the Amazon Redshift database.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationSqlKnowledgeBaseConfigurationRedshiftConfigurationStorageConfigurationRedshiftConfigurationArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] database_name: Name of the Amazon Redshift database.
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Amazon Redshift database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict(TypedDict):
        embedding_model_arn: pulumi.Input[_builtins.str]
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict']]
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        supplemental_data_storage_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict']]
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[_builtins.str],
                 embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']] = None,
                 supplemental_data_storage_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs'] embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs'] supplemental_data_storage_configuration: supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @_builtins.property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "embedding_model_arn", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @embedding_model_configuration.setter
    def embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "embedding_model_configuration", value)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]:
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")

    @supplemental_data_storage_configuration.setter
    def supplemental_data_storage_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]):
        pulumi.set(self, "supplemental_data_storage_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict(TypedDict):
        bedrock_embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict']]
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs'] bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]:
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")

    @bedrock_embedding_model_configuration.setter
    def bedrock_embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_embedding_model_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        embedding_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[_builtins.int]] = None,
                 embedding_data_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] dimensions: Dimension details for the vector configuration used on the Bedrock embeddings model.
        :param pulumi.Input[_builtins.str] embedding_data_type: Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        return pulumi.get(self, "embedding_data_type")

    @embedding_data_type.setter
    def embedding_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "embedding_data_type", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict(TypedDict):
        storage_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict']]]]
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs:
    def __init__(__self__, *,
                 storage_locations: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]] storage_locations: A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @_builtins.property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]:
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        return pulumi.get(self, "storage_locations")

    @storage_locations.setter
    def storage_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]):
        pulumi.set(self, "storage_locations", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        s3_location: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict']]
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 s3_location: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Storage service used for this location. `S3` is the only valid value.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs'] s3_location: Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]:
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        URI of the location.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] uri: URI of the location.
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the location.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        """
        mongo_db_atlas_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in MongoDB Atlas. See `mongo_db_atlas_configuration` block for details.
        """
        neptune_analytics_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon Neptune Analytics. See `neptune_analytics_configuration` block for details.
        """
        opensearch_managed_cluster_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service Managed Cluster. See `opensearch_managed_cluster_configuration` block for details.
        """
        opensearch_serverless_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service Serverless. See `opensearch_serverless_configuration` block for details.
        """
        pinecone_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        rds_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict']]
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        redis_enterprise_cloud_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        s3_vectors_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon S3 Vectors. See `s3_vectors_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 mongo_db_atlas_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs']] = None,
                 neptune_analytics_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs']] = None,
                 opensearch_managed_cluster_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs']] = None,
                 opensearch_serverless_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']] = None,
                 redis_enterprise_cloud_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']] = None,
                 s3_vectors_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs'] mongo_db_atlas_configuration: The storage configuration of the knowledge base in MongoDB Atlas. See `mongo_db_atlas_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs'] neptune_analytics_configuration: The storage configuration of the knowledge base in Amazon Neptune Analytics. See `neptune_analytics_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs'] opensearch_managed_cluster_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service Managed Cluster. See `opensearch_managed_cluster_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs'] opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service Serverless. See `opensearch_serverless_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs'] pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs'] rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs'] redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs'] s3_vectors_configuration: The storage configuration of the knowledge base in Amazon S3 Vectors. See `s3_vectors_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if mongo_db_atlas_configuration is not None:
            pulumi.set(__self__, "mongo_db_atlas_configuration", mongo_db_atlas_configuration)
        if neptune_analytics_configuration is not None:
            pulumi.set(__self__, "neptune_analytics_configuration", neptune_analytics_configuration)
        if opensearch_managed_cluster_configuration is not None:
            pulumi.set(__self__, "opensearch_managed_cluster_configuration", opensearch_managed_cluster_configuration)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)
        if s3_vectors_configuration is not None:
            pulumi.set(__self__, "s3_vectors_configuration", s3_vectors_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `MONGO_DB_ATLAS`, `OPENSEARCH_SERVERLESS`, `OPENSEARCH_MANAGED_CLUSTER`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`, `S3_VECTORS`, `NEPTUNE_ANALYTICS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="mongoDbAtlasConfiguration")
    def mongo_db_atlas_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in MongoDB Atlas. See `mongo_db_atlas_configuration` block for details.
        """
        return pulumi.get(self, "mongo_db_atlas_configuration")

    @mongo_db_atlas_configuration.setter
    def mongo_db_atlas_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs']]):
        pulumi.set(self, "mongo_db_atlas_configuration", value)

    @_builtins.property
    @pulumi.getter(name="neptuneAnalyticsConfiguration")
    def neptune_analytics_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon Neptune Analytics. See `neptune_analytics_configuration` block for details.
        """
        return pulumi.get(self, "neptune_analytics_configuration")

    @neptune_analytics_configuration.setter
    def neptune_analytics_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs']]):
        pulumi.set(self, "neptune_analytics_configuration", value)

    @_builtins.property
    @pulumi.getter(name="opensearchManagedClusterConfiguration")
    def opensearch_managed_cluster_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service Managed Cluster. See `opensearch_managed_cluster_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_managed_cluster_configuration")

    @opensearch_managed_cluster_configuration.setter
    def opensearch_managed_cluster_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs']]):
        pulumi.set(self, "opensearch_managed_cluster_configuration", value)

    @_builtins.property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service Serverless. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @_builtins.property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @_builtins.property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)

    @_builtins.property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")

    @redis_enterprise_cloud_configuration.setter
    def redis_enterprise_cloud_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]):
        pulumi.set(self, "redis_enterprise_cloud_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3VectorsConfiguration")
    def s3_vectors_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon S3 Vectors. See `s3_vectors_configuration` block for details.
        """
        return pulumi.get(self, "s3_vectors_configuration")

    @s3_vectors_configuration.setter
    def s3_vectors_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs']]):
        pulumi.set(self, "s3_vectors_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgsDict(TypedDict):
        collection_name: pulumi.Input[_builtins.str]
        """
        The name of the collection in the MongoDB Atlas database.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your MongoDB Atlas database.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        The name of the database in the MongoDB Atlas database.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        The endpoint URL of the MongoDB Atlas database.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        The name of the vector index.
        """
        endpoint_service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the service that hosts the MongoDB Atlas database.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgsDict']]
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        text_index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the vector index.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationArgs:
    def __init__(__self__, *,
                 collection_name: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 endpoint_service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs']] = None,
                 text_index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collection_name: The name of the collection in the MongoDB Atlas database.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your MongoDB Atlas database.
        :param pulumi.Input[_builtins.str] database_name: The name of the database in the MongoDB Atlas database.
        :param pulumi.Input[_builtins.str] endpoint: The endpoint URL of the MongoDB Atlas database.
        :param pulumi.Input[_builtins.str] vector_index_name: The name of the vector index.
        :param pulumi.Input[_builtins.str] endpoint_service_name: The name of the service that hosts the MongoDB Atlas database.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] text_index_name: The name of the vector index.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if endpoint_service_name is not None:
            pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if text_index_name is not None:
            pulumi.set(__self__, "text_index_name", text_index_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the collection in the MongoDB Atlas database.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your MongoDB Atlas database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the database in the MongoDB Atlas database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint URL of the MongoDB Atlas database.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the service that hosts the MongoDB Atlas database.
        """
        return pulumi.get(self, "endpoint_service_name")

    @endpoint_service_name.setter
    def endpoint_service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_service_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs']]:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="textIndexName")
    def text_index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the vector index.
        """
        return pulumi.get(self, "text_index_name")

    @text_index_name.setter
    def text_index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_index_name", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationMongoDbAtlasConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgsDict(TypedDict):
        graph_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Neptune Analytics vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 graph_arn: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] graph_arn: ARN of the Neptune Analytics vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "graph_arn", graph_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="graphArn")
    def graph_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Neptune Analytics vector store.
        """
        return pulumi.get(self, "graph_arn")

    @graph_arn.setter
    def graph_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "graph_arn", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationNeptuneAnalyticsConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgsDict(TypedDict):
        domain_arn: pulumi.Input[_builtins.str]
        """
        ARN of the OpenSearch domain.
        """
        domain_endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint URL of the OpenSearch domain.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of the vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationArgs:
    def __init__(__self__, *,
                 domain_arn: pulumi.Input[_builtins.str],
                 domain_endpoint: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] domain_arn: ARN of the OpenSearch domain.
        :param pulumi.Input[_builtins.str] domain_endpoint: Endpoint URL of the OpenSearch domain.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of the vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "domain_arn", domain_arn)
        pulumi.set(__self__, "domain_endpoint", domain_endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="domainArn")
    def domain_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the OpenSearch domain.
        """
        return pulumi.get(self, "domain_arn")

    @domain_arn.setter
    def domain_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_arn", value)

    @_builtins.property
    @pulumi.getter(name="domainEndpoint")
    def domain_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint URL of the OpenSearch domain.
        """
        return pulumi.get(self, "domain_endpoint")

    @domain_endpoint.setter
    def domain_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchManagedClusterConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict(TypedDict):
        collection_arn: pulumi.Input[_builtins.str]
        """
        ARN of the OpenSearch Service vector store.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of the vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] collection_arn: ARN of the OpenSearch Service vector store.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of the vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_arn", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict(TypedDict):
        connection_string: pulumi.Input[_builtins.str]
        """
        Endpoint URL for your index management page.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to be used to write new data to your database.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_string: Endpoint URL for your index management page.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param pulumi.Input[_builtins.str] namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_string", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        Name of your Amazon RDS database.
        """
        resource_arn: pulumi.Input[_builtins.str]
        """
        ARN of the vector store.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        Name of the table in the database.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict']]
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 resource_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[_builtins.str] database_name: Name of your Amazon RDS database.
        :param pulumi.Input[_builtins.str] resource_arn: ARN of the vector store.
        :param pulumi.Input[_builtins.str] table_name: Name of the table in the database.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs'] field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        primary_key_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        custom_metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name for the universal metadata field where Amazon Bedrock will store any custom metadata from your data source.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 primary_key_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str],
                 custom_metadata_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        :param pulumi.Input[_builtins.str] custom_metadata_field: Name for the universal metadata field where Amazon Bedrock will store any custom metadata from your data source.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)
        if custom_metadata_field is not None:
            pulumi.set(__self__, "custom_metadata_field", custom_metadata_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary_key_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)

    @_builtins.property
    @pulumi.getter(name="customMetadataField")
    def custom_metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name for the universal metadata field where Amazon Bedrock will store any custom metadata from your data source.
        """
        return pulumi.get(self, "custom_metadata_field")

    @custom_metadata_field.setter
    def custom_metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_metadata_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of the vector index.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param pulumi.Input[_builtins.str] endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of the vector index.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[_builtins.str]] = None,
                 text_field: Optional[pulumi.Input[_builtins.str]] = None,
                 vector_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgsDict(TypedDict):
        index_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the S3 Vectors index. Conflicts with `index_name` and `vector_bucket_arn`.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the S3 Vectors index. Must be specified with `vector_bucket_arn`. Conflicts with `index_arn`.
        """
        vector_bucket_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the S3 Vectors vector bucket. Must be specified with `index_name`. Conflicts with `index_arn`.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationS3VectorsConfigurationArgs:
    def __init__(__self__, *,
                 index_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None,
                 vector_bucket_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index_arn: ARN of the S3 Vectors index. Conflicts with `index_name` and `vector_bucket_arn`.
        :param pulumi.Input[_builtins.str] index_name: Name of the S3 Vectors index. Must be specified with `vector_bucket_arn`. Conflicts with `index_arn`.
        :param pulumi.Input[_builtins.str] vector_bucket_arn: ARN of the S3 Vectors vector bucket. Must be specified with `index_name`. Conflicts with `index_arn`.
        """
        if index_arn is not None:
            pulumi.set(__self__, "index_arn", index_arn)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if vector_bucket_arn is not None:
            pulumi.set(__self__, "vector_bucket_arn", vector_bucket_arn)

    @_builtins.property
    @pulumi.getter(name="indexArn")
    def index_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the S3 Vectors index. Conflicts with `index_name` and `vector_bucket_arn`.
        """
        return pulumi.get(self, "index_arn")

    @index_arn.setter
    def index_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_arn", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the S3 Vectors index. Must be specified with `vector_bucket_arn`. Conflicts with `index_arn`.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter(name="vectorBucketArn")
    def vector_bucket_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the S3 Vectors vector bucket. Must be specified with `index_name`. Conflicts with `index_arn`.
        """
        return pulumi.get(self, "vector_bucket_arn")

    @vector_bucket_arn.setter
    def vector_bucket_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vector_bucket_arn", value)


if not MYPY:
    class AgentKnowledgeBaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentKnowledgeBaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentPromptVariantArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt variant.
        """
        template_type: pulumi.Input[_builtins.str]
        """
        Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        """
        additional_model_request_fields: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        """
        gen_ai_resource: NotRequired[pulumi.Input['AgentPromptVariantGenAiResourceArgsDict']]
        """
        Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentPromptVariantInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgsDict']]]]
        """
        A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        """
        template_configuration: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationArgsDict']]
        """
        Contains configurations for the prompt template. See Template Configuration for more information.
        """
elif False:
    AgentPromptVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 template_type: pulumi.Input[_builtins.str],
                 additional_model_request_fields: Optional[pulumi.Input[_builtins.str]] = None,
                 gen_ai_resource: Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 template_configuration: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt variant.
        :param pulumi.Input[_builtins.str] template_type: Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        :param pulumi.Input[_builtins.str] additional_model_request_fields: Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        :param pulumi.Input['AgentPromptVariantGenAiResourceArgs'] gen_ai_resource: Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        :param pulumi.Input['AgentPromptVariantInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]] metadatas: A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        :param pulumi.Input[_builtins.str] model_id: Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationArgs'] template_configuration: Contains configurations for the prompt template. See Template Configuration for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if gen_ai_resource is not None:
            pulumi.set(__self__, "gen_ai_resource", gen_ai_resource)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt variant.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="genAiResource")
    def gen_ai_resource(self) -> Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']]:
        """
        Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        """
        return pulumi.get(self, "gen_ai_resource")

    @gen_ai_resource.setter
    def gen_ai_resource(self, value: Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']]):
        pulumi.set(self, "gen_ai_resource", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]]:
        """
        A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']]:
        """
        Contains configurations for the prompt template. See Template Configuration for more information.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']]):
        pulumi.set(self, "template_configuration", value)


if not MYPY:
    class AgentPromptVariantGenAiResourceArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgsDict']]
        """
        Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
elif False:
    AgentPromptVariantGenAiResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantGenAiResourceArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs'] agent: Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']]:
        """
        Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class AgentPromptVariantGenAiResourceAgentArgsDict(TypedDict):
        agent_identifier: pulumi.Input[_builtins.str]
        """
        ARN of the agent with which to use the prompt.
        """
elif False:
    AgentPromptVariantGenAiResourceAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantGenAiResourceAgentArgs:
    def __init__(__self__, *,
                 agent_identifier: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_identifier: ARN of the agent with which to use the prompt.
        """
        pulumi.set(__self__, "agent_identifier", agent_identifier)

    @_builtins.property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the agent with which to use the prompt.
        """
        return pulumi.get(self, "agent_identifier")

    @agent_identifier.setter
    def agent_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_identifier", value)


if not MYPY:
    class AgentPromptVariantInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgsDict']]
        """
        Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
elif False:
    AgentPromptVariantInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs'] text: Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']]:
        """
        Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentPromptVariantInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentPromptVariantMetadataArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of a metadata tag for a prompt variant.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of a metadata tag for a prompt variant.
        """
elif False:
    AgentPromptVariantMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantMetadataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Key of a metadata tag for a prompt variant.
        :param pulumi.Input[_builtins.str] value: Value of a metadata tag for a prompt variant.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of a metadata tag for a prompt variant.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of a metadata tag for a prompt variant.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationArgsDict(TypedDict):
        chat: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgsDict']]
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        text: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgsDict']]
        """
        Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
elif False:
    AgentPromptVariantTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationArgs:
    def __init__(__self__, *,
                 chat: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']] = None,
                 text: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs'] chat: Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs'] text: Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
        if chat is not None:
            pulumi.set(__self__, "chat", chat)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']]:
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        return pulumi.get(self, "chat")

    @chat.setter
    def chat(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']]):
        pulumi.set(self, "chat", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']]:
        """
        Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict']]]]
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgsDict']]]]
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        systems: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgsDict']]]]
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        tool_configuration: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict']]
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]] = None,
                 systems: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]] = None,
                 tool_configuration: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]] messages: A list of messages in the chat for the prompt. See Message for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]] systems: A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs'] tool_configuration: Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if systems is not None:
            pulumi.set(__self__, "systems", systems)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]]:
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter
    def systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]]:
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        return pulumi.get(self, "systems")

    @systems.setter
    def systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]]):
        pulumi.set(self, "systems", value)

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']]:
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        return pulumi.get(self, "tool_configuration")

    @tool_configuration.setter
    def tool_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']]):
        pulumi.set(self, "tool_configuration", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The role that the message belongs to.
        """
        content: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict']]
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] role: The role that the message belongs to.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs'] content: Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        pulumi.set(__self__, "role", role)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the message belongs to.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']]:
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']]):
        pulumi.set(self, "content", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict']]
        text: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageContentArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatSystemArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text in the system prompt.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatSystemArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input[_builtins.str] text: The text in the system prompt.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text in the system prompt.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict(TypedDict):
        tool_choice: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict']]
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict']]]]
        """
        A list of tools to pass to a model. See Tool for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs:
    def __init__(__self__, *,
                 tool_choice: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs'] tool_choice: Defines which tools the model should request when invoked. See Tool Choice for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]] tools: A list of tools to pass to a model. See Tool for more information.
        """
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']]:
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        return pulumi.get(self, "tool_choice")

    @tool_choice.setter
    def tool_choice(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']]):
        pulumi.set(self, "tool_choice", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]]:
        """
        A list of tools to pass to a model. See Tool for more information.
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]]):
        pulumi.set(self, "tools", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        tool_spec: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict']]
        """
        The specification for the tool. See Tool Specification for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']] = None,
                 tool_spec: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs'] tool_spec: The specification for the tool. See Tool Specification for more information.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if tool_spec is not None:
            pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]:
        """
        The specification for the tool. See Tool Specification for more information.
        """
        return pulumi.get(self, "tool_spec")

    @tool_spec.setter
    def tool_spec(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]):
        pulumi.set(self, "tool_spec", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict(TypedDict):
        any: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict']]
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        auto: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict']]
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        tool: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict']]
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']] = None,
                 auto: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']] = None,
                 tool: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs'] any: Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs'] auto: Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs'] tool: Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]:
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]):
        pulumi.set(self, "any", value)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]:
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        return pulumi.get(self, "auto")

    @auto.setter
    def auto(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]):
        pulumi.set(self, "auto", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]:
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict(TypedDict):
        pass
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict(TypedDict):
        pass
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt.

        The following arguments are optional:
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt.

        The following arguments are optional:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the prompt.
        """
        input_schema: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict']]
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_schema: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt.
               
               The following arguments are optional:
        :param pulumi.Input[_builtins.str] description: Description of the prompt.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs'] input_schema: The input schema of the tool. See Tool Input Schema for more information.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the prompt.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]:
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]):
        pulumi.set(self, "input_schema", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict(TypedDict):
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON object defining the input schema for the tool.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs:
    def __init__(__self__, *,
                 json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] json: A JSON object defining the input schema for the tool.
        """
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON object defining the input schema for the tool.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgsDict']]
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict']]]]
elif False:
    AgentPromptVariantTemplateConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']] = None,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]] = None):
        pulumi.set(__self__, "text", text)
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationTextCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentcoreAgentRuntimeAgentRuntimeArtifactArgsDict(TypedDict):
        code_configuration: NotRequired[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgsDict']]
        """
        Code configuration block for the agent runtime artifact, including the source code location and execution settings. Exactly one of `code_configuration` or `container_configuration` must be specified. See `code_configuration` below.
        """
        container_configuration: NotRequired[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgsDict']]
        """
        Container configuration block for the agent artifact. Exactly one of `code_configuration` or `container_configuration` must be specified. See `container_configuration` below.
        """
elif False:
    AgentcoreAgentRuntimeAgentRuntimeArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAgentRuntimeArtifactArgs:
    def __init__(__self__, *,
                 code_configuration: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs']] = None,
                 container_configuration: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs'] code_configuration: Code configuration block for the agent runtime artifact, including the source code location and execution settings. Exactly one of `code_configuration` or `container_configuration` must be specified. See `code_configuration` below.
        :param pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs'] container_configuration: Container configuration block for the agent artifact. Exactly one of `code_configuration` or `container_configuration` must be specified. See `container_configuration` below.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)

    @_builtins.property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs']]:
        """
        Code configuration block for the agent runtime artifact, including the source code location and execution settings. Exactly one of `code_configuration` or `container_configuration` must be specified. See `code_configuration` below.
        """
        return pulumi.get(self, "code_configuration")

    @code_configuration.setter
    def code_configuration(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs']]):
        pulumi.set(self, "code_configuration", value)

    @_builtins.property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs']]:
        """
        Container configuration block for the agent artifact. Exactly one of `code_configuration` or `container_configuration` must be specified. See `container_configuration` below.
        """
        return pulumi.get(self, "container_configuration")

    @container_configuration.setter
    def container_configuration(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs']]):
        pulumi.set(self, "container_configuration", value)


if not MYPY:
    class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgsDict(TypedDict):
        entry_points: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array specifying the entry point for code execution, indicating the function or method to invoke when the code runs. The array must contain 1 or 2 elements. Examples: `["main.py"]`, `["opentelemetry-instrument", "main.py"]`.
        """
        runtime: pulumi.Input[_builtins.str]
        """
        Runtime environment used to execute the code. Valid values: `PYTHON_3_10`, `PYTHON_3_11`, `PYTHON_3_12`, `PYTHON_3_13`.
        """
        code: NotRequired[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgsDict']]
        """
        Configuration block for the source code location and configuration details. See `code` below.
        """
elif False:
    AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationArgs:
    def __init__(__self__, *,
                 entry_points: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 runtime: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] entry_points: Array specifying the entry point for code execution, indicating the function or method to invoke when the code runs. The array must contain 1 or 2 elements. Examples: `["main.py"]`, `["opentelemetry-instrument", "main.py"]`.
        :param pulumi.Input[_builtins.str] runtime: Runtime environment used to execute the code. Valid values: `PYTHON_3_10`, `PYTHON_3_11`, `PYTHON_3_12`, `PYTHON_3_13`.
        :param pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs'] code: Configuration block for the source code location and configuration details. See `code` below.
        """
        pulumi.set(__self__, "entry_points", entry_points)
        pulumi.set(__self__, "runtime", runtime)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @_builtins.property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array specifying the entry point for code execution, indicating the function or method to invoke when the code runs. The array must contain 1 or 2 elements. Examples: `["main.py"]`, `["opentelemetry-instrument", "main.py"]`.
        """
        return pulumi.get(self, "entry_points")

    @entry_points.setter
    def entry_points(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "entry_points", value)

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> pulumi.Input[_builtins.str]:
        """
        Runtime environment used to execute the code. Valid values: `PYTHON_3_10`, `PYTHON_3_11`, `PYTHON_3_12`, `PYTHON_3_13`.
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runtime", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs']]:
        """
        Configuration block for the source code location and configuration details. See `code` below.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs']]):
        pulumi.set(self, "code", value)


if not MYPY:
    class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3ArgsDict']]
        """
        Configuration block for the Amazon S3 object that contains the source code for the agent runtime. See `s3` below.
        """
elif False:
    AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args']] = None):
        """
        :param pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args'] s3: Configuration block for the Amazon S3 object that contains the source code for the agent runtime. See `s3` below.
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args']]:
        """
        Configuration block for the Amazon S3 object that contains the source code for the agent runtime. See `s3` below.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3ArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Name of the Amazon S3 bucket.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        Key of the object containing the ZIP file of the source code for the agent runtime in the Amazon S3 bucket.
        """
        version_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version ID of the Amazon S3 object. If not specified, the latest version of the object is used.
        """
elif False:
    AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAgentRuntimeArtifactCodeConfigurationCodeS3Args:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 prefix: pulumi.Input[_builtins.str],
                 version_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of the Amazon S3 bucket.
        :param pulumi.Input[_builtins.str] prefix: Key of the object containing the ZIP file of the source code for the agent runtime in the Amazon S3 bucket.
        :param pulumi.Input[_builtins.str] version_id: Version ID of the Amazon S3 object. If not specified, the latest version of the object is used.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "prefix", prefix)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the object containing the ZIP file of the source code for the agent runtime in the Amazon S3 bucket.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version ID of the Amazon S3 object. If not specified, the latest version of the object is used.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgsDict(TypedDict):
        container_uri: pulumi.Input[_builtins.str]
        """
        URI of the container image in Amazon ECR.
        """
elif False:
    AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAgentRuntimeArtifactContainerConfigurationArgs:
    def __init__(__self__, *,
                 container_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] container_uri: URI of the container image in Amazon ECR.
        """
        pulumi.set(__self__, "container_uri", container_uri)

    @_builtins.property
    @pulumi.getter(name="containerUri")
    def container_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the container image in Amazon ECR.
        """
        return pulumi.get(self, "container_uri")

    @container_uri.setter
    def container_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container_uri", value)


if not MYPY:
    class AgentcoreAgentRuntimeAuthorizerConfigurationArgsDict(TypedDict):
        custom_jwt_authorizer: NotRequired[pulumi.Input['AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgsDict']]
        """
        JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
elif False:
    AgentcoreAgentRuntimeAuthorizerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAuthorizerConfigurationArgs:
    def __init__(__self__, *,
                 custom_jwt_authorizer: Optional[pulumi.Input['AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs']] = None):
        """
        :param pulumi.Input['AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs'] custom_jwt_authorizer: JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
        if custom_jwt_authorizer is not None:
            pulumi.set(__self__, "custom_jwt_authorizer", custom_jwt_authorizer)

    @_builtins.property
    @pulumi.getter(name="customJwtAuthorizer")
    def custom_jwt_authorizer(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs']]:
        """
        JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
        return pulumi.get(self, "custom_jwt_authorizer")

    @custom_jwt_authorizer.setter
    def custom_jwt_authorizer(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs']]):
        pulumi.set(self, "custom_jwt_authorizer", value)


if not MYPY:
    class AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgsDict(TypedDict):
        discovery_url: pulumi.Input[_builtins.str]
        """
        URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of allowed audience values for JWT token validation.
        """
        allowed_clients: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of allowed client IDs for JWT token validation.
        """
elif False:
    AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeAuthorizerConfigurationCustomJwtAuthorizerArgs:
    def __init__(__self__, *,
                 discovery_url: pulumi.Input[_builtins.str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_clients: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] discovery_url: URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_audiences: Set of allowed audience values for JWT token validation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_clients: Set of allowed client IDs for JWT token validation.
        """
        pulumi.set(__self__, "discovery_url", discovery_url)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of allowed audience values for JWT token validation.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @_builtins.property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of allowed client IDs for JWT token validation.
        """
        return pulumi.get(self, "allowed_clients")

    @allowed_clients.setter
    def allowed_clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_clients", value)


if not MYPY:
    class AgentcoreAgentRuntimeEndpointTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentcoreAgentRuntimeEndpointTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeEndpointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentcoreAgentRuntimeLifecycleConfigurationArgsDict(TypedDict):
        idle_runtime_session_timeout: pulumi.Input[_builtins.int]
        """
        Timeout in seconds for idle runtime sessions.
        """
        max_lifetime: pulumi.Input[_builtins.int]
        """
        Maximum lifetime for the instance in seconds.
        """
elif False:
    AgentcoreAgentRuntimeLifecycleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeLifecycleConfigurationArgs:
    def __init__(__self__, *,
                 idle_runtime_session_timeout: pulumi.Input[_builtins.int],
                 max_lifetime: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] idle_runtime_session_timeout: Timeout in seconds for idle runtime sessions.
        :param pulumi.Input[_builtins.int] max_lifetime: Maximum lifetime for the instance in seconds.
        """
        pulumi.set(__self__, "idle_runtime_session_timeout", idle_runtime_session_timeout)
        pulumi.set(__self__, "max_lifetime", max_lifetime)

    @_builtins.property
    @pulumi.getter(name="idleRuntimeSessionTimeout")
    def idle_runtime_session_timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Timeout in seconds for idle runtime sessions.
        """
        return pulumi.get(self, "idle_runtime_session_timeout")

    @idle_runtime_session_timeout.setter
    def idle_runtime_session_timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "idle_runtime_session_timeout", value)

    @_builtins.property
    @pulumi.getter(name="maxLifetime")
    def max_lifetime(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum lifetime for the instance in seconds.
        """
        return pulumi.get(self, "max_lifetime")

    @max_lifetime.setter
    def max_lifetime(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_lifetime", value)


if not MYPY:
    class AgentcoreAgentRuntimeNetworkConfigurationArgsDict(TypedDict):
        network_mode: pulumi.Input[_builtins.str]
        """
        Network mode for the agent runtime. Valid values: `PUBLIC`, `VPC`.
        """
        network_mode_config: NotRequired[pulumi.Input['AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgsDict']]
        """
        Network mode configuration. See `network_mode_config` below.
        """
elif False:
    AgentcoreAgentRuntimeNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeNetworkConfigurationArgs:
    def __init__(__self__, *,
                 network_mode: pulumi.Input[_builtins.str],
                 network_mode_config: Optional[pulumi.Input['AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] network_mode: Network mode for the agent runtime. Valid values: `PUBLIC`, `VPC`.
        :param pulumi.Input['AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs'] network_mode_config: Network mode configuration. See `network_mode_config` below.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if network_mode_config is not None:
            pulumi.set(__self__, "network_mode_config", network_mode_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Network mode for the agent runtime. Valid values: `PUBLIC`, `VPC`.
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_mode", value)

    @_builtins.property
    @pulumi.getter(name="networkModeConfig")
    def network_mode_config(self) -> Optional[pulumi.Input['AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs']]:
        """
        Network mode configuration. See `network_mode_config` below.
        """
        return pulumi.get(self, "network_mode_config")

    @network_mode_config.setter
    def network_mode_config(self, value: Optional[pulumi.Input['AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs']]):
        pulumi.set(self, "network_mode_config", value)


if not MYPY:
    class AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgsDict(TypedDict):
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Security groups associated with the VPC configuration.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Subnets associated with the VPC configuration.
        """
elif False:
    AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeNetworkConfigurationNetworkModeConfigArgs:
    def __init__(__self__, *,
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: Security groups associated with the VPC configuration.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: Subnets associated with the VPC configuration.
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Security groups associated with the VPC configuration.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Subnets associated with the VPC configuration.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class AgentcoreAgentRuntimeProtocolConfigurationArgsDict(TypedDict):
        server_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Server protocol for the agent runtime. Valid values: `HTTP`, `MCP`, `A2A`.
        """
elif False:
    AgentcoreAgentRuntimeProtocolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeProtocolConfigurationArgs:
    def __init__(__self__, *,
                 server_protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] server_protocol: Server protocol for the agent runtime. Valid values: `HTTP`, `MCP`, `A2A`.
        """
        if server_protocol is not None:
            pulumi.set(__self__, "server_protocol", server_protocol)

    @_builtins.property
    @pulumi.getter(name="serverProtocol")
    def server_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Server protocol for the agent runtime. Valid values: `HTTP`, `MCP`, `A2A`.
        """
        return pulumi.get(self, "server_protocol")

    @server_protocol.setter
    def server_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_protocol", value)


if not MYPY:
    class AgentcoreAgentRuntimeRequestHeaderConfigurationArgsDict(TypedDict):
        request_header_allowlists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP request headers that are allowed to be passed through to the runtime.
        """
elif False:
    AgentcoreAgentRuntimeRequestHeaderConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeRequestHeaderConfigurationArgs:
    def __init__(__self__, *,
                 request_header_allowlists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] request_header_allowlists: A list of HTTP request headers that are allowed to be passed through to the runtime.
        """
        if request_header_allowlists is not None:
            pulumi.set(__self__, "request_header_allowlists", request_header_allowlists)

    @_builtins.property
    @pulumi.getter(name="requestHeaderAllowlists")
    def request_header_allowlists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP request headers that are allowed to be passed through to the runtime.
        """
        return pulumi.get(self, "request_header_allowlists")

    @request_header_allowlists.setter
    def request_header_allowlists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_header_allowlists", value)


if not MYPY:
    class AgentcoreAgentRuntimeTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentcoreAgentRuntimeTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentcoreAgentRuntimeWorkloadIdentityDetailArgsDict(TypedDict):
        workload_identity_arn: pulumi.Input[_builtins.str]
        """
        ARN of the workload identity.
        """
elif False:
    AgentcoreAgentRuntimeWorkloadIdentityDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreAgentRuntimeWorkloadIdentityDetailArgs:
    def __init__(__self__, *,
                 workload_identity_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] workload_identity_arn: ARN of the workload identity.
        """
        pulumi.set(__self__, "workload_identity_arn", workload_identity_arn)

    @_builtins.property
    @pulumi.getter(name="workloadIdentityArn")
    def workload_identity_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the workload identity.
        """
        return pulumi.get(self, "workload_identity_arn")

    @workload_identity_arn.setter
    def workload_identity_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workload_identity_arn", value)


if not MYPY:
    class AgentcoreApiKeyCredentialProviderApiKeySecretArnArgsDict(TypedDict):
        secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret in AWS Secrets Manager.
        """
elif False:
    AgentcoreApiKeyCredentialProviderApiKeySecretArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreApiKeyCredentialProviderApiKeySecretArnArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] secret_arn: ARN of the secret in AWS Secrets Manager.
        """
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret in AWS Secrets Manager.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class AgentcoreBrowserNetworkConfigurationArgsDict(TypedDict):
        network_mode: pulumi.Input[_builtins.str]
        """
        Network mode for the browser. Valid values: `PUBLIC`, `VPC`.
        """
        vpc_config: NotRequired[pulumi.Input['AgentcoreBrowserNetworkConfigurationVpcConfigArgsDict']]
        """
        VPC configuration when `network_mode` is `VPC`. See `vpc_config` below.
        """
elif False:
    AgentcoreBrowserNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreBrowserNetworkConfigurationArgs:
    def __init__(__self__, *,
                 network_mode: pulumi.Input[_builtins.str],
                 vpc_config: Optional[pulumi.Input['AgentcoreBrowserNetworkConfigurationVpcConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] network_mode: Network mode for the browser. Valid values: `PUBLIC`, `VPC`.
        :param pulumi.Input['AgentcoreBrowserNetworkConfigurationVpcConfigArgs'] vpc_config: VPC configuration when `network_mode` is `VPC`. See `vpc_config` below.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Network mode for the browser. Valid values: `PUBLIC`, `VPC`.
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_mode", value)

    @_builtins.property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['AgentcoreBrowserNetworkConfigurationVpcConfigArgs']]:
        """
        VPC configuration when `network_mode` is `VPC`. See `vpc_config` below.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['AgentcoreBrowserNetworkConfigurationVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class AgentcoreBrowserNetworkConfigurationVpcConfigArgsDict(TypedDict):
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of security group IDs for the VPC configuration.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of subnet IDs for the VPC configuration.
        """
elif False:
    AgentcoreBrowserNetworkConfigurationVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreBrowserNetworkConfigurationVpcConfigArgs:
    def __init__(__self__, *,
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: Set of security group IDs for the VPC configuration.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: Set of subnet IDs for the VPC configuration.
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of security group IDs for the VPC configuration.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of subnet IDs for the VPC configuration.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class AgentcoreBrowserRecordingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable recording for browser sessions. Defaults to `false`.
        """
        s3_location: NotRequired[pulumi.Input['AgentcoreBrowserRecordingS3LocationArgsDict']]
        """
        S3 location where browser session recordings are stored. See `s3_location` below.
        """
elif False:
    AgentcoreBrowserRecordingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreBrowserRecordingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 s3_location: Optional[pulumi.Input['AgentcoreBrowserRecordingS3LocationArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable recording for browser sessions. Defaults to `false`.
        :param pulumi.Input['AgentcoreBrowserRecordingS3LocationArgs'] s3_location: S3 location where browser session recordings are stored. See `s3_location` below.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable recording for browser sessions. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentcoreBrowserRecordingS3LocationArgs']]:
        """
        S3 location where browser session recordings are stored. See `s3_location` below.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentcoreBrowserRecordingS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentcoreBrowserRecordingS3LocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Name of the S3 bucket where recordings are stored.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        S3 key prefix for recording files.
        """
elif False:
    AgentcoreBrowserRecordingS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreBrowserRecordingS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of the S3 bucket where recordings are stored.
        :param pulumi.Input[_builtins.str] prefix: S3 key prefix for recording files.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the S3 bucket where recordings are stored.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        S3 key prefix for recording files.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AgentcoreBrowserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentcoreBrowserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreBrowserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentcoreCodeInterpreterNetworkConfigurationArgsDict(TypedDict):
        network_mode: pulumi.Input[_builtins.str]
        """
        Network mode for the code interpreter. Valid values: `PUBLIC`, `SANDBOX`, `VPC`.
        """
        vpc_config: NotRequired[pulumi.Input['AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgsDict']]
        """
        VPC configuration. See `vpc_config` below.
        """
elif False:
    AgentcoreCodeInterpreterNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreCodeInterpreterNetworkConfigurationArgs:
    def __init__(__self__, *,
                 network_mode: pulumi.Input[_builtins.str],
                 vpc_config: Optional[pulumi.Input['AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] network_mode: Network mode for the code interpreter. Valid values: `PUBLIC`, `SANDBOX`, `VPC`.
        :param pulumi.Input['AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs'] vpc_config: VPC configuration. See `vpc_config` below.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Network mode for the code interpreter. Valid values: `PUBLIC`, `SANDBOX`, `VPC`.
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_mode", value)

    @_builtins.property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs']]:
        """
        VPC configuration. See `vpc_config` below.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgsDict(TypedDict):
        security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Security groups associated with the VPC configuration.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Subnets associated with the VPC configuration.
        """
elif False:
    AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreCodeInterpreterNetworkConfigurationVpcConfigArgs:
    def __init__(__self__, *,
                 security_groups: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: Security groups associated with the VPC configuration.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: Subnets associated with the VPC configuration.
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Security groups associated with the VPC configuration.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Subnets associated with the VPC configuration.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class AgentcoreCodeInterpreterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentcoreCodeInterpreterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreCodeInterpreterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentcoreGatewayAuthorizerConfigurationArgsDict(TypedDict):
        custom_jwt_authorizer: NotRequired[pulumi.Input['AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgsDict']]
        """
        JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
elif False:
    AgentcoreGatewayAuthorizerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayAuthorizerConfigurationArgs:
    def __init__(__self__, *,
                 custom_jwt_authorizer: Optional[pulumi.Input['AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs'] custom_jwt_authorizer: JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
        if custom_jwt_authorizer is not None:
            pulumi.set(__self__, "custom_jwt_authorizer", custom_jwt_authorizer)

    @_builtins.property
    @pulumi.getter(name="customJwtAuthorizer")
    def custom_jwt_authorizer(self) -> Optional[pulumi.Input['AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs']]:
        """
        JWT-based authorization configuration block. See `custom_jwt_authorizer` below.
        """
        return pulumi.get(self, "custom_jwt_authorizer")

    @custom_jwt_authorizer.setter
    def custom_jwt_authorizer(self, value: Optional[pulumi.Input['AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs']]):
        pulumi.set(self, "custom_jwt_authorizer", value)


if not MYPY:
    class AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgsDict(TypedDict):
        discovery_url: pulumi.Input[_builtins.str]
        """
        URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of allowed audience values for JWT token validation.
        """
        allowed_clients: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of allowed client IDs for JWT token validation.
        """
elif False:
    AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayAuthorizerConfigurationCustomJwtAuthorizerArgs:
    def __init__(__self__, *,
                 discovery_url: pulumi.Input[_builtins.str],
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_clients: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] discovery_url: URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_audiences: Set of allowed audience values for JWT token validation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_clients: Set of allowed client IDs for JWT token validation.
        """
        pulumi.set(__self__, "discovery_url", discovery_url)
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        URL used to fetch OpenID Connect configuration or authorization server metadata. Must end with `.well-known/openid-configuration`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of allowed audience values for JWT token validation.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @_builtins.property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of allowed client IDs for JWT token validation.
        """
        return pulumi.get(self, "allowed_clients")

    @allowed_clients.setter
    def allowed_clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_clients", value)


if not MYPY:
    class AgentcoreGatewayInterceptorConfigurationArgsDict(TypedDict):
        interception_points: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of interception points. Valid values: `REQUEST`, `RESPONSE`.
        """
        input_configuration: NotRequired[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInputConfigurationArgsDict']]
        """
        Input configuration for the interceptor. See `input_configuration` below.
        """
        interceptor: NotRequired[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorArgsDict']]
        """
        Interceptor infrastructure configuration. See `interceptor` below.
        """
elif False:
    AgentcoreGatewayInterceptorConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayInterceptorConfigurationArgs:
    def __init__(__self__, *,
                 interception_points: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 input_configuration: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs']] = None,
                 interceptor: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] interception_points: Set of interception points. Valid values: `REQUEST`, `RESPONSE`.
        :param pulumi.Input['AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs'] input_configuration: Input configuration for the interceptor. See `input_configuration` below.
        :param pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorArgs'] interceptor: Interceptor infrastructure configuration. See `interceptor` below.
        """
        pulumi.set(__self__, "interception_points", interception_points)
        if input_configuration is not None:
            pulumi.set(__self__, "input_configuration", input_configuration)
        if interceptor is not None:
            pulumi.set(__self__, "interceptor", interceptor)

    @_builtins.property
    @pulumi.getter(name="interceptionPoints")
    def interception_points(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of interception points. Valid values: `REQUEST`, `RESPONSE`.
        """
        return pulumi.get(self, "interception_points")

    @interception_points.setter
    def interception_points(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "interception_points", value)

    @_builtins.property
    @pulumi.getter(name="inputConfiguration")
    def input_configuration(self) -> Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs']]:
        """
        Input configuration for the interceptor. See `input_configuration` below.
        """
        return pulumi.get(self, "input_configuration")

    @input_configuration.setter
    def input_configuration(self, value: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs']]):
        pulumi.set(self, "input_configuration", value)

    @_builtins.property
    @pulumi.getter
    def interceptor(self) -> Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorArgs']]:
        """
        Interceptor infrastructure configuration. See `interceptor` below.
        """
        return pulumi.get(self, "interceptor")

    @interceptor.setter
    def interceptor(self, value: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorArgs']]):
        pulumi.set(self, "interceptor", value)


if not MYPY:
    class AgentcoreGatewayInterceptorConfigurationInputConfigurationArgsDict(TypedDict):
        pass_request_headers: pulumi.Input[_builtins.bool]
        """
        Whether to pass request headers to the interceptor.
        """
elif False:
    AgentcoreGatewayInterceptorConfigurationInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayInterceptorConfigurationInputConfigurationArgs:
    def __init__(__self__, *,
                 pass_request_headers: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] pass_request_headers: Whether to pass request headers to the interceptor.
        """
        pulumi.set(__self__, "pass_request_headers", pass_request_headers)

    @_builtins.property
    @pulumi.getter(name="passRequestHeaders")
    def pass_request_headers(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to pass request headers to the interceptor.
        """
        return pulumi.get(self, "pass_request_headers")

    @pass_request_headers.setter
    def pass_request_headers(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "pass_request_headers", value)


if not MYPY:
    class AgentcoreGatewayInterceptorConfigurationInterceptorArgsDict(TypedDict):
        lambda_: NotRequired[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgsDict']]
        """
        Lambda function configuration for the interceptor. See `lambda` below.
        """
elif False:
    AgentcoreGatewayInterceptorConfigurationInterceptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayInterceptorConfigurationInterceptorArgs:
    def __init__(__self__, *,
                 lambda_: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs'] lambda_: Lambda function configuration for the interceptor. See `lambda` below.
        """
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs']]:
        """
        Lambda function configuration for the interceptor. See `lambda` below.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input['AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs']]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function to invoke for the interceptor.
        """
elif False:
    AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayInterceptorConfigurationInterceptorLambdaArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Lambda function to invoke for the interceptor.
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function to invoke for the interceptor.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class AgentcoreGatewayProtocolConfigurationArgsDict(TypedDict):
        mcp: NotRequired[pulumi.Input['AgentcoreGatewayProtocolConfigurationMcpArgsDict']]
        """
        Model Context Protocol (MCP) configuration block. See `mcp` below.
        """
elif False:
    AgentcoreGatewayProtocolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayProtocolConfigurationArgs:
    def __init__(__self__, *,
                 mcp: Optional[pulumi.Input['AgentcoreGatewayProtocolConfigurationMcpArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayProtocolConfigurationMcpArgs'] mcp: Model Context Protocol (MCP) configuration block. See `mcp` below.
        """
        if mcp is not None:
            pulumi.set(__self__, "mcp", mcp)

    @_builtins.property
    @pulumi.getter
    def mcp(self) -> Optional[pulumi.Input['AgentcoreGatewayProtocolConfigurationMcpArgs']]:
        """
        Model Context Protocol (MCP) configuration block. See `mcp` below.
        """
        return pulumi.get(self, "mcp")

    @mcp.setter
    def mcp(self, value: Optional[pulumi.Input['AgentcoreGatewayProtocolConfigurationMcpArgs']]):
        pulumi.set(self, "mcp", value)


if not MYPY:
    class AgentcoreGatewayProtocolConfigurationMcpArgsDict(TypedDict):
        instructions: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instructions for the MCP protocol configuration.
        """
        search_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Search type for MCP. Valid values: `SEMANTIC`.
        """
        supported_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of supported MCP protocol versions.
        """
elif False:
    AgentcoreGatewayProtocolConfigurationMcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayProtocolConfigurationMcpArgs:
    def __init__(__self__, *,
                 instructions: Optional[pulumi.Input[_builtins.str]] = None,
                 search_type: Optional[pulumi.Input[_builtins.str]] = None,
                 supported_versions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] instructions: Instructions for the MCP protocol configuration.
        :param pulumi.Input[_builtins.str] search_type: Search type for MCP. Valid values: `SEMANTIC`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] supported_versions: Set of supported MCP protocol versions.
        """
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if search_type is not None:
            pulumi.set(__self__, "search_type", search_type)
        if supported_versions is not None:
            pulumi.set(__self__, "supported_versions", supported_versions)

    @_builtins.property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instructions for the MCP protocol configuration.
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instructions", value)

    @_builtins.property
    @pulumi.getter(name="searchType")
    def search_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Search type for MCP. Valid values: `SEMANTIC`.
        """
        return pulumi.get(self, "search_type")

    @search_type.setter
    def search_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "search_type", value)

    @_builtins.property
    @pulumi.getter(name="supportedVersions")
    def supported_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of supported MCP protocol versions.
        """
        return pulumi.get(self, "supported_versions")

    @supported_versions.setter
    def supported_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supported_versions", value)


if not MYPY:
    class AgentcoreGatewayTargetCredentialProviderConfigurationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgsDict']]
        """
        API key-based authentication configuration. See `api_key` below.
        """
        gateway_iam_role: NotRequired[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgsDict']]
        """
        Use the gateway's IAM role for authentication. This is an empty configuration block.
        """
        oauth: NotRequired[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgsDict']]
        """
        OAuth-based authentication configuration. See `oauth` below.
        """
elif False:
    AgentcoreGatewayTargetCredentialProviderConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetCredentialProviderConfigurationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs']] = None,
                 gateway_iam_role: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs']] = None,
                 oauth: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs'] api_key: API key-based authentication configuration. See `api_key` below.
        :param pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs'] gateway_iam_role: Use the gateway's IAM role for authentication. This is an empty configuration block.
        :param pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs'] oauth: OAuth-based authentication configuration. See `oauth` below.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if gateway_iam_role is not None:
            pulumi.set(__self__, "gateway_iam_role", gateway_iam_role)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs']]:
        """
        API key-based authentication configuration. See `api_key` below.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="gatewayIamRole")
    def gateway_iam_role(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs']]:
        """
        Use the gateway's IAM role for authentication. This is an empty configuration block.
        """
        return pulumi.get(self, "gateway_iam_role")

    @gateway_iam_role.setter
    def gateway_iam_role(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs']]):
        pulumi.set(self, "gateway_iam_role", value)

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs']]:
        """
        OAuth-based authentication configuration. See `oauth` below.
        """
        return pulumi.get(self, "oauth")

    @oauth.setter
    def oauth(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs']]):
        pulumi.set(self, "oauth", value)


if not MYPY:
    class AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgsDict(TypedDict):
        provider_arn: pulumi.Input[_builtins.str]
        """
        ARN of the OIDC provider for API key authentication.
        """
        credential_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location where the API key credential is provided. Valid values: `HEADER`, `QUERY_PARAMETER`.
        """
        credential_parameter_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the parameter containing the API key credential.
        """
        credential_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix to add to the API key credential value.
        """
elif False:
    AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetCredentialProviderConfigurationApiKeyArgs:
    def __init__(__self__, *,
                 provider_arn: pulumi.Input[_builtins.str],
                 credential_location: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_parameter_name: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_arn: ARN of the OIDC provider for API key authentication.
        :param pulumi.Input[_builtins.str] credential_location: Location where the API key credential is provided. Valid values: `HEADER`, `QUERY_PARAMETER`.
        :param pulumi.Input[_builtins.str] credential_parameter_name: Name of the parameter containing the API key credential.
        :param pulumi.Input[_builtins.str] credential_prefix: Prefix to add to the API key credential value.
        """
        pulumi.set(__self__, "provider_arn", provider_arn)
        if credential_location is not None:
            pulumi.set(__self__, "credential_location", credential_location)
        if credential_parameter_name is not None:
            pulumi.set(__self__, "credential_parameter_name", credential_parameter_name)
        if credential_prefix is not None:
            pulumi.set(__self__, "credential_prefix", credential_prefix)

    @_builtins.property
    @pulumi.getter(name="providerArn")
    def provider_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the OIDC provider for API key authentication.
        """
        return pulumi.get(self, "provider_arn")

    @provider_arn.setter
    def provider_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_arn", value)

    @_builtins.property
    @pulumi.getter(name="credentialLocation")
    def credential_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location where the API key credential is provided. Valid values: `HEADER`, `QUERY_PARAMETER`.
        """
        return pulumi.get(self, "credential_location")

    @credential_location.setter
    def credential_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_location", value)

    @_builtins.property
    @pulumi.getter(name="credentialParameterName")
    def credential_parameter_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the parameter containing the API key credential.
        """
        return pulumi.get(self, "credential_parameter_name")

    @credential_parameter_name.setter
    def credential_parameter_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_parameter_name", value)

    @_builtins.property
    @pulumi.getter(name="credentialPrefix")
    def credential_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix to add to the API key credential value.
        """
        return pulumi.get(self, "credential_prefix")

    @credential_prefix.setter
    def credential_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credential_prefix", value)


if not MYPY:
    class AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgsDict(TypedDict):
        pass
elif False:
    AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetCredentialProviderConfigurationGatewayIamRoleArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgsDict(TypedDict):
        provider_arn: pulumi.Input[_builtins.str]
        """
        ARN of the OIDC provider for OAuth authentication.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth scopes to request.
        """
        custom_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of custom parameters to include in OAuth requests.
        """
elif False:
    AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetCredentialProviderConfigurationOauthArgs:
    def __init__(__self__, *,
                 provider_arn: pulumi.Input[_builtins.str],
                 scopes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 custom_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_arn: ARN of the OIDC provider for OAuth authentication.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Set of OAuth scopes to request.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_parameters: Map of custom parameters to include in OAuth requests.
        """
        pulumi.set(__self__, "provider_arn", provider_arn)
        pulumi.set(__self__, "scopes", scopes)
        if custom_parameters is not None:
            pulumi.set(__self__, "custom_parameters", custom_parameters)

    @_builtins.property
    @pulumi.getter(name="providerArn")
    def provider_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the OIDC provider for OAuth authentication.
        """
        return pulumi.get(self, "provider_arn")

    @provider_arn.setter
    def provider_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_arn", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth scopes to request.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="customParameters")
    def custom_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of custom parameters to include in OAuth requests.
        """
        return pulumi.get(self, "custom_parameters")

    @custom_parameters.setter
    def custom_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_parameters", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationArgsDict(TypedDict):
        mcp: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpArgsDict']]
        """
        Model Context Protocol (MCP) configuration. See `mcp` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationArgs:
    def __init__(__self__, *,
                 mcp: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpArgs'] mcp: Model Context Protocol (MCP) configuration. See `mcp` below.
        """
        if mcp is not None:
            pulumi.set(__self__, "mcp", mcp)

    @_builtins.property
    @pulumi.getter
    def mcp(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpArgs']]:
        """
        Model Context Protocol (MCP) configuration. See `mcp` below.
        """
        return pulumi.get(self, "mcp")

    @mcp.setter
    def mcp(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpArgs']]):
        pulumi.set(self, "mcp", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpArgsDict(TypedDict):
        lambda_: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgsDict']]
        """
        Lambda function target configuration. See `lambda` below.
        """
        mcp_server: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgsDict']]
        """
        MCP server target configuration. See `mcp_server` below.
        """
        open_api_schema: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgsDict']]
        """
        OpenAPI schema-based target configuration. See `api_schema_configuration` below.
        """
        smithy_model: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgsDict']]
        """
        Smithy model-based target configuration. See `api_schema_configuration` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpArgs:
    def __init__(__self__, *,
                 lambda_: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs']] = None,
                 mcp_server: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs']] = None,
                 open_api_schema: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs']] = None,
                 smithy_model: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs']] = None):
        """
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs'] lambda_: Lambda function target configuration. See `lambda` below.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs'] mcp_server: MCP server target configuration. See `mcp_server` below.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs'] open_api_schema: OpenAPI schema-based target configuration. See `api_schema_configuration` below.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs'] smithy_model: Smithy model-based target configuration. See `api_schema_configuration` below.
        """
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)
        if mcp_server is not None:
            pulumi.set(__self__, "mcp_server", mcp_server)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if smithy_model is not None:
            pulumi.set(__self__, "smithy_model", smithy_model)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs']]:
        """
        Lambda function target configuration. See `lambda` below.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs']]):
        pulumi.set(self, "lambda_", value)

    @_builtins.property
    @pulumi.getter(name="mcpServer")
    def mcp_server(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs']]:
        """
        MCP server target configuration. See `mcp_server` below.
        """
        return pulumi.get(self, "mcp_server")

    @mcp_server.setter
    def mcp_server(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs']]):
        pulumi.set(self, "mcp_server", value)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs']]:
        """
        OpenAPI schema-based target configuration. See `api_schema_configuration` below.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs']]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="smithyModel")
    def smithy_model(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs']]:
        """
        Smithy model-based target configuration. See `api_schema_configuration` below.
        """
        return pulumi.get(self, "smithy_model")

    @smithy_model.setter
    def smithy_model(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs']]):
        pulumi.set(self, "smithy_model", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgsDict(TypedDict):
        lambda_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function to invoke.
        """
        tool_schema: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgsDict']]
        """
        Schema definition for the tool. See `tool_schema` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str],
                 tool_schema: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] lambda_arn: ARN of the Lambda function to invoke.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs'] tool_schema: Schema definition for the tool. See `tool_schema` below.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if tool_schema is not None:
            pulumi.set(__self__, "tool_schema", tool_schema)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function to invoke.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @_builtins.property
    @pulumi.getter(name="toolSchema")
    def tool_schema(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs']]:
        """
        Schema definition for the tool. See `tool_schema` below.
        """
        return pulumi.get(self, "tool_schema")

    @tool_schema.setter
    def tool_schema(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs']]):
        pulumi.set(self, "tool_schema", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgsDict(TypedDict):
        inline_payloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgsDict']]]]
        """
        Inline tool definition. See `inline_payload` below.
        """
        s3: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3ArgsDict']]
        """
        S3-based tool definition. See `s3` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaArgs:
    def __init__(__self__, *,
                 inline_payloads: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs']]]] = None,
                 s3: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs']]] inline_payloads: Inline tool definition. See `inline_payload` below.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args'] s3: S3-based tool definition. See `s3` below.
        """
        if inline_payloads is not None:
            pulumi.set(__self__, "inline_payloads", inline_payloads)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="inlinePayloads")
    def inline_payloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs']]]]:
        """
        Inline tool definition. See `inline_payload` below.
        """
        return pulumi.get(self, "inline_payloads")

    @inline_payloads.setter
    def inline_payloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs']]]]):
        pulumi.set(self, "inline_payloads", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args']]:
        """
        S3-based tool definition. See `s3` below.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        Description of what the tool does.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the tool.
        """
        input_schema: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgsDict']]
        """
        Schema for the tool's input. See `schema_definition` below.
        """
        output_schema: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgsDict']]
        """
        Schema for the tool's output. See `schema_definition` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 input_schema: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs']] = None,
                 output_schema: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of what the tool does.
        :param pulumi.Input[_builtins.str] name: Name of the tool.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs'] input_schema: Schema for the tool's input. See `schema_definition` below.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs'] output_schema: Schema for the tool's output. See `schema_definition` below.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if output_schema is not None:
            pulumi.set(__self__, "output_schema", output_schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        Description of what the tool does.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs']]:
        """
        Schema for the tool's input. See `schema_definition` below.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs']]):
        pulumi.set(self, "input_schema", value)

    @_builtins.property
    @pulumi.getter(name="outputSchema")
    def output_schema(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs']]:
        """
        Schema for the tool's output. See `schema_definition` below.
        """
        return pulumi.get(self, "output_schema")

    @output_schema.setter
    def output_schema(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs']]):
        pulumi.set(self, "output_schema", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the gateway target.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgsDict']]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgsDict']]]]
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the gateway target.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the gateway target.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgs']]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgs']]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgsDict']]
        """
        Nested items definition for arrays of arrays.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgsDict']]]]
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs'] items: Nested items definition for arrays of arrays.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs']]] properties: Set of property definitions for arrays of objects. See `property` below.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs']]:
        """
        Nested items definition for arrays of arrays.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs']]]]:
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaItemsPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgsDict']]
        """
        Items definition for array properties. See `items` above.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgsDict']]]]
        """
        Set of nested property definitions for object properties.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs']]]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs'] items: Items definition for array properties. See `items` above.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs']]] properties: Set of nested property definitions for object properties.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs']]:
        """
        Items definition for array properties. See `items` above.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs']]]]:
        """
        Set of nested property definitions for object properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgsDict']]
        """
        Nested items definition for arrays of arrays.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgsDict']]]]
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs'] items: Nested items definition for arrays of arrays.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs']]] properties: Set of property definitions for arrays of objects. See `property` below.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs']]:
        """
        Nested items definition for arrays of arrays.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs']]]]:
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyItemsPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadInputSchemaPropertyPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the gateway target.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgsDict']]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgsDict']]]]
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the gateway target.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the gateway target.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgs']]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgs']]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgsDict']]
        """
        Nested items definition for arrays of arrays.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgsDict']]]]
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs'] items: Nested items definition for arrays of arrays.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs']]] properties: Set of property definitions for arrays of objects. See `property` below.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs']]:
        """
        Nested items definition for arrays of arrays.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs']]]]:
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaItemsPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgsDict']]
        """
        Items definition for array properties. See `items` above.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgsDict']]]]
        """
        Set of nested property definitions for object properties.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs']]]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs'] items: Items definition for array properties. See `items` above.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs']]] properties: Set of nested property definitions for object properties.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs']]:
        """
        Items definition for array properties. See `items` above.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs']]]]:
        """
        Set of nested property definitions for object properties.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgsDict']]
        """
        Nested items definition for arrays of arrays.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgsDict']]]]
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs'] items: Nested items definition for arrays of arrays.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs']]] properties: Set of property definitions for arrays of objects. See `property` below.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs']]:
        """
        Nested items definition for arrays of arrays.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs']]]]:
        """
        Set of property definitions for arrays of objects. See `property` below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Data type of the array items.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the array items.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsItemsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Data type of the array items.
        :param pulumi.Input[_builtins.str] description: Description of the array items.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the array items.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the array items.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyItemsPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the property.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the property.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the property.
        """
        items_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        properties_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this property is required. Defaults to `false`.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaInlinePayloadOutputSchemaPropertyPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 items_json: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_json: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] type: Data type of the property.
        :param pulumi.Input[_builtins.str] description: Description of the property.
        :param pulumi.Input[_builtins.str] items_json: JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        :param pulumi.Input[_builtins.str] properties_json: JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        :param pulumi.Input[_builtins.bool] required: Whether this property is required. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items_json is not None:
            pulumi.set(__self__, "items_json", items_json)
        if properties_json is not None:
            pulumi.set(__self__, "properties_json", properties_json)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the property.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="itemsJson")
    def items_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for array items. Used for complex nested structures. Cannot be used with `properties_json`.
        """
        return pulumi.get(self, "items_json")

    @items_json.setter
    def items_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items_json", value)

    @_builtins.property
    @pulumi.getter(name="propertiesJson")
    def properties_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON-encoded schema definition for object properties. Used for complex nested structures. Cannot be used with `items_json`.
        """
        return pulumi.get(self, "properties_json")

    @properties_json.setter
    def properties_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_json", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this property is required. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3ArgsDict(TypedDict):
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID of the S3 bucket owner.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 URI where the schema is stored.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpLambdaToolSchemaS3Args:
    def __init__(__self__, *,
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: Account ID of the S3 bucket owner.
        :param pulumi.Input[_builtins.str] uri: S3 URI where the schema is stored.
        """
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID of the S3 bucket owner.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 URI where the schema is stored.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint for the MCP server target configuration.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpMcpServerArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Endpoint for the MCP server target configuration.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint for the MCP server target configuration.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgsDict(TypedDict):
        inline_payload: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgsDict']]
        s3: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3ArgsDict']]
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaArgs:
    def __init__(__self__, *,
                 inline_payload: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgs']] = None,
                 s3: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3Args']] = None):
        if inline_payload is not None:
            pulumi.set(__self__, "inline_payload", inline_payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="inlinePayload")
    def inline_payload(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgs']]:
        return pulumi.get(self, "inline_payload")

    @inline_payload.setter
    def inline_payload(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgs']]):
        pulumi.set(self, "inline_payload", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgsDict(TypedDict):
        payload: pulumi.Input[_builtins.str]
        """
        The inline schema payload content.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaInlinePayloadArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] payload: The inline schema payload content.
        """
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        """
        The inline schema payload content.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3ArgsDict(TypedDict):
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID of the S3 bucket owner.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 URI where the schema is stored.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpOpenApiSchemaS3Args:
    def __init__(__self__, *,
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: Account ID of the S3 bucket owner.
        :param pulumi.Input[_builtins.str] uri: S3 URI where the schema is stored.
        """
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID of the S3 bucket owner.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 URI where the schema is stored.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgsDict(TypedDict):
        inline_payload: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgsDict']]
        s3: NotRequired[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3ArgsDict']]
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelArgs:
    def __init__(__self__, *,
                 inline_payload: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgs']] = None,
                 s3: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3Args']] = None):
        if inline_payload is not None:
            pulumi.set(__self__, "inline_payload", inline_payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="inlinePayload")
    def inline_payload(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgs']]:
        return pulumi.get(self, "inline_payload")

    @inline_payload.setter
    def inline_payload(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgs']]):
        pulumi.set(self, "inline_payload", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgsDict(TypedDict):
        payload: pulumi.Input[_builtins.str]
        """
        The inline schema payload content.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelInlinePayloadArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] payload: The inline schema payload content.
        """
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        """
        The inline schema payload content.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3ArgsDict(TypedDict):
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID of the S3 bucket owner.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 URI where the schema is stored.
        """
elif False:
    AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTargetConfigurationMcpSmithyModelS3Args:
    def __init__(__self__, *,
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: Account ID of the S3 bucket owner.
        :param pulumi.Input[_builtins.str] uri: S3 URI where the schema is stored.
        """
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID of the S3 bucket owner.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 URI where the schema is stored.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentcoreGatewayTargetTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentcoreGatewayTargetTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTargetTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentcoreGatewayTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentcoreGatewayTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentcoreGatewayWorkloadIdentityDetailArgsDict(TypedDict):
        workload_identity_arn: pulumi.Input[_builtins.str]
        """
        ARN of the workload identity.
        """
elif False:
    AgentcoreGatewayWorkloadIdentityDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreGatewayWorkloadIdentityDetailArgs:
    def __init__(__self__, *,
                 workload_identity_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] workload_identity_arn: ARN of the workload identity.
        """
        pulumi.set(__self__, "workload_identity_arn", workload_identity_arn)

    @_builtins.property
    @pulumi.getter(name="workloadIdentityArn")
    def workload_identity_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the workload identity.
        """
        return pulumi.get(self, "workload_identity_arn")

    @workload_identity_arn.setter
    def workload_identity_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workload_identity_arn", value)


if not MYPY:
    class AgentcoreMemoryStrategyConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of custom override. Valid values: `SEMANTIC_OVERRIDE`, `SUMMARY_OVERRIDE`, `USER_PREFERENCE_OVERRIDE`. Changing this forces a new resource.
        """
        consolidation: NotRequired[pulumi.Input['AgentcoreMemoryStrategyConfigurationConsolidationArgsDict']]
        """
        Consolidation configuration for processing and organizing memory content. See `consolidation` below. Once added, this block cannot be removed without recreating the resource.
        """
        extraction: NotRequired[pulumi.Input['AgentcoreMemoryStrategyConfigurationExtractionArgsDict']]
        """
        Extraction configuration for identifying and extracting relevant information. See `extraction` below. Cannot be used with `type` set to `SUMMARY_OVERRIDE`. Once added, this block cannot be removed without recreating the resource.
        """
elif False:
    AgentcoreMemoryStrategyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreMemoryStrategyConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 consolidation: Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationConsolidationArgs']] = None,
                 extraction: Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationExtractionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of custom override. Valid values: `SEMANTIC_OVERRIDE`, `SUMMARY_OVERRIDE`, `USER_PREFERENCE_OVERRIDE`. Changing this forces a new resource.
        :param pulumi.Input['AgentcoreMemoryStrategyConfigurationConsolidationArgs'] consolidation: Consolidation configuration for processing and organizing memory content. See `consolidation` below. Once added, this block cannot be removed without recreating the resource.
        :param pulumi.Input['AgentcoreMemoryStrategyConfigurationExtractionArgs'] extraction: Extraction configuration for identifying and extracting relevant information. See `extraction` below. Cannot be used with `type` set to `SUMMARY_OVERRIDE`. Once added, this block cannot be removed without recreating the resource.
        """
        pulumi.set(__self__, "type", type)
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of custom override. Valid values: `SEMANTIC_OVERRIDE`, `SUMMARY_OVERRIDE`, `USER_PREFERENCE_OVERRIDE`. Changing this forces a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationConsolidationArgs']]:
        """
        Consolidation configuration for processing and organizing memory content. See `consolidation` below. Once added, this block cannot be removed without recreating the resource.
        """
        return pulumi.get(self, "consolidation")

    @consolidation.setter
    def consolidation(self, value: Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationConsolidationArgs']]):
        pulumi.set(self, "consolidation", value)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationExtractionArgs']]:
        """
        Extraction configuration for identifying and extracting relevant information. See `extraction` below. Cannot be used with `type` set to `SUMMARY_OVERRIDE`. Once added, this block cannot be removed without recreating the resource.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['AgentcoreMemoryStrategyConfigurationExtractionArgs']]):
        pulumi.set(self, "extraction", value)


if not MYPY:
    class AgentcoreMemoryStrategyConfigurationConsolidationArgsDict(TypedDict):
        append_to_prompt: pulumi.Input[_builtins.str]
        """
        Additional text to append to the model prompt for consolidation processing.
        """
        model_id: pulumi.Input[_builtins.str]
        """
        ID of the foundation model to use for consolidation processing.
        """
elif False:
    AgentcoreMemoryStrategyConfigurationConsolidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreMemoryStrategyConfigurationConsolidationArgs:
    def __init__(__self__, *,
                 append_to_prompt: pulumi.Input[_builtins.str],
                 model_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] append_to_prompt: Additional text to append to the model prompt for consolidation processing.
        :param pulumi.Input[_builtins.str] model_id: ID of the foundation model to use for consolidation processing.
        """
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Additional text to append to the model prompt for consolidation processing.
        """
        return pulumi.get(self, "append_to_prompt")

    @append_to_prompt.setter
    def append_to_prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "append_to_prompt", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the foundation model to use for consolidation processing.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)


if not MYPY:
    class AgentcoreMemoryStrategyConfigurationExtractionArgsDict(TypedDict):
        append_to_prompt: pulumi.Input[_builtins.str]
        """
        Additional text to append to the model prompt for extraction processing.
        """
        model_id: pulumi.Input[_builtins.str]
        """
        ID of the foundation model to use for extraction processing.
        """
elif False:
    AgentcoreMemoryStrategyConfigurationExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreMemoryStrategyConfigurationExtractionArgs:
    def __init__(__self__, *,
                 append_to_prompt: pulumi.Input[_builtins.str],
                 model_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] append_to_prompt: Additional text to append to the model prompt for extraction processing.
        :param pulumi.Input[_builtins.str] model_id: ID of the foundation model to use for extraction processing.
        """
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Additional text to append to the model prompt for extraction processing.
        """
        return pulumi.get(self, "append_to_prompt")

    @append_to_prompt.setter
    def append_to_prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "append_to_prompt", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the foundation model to use for extraction processing.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)


if not MYPY:
    class AgentcoreMemoryStrategyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentcoreMemoryStrategyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreMemoryStrategyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentcoreMemoryTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentcoreMemoryTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreMemoryTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderClientSecretArnArgsDict(TypedDict):
        secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret in AWS Secrets Manager.
        """
elif False:
    AgentcoreOauth2CredentialProviderClientSecretArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderClientSecretArnArgs:
    def __init__(__self__, *,
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] secret_arn: ARN of the secret in AWS Secrets Manager.
        """
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret in AWS Secrets Manager.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigArgsDict(TypedDict):
        custom_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgsDict']]
        """
        Custom OAuth2 provider configuration. See `custom` below.
        """
        github_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgsDict']]
        """
        GitHub OAuth provider configuration. See `github` below.
        """
        google_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgsDict']]
        """
        Google OAuth provider configuration. See `google` below.
        """
        microsoft_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgsDict']]
        """
        Microsoft OAuth provider configuration. See `microsoft` below.
        """
        salesforce_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgsDict']]
        """
        Salesforce OAuth provider configuration. See `salesforce` below.
        """
        slack_oauth2_provider_config: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgsDict']]
        """
        Slack OAuth provider configuration. See `slack` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 custom_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs']] = None,
                 github_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs']] = None,
                 google_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs']] = None,
                 microsoft_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs']] = None,
                 salesforce_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs']] = None,
                 slack_oauth2_provider_config: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs']] = None):
        """
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs'] custom_oauth2_provider_config: Custom OAuth2 provider configuration. See `custom` below.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs'] github_oauth2_provider_config: GitHub OAuth provider configuration. See `github` below.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs'] google_oauth2_provider_config: Google OAuth provider configuration. See `google` below.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs'] microsoft_oauth2_provider_config: Microsoft OAuth provider configuration. See `microsoft` below.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs'] salesforce_oauth2_provider_config: Salesforce OAuth provider configuration. See `salesforce` below.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs'] slack_oauth2_provider_config: Slack OAuth provider configuration. See `slack` below.
        """
        if custom_oauth2_provider_config is not None:
            pulumi.set(__self__, "custom_oauth2_provider_config", custom_oauth2_provider_config)
        if github_oauth2_provider_config is not None:
            pulumi.set(__self__, "github_oauth2_provider_config", github_oauth2_provider_config)
        if google_oauth2_provider_config is not None:
            pulumi.set(__self__, "google_oauth2_provider_config", google_oauth2_provider_config)
        if microsoft_oauth2_provider_config is not None:
            pulumi.set(__self__, "microsoft_oauth2_provider_config", microsoft_oauth2_provider_config)
        if salesforce_oauth2_provider_config is not None:
            pulumi.set(__self__, "salesforce_oauth2_provider_config", salesforce_oauth2_provider_config)
        if slack_oauth2_provider_config is not None:
            pulumi.set(__self__, "slack_oauth2_provider_config", slack_oauth2_provider_config)

    @_builtins.property
    @pulumi.getter(name="customOauth2ProviderConfig")
    def custom_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs']]:
        """
        Custom OAuth2 provider configuration. See `custom` below.
        """
        return pulumi.get(self, "custom_oauth2_provider_config")

    @custom_oauth2_provider_config.setter
    def custom_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs']]):
        pulumi.set(self, "custom_oauth2_provider_config", value)

    @_builtins.property
    @pulumi.getter(name="githubOauth2ProviderConfig")
    def github_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs']]:
        """
        GitHub OAuth provider configuration. See `github` below.
        """
        return pulumi.get(self, "github_oauth2_provider_config")

    @github_oauth2_provider_config.setter
    def github_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs']]):
        pulumi.set(self, "github_oauth2_provider_config", value)

    @_builtins.property
    @pulumi.getter(name="googleOauth2ProviderConfig")
    def google_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs']]:
        """
        Google OAuth provider configuration. See `google` below.
        """
        return pulumi.get(self, "google_oauth2_provider_config")

    @google_oauth2_provider_config.setter
    def google_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs']]):
        pulumi.set(self, "google_oauth2_provider_config", value)

    @_builtins.property
    @pulumi.getter(name="microsoftOauth2ProviderConfig")
    def microsoft_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs']]:
        """
        Microsoft OAuth provider configuration. See `microsoft` below.
        """
        return pulumi.get(self, "microsoft_oauth2_provider_config")

    @microsoft_oauth2_provider_config.setter
    def microsoft_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs']]):
        pulumi.set(self, "microsoft_oauth2_provider_config", value)

    @_builtins.property
    @pulumi.getter(name="salesforceOauth2ProviderConfig")
    def salesforce_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs']]:
        """
        Salesforce OAuth provider configuration. See `salesforce` below.
        """
        return pulumi.get(self, "salesforce_oauth2_provider_config")

    @salesforce_oauth2_provider_config.setter
    def salesforce_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs']]):
        pulumi.set(self, "salesforce_oauth2_provider_config", value)

    @_builtins.property
    @pulumi.getter(name="slackOauth2ProviderConfig")
    def slack_oauth2_provider_config(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs']]:
        """
        Slack OAuth provider configuration. See `slack` below.
        """
        return pulumi.get(self, "slack_oauth2_provider_config")

    @slack_oauth2_provider_config.setter
    def slack_oauth2_provider_config(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs']]):
        pulumi.set(self, "slack_oauth2_provider_config", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Used together with write-only credentials to trigger an update. Increment this value when an update to `client_id_wo` or `client_secret_wo` is required.

        **OAuth Discovery Configuration:**
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OAuth2 client ID. Cannot be used with `client_id_wo`. Must be used together with `client_secret`.
        """
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        Write-only OAuth2 client ID. Cannot be used with `client_id`. Must be used together with `client_secret_wo` and `client_credentials_wo_version`.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        OAuth2 client secret. Cannot be used with `client_secret_wo`. Must be used together with `client_id`.

        **Write-Only Credentials (choose one pair):**
        """
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        Write-only OAuth2 client secret. Cannot be used with `client_secret`. Must be used together with `client_id_wo` and `client_credentials_wo_version`.
        """
        oauth_discovery: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgsDict']]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discovery: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] client_credentials_wo_version: Used together with write-only credentials to trigger an update. Increment this value when an update to `client_id_wo` or `client_secret_wo` is required.
               
               **OAuth Discovery Configuration:**
        :param pulumi.Input[_builtins.str] client_id: OAuth2 client ID. Cannot be used with `client_id_wo`. Must be used together with `client_secret`.
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
               Write-only OAuth2 client ID. Cannot be used with `client_id`. Must be used together with `client_secret_wo` and `client_credentials_wo_version`.
        :param pulumi.Input[_builtins.str] client_secret: OAuth2 client secret. Cannot be used with `client_secret_wo`. Must be used together with `client_id`.
               
               **Write-Only Credentials (choose one pair):**
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
               Write-only OAuth2 client secret. Cannot be used with `client_secret`. Must be used together with `client_id_wo` and `client_credentials_wo_version`.
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs'] oauth_discovery: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discovery is not None:
            pulumi.set(__self__, "oauth_discovery", oauth_discovery)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Used together with write-only credentials to trigger an update. Increment this value when an update to `client_id_wo` or `client_secret_wo` is required.

        **OAuth Discovery Configuration:**
        """
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth2 client ID. Cannot be used with `client_id_wo`. Must be used together with `client_secret`.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        Write-only OAuth2 client ID. Cannot be used with `client_id`. Must be used together with `client_secret_wo` and `client_credentials_wo_version`.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OAuth2 client secret. Cannot be used with `client_secret_wo`. Must be used together with `client_id`.

        **Write-Only Credentials (choose one pair):**
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        Write-only OAuth2 client secret. Cannot be used with `client_secret`. Must be used together with `client_id_wo` and `client_credentials_wo_version`.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscovery")
    def oauth_discovery(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs']]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discovery")

    @oauth_discovery.setter
    def oauth_discovery(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs']]):
        pulumi.set(self, "oauth_discovery", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadata: NotRequired[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadata: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']] = None,
                 discovery_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs'] authorization_server_metadata: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        if authorization_server_metadata is not None:
            pulumi.set(__self__, "authorization_server_metadata", authorization_server_metadata)
        if discovery_url is not None:
            pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadata")
    def authorization_server_metadata(self) -> Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadata")

    @authorization_server_metadata.setter
    def authorization_server_metadata(self, value: Optional[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]):
        pulumi.set(self, "authorization_server_metadata", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
        response_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigCustomOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 response_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if response_types is not None:
            pulumi.set(__self__, "response_types", response_types)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "response_types", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        oauth_discoveries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgsDict']]]]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discoveries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs']]] oauth_discoveries: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discoveries is not None:
            pulumi.set(__self__, "oauth_discoveries", oauth_discoveries)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscoveries")
    def oauth_discoveries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs']]]]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discoveries")

    @oauth_discoveries.setter
    def oauth_discoveries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs']]]]):
        pulumi.set(self, "oauth_discoveries", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: pulumi.Input[_builtins.str]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]],
                 discovery_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]] authorization_server_metadatas: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        pulumi.set(__self__, "authorization_server_metadatas", authorization_server_metadatas)
        pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadatas")
    def authorization_server_metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadatas")

    @authorization_server_metadatas.setter
    def authorization_server_metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]):
        pulumi.set(self, "authorization_server_metadatas", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGithubOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "response_types", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        oauth_discoveries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgsDict']]]]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discoveries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs']]] oauth_discoveries: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discoveries is not None:
            pulumi.set(__self__, "oauth_discoveries", oauth_discoveries)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscoveries")
    def oauth_discoveries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs']]]]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discoveries")

    @oauth_discoveries.setter
    def oauth_discoveries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs']]]]):
        pulumi.set(self, "oauth_discoveries", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: pulumi.Input[_builtins.str]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]],
                 discovery_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]] authorization_server_metadatas: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        pulumi.set(__self__, "authorization_server_metadatas", authorization_server_metadatas)
        pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadatas")
    def authorization_server_metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadatas")

    @authorization_server_metadatas.setter
    def authorization_server_metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]):
        pulumi.set(self, "authorization_server_metadatas", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigGoogleOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "response_types", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        oauth_discoveries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgsDict']]]]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discoveries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs']]] oauth_discoveries: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discoveries is not None:
            pulumi.set(__self__, "oauth_discoveries", oauth_discoveries)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscoveries")
    def oauth_discoveries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs']]]]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discoveries")

    @oauth_discoveries.setter
    def oauth_discoveries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs']]]]):
        pulumi.set(self, "oauth_discoveries", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: pulumi.Input[_builtins.str]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]],
                 discovery_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]] authorization_server_metadatas: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        pulumi.set(__self__, "authorization_server_metadatas", authorization_server_metadatas)
        pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadatas")
    def authorization_server_metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadatas")

    @authorization_server_metadatas.setter
    def authorization_server_metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]):
        pulumi.set(self, "authorization_server_metadatas", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigMicrosoftOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "response_types", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        oauth_discoveries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgsDict']]]]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discoveries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs']]] oauth_discoveries: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discoveries is not None:
            pulumi.set(__self__, "oauth_discoveries", oauth_discoveries)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscoveries")
    def oauth_discoveries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs']]]]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discoveries")

    @oauth_discoveries.setter
    def oauth_discoveries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs']]]]):
        pulumi.set(self, "oauth_discoveries", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: pulumi.Input[_builtins.str]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]],
                 discovery_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]] authorization_server_metadatas: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        pulumi.set(__self__, "authorization_server_metadatas", authorization_server_metadatas)
        pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadatas")
    def authorization_server_metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadatas")

    @authorization_server_metadatas.setter
    def authorization_server_metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]):
        pulumi.set(self, "authorization_server_metadatas", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSalesforceOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "response_types", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgsDict(TypedDict):
        client_credentials_wo_version: NotRequired[pulumi.Input[_builtins.int]]
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_id_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        client_secret_wo: NotRequired[pulumi.Input[_builtins.str]]
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        oauth_discoveries: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgsDict']]]]
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigArgs:
    def __init__(__self__, *,
                 client_credentials_wo_version: Optional[pulumi.Input[_builtins.int]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_wo: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_discoveries: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[_builtins.str] client_secret_wo: **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs']]] oauth_discoveries: OAuth discovery configuration. See `oauth_discovery` below.
        """
        if client_credentials_wo_version is not None:
            pulumi.set(__self__, "client_credentials_wo_version", client_credentials_wo_version)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_id_wo is not None:
            pulumi.set(__self__, "client_id_wo", client_id_wo)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_secret_wo is not None:
            pulumi.set(__self__, "client_secret_wo", client_secret_wo)
        if oauth_discoveries is not None:
            pulumi.set(__self__, "oauth_discoveries", oauth_discoveries)

    @_builtins.property
    @pulumi.getter(name="clientCredentialsWoVersion")
    def client_credentials_wo_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "client_credentials_wo_version")

    @client_credentials_wo_version.setter
    def client_credentials_wo_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "client_credentials_wo_version", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientIdWo")
    def client_id_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_id_wo")

    @client_id_wo.setter
    def client_id_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_wo", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretWo")
    def client_secret_wo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
        """
        return pulumi.get(self, "client_secret_wo")

    @client_secret_wo.setter
    def client_secret_wo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_wo", value)

    @_builtins.property
    @pulumi.getter(name="oauthDiscoveries")
    def oauth_discoveries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs']]]]:
        """
        OAuth discovery configuration. See `oauth_discovery` below.
        """
        return pulumi.get(self, "oauth_discoveries")

    @oauth_discoveries.setter
    def oauth_discoveries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs']]]]):
        pulumi.set(self, "oauth_discoveries", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgsDict(TypedDict):
        authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict']]]
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        discovery_url: pulumi.Input[_builtins.str]
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryArgs:
    def __init__(__self__, *,
                 authorization_server_metadatas: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]],
                 discovery_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]] authorization_server_metadatas: Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        :param pulumi.Input[_builtins.str] discovery_url: OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        pulumi.set(__self__, "authorization_server_metadatas", authorization_server_metadatas)
        pulumi.set(__self__, "discovery_url", discovery_url)

    @_builtins.property
    @pulumi.getter(name="authorizationServerMetadatas")
    def authorization_server_metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]:
        """
        Manual OAuth2 authorization server metadata configuration. Cannot be used together with `discovery_url`. See `authorization_server_metadata` below.
        """
        return pulumi.get(self, "authorization_server_metadatas")

    @authorization_server_metadatas.setter
    def authorization_server_metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs']]]):
        pulumi.set(self, "authorization_server_metadatas", value)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> pulumi.Input[_builtins.str]:
        """
        OpenID Connect discovery URL (e.g., `https://provider.com/.well-known/openid-configuration`). Cannot be used together with `authorization_server_metadata`.
        """
        return pulumi.get(self, "discovery_url")

    @discovery_url.setter
    def discovery_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_url", value)


if not MYPY:
    class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization endpoint URL.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        OAuth2 authorization server issuer identifier.
        """
        response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        OAuth2 token endpoint URL.
        """
elif False:
    AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreOauth2CredentialProviderOauth2ProviderConfigSlackOauth2ProviderConfigOauthDiscoveryAuthorizationServerMetadataArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 response_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: OAuth2 authorization endpoint URL.
        :param pulumi.Input[_builtins.str] issuer: OAuth2 authorization server issuer identifier.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_types: Set of OAuth2 response types supported by the authorization server.
        :param pulumi.Input[_builtins.str] token_endpoint: OAuth2 token endpoint URL.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "response_types", response_types)
        pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization endpoint URL.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 authorization server issuer identifier.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="responseTypes")
    def response_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of OAuth2 response types supported by the authorization server.
        """
        return pulumi.get(self, "response_types")

    @response_types.setter
    def response_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "response_types", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth2 token endpoint URL.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AgentcoreTokenVaultCmkKmsConfigurationArgsDict(TypedDict):
        key_type: pulumi.Input[_builtins.str]
        """
        Type of KMS key. Valid values: `CustomerManagedKey`, `ServiceManagedKey`.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the KMS key.
        """
elif False:
    AgentcoreTokenVaultCmkKmsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentcoreTokenVaultCmkKmsConfigurationArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_type: Type of KMS key. Valid values: `CustomerManagedKey`, `ServiceManagedKey`.
        :param pulumi.Input[_builtins.str] kms_key_arn: ARN of the KMS key.
        """
        pulumi.set(__self__, "key_type", key_type)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of KMS key. Valid values: `CustomerManagedKey`, `ServiceManagedKey`.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the KMS key.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class CustomModelOutputDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the output data is stored.
        """
elif False:
    CustomModelOutputDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOutputDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    CustomModelTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class CustomModelTrainingDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the training data is stored.
        """
elif False:
    CustomModelTrainingDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTrainingMetricArgsDict(TypedDict):
        training_loss: pulumi.Input[_builtins.float]
        """
        Loss metric associated with the customization job.
        """
elif False:
    CustomModelTrainingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingMetricArgs:
    def __init__(__self__, *,
                 training_loss: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @_builtins.property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> pulumi.Input[_builtins.float]:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")

    @training_loss.setter
    def training_loss(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "training_loss", value)


if not MYPY:
    class CustomModelValidationDataConfigArgsDict(TypedDict):
        validators: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgsDict']]]]
        """
        Information about the validators.
        """
elif False:
    CustomModelValidationDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigArgs:
    def __init__(__self__, *,
                 validators: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @_builtins.property
    @pulumi.getter
    def validators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")

    @validators.setter
    def validators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]):
        pulumi.set(self, "validators", value)


if not MYPY:
    class CustomModelValidationDataConfigValidatorArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the validation data is stored.
        """
elif False:
    CustomModelValidationDataConfigValidatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigValidatorArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelValidationMetricArgsDict(TypedDict):
        validation_loss: pulumi.Input[_builtins.float]
        """
        The validation loss associated with the validator.
        """
elif False:
    CustomModelValidationMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationMetricArgs:
    def __init__(__self__, *,
                 validation_loss: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @_builtins.property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> pulumi.Input[_builtins.float]:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")

    @validation_loss.setter
    def validation_loss(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "validation_loss", value)


if not MYPY:
    class CustomModelVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        VPC configuration security group IDs.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        VPC configuration subnets.
        """
elif False:
    CustomModelVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: VPC configuration security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class GuardrailContentPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgsDict']]]]
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        tier_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigTierConfigArgsDict']]]]
        """
        Configuration block for the content policy tier. See Tier Config for more information.
        """
elif False:
    GuardrailContentPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]] = None,
                 tier_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigTierConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]] filters_configs: Set of content filter configs in content policy.
               See Filters Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigTierConfigArgs']]] tier_configs: Configuration block for the content policy tier. See Tier Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)
        if tier_configs is not None:
            pulumi.set(__self__, "tier_configs", tier_configs)

    @_builtins.property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]:
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)

    @_builtins.property
    @pulumi.getter(name="tierConfigs")
    def tier_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigTierConfigArgs']]]]:
        """
        Configuration block for the content policy tier. See Tier Config for more information.
        """
        return pulumi.get(self, "tier_configs")

    @tier_configs.setter
    def tier_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigTierConfigArgs']]]]):
        pulumi.set(self, "tier_configs", value)


if not MYPY:
    class GuardrailContentPolicyConfigFiltersConfigArgsDict(TypedDict):
        input_strength: pulumi.Input[_builtins.str]
        """
        Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        """
        output_strength: pulumi.Input[_builtins.str]
        """
        Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of contextual grounding filter.
        """
        input_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Toggles guardrail evaluation on input.
        """
        input_modalities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of selected input modalities. Valid values: `IMAGE`, `TEXT`.
        """
        output_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Toggles guardrail evaluation on output.
        """
        output_modalities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of selected output modalities. Valid values: `IMAGE`, `TEXT`.
        """
elif False:
    GuardrailContentPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input[_builtins.str],
                 output_strength: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 input_action: Optional[pulumi.Input[_builtins.str]] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 input_modalities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 output_action: Optional[pulumi.Input[_builtins.str]] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_modalities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] input_strength: Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        :param pulumi.Input[_builtins.str] output_strength: Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        :param pulumi.Input[_builtins.str] type: Type of contextual grounding filter.
        :param pulumi.Input[_builtins.str] input_action: Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] input_enabled: Toggles guardrail evaluation on input.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] input_modalities: List of selected input modalities. Valid values: `IMAGE`, `TEXT`.
        :param pulumi.Input[_builtins.str] output_action: Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] output_enabled: Toggles guardrail evaluation on output.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] output_modalities: List of selected output modalities. Valid values: `IMAGE`, `TEXT`.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if input_modalities is not None:
            pulumi.set(__self__, "input_modalities", input_modalities)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)
        if output_modalities is not None:
            pulumi.set(__self__, "output_modalities", output_modalities)

    @_builtins.property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input[_builtins.str]:
        """
        Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_strength", value)

    @_builtins.property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input[_builtins.str]:
        """
        Strength for filters. Valid values: `NONE`, `LOW`, `MEDIUM`, `HIGH`.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_strength", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Toggles guardrail evaluation on input.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="inputModalities")
    def input_modalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of selected input modalities. Valid values: `IMAGE`, `TEXT`.
        """
        return pulumi.get(self, "input_modalities")

    @input_modalities.setter
    def input_modalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_modalities", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Toggles guardrail evaluation on output.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputModalities")
    def output_modalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of selected output modalities. Valid values: `IMAGE`, `TEXT`.
        """
        return pulumi.get(self, "output_modalities")

    @output_modalities.setter
    def output_modalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_modalities", value)


if not MYPY:
    class GuardrailContentPolicyConfigTierConfigArgsDict(TypedDict):
        tier_name: pulumi.Input[_builtins.str]
        """
        The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
elif False:
    GuardrailContentPolicyConfigTierConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigTierConfigArgs:
    def __init__(__self__, *,
                 tier_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tier_name: The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
        return pulumi.get(self, "tier_name")

    @tier_name.setter
    def tier_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tier_name", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict']]]]
        """
        One or more blocks defining contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]] filters_configs: One or more blocks defining contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @_builtins.property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]:
        """
        One or more blocks defining contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict(TypedDict):
        threshold: pulumi.Input[_builtins.float]
        """
        The threshold for this filter.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[_builtins.float],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.float] threshold: The threshold for this filter.
        :param pulumi.Input[_builtins.str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailCrossRegionConfigArgsDict(TypedDict):
        guardrail_profile_identifier: pulumi.Input[_builtins.str]
        """
        Guardrail profile ARN.
        """
elif False:
    GuardrailCrossRegionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCrossRegionConfigArgs:
    def __init__(__self__, *,
                 guardrail_profile_identifier: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_profile_identifier: Guardrail profile ARN.
        """
        pulumi.set(__self__, "guardrail_profile_identifier", guardrail_profile_identifier)

    @_builtins.property
    @pulumi.getter(name="guardrailProfileIdentifier")
    def guardrail_profile_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Guardrail profile ARN.
        """
        return pulumi.get(self, "guardrail_profile_identifier")

    @guardrail_profile_identifier.setter
    def guardrail_profile_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_profile_identifier", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigArgsDict(TypedDict):
        pii_entities_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict']]]]
        """
        List of entities. See PII Entities Config for more information.
        """
        regexes_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict']]]]
        """
        List of regex. See Regexes Config for more information.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]] = None,
                 regexes_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @_builtins.property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @pii_entities_configs.setter
    def pii_entities_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]):
        pulumi.set(self, "pii_entities_configs", value)

    @_builtins.property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")

    @regexes_configs.setter
    def regexes_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]):
        pulumi.set(self, "regexes_configs", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        type: pulumi.Input[_builtins.str]
        """
        The currently supported PII entities.
        """
        input_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        output_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 input_action: Optional[pulumi.Input[_builtins.str]] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input[_builtins.str]] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.str] type: The currently supported PII entities.
        :param pulumi.Input[_builtins.str] input_action: Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.bool] input_enabled: Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        :param pulumi.Input[_builtins.str] output_action: Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.bool] output_enabled: Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        name: pulumi.Input[_builtins.str]
        """
        The regex name.
        """
        pattern: pulumi.Input[_builtins.str]
        """
        The regex pattern.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regex description.
        """
        input_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        output_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_action: Optional[pulumi.Input[_builtins.str]] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input[_builtins.str]] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.str] name: The regex name.
        :param pulumi.Input[_builtins.str] pattern: The regex pattern.
        :param pulumi.Input[_builtins.str] description: The regex description.
        :param pulumi.Input[_builtins.str] input_action: Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.bool] input_enabled: Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        :param pulumi.Input[_builtins.str] output_action: Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        :param pulumi.Input[_builtins.bool] output_enabled: Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Options for sensitive information action. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `ANONYMIZE`, `NONE`.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GuardrailTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GuardrailTopicPolicyConfigArgsDict(TypedDict):
        tier_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTierConfigArgsDict']]]]
        """
        Configuration block for the topic policy tier. See Tier Config for more information.
        """
        topics_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgsDict']]]]
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
elif False:
    GuardrailTopicPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 tier_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTierConfigArgs']]]] = None,
                 topics_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTierConfigArgs']]] tier_configs: Configuration block for the topic policy tier. See Tier Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if tier_configs is not None:
            pulumi.set(__self__, "tier_configs", tier_configs)
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @_builtins.property
    @pulumi.getter(name="tierConfigs")
    def tier_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTierConfigArgs']]]]:
        """
        Configuration block for the topic policy tier. See Tier Config for more information.
        """
        return pulumi.get(self, "tier_configs")

    @tier_configs.setter
    def tier_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTierConfigArgs']]]]):
        pulumi.set(self, "tier_configs", value)

    @_builtins.property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")

    @topics_configs.setter
    def topics_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]):
        pulumi.set(self, "topics_configs", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTierConfigArgsDict(TypedDict):
        tier_name: pulumi.Input[_builtins.str]
        """
        The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
elif False:
    GuardrailTopicPolicyConfigTierConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTierConfigArgs:
    def __init__(__self__, *,
                 tier_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tier_name: The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the content policy tier. Valid values include STANDARD or CLASSIC.
        """
        return pulumi.get(self, "tier_name")

    @tier_name.setter
    def tier_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tier_name", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTopicsConfigArgsDict(TypedDict):
        definition: pulumi.Input[_builtins.str]
        """
        Definition of topic in topic policy.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of topic in topic policy.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of topic in a policy.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of text examples.
        """
elif False:
    GuardrailTopicPolicyConfigTopicsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTopicsConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] definition: Definition of topic in topic policy.
        :param pulumi.Input[_builtins.str] name: Name of topic in topic policy.
        :param pulumi.Input[_builtins.str] type: Type of topic in a policy.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> pulumi.Input[_builtins.str]:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "definition", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "examples", value)


if not MYPY:
    class GuardrailVersionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    GuardrailVersionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailVersionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GuardrailWordPolicyConfigArgsDict(TypedDict):
        managed_word_lists_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgsDict']]]]
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        words_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgsDict']]]]
        """
        List of custom word configs. See Words Config for more information.
        """
elif False:
    GuardrailWordPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]] = None,
                 words_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @_builtins.property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @managed_word_lists_configs.setter
    def managed_word_lists_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_configs", value)

    @_builtins.property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")

    @words_configs.setter
    def words_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]):
        pulumi.set(self, "words_configs", value)


if not MYPY:
    class GuardrailWordPolicyConfigManagedWordListsConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Options for managed words.
        """
        input_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        output_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
elif False:
    GuardrailWordPolicyConfigManagedWordListsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigManagedWordListsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 input_action: Optional[pulumi.Input[_builtins.str]] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input[_builtins.str]] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Options for managed words.
        :param pulumi.Input[_builtins.str] input_action: Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] input_enabled: Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        :param pulumi.Input[_builtins.str] output_action: Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] output_enabled: Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailWordPolicyConfigWordsConfigArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        The custom word text.
        """
        input_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        output_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
elif False:
    GuardrailWordPolicyConfigWordsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigWordsConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 input_action: Optional[pulumi.Input[_builtins.str]] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input[_builtins.str]] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] text: The custom word text.
        :param pulumi.Input[_builtins.str] input_action: Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] input_enabled: Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        :param pulumi.Input[_builtins.str] output_action: Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        :param pulumi.Input[_builtins.bool] output_enabled: Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        pulumi.set(__self__, "text", text)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the input. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when harmful content is detected in the output. Valid values: `BLOCK`, `NONE`.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class InferenceProfileModelArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)


if not MYPY:
    class InferenceProfileModelSourceArgsDict(TypedDict):
        copy_from: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelSourceArgs:
    def __init__(__self__, *,
                 copy_from: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] copy_from: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @_builtins.property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "copy_from")

    @copy_from.setter
    def copy_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "copy_from", value)


if not MYPY:
    class InferenceProfileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InferenceProfileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ProvisionedModelThroughputTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProvisionedModelThroughputTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionedModelThroughputTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryArgsDict(TypedDict):
        agent_name: _builtins.str
        """
        Name of agent to which the version belongs.
        """
        agent_status: _builtins.str
        """
        Status of the agent to which the version belongs.
        """
        agent_version: _builtins.str
        """
        Version of the agent.
        """
        created_at: _builtins.str
        """
        Time at which the version was created.
        """
        description: _builtins.str
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        updated_at: _builtins.str
        """
        Time at which the version was last updated.
        """
        guardrail_configurations: NotRequired[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict']]
elif False:
    GetAgentAgentVersionsAgentVersionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryArgs:
    def __init__(__self__, *,
                 agent_name: _builtins.str,
                 agent_status: _builtins.str,
                 agent_version: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 updated_at: _builtins.str,
                 guardrail_configurations: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']] = None):
        """
        :param _builtins.str agent_name: Name of agent to which the version belongs.
        :param _builtins.str agent_status: Status of the agent to which the version belongs.
        :param _builtins.str agent_version: Version of the agent.
        :param _builtins.str created_at: Time at which the version was created.
        :param _builtins.str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param _builtins.str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @_builtins.property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> _builtins.str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @agent_name.setter
    def agent_name(self, value: _builtins.str):
        pulumi.set(self, "agent_name", value)

    @_builtins.property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> _builtins.str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @agent_status.setter
    def agent_status(self, value: _builtins.str):
        pulumi.set(self, "agent_status", value)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> _builtins.str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: _builtins.str):
        pulumi.set(self, "agent_version", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: _builtins.str):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configurations")

    @guardrail_configurations.setter
    def guardrail_configurations(self, value: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configurations", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: _builtins.str
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: _builtins.str
        """
        Version of the guardrail.
        """
elif False:
    GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: _builtins.str,
                 guardrail_version: _builtins.str):
        """
        :param _builtins.str guardrail_identifier: Unique identifier of the guardrail.
        :param _builtins.str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> _builtins.str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: _builtins.str):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> _builtins.str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: _builtins.str):
        pulumi.set(self, "guardrail_version", value)


