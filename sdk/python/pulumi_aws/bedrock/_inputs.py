# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentActionGroupActionGroupExecutorArgs',
    'AgentAgentActionGroupActionGroupExecutorArgsDict',
    'AgentAgentActionGroupApiSchemaArgs',
    'AgentAgentActionGroupApiSchemaArgsDict',
    'AgentAgentActionGroupApiSchemaS3Args',
    'AgentAgentActionGroupApiSchemaS3ArgsDict',
    'AgentAgentActionGroupFunctionSchemaArgs',
    'AgentAgentActionGroupFunctionSchemaArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict',
    'AgentAgentActionGroupTimeoutsArgs',
    'AgentAgentActionGroupTimeoutsArgsDict',
    'AgentAgentAliasRoutingConfigurationArgs',
    'AgentAgentAliasRoutingConfigurationArgsDict',
    'AgentAgentAliasTimeoutsArgs',
    'AgentAgentAliasTimeoutsArgsDict',
    'AgentAgentCollaboratorAgentDescriptorArgs',
    'AgentAgentCollaboratorAgentDescriptorArgsDict',
    'AgentAgentCollaboratorTimeoutsArgs',
    'AgentAgentCollaboratorTimeoutsArgsDict',
    'AgentAgentGuardrailConfigurationArgs',
    'AgentAgentGuardrailConfigurationArgsDict',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgs',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict',
    'AgentAgentMemoryConfigurationArgs',
    'AgentAgentMemoryConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict',
    'AgentAgentTimeoutsArgs',
    'AgentAgentTimeoutsArgsDict',
    'AgentDataSourceDataSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict',
    'AgentDataSourceServerSideEncryptionConfigurationArgs',
    'AgentDataSourceServerSideEncryptionConfigurationArgsDict',
    'AgentDataSourceTimeoutsArgs',
    'AgentDataSourceTimeoutsArgsDict',
    'AgentDataSourceVectorIngestionConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseTimeoutsArgs',
    'AgentKnowledgeBaseTimeoutsArgsDict',
    'CustomModelOutputDataConfigArgs',
    'CustomModelOutputDataConfigArgsDict',
    'CustomModelTimeoutsArgs',
    'CustomModelTimeoutsArgsDict',
    'CustomModelTrainingDataConfigArgs',
    'CustomModelTrainingDataConfigArgsDict',
    'CustomModelTrainingMetricArgs',
    'CustomModelTrainingMetricArgsDict',
    'CustomModelValidationDataConfigArgs',
    'CustomModelValidationDataConfigArgsDict',
    'CustomModelValidationDataConfigValidatorArgs',
    'CustomModelValidationDataConfigValidatorArgsDict',
    'CustomModelValidationMetricArgs',
    'CustomModelValidationMetricArgsDict',
    'CustomModelVpcConfigArgs',
    'CustomModelVpcConfigArgsDict',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContentPolicyConfigArgsDict',
    'GuardrailContentPolicyConfigFiltersConfigArgs',
    'GuardrailContentPolicyConfigFiltersConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgs',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict',
    'GuardrailTimeoutsArgs',
    'GuardrailTimeoutsArgsDict',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailTopicPolicyConfigArgsDict',
    'GuardrailTopicPolicyConfigTopicsConfigArgs',
    'GuardrailTopicPolicyConfigTopicsConfigArgsDict',
    'GuardrailVersionTimeoutsArgs',
    'GuardrailVersionTimeoutsArgsDict',
    'GuardrailWordPolicyConfigArgs',
    'GuardrailWordPolicyConfigArgsDict',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgs',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgsDict',
    'GuardrailWordPolicyConfigWordsConfigArgs',
    'GuardrailWordPolicyConfigWordsConfigArgsDict',
    'InferenceProfileModelArgs',
    'InferenceProfileModelArgsDict',
    'InferenceProfileModelSourceArgs',
    'InferenceProfileModelSourceArgsDict',
    'InferenceProfileTimeoutsArgs',
    'InferenceProfileTimeoutsArgsDict',
    'ProvisionedModelThroughputTimeoutsArgs',
    'ProvisionedModelThroughputTimeoutsArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryArgs',
    'GetAgentAgentVersionsAgentVersionSummaryArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentActionGroupActionGroupExecutorArgsDict(TypedDict):
        custom_control: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        lambda_: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
elif False:
    AgentAgentActionGroupActionGroupExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupActionGroupExecutorArgs:
    def __init__(__self__, *,
                 custom_control: Optional[pulumi.Input[builtins.str]] = None,
                 lambda_: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param pulumi.Input[builtins.str] lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_control", value)

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaArgsDict(TypedDict):
        payload: NotRequired[pulumi.Input[builtins.str]]
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        s3: NotRequired[pulumi.Input['AgentAgentActionGroupApiSchemaS3ArgsDict']]
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
elif False:
    AgentAgentActionGroupApiSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaArgs:
    def __init__(__self__, *,
                 payload: Optional[pulumi.Input[builtins.str]] = None,
                 s3: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']] = None):
        """
        :param pulumi.Input[builtins.str] payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param pulumi.Input['AgentAgentActionGroupApiSchemaS3Args'] s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaS3ArgsDict(TypedDict):
        s3_bucket_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the S3 bucket.
        """
        s3_object_key: NotRequired[pulumi.Input[builtins.str]]
        """
        S3 object key containing the resource.
        """
elif False:
    AgentAgentActionGroupApiSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaS3Args:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[builtins.str]] = None,
                 s3_object_key: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] s3_bucket_name: Name of the S3 bucket.
        :param pulumi.Input[builtins.str] s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "s3_object_key", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaArgsDict(TypedDict):
        member_functions: NotRequired[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict']]
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaArgs:
    def __init__(__self__, *,
                 member_functions: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']] = None):
        """
        :param pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs'] member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")

    @member_functions.setter
    def member_functions(self, value: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]):
        pulumi.set(self, "member_functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict(TypedDict):
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict']]]]
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs:
    def __init__(__self__, *,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]):
        pulumi.set(self, "functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name for the function.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the function and its purpose.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict']]]]
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name for the function.
        :param pulumi.Input[builtins.str] description: Description of the function and its purpose.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict(TypedDict):
        map_block_key: pulumi.Input[builtins.str]
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        type: pulumi.Input[builtins.str]
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 required: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param pulumi.Input[builtins.str] type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param pulumi.Input[builtins.str] description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param pulumi.Input[builtins.bool] required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[builtins.str]:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "map_block_key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentAgentActionGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentActionGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentAliasRoutingConfigurationArgsDict(TypedDict):
        agent_version: pulumi.Input[builtins.str]
        """
        Version of the agent with which the alias is associated.
        """
        provisioned_throughput: pulumi.Input[builtins.str]
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
elif False:
    AgentAgentAliasRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[builtins.str],
                 provisioned_throughput: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] agent_version: Version of the agent with which the alias is associated.
        :param pulumi.Input[builtins.str] provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[builtins.str]:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "agent_version", value)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provisioned_throughput", value)


if not MYPY:
    class AgentAgentAliasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentAliasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentCollaboratorAgentDescriptorArgsDict(TypedDict):
        alias_arn: pulumi.Input[builtins.str]
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
elif False:
    AgentAgentCollaboratorAgentDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorAgentDescriptorArgs:
    def __init__(__self__, *,
                 alias_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] alias_arn: ARN of the Alias of an Agent to use as the collaborator.
        """
        pulumi.set(__self__, "alias_arn", alias_arn)

    @property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
        return pulumi.get(self, "alias_arn")

    @alias_arn.setter
    def alias_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "alias_arn", value)


if not MYPY:
    class AgentAgentCollaboratorTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentCollaboratorTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[builtins.str]
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[builtins.str]
        """
        Version of the guardrail.
        """
elif False:
    AgentAgentGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[builtins.str],
                 guardrail_version: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] guardrail_identifier: Unique identifier of the guardrail.
        :param pulumi.Input[builtins.str] guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[builtins.str]:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[builtins.str]:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentKnowledgeBaseAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentMemoryConfigurationArgsDict(TypedDict):
        enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        storage_days: pulumi.Input[builtins.int]
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
elif False:
    AgentAgentMemoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentMemoryConfigurationArgs:
    def __init__(__self__, *,
                 enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 storage_days: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] enabled_memory_types: The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        :param pulumi.Input[builtins.int] storage_days: The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        pulumi.set(__self__, "storage_days", storage_days)

    @property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        return pulumi.get(self, "enabled_memory_types")

    @enabled_memory_types.setter
    def enabled_memory_types(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "enabled_memory_types", value)

    @property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> pulumi.Input[builtins.int]:
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        return pulumi.get(self, "storage_days")

    @storage_days.setter
    def storage_days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "storage_days", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationArgsDict(TypedDict):
        override_lambda: pulumi.Input[builtins.str]
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict']]]
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
elif False:
    AgentAgentPromptOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 override_lambda: pulumi.Input[builtins.str],
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        """
        :param pulumi.Input[builtins.str] override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "override_lambda", value)

    @property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict(TypedDict):
        base_prompt_template: pulumi.Input[builtins.str]
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict']]]
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        parser_mode: pulumi.Input[builtins.str]
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_creation_mode: pulumi.Input[builtins.str]
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_state: pulumi.Input[builtins.str]
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        prompt_type: pulumi.Input[builtins.str]
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationArgs:
    def __init__(__self__, *,
                 base_prompt_template: pulumi.Input[builtins.str],
                 inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]],
                 parser_mode: pulumi.Input[builtins.str],
                 prompt_creation_mode: pulumi.Input[builtins.str],
                 prompt_state: pulumi.Input[builtins.str],
                 prompt_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param pulumi.Input[builtins.str] parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[builtins.str] prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[builtins.str] prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[builtins.str] prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> pulumi.Input[builtins.str]:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_prompt_template", value)

    @property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @inference_configurations.setter
    def inference_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]):
        pulumi.set(self, "inference_configurations", value)

    @property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> pulumi.Input[builtins.str]:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "parser_mode", value)

    @property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> pulumi.Input[builtins.str]:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "prompt_creation_mode", value)

    @property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> pulumi.Input[builtins.str]:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "prompt_state", value)

    @property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> pulumi.Input[builtins.str]:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "prompt_type", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict(TypedDict):
        max_length: pulumi.Input[builtins.int]
        """
        Maximum number of tokens to allow in the generated response.
        """
        stop_sequences: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        temperature: pulumi.Input[builtins.float]
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        top_k: pulumi.Input[builtins.int]
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        top_p: pulumi.Input[builtins.float]
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_length: pulumi.Input[builtins.int],
                 stop_sequences: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 temperature: pulumi.Input[builtins.float],
                 top_k: pulumi.Input[builtins.int],
                 top_p: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.int] max_length: Maximum number of tokens to allow in the generated response.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param pulumi.Input[builtins.float] temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param pulumi.Input[builtins.int] top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param pulumi.Input[builtins.float] top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[builtins.int]:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "stop_sequences", value)

    @property
    @pulumi.getter
    def temperature(self) -> pulumi.Input[builtins.float]:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> pulumi.Input[builtins.int]:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "top_k", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> pulumi.Input[builtins.float]:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentAgentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        confluence_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict']]
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        s3_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict']]
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        salesforce_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict']]
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        share_point_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict']]
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        web_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict']]
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 confluence_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']] = None,
                 web_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs'] confluence_configuration: Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs'] s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs'] salesforce_configuration: Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs'] share_point_configuration: Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs'] web_configuration: Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]:
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]:
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]:
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]:
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        return pulumi.get(self, "web_configuration")

    @web_configuration.setter
    def web_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]):
        pulumi.set(self, "web_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_type: pulumi.Input[builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        host_url: pulumi.Input[builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 host_type: pulumi.Input[builtins.str],
                 host_url: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_arn: pulumi.Input[builtins.str]
        """
        ARN of the bucket that contains the data source.
        """
        bucket_owner_account_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Bucket account owner ID for the S3 bucket.
        """
        inclusion_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
elif False:
    AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[builtins.str],
                 bucket_owner_account_id: Optional[pulumi.Input[builtins.str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] bucket_arn: ARN of the bucket that contains the data source.
        :param pulumi.Input[builtins.str] bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_url: pulumi.Input[builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 host_url: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        domain: pulumi.Input[builtins.str]
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        host_type: pulumi.Input[builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        site_urls: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of one or more SharePoint site URLs.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The identifier of your Microsoft 365 tenant.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 domain: pulumi.Input[builtins.str],
                 host_type: pulumi.Input[builtins.str],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[builtins.str] domain: The domain of your SharePoint instance or site URL/URLs.
        :param pulumi.Input[builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] site_urls: A list of one or more SharePoint site URLs.
        :param pulumi.Input[builtins.str] tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[builtins.str]:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "site_urls", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict(TypedDict):
        crawler_limits: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict']]
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        Scope of what is crawled for your URLs.
        """
        user_agent: NotRequired[pulumi.Input[builtins.str]]
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 crawler_limits: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']] = None,
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None,
                 user_agent: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs'] crawler_limits: Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclusion_filters: List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] inclusion_filters: List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        :param pulumi.Input[builtins.str] scope: Scope of what is crawled for your URLs.
        :param pulumi.Input[builtins.str] user_agent: String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]:
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        return pulumi.get(self, "crawler_limits")

    @crawler_limits.setter
    def crawler_limits(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]):
        pulumi.set(self, "crawler_limits", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scope of what is crawled for your URLs.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_agent", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict(TypedDict):
        max_pages: NotRequired[pulumi.Input[builtins.int]]
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        rate_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs:
    def __init__(__self__, *,
                 max_pages: Optional[pulumi.Input[builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_pages: Max number of web pages crawled from your source URLs, up to 25,000 pages.
        :param pulumi.Input[builtins.int] rate_limit: Max rate at which pages are crawled, up to 300 per minute per host.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        return pulumi.get(self, "max_pages")

    @max_pages.setter
    def max_pages(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_pages", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict(TypedDict):
        url_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict']]
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 url_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs'] url_configuration: The URL configuration of your web data source. See `url_configuration` block for details.
        """
        if url_configuration is not None:
            pulumi.set(__self__, "url_configuration", url_configuration)

    @property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]:
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
        return pulumi.get(self, "url_configuration")

    @url_configuration.setter
    def url_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]):
        pulumi.set(self, "url_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict(TypedDict):
        seed_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict']]]]
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]] seed_urls: List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        if seed_urls is not None:
            pulumi.set(__self__, "seed_urls", seed_urls)

    @property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]:
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]):
        pulumi.set(self, "seed_urls", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] url: Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AgentDataSourceServerSideEncryptionConfigurationArgsDict(TypedDict):
        kms_key_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
elif False:
    AgentDataSourceServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class AgentDataSourceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentDataSourceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationArgsDict(TypedDict):
        chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict']]
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        custom_transformation_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict']]
        """
        Configuration for custom transformation of data source documents.
        """
        parsing_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict']]
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs'] custom_transformation_configuration: Configuration for custom transformation of data source documents.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs'] parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]:
        """
        Configuration for custom transformation of data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict(TypedDict):
        chunking_strategy: pulumi.Input[builtins.str]
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        fixed_size_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        hierarchical_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        semantic_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input[builtins.str],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input[builtins.str]:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "chunking_strategy", value)

    @property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[builtins.int]
        """
        Maximum number of tokens to include in a chunk.
        """
        overlap_percentage: pulumi.Input[builtins.int]
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[builtins.int],
                 overlap_percentage: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] max_tokens: Maximum number of tokens to include in a chunk.
        :param pulumi.Input[builtins.int] overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[builtins.int]:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_tokens", value)

    @property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[builtins.int]:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "overlap_percentage", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict(TypedDict):
        level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict']]]
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        overlap_tokens: pulumi.Input[builtins.int]
        """
        The number of tokens to repeat across chunks in the same layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param pulumi.Input[builtins.int] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[builtins.int]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "overlap_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[builtins.int]
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict(TypedDict):
        breakpoint_percentile_threshold: pulumi.Input[builtins.int]
        """
        The dissimilarity threshold for splitting chunks.
        """
        buffer_size: pulumi.Input[builtins.int]
        """
        The buffer size.
        """
        max_token: pulumi.Input[builtins.int]
        """
        The maximum number of tokens a chunk can contain.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[builtins.int],
                 buffer_size: pulumi.Input[builtins.int],
                 max_token: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[builtins.int] buffer_size: The buffer size.
        :param pulumi.Input[builtins.int] max_token: The maximum number of tokens a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[builtins.int]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[builtins.int]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of tokens a chunk can contain.
        """
        return pulumi.get(self, "max_token")

    @max_token.setter
    def max_token(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_token", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict(TypedDict):
        intermediate_storage: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict']]
        """
        The intermediate storage for custom transformation.
        """
        transformation: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict']]
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']] = None,
                 transformation: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs'] intermediate_storage: The intermediate storage for custom transformation.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs'] transformation: A custom processing step for documents moving through the data source ingestion pipeline.
        """
        if intermediate_storage is not None:
            pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)

    @property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]:
        """
        The intermediate storage for custom transformation.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]):
        pulumi.set(self, "intermediate_storage", value)

    @property
    @pulumi.getter
    def transformation(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]:
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]):
        pulumi.set(self, "transformation", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict(TypedDict):
        s3_location: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict']]
        """
        Configuration block for intermedia S3 storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs'] s3_location: Configuration block for intermedia S3 storage.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]:
        """
        Configuration block for intermedia S3 storage.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[builtins.str]
        """
        S3 URI for intermediate storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] uri: S3 URI for intermediate storage.
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[builtins.str]:
        """
        S3 URI for intermediate storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict(TypedDict):
        step_to_apply: pulumi.Input[builtins.str]
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        transformation_function: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict']]
        """
        The lambda function that processes documents.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input[builtins.str],
                 transformation_function: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']] = None):
        """
        :param pulumi.Input[builtins.str] step_to_apply: When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs'] transformation_function: The lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        if transformation_function is not None:
            pulumi.set(__self__, "transformation_function", transformation_function)

    @property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input[builtins.str]:
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "step_to_apply", value)

    @property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]:
        """
        The lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]):
        pulumi.set(self, "transformation_function", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict(TypedDict):
        transformation_lambda_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict']]
        """
        The configuration of the lambda function.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The configuration of the lambda function.
        """
        if transformation_lambda_configuration is not None:
            pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]:
        """
        The configuration of the lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]):
        pulumi.set(self, "transformation_lambda_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict(TypedDict):
        lambda_arn: pulumi.Input[builtins.str]
        """
        The ARN of the lambda to use for custom transformation.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] lambda_arn: The ARN of the lambda to use for custom transformation.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the lambda to use for custom transformation.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict(TypedDict):
        parsing_strategy: pulumi.Input[builtins.str]
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict']]
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input[builtins.str],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input[builtins.str]:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "parsing_strategy", value)

    @property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict(TypedDict):
        model_arn: pulumi.Input[builtins.str]
        """
        The ARN of the model used to parse documents
        """
        parsing_prompt: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict']]
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[builtins.str],
                 parsing_prompt: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']] = None):
        """
        :param pulumi.Input[builtins.str] model_arn: The ARN of the model used to parse documents
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "model_arn", value)

    @property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict(TypedDict):
        parsing_prompt_string: pulumi.Input[builtins.str]
        """
        Instructions for interpreting the contents of the document.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_string: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> pulumi.Input[builtins.str]:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")

    @parsing_prompt_string.setter
    def parsing_prompt_string(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "parsing_prompt_string", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        vector_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict']]
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 vector_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]:
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict(TypedDict):
        embedding_model_arn: pulumi.Input[builtins.str]
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict']]
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        supplemental_data_storage_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict']]
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[builtins.str],
                 embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']] = None,
                 supplemental_data_storage_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs'] embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs'] supplemental_data_storage_configuration: supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "embedding_model_arn", value)

    @property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @embedding_model_configuration.setter
    def embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "embedding_model_configuration", value)

    @property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]:
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")

    @supplemental_data_storage_configuration.setter
    def supplemental_data_storage_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]):
        pulumi.set(self, "supplemental_data_storage_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict(TypedDict):
        bedrock_embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict']]
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs'] bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]:
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")

    @bedrock_embedding_model_configuration.setter
    def bedrock_embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_embedding_model_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[builtins.int]]
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        embedding_data_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[builtins.int]] = None,
                 embedding_data_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] dimensions: Dimension details for the vector configuration used on the Bedrock embeddings model.
        :param pulumi.Input[builtins.str] embedding_data_type: Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        return pulumi.get(self, "embedding_data_type")

    @embedding_data_type.setter
    def embedding_data_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "embedding_data_type", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict(TypedDict):
        storage_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict']]]]
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs:
    def __init__(__self__, *,
                 storage_locations: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]] storage_locations: A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]:
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        return pulumi.get(self, "storage_locations")

    @storage_locations.setter
    def storage_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]):
        pulumi.set(self, "storage_locations", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        s3_location: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict']]
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 s3_location: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Storage service used for this location. `S3` is the only valid value.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs'] s3_location: Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]:
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[builtins.str]
        """
        URI of the location.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] uri: URI of the location.
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[builtins.str]:
        """
        URI of the location.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        opensearch_serverless_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        pinecone_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        rds_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict']]
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        redis_enterprise_cloud_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 opensearch_serverless_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']] = None,
                 redis_enterprise_cloud_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs'] opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs'] pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs'] rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs'] redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)

    @property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")

    @redis_enterprise_cloud_configuration.setter
    def redis_enterprise_cloud_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]):
        pulumi.set(self, "redis_enterprise_cloud_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict(TypedDict):
        collection_arn: pulumi.Input[builtins.str]
        """
        ARN of the OpenSearch Service vector store.
        """
        vector_index_name: pulumi.Input[builtins.str]
        """
        Name of the vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[builtins.str],
                 vector_index_name: pulumi.Input[builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] collection_arn: ARN of the OpenSearch Service vector store.
        :param pulumi.Input[builtins.str] vector_index_name: Name of the vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "collection_arn", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[builtins.str]] = None,
                 text_field: Optional[pulumi.Input[builtins.str]] = None,
                 vector_field: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict(TypedDict):
        connection_string: pulumi.Input[builtins.str]
        """
        Endpoint URL for your index management page.
        """
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace to be used to write new data to your database.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[builtins.str],
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connection_string: Endpoint URL for your index management page.
        :param pulumi.Input[builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param pulumi.Input[builtins.str] namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[builtins.str]:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[builtins.str]] = None,
                 text_field: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        database_name: pulumi.Input[builtins.str]
        """
        Name of your Amazon RDS database.
        """
        resource_arn: pulumi.Input[builtins.str]
        """
        ARN of the vector store.
        """
        table_name: pulumi.Input[builtins.str]
        """
        Name of the table in the database.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict']]
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 database_name: pulumi.Input[builtins.str],
                 resource_arn: pulumi.Input[builtins.str],
                 table_name: pulumi.Input[builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[builtins.str] database_name: Name of your Amazon RDS database.
        :param pulumi.Input[builtins.str] resource_arn: ARN of the vector store.
        :param pulumi.Input[builtins.str] table_name: Name of the table in the database.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs'] field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        primary_key_field: pulumi.Input[builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        text_field: pulumi.Input[builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[builtins.str],
                 primary_key_field: pulumi.Input[builtins.str],
                 text_field: pulumi.Input[builtins.str],
                 vector_field: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[builtins.str] primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "primary_key_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        endpoint: pulumi.Input[builtins.str]
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        vector_index_name: pulumi.Input[builtins.str]
        """
        Name of the vector index.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[builtins.str],
                 endpoint: pulumi.Input[builtins.str],
                 vector_index_name: pulumi.Input[builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param pulumi.Input[builtins.str] endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param pulumi.Input[builtins.str] vector_index_name: Name of the vector index.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[builtins.str]:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[builtins.str]] = None,
                 text_field: Optional[pulumi.Input[builtins.str]] = None,
                 vector_field: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentKnowledgeBaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CustomModelOutputDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[builtins.str]
        """
        The S3 URI where the output data is stored.
        """
elif False:
    CustomModelOutputDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOutputDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[builtins.str]:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    CustomModelTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class CustomModelTrainingDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[builtins.str]
        """
        The S3 URI where the training data is stored.
        """
elif False:
    CustomModelTrainingDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[builtins.str]:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTrainingMetricArgsDict(TypedDict):
        training_loss: pulumi.Input[builtins.float]
        """
        Loss metric associated with the customization job.
        """
elif False:
    CustomModelTrainingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingMetricArgs:
    def __init__(__self__, *,
                 training_loss: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.float] training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> pulumi.Input[builtins.float]:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")

    @training_loss.setter
    def training_loss(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "training_loss", value)


if not MYPY:
    class CustomModelValidationDataConfigArgsDict(TypedDict):
        validators: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgsDict']]]]
        """
        Information about the validators.
        """
elif False:
    CustomModelValidationDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigArgs:
    def __init__(__self__, *,
                 validators: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")

    @validators.setter
    def validators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]):
        pulumi.set(self, "validators", value)


if not MYPY:
    class CustomModelValidationDataConfigValidatorArgsDict(TypedDict):
        s3_uri: pulumi.Input[builtins.str]
        """
        The S3 URI where the validation data is stored.
        """
elif False:
    CustomModelValidationDataConfigValidatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigValidatorArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[builtins.str]:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelValidationMetricArgsDict(TypedDict):
        validation_loss: pulumi.Input[builtins.float]
        """
        The validation loss associated with the validator.
        """
elif False:
    CustomModelValidationMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationMetricArgs:
    def __init__(__self__, *,
                 validation_loss: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.float] validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> pulumi.Input[builtins.float]:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")

    @validation_loss.setter
    def validation_loss(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "validation_loss", value)


if not MYPY:
    class CustomModelVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        VPC configuration security group IDs.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        VPC configuration subnets.
        """
elif False:
    CustomModelVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: VPC configuration security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class GuardrailContentPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgsDict']]]]
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
elif False:
    GuardrailContentPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]] filters_configs: Set of content filter configs in content policy.
               See Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]:
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContentPolicyConfigFiltersConfigArgsDict(TypedDict):
        input_strength: pulumi.Input[builtins.str]
        """
        Strength for filters.
        """
        output_strength: pulumi.Input[builtins.str]
        """
        Strength for filters.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContentPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input[builtins.str],
                 output_strength: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] input_strength: Strength for filters.
        :param pulumi.Input[builtins.str] output_strength: Strength for filters.
        :param pulumi.Input[builtins.str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input[builtins.str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "input_strength", value)

    @property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input[builtins.str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "output_strength", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict']]]]
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]] filters_configs: List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]:
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict(TypedDict):
        threshold: pulumi.Input[builtins.float]
        """
        The threshold for this filter.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[builtins.float],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.float] threshold: The threshold for this filter.
        :param pulumi.Input[builtins.str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigArgsDict(TypedDict):
        pii_entities_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict']]]]
        """
        List of entities. See PII Entities Config for more information.
        """
        regexes_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict']]]]
        """
        List of regex. See Regexes Config for more information.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]] = None,
                 regexes_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @pii_entities_configs.setter
    def pii_entities_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]):
        pulumi.set(self, "pii_entities_configs", value)

    @property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")

    @regexes_configs.setter
    def regexes_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]):
        pulumi.set(self, "regexes_configs", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict(TypedDict):
        action: pulumi.Input[builtins.str]
        """
        Options for sensitive information action.
        """
        type: pulumi.Input[builtins.str]
        """
        The currently supported PII entities.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] action: Options for sensitive information action.
        :param pulumi.Input[builtins.str] type: The currently supported PII entities.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[builtins.str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict(TypedDict):
        action: pulumi.Input[builtins.str]
        """
        Options for sensitive information action.
        """
        name: pulumi.Input[builtins.str]
        """
        The regex name.
        """
        pattern: pulumi.Input[builtins.str]
        """
        The regex pattern.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The regex description.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 pattern: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: Options for sensitive information action.
        :param pulumi.Input[builtins.str] name: The regex name.
        :param pulumi.Input[builtins.str] pattern: The regex pattern.
        :param pulumi.Input[builtins.str] description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[builtins.str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[builtins.str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GuardrailTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GuardrailTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GuardrailTopicPolicyConfigArgsDict(TypedDict):
        topics_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgsDict']]]]
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
elif False:
    GuardrailTopicPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 topics_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")

    @topics_configs.setter
    def topics_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]):
        pulumi.set(self, "topics_configs", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTopicsConfigArgsDict(TypedDict):
        definition: pulumi.Input[builtins.str]
        """
        Definition of topic in topic policy.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of topic in topic policy.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of topic in a policy.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of text examples.
        """
elif False:
    GuardrailTopicPolicyConfigTopicsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTopicsConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] definition: Definition of topic in topic policy.
        :param pulumi.Input[builtins.str] name: Name of topic in topic policy.
        :param pulumi.Input[builtins.str] type: Type of topic in a policy.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[builtins.str]:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "examples", value)


if not MYPY:
    class GuardrailVersionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    GuardrailVersionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailVersionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GuardrailWordPolicyConfigArgsDict(TypedDict):
        managed_word_lists_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgsDict']]]]
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        words_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgsDict']]]]
        """
        List of custom word configs. See Words Config for more information.
        """
elif False:
    GuardrailWordPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]] = None,
                 words_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @managed_word_lists_configs.setter
    def managed_word_lists_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_configs", value)

    @property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")

    @words_configs.setter
    def words_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]):
        pulumi.set(self, "words_configs", value)


if not MYPY:
    class GuardrailWordPolicyConfigManagedWordListsConfigArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Options for managed words.
        """
elif False:
    GuardrailWordPolicyConfigManagedWordListsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigManagedWordListsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] type: Options for managed words.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailWordPolicyConfigWordsConfigArgsDict(TypedDict):
        text: pulumi.Input[builtins.str]
        """
        The custom word text.
        """
elif False:
    GuardrailWordPolicyConfigWordsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigWordsConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[builtins.str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class InferenceProfileModelArgsDict(TypedDict):
        model_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "model_arn", value)


if not MYPY:
    class InferenceProfileModelSourceArgsDict(TypedDict):
        copy_from: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelSourceArgs:
    def __init__(__self__, *,
                 copy_from: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] copy_from: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "copy_from")

    @copy_from.setter
    def copy_from(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "copy_from", value)


if not MYPY:
    class InferenceProfileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InferenceProfileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ProvisionedModelThroughputTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProvisionedModelThroughputTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionedModelThroughputTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryArgsDict(TypedDict):
        agent_name: builtins.str
        """
        Name of agent to which the version belongs.
        """
        agent_status: builtins.str
        """
        Status of the agent to which the version belongs.
        """
        agent_version: builtins.str
        """
        Version of the agent.
        """
        created_at: builtins.str
        """
        Time at which the version was created.
        """
        description: builtins.str
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        updated_at: builtins.str
        """
        Time at which the version was last updated.
        """
        guardrail_configurations: NotRequired[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict']]
elif False:
    GetAgentAgentVersionsAgentVersionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryArgs:
    def __init__(__self__, *,
                 agent_name: builtins.str,
                 agent_status: builtins.str,
                 agent_version: builtins.str,
                 created_at: builtins.str,
                 description: builtins.str,
                 updated_at: builtins.str,
                 guardrail_configurations: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']] = None):
        """
        :param builtins.str agent_name: Name of agent to which the version belongs.
        :param builtins.str agent_status: Status of the agent to which the version belongs.
        :param builtins.str agent_version: Version of the agent.
        :param builtins.str created_at: Time at which the version was created.
        :param builtins.str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param builtins.str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> builtins.str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @agent_name.setter
    def agent_name(self, value: builtins.str):
        pulumi.set(self, "agent_name", value)

    @property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> builtins.str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @agent_status.setter
    def agent_status(self, value: builtins.str):
        pulumi.set(self, "agent_status", value)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> builtins.str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: builtins.str):
        pulumi.set(self, "agent_version", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: builtins.str):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> builtins.str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: builtins.str):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configurations")

    @guardrail_configurations.setter
    def guardrail_configurations(self, value: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configurations", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: builtins.str
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: builtins.str
        """
        Version of the guardrail.
        """
elif False:
    GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: builtins.str,
                 guardrail_version: builtins.str):
        """
        :param builtins.str guardrail_identifier: Unique identifier of the guardrail.
        :param builtins.str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> builtins.str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: builtins.str):
        pulumi.set(self, "guardrail_identifier", value)

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> builtins.str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: builtins.str):
        pulumi.set(self, "guardrail_version", value)


