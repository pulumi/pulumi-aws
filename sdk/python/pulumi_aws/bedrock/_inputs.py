# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentActionGroupActionGroupExecutorArgs',
    'AgentAgentActionGroupActionGroupExecutorArgsDict',
    'AgentAgentActionGroupApiSchemaArgs',
    'AgentAgentActionGroupApiSchemaArgsDict',
    'AgentAgentActionGroupApiSchemaS3Args',
    'AgentAgentActionGroupApiSchemaS3ArgsDict',
    'AgentAgentActionGroupFunctionSchemaArgs',
    'AgentAgentActionGroupFunctionSchemaArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict',
    'AgentAgentActionGroupTimeoutsArgs',
    'AgentAgentActionGroupTimeoutsArgsDict',
    'AgentAgentAliasRoutingConfigurationArgs',
    'AgentAgentAliasRoutingConfigurationArgsDict',
    'AgentAgentAliasTimeoutsArgs',
    'AgentAgentAliasTimeoutsArgsDict',
    'AgentAgentCollaboratorAgentDescriptorArgs',
    'AgentAgentCollaboratorAgentDescriptorArgsDict',
    'AgentAgentCollaboratorTimeoutsArgs',
    'AgentAgentCollaboratorTimeoutsArgsDict',
    'AgentAgentGuardrailConfigurationArgs',
    'AgentAgentGuardrailConfigurationArgsDict',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgs',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict',
    'AgentAgentMemoryConfigurationArgs',
    'AgentAgentMemoryConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict',
    'AgentAgentTimeoutsArgs',
    'AgentAgentTimeoutsArgsDict',
    'AgentDataSourceDataSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict',
    'AgentDataSourceServerSideEncryptionConfigurationArgs',
    'AgentDataSourceServerSideEncryptionConfigurationArgsDict',
    'AgentDataSourceTimeoutsArgs',
    'AgentDataSourceTimeoutsArgsDict',
    'AgentDataSourceVectorIngestionConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict',
    'AgentFlowDefinitionArgs',
    'AgentFlowDefinitionArgsDict',
    'AgentFlowDefinitionConnectionArgs',
    'AgentFlowDefinitionConnectionArgsDict',
    'AgentFlowDefinitionConnectionConfigurationArgs',
    'AgentFlowDefinitionConnectionConfigurationArgsDict',
    'AgentFlowDefinitionConnectionConfigurationConditionalArgs',
    'AgentFlowDefinitionConnectionConfigurationConditionalArgsDict',
    'AgentFlowDefinitionConnectionConfigurationDataArgs',
    'AgentFlowDefinitionConnectionConfigurationDataArgsDict',
    'AgentFlowDefinitionNodeArgs',
    'AgentFlowDefinitionNodeArgsDict',
    'AgentFlowDefinitionNodeConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationAgentArgs',
    'AgentFlowDefinitionNodeConfigurationAgentArgsDict',
    'AgentFlowDefinitionNodeConfigurationCollectorArgs',
    'AgentFlowDefinitionNodeConfigurationCollectorArgsDict',
    'AgentFlowDefinitionNodeConfigurationConditionArgs',
    'AgentFlowDefinitionNodeConfigurationConditionArgsDict',
    'AgentFlowDefinitionNodeConfigurationConditionConditionArgs',
    'AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict',
    'AgentFlowDefinitionNodeConfigurationInlineCodeArgs',
    'AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict',
    'AgentFlowDefinitionNodeConfigurationInputArgs',
    'AgentFlowDefinitionNodeConfigurationInputArgsDict',
    'AgentFlowDefinitionNodeConfigurationIteratorArgs',
    'AgentFlowDefinitionNodeConfigurationIteratorArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs',
    'AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict',
    'AgentFlowDefinitionNodeConfigurationLexArgs',
    'AgentFlowDefinitionNodeConfigurationLexArgsDict',
    'AgentFlowDefinitionNodeConfigurationOutputArgs',
    'AgentFlowDefinitionNodeConfigurationOutputArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptArgs',
    'AgentFlowDefinitionNodeConfigurationPromptArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs',
    'AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalArgs',
    'AgentFlowDefinitionNodeConfigurationRetrievalArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args',
    'AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageArgs',
    'AgentFlowDefinitionNodeConfigurationStorageArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args',
    'AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict',
    'AgentFlowDefinitionNodeInputArgs',
    'AgentFlowDefinitionNodeInputArgsDict',
    'AgentFlowDefinitionNodeOutputArgs',
    'AgentFlowDefinitionNodeOutputArgsDict',
    'AgentFlowTimeoutsArgs',
    'AgentFlowTimeoutsArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseTimeoutsArgs',
    'AgentKnowledgeBaseTimeoutsArgsDict',
    'AgentPromptVariantArgs',
    'AgentPromptVariantArgsDict',
    'AgentPromptVariantGenAiResourceArgs',
    'AgentPromptVariantGenAiResourceArgsDict',
    'AgentPromptVariantGenAiResourceAgentArgs',
    'AgentPromptVariantGenAiResourceAgentArgsDict',
    'AgentPromptVariantInferenceConfigurationArgs',
    'AgentPromptVariantInferenceConfigurationArgsDict',
    'AgentPromptVariantInferenceConfigurationTextArgs',
    'AgentPromptVariantInferenceConfigurationTextArgsDict',
    'AgentPromptVariantMetadataArgs',
    'AgentPromptVariantMetadataArgsDict',
    'AgentPromptVariantTemplateConfigurationArgs',
    'AgentPromptVariantTemplateConfigurationArgsDict',
    'AgentPromptVariantTemplateConfigurationChatArgs',
    'AgentPromptVariantTemplateConfigurationChatArgsDict',
    'AgentPromptVariantTemplateConfigurationChatInputVariableArgs',
    'AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageContentArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict',
    'AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatSystemArgs',
    'AgentPromptVariantTemplateConfigurationChatSystemArgsDict',
    'AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs',
    'AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict',
    'AgentPromptVariantTemplateConfigurationTextArgs',
    'AgentPromptVariantTemplateConfigurationTextArgsDict',
    'AgentPromptVariantTemplateConfigurationTextCachePointArgs',
    'AgentPromptVariantTemplateConfigurationTextCachePointArgsDict',
    'AgentPromptVariantTemplateConfigurationTextInputVariableArgs',
    'AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict',
    'CustomModelOutputDataConfigArgs',
    'CustomModelOutputDataConfigArgsDict',
    'CustomModelTimeoutsArgs',
    'CustomModelTimeoutsArgsDict',
    'CustomModelTrainingDataConfigArgs',
    'CustomModelTrainingDataConfigArgsDict',
    'CustomModelTrainingMetricArgs',
    'CustomModelTrainingMetricArgsDict',
    'CustomModelValidationDataConfigArgs',
    'CustomModelValidationDataConfigArgsDict',
    'CustomModelValidationDataConfigValidatorArgs',
    'CustomModelValidationDataConfigValidatorArgsDict',
    'CustomModelValidationMetricArgs',
    'CustomModelValidationMetricArgsDict',
    'CustomModelVpcConfigArgs',
    'CustomModelVpcConfigArgsDict',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContentPolicyConfigArgsDict',
    'GuardrailContentPolicyConfigFiltersConfigArgs',
    'GuardrailContentPolicyConfigFiltersConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgs',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict',
    'GuardrailTimeoutsArgs',
    'GuardrailTimeoutsArgsDict',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailTopicPolicyConfigArgsDict',
    'GuardrailTopicPolicyConfigTopicsConfigArgs',
    'GuardrailTopicPolicyConfigTopicsConfigArgsDict',
    'GuardrailVersionTimeoutsArgs',
    'GuardrailVersionTimeoutsArgsDict',
    'GuardrailWordPolicyConfigArgs',
    'GuardrailWordPolicyConfigArgsDict',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgs',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgsDict',
    'GuardrailWordPolicyConfigWordsConfigArgs',
    'GuardrailWordPolicyConfigWordsConfigArgsDict',
    'InferenceProfileModelArgs',
    'InferenceProfileModelArgsDict',
    'InferenceProfileModelSourceArgs',
    'InferenceProfileModelSourceArgsDict',
    'InferenceProfileTimeoutsArgs',
    'InferenceProfileTimeoutsArgsDict',
    'ProvisionedModelThroughputTimeoutsArgs',
    'ProvisionedModelThroughputTimeoutsArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryArgs',
    'GetAgentAgentVersionsAgentVersionSummaryArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentActionGroupActionGroupExecutorArgsDict(TypedDict):
        custom_control: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        lambda_: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
elif False:
    AgentAgentActionGroupActionGroupExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupActionGroupExecutorArgs:
    def __init__(__self__, *,
                 custom_control: Optional[pulumi.Input[_builtins.str]] = None,
                 lambda_: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param pulumi.Input[_builtins.str] lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_control", value)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaArgsDict(TypedDict):
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        s3: NotRequired[pulumi.Input['AgentAgentActionGroupApiSchemaS3ArgsDict']]
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
elif False:
    AgentAgentActionGroupApiSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaArgs:
    def __init__(__self__, *,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 s3: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']] = None):
        """
        :param pulumi.Input[_builtins.str] payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param pulumi.Input['AgentAgentActionGroupApiSchemaS3Args'] s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaS3ArgsDict(TypedDict):
        s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the S3 bucket.
        """
        s3_object_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 object key containing the resource.
        """
elif False:
    AgentAgentActionGroupApiSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaS3Args:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_object_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] s3_bucket_name: Name of the S3 bucket.
        :param pulumi.Input[_builtins.str] s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_key", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaArgsDict(TypedDict):
        member_functions: NotRequired[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict']]
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaArgs:
    def __init__(__self__, *,
                 member_functions: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']] = None):
        """
        :param pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs'] member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @_builtins.property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")

    @member_functions.setter
    def member_functions(self, value: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]):
        pulumi.set(self, "member_functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict(TypedDict):
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict']]]]
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs:
    def __init__(__self__, *,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]):
        pulumi.set(self, "functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name for the function.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the function and its purpose.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict']]]]
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name for the function.
        :param pulumi.Input[_builtins.str] description: Description of the function and its purpose.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict(TypedDict):
        map_block_key: pulumi.Input[_builtins.str]
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        type: pulumi.Input[_builtins.str]
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param pulumi.Input[_builtins.str] type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param pulumi.Input[_builtins.str] description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param pulumi.Input[_builtins.bool] required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "map_block_key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentAgentActionGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentActionGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentAliasRoutingConfigurationArgsDict(TypedDict):
        agent_version: pulumi.Input[_builtins.str]
        """
        Version of the agent with which the alias is associated.
        """
        provisioned_throughput: pulumi.Input[_builtins.str]
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
elif False:
    AgentAgentAliasRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[_builtins.str],
                 provisioned_throughput: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_version: Version of the agent with which the alias is associated.
        :param pulumi.Input[_builtins.str] provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_version", value)

    @_builtins.property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provisioned_throughput", value)


if not MYPY:
    class AgentAgentAliasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentAliasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentCollaboratorAgentDescriptorArgsDict(TypedDict):
        alias_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
elif False:
    AgentAgentCollaboratorAgentDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorAgentDescriptorArgs:
    def __init__(__self__, *,
                 alias_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] alias_arn: ARN of the Alias of an Agent to use as the collaborator.
        """
        pulumi.set(__self__, "alias_arn", alias_arn)

    @_builtins.property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
        return pulumi.get(self, "alias_arn")

    @alias_arn.setter
    def alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias_arn", value)


if not MYPY:
    class AgentAgentCollaboratorTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentCollaboratorTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentCollaboratorTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        Version of the guardrail.
        """
elif False:
    AgentAgentGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: Unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentKnowledgeBaseAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentMemoryConfigurationArgsDict(TypedDict):
        enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        storage_days: pulumi.Input[_builtins.int]
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
elif False:
    AgentAgentMemoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentMemoryConfigurationArgs:
    def __init__(__self__, *,
                 enabled_memory_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 storage_days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enabled_memory_types: The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        :param pulumi.Input[_builtins.int] storage_days: The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        pulumi.set(__self__, "storage_days", storage_days)

    @_builtins.property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        return pulumi.get(self, "enabled_memory_types")

    @enabled_memory_types.setter
    def enabled_memory_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "enabled_memory_types", value)

    @_builtins.property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> pulumi.Input[_builtins.int]:
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        return pulumi.get(self, "storage_days")

    @storage_days.setter
    def storage_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "storage_days", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationArgsDict(TypedDict):
        override_lambda: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict']]]
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
elif False:
    AgentAgentPromptOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 override_lambda: pulumi.Input[_builtins.str],
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        """
        :param pulumi.Input[_builtins.str] override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @_builtins.property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "override_lambda", value)

    @_builtins.property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict(TypedDict):
        base_prompt_template: pulumi.Input[_builtins.str]
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict']]]
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        parser_mode: pulumi.Input[_builtins.str]
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_creation_mode: pulumi.Input[_builtins.str]
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_state: pulumi.Input[_builtins.str]
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        prompt_type: pulumi.Input[_builtins.str]
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationArgs:
    def __init__(__self__, *,
                 base_prompt_template: pulumi.Input[_builtins.str],
                 inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]],
                 parser_mode: pulumi.Input[_builtins.str],
                 prompt_creation_mode: pulumi.Input[_builtins.str],
                 prompt_state: pulumi.Input[_builtins.str],
                 prompt_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param pulumi.Input[_builtins.str] parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[_builtins.str] prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[_builtins.str] prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[_builtins.str] prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @_builtins.property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> pulumi.Input[_builtins.str]:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_prompt_template", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @inference_configurations.setter
    def inference_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]):
        pulumi.set(self, "inference_configurations", value)

    @_builtins.property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parser_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_creation_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> pulumi.Input[_builtins.str]:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_state", value)

    @_builtins.property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> pulumi.Input[_builtins.str]:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_type", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict(TypedDict):
        max_length: pulumi.Input[_builtins.int]
        """
        Maximum number of tokens to allow in the generated response.
        """
        stop_sequences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        temperature: pulumi.Input[_builtins.float]
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        top_k: pulumi.Input[_builtins.int]
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        top_p: pulumi.Input[_builtins.float]
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_length: pulumi.Input[_builtins.int],
                 stop_sequences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 temperature: pulumi.Input[_builtins.float],
                 top_k: pulumi.Input[_builtins.int],
                 top_p: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.int] max_length: Maximum number of tokens to allow in the generated response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param pulumi.Input[_builtins.float] temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param pulumi.Input[_builtins.int] top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param pulumi.Input[_builtins.float] top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> pulumi.Input[_builtins.float]:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> pulumi.Input[_builtins.int]:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "top_k", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> pulumi.Input[_builtins.float]:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentAgentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        confluence_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict']]
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        s3_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict']]
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        salesforce_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict']]
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        share_point_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict']]
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        web_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict']]
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 confluence_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']] = None,
                 web_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs'] confluence_configuration: Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs'] s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs'] salesforce_configuration: Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs'] share_point_configuration: Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs'] web_configuration: Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]:
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @_builtins.property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]:
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]:
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @_builtins.property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]:
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        return pulumi.get(self, "web_configuration")

    @web_configuration.setter
    def web_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationArgs']]):
        pulumi.set(self, "web_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_type: pulumi.Input[_builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input[_builtins.str],
                 host_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[_builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_arn: pulumi.Input[_builtins.str]
        """
        ARN of the bucket that contains the data source.
        """
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bucket account owner ID for the S3 bucket.
        """
        inclusion_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
elif False:
    AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_arn: ARN of the bucket that contains the data source.
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict(TypedDict):
        filter_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict']]
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs'] filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        pattern_object_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict']]]]
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 pattern_object_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")

    @pattern_object_filters.setter
    def pattern_object_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs']]]]):
        pulumi.set(self, "pattern_object_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict']]]]
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict(TypedDict):
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict(TypedDict):
        auth_type: pulumi.Input[_builtins.str]
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        domain: pulumi.Input[_builtins.str]
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        host_type: pulumi.Input[_builtins.str]
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of one or more SharePoint site URLs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of your Microsoft 365 tenant.
        """
elif False:
    AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 domain: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input[_builtins.str],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param pulumi.Input[_builtins.str] domain: The domain of your SharePoint instance or site URL/URLs.
        :param pulumi.Input[_builtins.str] host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] site_urls: A list of one or more SharePoint site URLs.
        :param pulumi.Input[_builtins.str] tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "site_urls", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict(TypedDict):
        crawler_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict']]
        source_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict']]
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationArgs:
    def __init__(__self__, *,
                 crawler_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]:
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict(TypedDict):
        crawler_limits: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict']]
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope of what is crawled for your URLs.
        """
        user_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 crawler_limits: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']] = None,
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 user_agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs'] crawler_limits: Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclusion_filters: List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_filters: List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        :param pulumi.Input[_builtins.str] scope: Scope of what is crawled for your URLs.
        :param pulumi.Input[_builtins.str] user_agent: String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @_builtins.property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]:
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        return pulumi.get(self, "crawler_limits")

    @crawler_limits.setter
    def crawler_limits(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs']]):
        pulumi.set(self, "crawler_limits", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope of what is crawled for your URLs.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_agent", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict(TypedDict):
        max_pages: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        rate_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs:
    def __init__(__self__, *,
                 max_pages: Optional[pulumi.Input[_builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_pages: Max number of web pages crawled from your source URLs, up to 25,000 pages.
        :param pulumi.Input[_builtins.int] rate_limit: Max rate at which pages are crawled, up to 300 per minute per host.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        return pulumi.get(self, "max_pages")

    @max_pages.setter
    def max_pages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pages", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict(TypedDict):
        url_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict']]
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationArgs:
    def __init__(__self__, *,
                 url_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs'] url_configuration: The URL configuration of your web data source. See `url_configuration` block for details.
        """
        if url_configuration is not None:
            pulumi.set(__self__, "url_configuration", url_configuration)

    @_builtins.property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]:
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
        return pulumi.get(self, "url_configuration")

    @url_configuration.setter
    def url_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs']]):
        pulumi.set(self, "url_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict(TypedDict):
        seed_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict']]]]
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]] seed_urls: List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        if seed_urls is not None:
            pulumi.set(__self__, "seed_urls", seed_urls)

    @_builtins.property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]:
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs']]]]):
        pulumi.set(self, "seed_urls", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
elif False:
    AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AgentDataSourceServerSideEncryptionConfigurationArgsDict(TypedDict):
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
elif False:
    AgentDataSourceServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class AgentDataSourceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentDataSourceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationArgsDict(TypedDict):
        chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict']]
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        custom_transformation_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict']]
        """
        Configuration for custom transformation of data source documents.
        """
        parsing_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict']]
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs'] custom_transformation_configuration: Configuration for custom transformation of data source documents.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs'] parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]:
        """
        Configuration for custom transformation of data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @_builtins.property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict(TypedDict):
        chunking_strategy: pulumi.Input[_builtins.str]
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        fixed_size_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        hierarchical_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        semantic_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input[_builtins.str],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input[_builtins.str]:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "chunking_strategy", value)

    @_builtins.property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[_builtins.int]
        """
        Maximum number of tokens to include in a chunk.
        """
        overlap_percentage: pulumi.Input[_builtins.int]
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int],
                 overlap_percentage: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to include in a chunk.
        :param pulumi.Input[_builtins.int] overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_percentage", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict(TypedDict):
        level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict']]]
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        overlap_tokens: pulumi.Input[_builtins.int]
        """
        The number of tokens to repeat across chunks in the same layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param pulumi.Input[_builtins.int] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @_builtins.property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @_builtins.property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict(TypedDict):
        breakpoint_percentile_threshold: pulumi.Input[_builtins.int]
        """
        The dissimilarity threshold for splitting chunks.
        """
        buffer_size: pulumi.Input[_builtins.int]
        """
        The buffer size.
        """
        max_token: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens a chunk can contain.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[_builtins.int],
                 buffer_size: pulumi.Input[_builtins.int],
                 max_token: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[_builtins.int] buffer_size: The buffer size.
        :param pulumi.Input[_builtins.int] max_token: The maximum number of tokens a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @_builtins.property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[_builtins.int]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "buffer_size", value)

    @_builtins.property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens a chunk can contain.
        """
        return pulumi.get(self, "max_token")

    @max_token.setter
    def max_token(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_token", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict(TypedDict):
        intermediate_storage: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict']]
        """
        The intermediate storage for custom transformation.
        """
        transformation: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict']]
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']] = None,
                 transformation: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs'] intermediate_storage: The intermediate storage for custom transformation.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs'] transformation: A custom processing step for documents moving through the data source ingestion pipeline.
        """
        if intermediate_storage is not None:
            pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)

    @_builtins.property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]:
        """
        The intermediate storage for custom transformation.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]):
        pulumi.set(self, "intermediate_storage", value)

    @_builtins.property
    @pulumi.getter
    def transformation(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]:
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]):
        pulumi.set(self, "transformation", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict(TypedDict):
        s3_location: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict']]
        """
        Configuration block for intermedia S3 storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs'] s3_location: Configuration block for intermedia S3 storage.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]:
        """
        Configuration block for intermedia S3 storage.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        S3 URI for intermediate storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] uri: S3 URI for intermediate storage.
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        S3 URI for intermediate storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict(TypedDict):
        step_to_apply: pulumi.Input[_builtins.str]
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        transformation_function: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict']]
        """
        The lambda function that processes documents.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input[_builtins.str],
                 transformation_function: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] step_to_apply: When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs'] transformation_function: The lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        if transformation_function is not None:
            pulumi.set(__self__, "transformation_function", transformation_function)

    @_builtins.property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input[_builtins.str]:
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "step_to_apply", value)

    @_builtins.property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]:
        """
        The lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]):
        pulumi.set(self, "transformation_function", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict(TypedDict):
        transformation_lambda_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict']]
        """
        The configuration of the lambda function.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The configuration of the lambda function.
        """
        if transformation_lambda_configuration is not None:
            pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @_builtins.property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]:
        """
        The configuration of the lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]):
        pulumi.set(self, "transformation_lambda_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict(TypedDict):
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the lambda to use for custom transformation.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] lambda_arn: The ARN of the lambda to use for custom transformation.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the lambda to use for custom transformation.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict(TypedDict):
        parsing_strategy: pulumi.Input[_builtins.str]
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict']]
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input[_builtins.str],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input[_builtins.str]:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parsing_strategy", value)

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the model used to parse documents
        """
        parsing_prompt: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict']]
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str],
                 parsing_prompt: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] model_arn: The ARN of the model used to parse documents
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)

    @_builtins.property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict(TypedDict):
        parsing_prompt_string: pulumi.Input[_builtins.str]
        """
        Instructions for interpreting the contents of the document.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_string: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @_builtins.property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> pulumi.Input[_builtins.str]:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")

    @parsing_prompt_string.setter
    def parsing_prompt_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parsing_prompt_string", value)


if not MYPY:
    class AgentFlowDefinitionArgsDict(TypedDict):
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgsDict']]]]
        """
        A list of connection definitions in the flow. See Connection for more information.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgsDict']]]]
        """
        A list of node definitions in the flow. See Node for more information.
        """
elif False:
    AgentFlowDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]] connections: A list of connection definitions in the flow. See Connection for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]] nodes: A list of node definitions in the flow. See Node for more information.
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]]:
        """
        A list of connection definitions in the flow. See Connection for more information.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionConnectionArgs']]]]):
        pulumi.set(self, "connections", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]]:
        """
        A list of node definitions in the flow. See Node for more information.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class AgentFlowDefinitionConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the connection that you can reference.
        """
        source: pulumi.Input[_builtins.str]
        """
        The node that the connection starts at.
        """
        target: pulumi.Input[_builtins.str]
        """
        The node that the connection ends at.
        """
        type: pulumi.Input[_builtins.str]
        """
        Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        """
        configuration: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgsDict']]
        """
        Configuration of the connection. See Connection Configuration for more information.
        """
elif False:
    AgentFlowDefinitionConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the connection that you can reference.
        :param pulumi.Input[_builtins.str] source: The node that the connection starts at.
        :param pulumi.Input[_builtins.str] target: The node that the connection ends at.
        :param pulumi.Input[_builtins.str] type: Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs'] configuration: Configuration of the connection. See Connection Configuration for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the connection that you can reference.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        The node that the connection starts at.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        The node that the connection ends at.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the source node that the connection begins from is a condition node `Conditional` or not `Data`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']]:
        """
        Configuration of the connection. See Connection Configuration for more information.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationArgs']]):
        pulumi.set(self, "configuration", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationArgsDict(TypedDict):
        conditional: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgsDict']]
        """
        The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        """
        data: NotRequired[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgsDict']]
        """
        The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
elif False:
    AgentFlowDefinitionConnectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationArgs:
    def __init__(__self__, *,
                 conditional: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']] = None,
                 data: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs'] conditional: The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs'] data: The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']]:
        """
        The configuration of a connection originating from a Condition node. See Conditional Connection Configuration for more information.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationConditionalArgs']]):
        pulumi.set(self, "conditional", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']]:
        """
        The configuration of a connection originating from a node that isnt a Condition node. See Data Connection Configuration for more information.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input['AgentFlowDefinitionConnectionConfigurationDataArgs']]):
        pulumi.set(self, "data", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationConditionalArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionConnectionConfigurationConditionalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationConditionalArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class AgentFlowDefinitionConnectionConfigurationDataArgsDict(TypedDict):
        source_output: pulumi.Input[_builtins.str]
        """
        The name of the output in the source node that the connection begins from.
        """
        target_input: pulumi.Input[_builtins.str]
        """
        The name of the input in the target node that the connection ends at.
        """
elif False:
    AgentFlowDefinitionConnectionConfigurationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionConnectionConfigurationDataArgs:
    def __init__(__self__, *,
                 source_output: pulumi.Input[_builtins.str],
                 target_input: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] source_output: The name of the output in the source node that the connection begins from.
        :param pulumi.Input[_builtins.str] target_input: The name of the input in the target node that the connection ends at.
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @_builtins.property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the output in the source node that the connection begins from.
        """
        return pulumi.get(self, "source_output")

    @source_output.setter
    def source_output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_output", value)

    @_builtins.property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the input in the target node that the connection ends at.
        """
        return pulumi.get(self, "target_input")

    @target_input.setter
    def target_input(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_input", value)


if not MYPY:
    class AgentFlowDefinitionNodeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the node.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        """
        configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgsDict']]
        """
        Contains configurations for the node. See Node Configuration for more information.
        """
        inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgsDict']]]]
        """
        A list of objects containing information about an input into the node. See Node Input for more information.
        """
        outputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgsDict']]]]
        """
        A list of objects containing information about an output from the node. See Node Output for more information.
        """
elif False:
    AgentFlowDefinitionNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]] = None,
                 outputs: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the node.
        :param pulumi.Input[_builtins.str] type: The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs'] configuration: Contains configurations for the node. See Node Configuration for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]] inputs: A list of objects containing information about an input into the node. See Node Input for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]] outputs: A list of objects containing information about an output from the node. See Node Output for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of node. This value must match the name of the key that you provide in the configuration. Valid values: `Agent`, `Collector`, `Condition`, `Input`, `Iterator`, `KnowledgeBase`, `LambdaFunction`, `Lex`, `Output`, `Prompt`, `Retrieval`, `Storage`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']]:
        """
        Contains configurations for the node. See Node Configuration for more information.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]]:
        """
        A list of objects containing information about an input into the node. See Node Input for more information.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]]:
        """
        A list of objects containing information about an output from the node. See Node Output for more information.
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeOutputArgs']]]]):
        pulumi.set(self, "outputs", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgsDict']]
        """
        Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        """
        collector: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgsDict']]
        """
        Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        """
        condition: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgsDict']]
        inline_code: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict']]
        """
        Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        """
        input: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgsDict']]
        iterator: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgsDict']]
        """
        Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        """
        knowledge_base: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict']]
        """
        Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        """
        lambda_function: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict']]
        """
        Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        """
        lex: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgsDict']]
        """
        Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        """
        output: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgsDict']]
        prompt: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgsDict']]
        """
        Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        """
        retrieval: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgsDict']]
        """
        Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        """
        storage: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgsDict']]
        """
        Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']] = None,
                 collector: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']] = None,
                 condition: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']] = None,
                 inline_code: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']] = None,
                 input: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']] = None,
                 iterator: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']] = None,
                 knowledge_base: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']] = None,
                 lambda_function: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']] = None,
                 lex: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']] = None,
                 output: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']] = None,
                 prompt: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']] = None,
                 retrieval: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']] = None,
                 storage: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs'] agent: Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs'] collector: Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs'] inline_code: Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs'] iterator: Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs'] knowledge_base: Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs'] lambda_function: Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs'] lex: Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs'] prompt: Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs'] retrieval: Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs'] storage: Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if collector is not None:
            pulumi.set(__self__, "collector", collector)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if inline_code is not None:
            pulumi.set(__self__, "inline_code", inline_code)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if iterator is not None:
            pulumi.set(__self__, "iterator", iterator)
        if knowledge_base is not None:
            pulumi.set(__self__, "knowledge_base", knowledge_base)
        if lambda_function is not None:
            pulumi.set(__self__, "lambda_function", lambda_function)
        if lex is not None:
            pulumi.set(__self__, "lex", lex)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if retrieval is not None:
            pulumi.set(__self__, "retrieval", retrieval)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']]:
        """
        Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response. See Agent Node Configuration for more information.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationAgentArgs']]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter
    def collector(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']]:
        """
        Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs. This object has no fields.
        """
        return pulumi.get(self, "collector")

    @collector.setter
    def collector(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationCollectorArgs']]):
        pulumi.set(self, "collector", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionArgs']]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']]:
        """
        Contains configurations for an inline code node in your flow. See Inline Code Node Configuration for more information.
        """
        return pulumi.get(self, "inline_code")

    @inline_code.setter
    def inline_code(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInlineCodeArgs']]):
        pulumi.set(self, "inline_code", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']]:
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationInputArgs']]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def iterator(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']]:
        """
        Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node. This object has no fields.
        """
        return pulumi.get(self, "iterator")

    @iterator.setter
    def iterator(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationIteratorArgs']]):
        pulumi.set(self, "iterator", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']]:
        """
        Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response. See Knowledge Base Node Configuration for more information.
        """
        return pulumi.get(self, "knowledge_base")

    @knowledge_base.setter
    def knowledge_base(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs']]):
        pulumi.set(self, "knowledge_base", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']]:
        """
        Contains configurations for a Lambda function node in your flow. Invokes a Lambda function. See Lambda Function Node Configuration for more information.
        """
        return pulumi.get(self, "lambda_function")

    @lambda_function.setter
    def lambda_function(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs']]):
        pulumi.set(self, "lambda_function", value)

    @_builtins.property
    @pulumi.getter
    def lex(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']]:
        """
        Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output. See Lex Node Configuration for more information.
        """
        return pulumi.get(self, "lex")

    @lex.setter
    def lex(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationLexArgs']]):
        pulumi.set(self, "lex", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']]:
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationOutputArgs']]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']]:
        """
        Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node. See Prompt Node Configuration for more information.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptArgs']]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter
    def retrieval(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']]:
        """
        Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output. See Retrieval Node Configuration for more information.
        """
        return pulumi.get(self, "retrieval")

    @retrieval.setter
    def retrieval(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalArgs']]):
        pulumi.set(self, "retrieval", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']]:
        """
        Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location. See Storage Node Configuration for more information.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationAgentArgsDict(TypedDict):
        agent_alias_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationAgentArgs:
    def __init__(__self__, *,
                 agent_alias_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_alias_arn: The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
        pulumi.set(__self__, "agent_alias_arn", agent_alias_arn)

    @_builtins.property
    @pulumi.getter(name="agentAliasArn")
    def agent_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        """
        return pulumi.get(self, "agent_alias_arn")

    @agent_alias_arn.setter
    def agent_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_alias_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationCollectorArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationCollectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationCollectorArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict']]]
elif False:
    AgentFlowDefinitionNodeConfigurationConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]):
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentFlowDefinitionNodeConfigurationConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationConditionConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        The code that's executed in your inline code node.
        """
        language: pulumi.Input[_builtins.str]
        """
        The programming language used by your inline code node.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationInlineCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationInlineCodeArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 language: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] code: The code that's executed in your inline code node.
        :param pulumi.Input[_builtins.str] language: The programming language used by your inline code node.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        The code that's executed in your inline code node.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> pulumi.Input[_builtins.str]:
        """
        The programming language used by your inline code node.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationInputArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationInputArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationIteratorArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationIteratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationIteratorArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict(TypedDict):
        knowledge_base_id: pulumi.Input[_builtins.str]
        """
        The unique identifier of the knowledge base to query.
        """
        model_id: pulumi.Input[_builtins.str]
        guardrail_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict']]
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        number_of_results: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseArgs:
    def __init__(__self__, *,
                 knowledge_base_id: pulumi.Input[_builtins.str],
                 model_id: pulumi.Input[_builtins.str],
                 guardrail_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']] = None,
                 number_of_results: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] knowledge_base_id: The unique identifier of the knowledge base to query.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs'] guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        pulumi.set(__self__, "model_id", model_id)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if number_of_results is not None:
            pulumi.set(__self__, "number_of_results", number_of_results)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the knowledge base to query.
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "knowledge_base_id", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']]:
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="numberOfResults")
    def number_of_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "number_of_results")

    @number_of_results.setter
    def number_of_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number_of_results", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        The unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        The version of the guardrail.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: The unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: The version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']] = None):
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationKnowledgeBaseInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict(TypedDict):
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationLambdaFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationLambdaFunctionArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] lambda_arn: The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Lambda function to invoke.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationLexArgsDict(TypedDict):
        bot_alias_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        """
        locale_id: pulumi.Input[_builtins.str]
        """
        The Region to invoke the Amazon Lex bot in
        """
elif False:
    AgentFlowDefinitionNodeConfigurationLexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationLexArgs:
    def __init__(__self__, *,
                 bot_alias_arn: pulumi.Input[_builtins.str],
                 locale_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bot_alias_arn: The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        :param pulumi.Input[_builtins.str] locale_id: The Region to invoke the Amazon Lex bot in
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        """
        return pulumi.get(self, "bot_alias_arn")

    @bot_alias_arn.setter
    def bot_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bot_alias_arn", value)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Region to invoke the Amazon Lex bot in
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationOutputArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationOutputArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptArgsDict(TypedDict):
        guardrail_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict']]
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        source_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptArgs:
    def __init__(__self__, *,
                 guardrail_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']] = None,
                 source_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs'] guardrail_configuration: Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']]:
        """
        Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration. See Guardrail Configuration for more information.
        """
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs']]):
        pulumi.set(self, "source_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[_builtins.str]
        """
        The unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[_builtins.str]
        """
        The version of the guardrail.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[_builtins.str],
                 guardrail_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] guardrail_identifier: The unique identifier of the guardrail.
        :param pulumi.Input[_builtins.str] guardrail_version: The version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict(TypedDict):
        inline: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict']]
        """
        Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        """
        resource: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict']]
        """
        Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationArgs:
    def __init__(__self__, *,
                 inline: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']] = None,
                 resource: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs'] inline: Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs'] resource: Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
        if inline is not None:
            pulumi.set(__self__, "inline", inline)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']]:
        """
        Contains configurations for a prompt that is defined inline. See Prompt Inline Configuration for more information.
        """
        return pulumi.get(self, "inline")

    @inline.setter
    def inline(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs']]):
        pulumi.set(self, "inline", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']]:
        """
        Contains configurations for a prompt from Prompt management. See Prompt Resource Configuration for more information.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs']]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict(TypedDict):
        model_id: pulumi.Input[_builtins.str]
        template_type: pulumi.Input[_builtins.str]
        """
        The type of prompt template. Valid values: `TEXT`, `CHAT`.
        """
        additional_model_request_fields: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional fields to be included in the model request for the Prompt node.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        template_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict']]
        """
        Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineArgs:
    def __init__(__self__, *,
                 model_id: pulumi.Input[_builtins.str],
                 template_type: pulumi.Input[_builtins.str],
                 additional_model_request_fields: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']] = None,
                 template_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] template_type: The type of prompt template. Valid values: `TEXT`, `CHAT`.
        :param pulumi.Input[_builtins.str] additional_model_request_fields: Additional fields to be included in the model request for the Prompt node.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs'] template_configuration: Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of prompt template. Valid values: `TEXT`, `CHAT`.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional fields to be included in the model request for the Prompt node.
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt. See Prompt Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']]:
        """
        Contains a prompt and variables in the prompt that can be replaced with values at runtime. See Prompt Template Configuration for more information.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs']]):
        pulumi.set(self, "template_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']] = None):
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict(TypedDict):
        chat: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict']]
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        text: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationArgs:
    def __init__(__self__, *,
                 chat: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']] = None,
                 text: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs'] chat: Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        if chat is not None:
            pulumi.set(__self__, "chat", chat)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']]:
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        return pulumi.get(self, "chat")

    @chat.setter
    def chat(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs']]):
        pulumi.set(self, "chat", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict']]]]
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict']]]]
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        systems: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict']]]]
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        tool_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict']]
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]] = None,
                 systems: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]] = None,
                 tool_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]] messages: A list of messages in the chat for the prompt. See Message for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]] systems: A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs'] tool_configuration: Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if systems is not None:
            pulumi.set(__self__, "systems", systems)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]]:
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter
    def systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]]:
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        return pulumi.get(self, "systems")

    @systems.setter
    def systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs']]]]):
        pulumi.set(self, "systems", value)

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']]:
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        return pulumi.get(self, "tool_configuration")

    @tool_configuration.setter
    def tool_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs']]):
        pulumi.set(self, "tool_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The role that the message belongs to.
        """
        content: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict']]
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] role: The role that the message belongs to.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs'] content: Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        pulumi.set(__self__, "role", role)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the message belongs to.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']]:
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs']]):
        pulumi.set(self, "content", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict']]
        text: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatMessageContentCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text in the system prompt.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input[_builtins.str] text: The text in the system prompt.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text in the system prompt.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatSystemCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict(TypedDict):
        tool_choice: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict']]
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict']]]]
        """
        A list of tools to pass to a model. See Tool for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationArgs:
    def __init__(__self__, *,
                 tool_choice: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs'] tool_choice: Defines which tools the model should request when invoked. See Tool Choice for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]] tools: A list of tools to pass to a model. See Tool for more information.
        """
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']]:
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        return pulumi.get(self, "tool_choice")

    @tool_choice.setter
    def tool_choice(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs']]):
        pulumi.set(self, "tool_choice", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]]:
        """
        A list of tools to pass to a model. See Tool for more information.
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs']]]]):
        pulumi.set(self, "tools", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        tool_spec: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict']]
        """
        The specification for the tool. See Tool Specification for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']] = None,
                 tool_spec: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs'] tool_spec: The specification for the tool. See Tool Specification for more information.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if tool_spec is not None:
            pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]:
        """
        The specification for the tool. See Tool Specification for more information.
        """
        return pulumi.get(self, "tool_spec")

    @tool_spec.setter
    def tool_spec(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]):
        pulumi.set(self, "tool_spec", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict(TypedDict):
        any: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict']]
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        auto: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict']]
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        tool: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict']]
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']] = None,
                 auto: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']] = None,
                 tool: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']] = None):
        """
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs'] any: Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs'] auto: Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs'] tool: Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]:
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]):
        pulumi.set(self, "any", value)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]:
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        return pulumi.get(self, "auto")

    @auto.setter
    def auto(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]):
        pulumi.set(self, "auto", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]:
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict(TypedDict):
        pass
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolChoiceToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the flow.
        """
        input_schema: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict']]
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_schema: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        :param pulumi.Input[_builtins.str] description: A description for the flow.
        :param pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs'] input_schema: The input schema of the tool. See Tool Input Schema for more information.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the flow.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]:
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]):
        pulumi.set(self, "input_schema", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict(TypedDict):
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON object defining the input schema for the tool.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs:
    def __init__(__self__, *,
                 json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] json: A JSON object defining the input schema for the tool.
        """
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON object defining the input schema for the tool.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        cache_point: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict']]
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict']]]]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 cache_point: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']] = None,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]] = None):
        pulumi.set(__self__, "text", text)
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationInlineTemplateConfigurationTextInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict(TypedDict):
        resource_arn: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationPromptSourceConfigurationResourceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "resource_arn", resource_arn)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalArgsDict(TypedDict):
        service_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalArgs:
    def __init__(__self__, *,
                 service_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']] = None):
        if service_configuration is not None:
            pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']]:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs']]):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']] = None):
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationRetrievalServiceConfigurationS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageArgsDict(TypedDict):
        service_configuration: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageArgs:
    def __init__(__self__, *,
                 service_configuration: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']] = None):
        if service_configuration is not None:
            pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']]:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs']]):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict']]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']] = None):
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeConfigurationStorageServiceConfigurationS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class AgentFlowDefinitionNodeInputArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        type: pulumi.Input[_builtins.str]
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        How input data flows between iterations in a DoWhile loop.
        """
elif False:
    AgentFlowDefinitionNodeInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeInputArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 category: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        :param pulumi.Input[_builtins.str] category: How input data flows between iterations in a DoWhile loop.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if category is not None:
            pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How input data flows between iterations in a DoWhile loop.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)


if not MYPY:
    class AgentFlowDefinitionNodeOutputArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the flow.
        """
        type: pulumi.Input[_builtins.str]
elif False:
    AgentFlowDefinitionNodeOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowDefinitionNodeOutputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: A name for the flow.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentFlowTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentFlowTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFlowTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        vector_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict']]
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 vector_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]:
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict(TypedDict):
        embedding_model_arn: pulumi.Input[_builtins.str]
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict']]
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        supplemental_data_storage_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict']]
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[_builtins.str],
                 embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']] = None,
                 supplemental_data_storage_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs'] embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs'] supplemental_data_storage_configuration: supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @_builtins.property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "embedding_model_arn", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @embedding_model_configuration.setter
    def embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "embedding_model_configuration", value)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]:
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")

    @supplemental_data_storage_configuration.setter
    def supplemental_data_storage_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs']]):
        pulumi.set(self, "supplemental_data_storage_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict(TypedDict):
        bedrock_embedding_model_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict']]
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs'] bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]:
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")

    @bedrock_embedding_model_configuration.setter
    def bedrock_embedding_model_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_embedding_model_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        embedding_data_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[_builtins.int]] = None,
                 embedding_data_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] dimensions: Dimension details for the vector configuration used on the Bedrock embeddings model.
        :param pulumi.Input[_builtins.str] embedding_data_type: Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        return pulumi.get(self, "embedding_data_type")

    @embedding_data_type.setter
    def embedding_data_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "embedding_data_type", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict(TypedDict):
        storage_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict']]]]
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs:
    def __init__(__self__, *,
                 storage_locations: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]] storage_locations: A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @_builtins.property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]:
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        return pulumi.get(self, "storage_locations")

    @storage_locations.setter
    def storage_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs']]]]):
        pulumi.set(self, "storage_locations", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        s3_location: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict']]
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 s3_location: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Storage service used for this location. `S3` is the only valid value.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs'] s3_location: Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]:
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        URI of the location.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] uri: URI of the location.
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the location.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        opensearch_serverless_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        pinecone_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        rds_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict']]
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        redis_enterprise_cloud_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 opensearch_serverless_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']] = None,
                 redis_enterprise_cloud_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs'] opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs'] pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs'] rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs'] redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @_builtins.property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @_builtins.property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)

    @_builtins.property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")

    @redis_enterprise_cloud_configuration.setter
    def redis_enterprise_cloud_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]):
        pulumi.set(self, "redis_enterprise_cloud_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict(TypedDict):
        collection_arn: pulumi.Input[_builtins.str]
        """
        ARN of the OpenSearch Service vector store.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of the vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] collection_arn: ARN of the OpenSearch Service vector store.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of the vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_arn", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[_builtins.str]] = None,
                 text_field: Optional[pulumi.Input[_builtins.str]] = None,
                 vector_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict(TypedDict):
        connection_string: pulumi.Input[_builtins.str]
        """
        Endpoint URL for your index management page.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to be used to write new data to your database.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_string: Endpoint URL for your index management page.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param pulumi.Input[_builtins.str] namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_string", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[_builtins.str]] = None,
                 text_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        Name of your Amazon RDS database.
        """
        resource_arn: pulumi.Input[_builtins.str]
        """
        ARN of the vector store.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        Name of the table in the database.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict']]
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 resource_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[_builtins.str] database_name: Name of your Amazon RDS database.
        :param pulumi.Input[_builtins.str] resource_arn: ARN of the vector store.
        :param pulumi.Input[_builtins.str] table_name: Name of the table in the database.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs'] field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        primary_key_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 primary_key_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary_key_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of the vector index.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 vector_index_name: pulumi.Input[_builtins.str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param pulumi.Input[_builtins.str] endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of the vector index.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[_builtins.str]] = None,
                 text_field: Optional[pulumi.Input[_builtins.str]] = None,
                 vector_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentKnowledgeBaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentPromptVariantArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt variant.
        """
        template_type: pulumi.Input[_builtins.str]
        """
        Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        """
        additional_model_request_fields: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        """
        gen_ai_resource: NotRequired[pulumi.Input['AgentPromptVariantGenAiResourceArgsDict']]
        """
        Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentPromptVariantInferenceConfigurationArgsDict']]
        """
        Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgsDict']]]]
        """
        A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        """
        template_configuration: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationArgsDict']]
        """
        Contains configurations for the prompt template. See Template Configuration for more information.
        """
elif False:
    AgentPromptVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 template_type: pulumi.Input[_builtins.str],
                 additional_model_request_fields: Optional[pulumi.Input[_builtins.str]] = None,
                 gen_ai_resource: Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 template_configuration: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt variant.
        :param pulumi.Input[_builtins.str] template_type: Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        :param pulumi.Input[_builtins.str] additional_model_request_fields: Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        :param pulumi.Input['AgentPromptVariantGenAiResourceArgs'] gen_ai_resource: Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        :param pulumi.Input['AgentPromptVariantInferenceConfigurationArgs'] inference_configuration: Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]] metadatas: A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        :param pulumi.Input[_builtins.str] model_id: Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationArgs'] template_configuration: Contains configurations for the prompt template. See Template Configuration for more information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if gen_ai_resource is not None:
            pulumi.set(__self__, "gen_ai_resource", gen_ai_resource)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt variant.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of prompt template to use. Valid values: `CHAT`, `TEXT`.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains model-specific inference configurations that arent in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="genAiResource")
    def gen_ai_resource(self) -> Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']]:
        """
        Specifies a generative AI resource with which to use the prompt. If this is not supplied, then a `gen_ai_resource` must be defined. See Generative AI Resource for more information.
        """
        return pulumi.get(self, "gen_ai_resource")

    @gen_ai_resource.setter
    def gen_ai_resource(self, value: Optional[pulumi.Input['AgentPromptVariantGenAiResourceArgs']]):
        pulumi.set(self, "gen_ai_resource", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']]:
        """
        Contains inference configurations for the prompt variant. See Inference Configuration for more information.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]]:
        """
        A list of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant. See Metadata for more information.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt. If this is not supplied, then a `gen_ai_resource` must be defined.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']]:
        """
        Contains configurations for the prompt template. See Template Configuration for more information.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationArgs']]):
        pulumi.set(self, "template_configuration", value)


if not MYPY:
    class AgentPromptVariantGenAiResourceArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgsDict']]
        """
        Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
elif False:
    AgentPromptVariantGenAiResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantGenAiResourceArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs'] agent: Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']]:
        """
        Specifies an Amazon Bedrock agent with which to use the prompt. See Agent Configuration for more information.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input['AgentPromptVariantGenAiResourceAgentArgs']]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class AgentPromptVariantGenAiResourceAgentArgsDict(TypedDict):
        agent_identifier: pulumi.Input[_builtins.str]
        """
        ARN of the agent with which to use the prompt.
        """
elif False:
    AgentPromptVariantGenAiResourceAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantGenAiResourceAgentArgs:
    def __init__(__self__, *,
                 agent_identifier: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent_identifier: ARN of the agent with which to use the prompt.
        """
        pulumi.set(__self__, "agent_identifier", agent_identifier)

    @_builtins.property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the agent with which to use the prompt.
        """
        return pulumi.get(self, "agent_identifier")

    @agent_identifier.setter
    def agent_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_identifier", value)


if not MYPY:
    class AgentPromptVariantInferenceConfigurationArgsDict(TypedDict):
        text: NotRequired[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgsDict']]
        """
        Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
elif False:
    AgentPromptVariantInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantInferenceConfigurationArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs'] text: Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']]:
        """
        Contains inference configurations for the prompt variant. See Text Inference Configuration for more information.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentPromptVariantInferenceConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantInferenceConfigurationTextArgsDict(TypedDict):
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of tokens to return in the response.
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings that define sequences after which the model will stop generating.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
elif False:
    AgentPromptVariantInferenceConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantInferenceConfigurationTextArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_tokens: Maximum number of tokens to return in the response.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of strings that define sequences after which the model will stop generating.
        :param pulumi.Input[_builtins.float] temperature: Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        :param pulumi.Input[_builtins.float] top_p: Percentage of most-likely candidates that the model considers for the next token.
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of tokens to return in the response.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings that define sequences after which the model will stop generating.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Percentage of most-likely candidates that the model considers for the next token.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentPromptVariantMetadataArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of a metadata tag for a prompt variant.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of a metadata tag for a prompt variant.
        """
elif False:
    AgentPromptVariantMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantMetadataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Key of a metadata tag for a prompt variant.
        :param pulumi.Input[_builtins.str] value: Value of a metadata tag for a prompt variant.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of a metadata tag for a prompt variant.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of a metadata tag for a prompt variant.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationArgsDict(TypedDict):
        chat: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgsDict']]
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        text: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgsDict']]
        """
        Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
elif False:
    AgentPromptVariantTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationArgs:
    def __init__(__self__, *,
                 chat: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']] = None,
                 text: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs'] chat: Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs'] text: Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
        if chat is not None:
            pulumi.set(__self__, "chat", chat)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']]:
        """
        Contains configurations to use the prompt in a conversational format. See Chat Template Configuration for more information.
        """
        return pulumi.get(self, "chat")

    @chat.setter
    def chat(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatArgs']]):
        pulumi.set(self, "chat", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']]:
        """
        Contains configurations for the text in a message for a prompt. See Text Template Configuration
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatArgsDict(TypedDict):
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict']]]]
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgsDict']]]]
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        systems: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgsDict']]]]
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        tool_configuration: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict']]
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]] = None,
                 systems: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]] = None,
                 tool_configuration: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]] messages: A list of messages in the chat for the prompt. See Message for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]] systems: A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs'] tool_configuration: Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if systems is not None:
            pulumi.set(__self__, "systems", systems)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]]:
        """
        A list of messages in the chat for the prompt. See Message for more information.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter
    def systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]]:
        """
        A list of system prompts to provide context to the model or to describe how it should behave. See System for more information.
        """
        return pulumi.get(self, "systems")

    @systems.setter
    def systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemArgs']]]]):
        pulumi.set(self, "systems", value)

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']]:
        """
        Configuration information for the tools that the model can use when generating a response. See Tool Configuration for more information.
        """
        return pulumi.get(self, "tool_configuration")

    @tool_configuration.setter
    def tool_configuration(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs']]):
        pulumi.set(self, "tool_configuration", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The role that the message belongs to.
        """
        content: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict']]
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] role: The role that the message belongs to.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs'] content: Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        pulumi.set(__self__, "role", role)
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the message belongs to.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']]:
        """
        Contains the content for the message you pass to, or receive from a model. See [Message Content] for more information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentArgs']]):
        pulumi.set(self, "content", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict']]
        text: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageContentArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatMessageContentCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatSystemArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text in the system prompt.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatSystemArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input[_builtins.str] text: The text in the system prompt.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text in the system prompt.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatSystemCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatSystemCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict(TypedDict):
        tool_choice: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict']]
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict']]]]
        """
        A list of tools to pass to a model. See Tool for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationArgs:
    def __init__(__self__, *,
                 tool_choice: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs'] tool_choice: Defines which tools the model should request when invoked. See Tool Choice for more information.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]] tools: A list of tools to pass to a model. See Tool for more information.
        """
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']]:
        """
        Defines which tools the model should request when invoked. See Tool Choice for more information.
        """
        return pulumi.get(self, "tool_choice")

    @tool_choice.setter
    def tool_choice(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs']]):
        pulumi.set(self, "tool_choice", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]]:
        """
        A list of tools to pass to a model. See Tool for more information.
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs']]]]):
        pulumi.set(self, "tools", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict(TypedDict):
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict']]
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        tool_spec: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict']]
        """
        The specification for the tool. See Tool Specification for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']] = None,
                 tool_spec: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs'] cache_point: Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs'] tool_spec: The specification for the tool. See Tool Specification for more information.
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if tool_spec is not None:
            pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']]:
        """
        Creates a cache checkpoint within a tool designation. See Cache Point for more information.
        """
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]:
        """
        The specification for the tool. See Tool Specification for more information.
        """
        return pulumi.get(self, "tool_spec")

    @tool_spec.setter
    def tool_spec(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs']]):
        pulumi.set(self, "tool_spec", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict(TypedDict):
        any: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict']]
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        auto: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict']]
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        tool: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict']]
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceArgs:
    def __init__(__self__, *,
                 any: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']] = None,
                 auto: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']] = None,
                 tool: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']] = None):
        """
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs'] any: Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs'] auto: Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs'] tool: Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        if any is not None:
            pulumi.set(__self__, "any", any)
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]:
        """
        Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. This object has no fields.
        """
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs']]):
        pulumi.set(self, "any", value)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]:
        """
        Defines tools. The model automatically decides whether to call a tool or to generate text instead. This object has no fields.
        """
        return pulumi.get(self, "auto")

    @auto.setter
    def auto(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs']]):
        pulumi.set(self, "auto", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]:
        """
        Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. See Named Tool for more information.
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs']]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict(TypedDict):
        pass
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAnyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict(TypedDict):
        pass
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceAutoArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt.

        The following arguments are optional:
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolChoiceToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the prompt.

        The following arguments are optional:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the prompt.
        """
        input_schema: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict']]
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_schema: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the prompt.
               
               The following arguments are optional:
        :param pulumi.Input[_builtins.str] description: Description of the prompt.
        :param pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs'] input_schema: The input schema of the tool. See Tool Input Schema for more information.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the prompt.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the prompt.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]:
        """
        The input schema of the tool. See Tool Input Schema for more information.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs']]):
        pulumi.set(self, "input_schema", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict(TypedDict):
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON object defining the input schema for the tool.
        """
elif False:
    AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationChatToolConfigurationToolToolSpecInputSchemaArgs:
    def __init__(__self__, *,
                 json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] json: A JSON object defining the input schema for the tool.
        """
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON object defining the input schema for the tool.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        cache_point: NotRequired[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgsDict']]
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict']]]]
elif False:
    AgentPromptVariantTemplateConfigurationTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 cache_point: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']] = None,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]] = None):
        pulumi.set(__self__, "text", text)
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['AgentPromptVariantTemplateConfigurationTextCachePointArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]]:
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentPromptVariantTemplateConfigurationTextInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextCachePointArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
elif False:
    AgentPromptVariantTemplateConfigurationTextCachePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextCachePointArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates that the CachePointBlock is of the default type. Valid values: `default`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable.
        """
elif False:
    AgentPromptVariantTemplateConfigurationTextInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptVariantTemplateConfigurationTextInputVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CustomModelOutputDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the output data is stored.
        """
elif False:
    CustomModelOutputDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOutputDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    CustomModelTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class CustomModelTrainingDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the training data is stored.
        """
elif False:
    CustomModelTrainingDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTrainingMetricArgsDict(TypedDict):
        training_loss: pulumi.Input[_builtins.float]
        """
        Loss metric associated with the customization job.
        """
elif False:
    CustomModelTrainingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingMetricArgs:
    def __init__(__self__, *,
                 training_loss: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @_builtins.property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> pulumi.Input[_builtins.float]:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")

    @training_loss.setter
    def training_loss(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "training_loss", value)


if not MYPY:
    class CustomModelValidationDataConfigArgsDict(TypedDict):
        validators: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgsDict']]]]
        """
        Information about the validators.
        """
elif False:
    CustomModelValidationDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigArgs:
    def __init__(__self__, *,
                 validators: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @_builtins.property
    @pulumi.getter
    def validators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")

    @validators.setter
    def validators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]):
        pulumi.set(self, "validators", value)


if not MYPY:
    class CustomModelValidationDataConfigValidatorArgsDict(TypedDict):
        s3_uri: pulumi.Input[_builtins.str]
        """
        The S3 URI where the validation data is stored.
        """
elif False:
    CustomModelValidationDataConfigValidatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigValidatorArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @_builtins.property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelValidationMetricArgsDict(TypedDict):
        validation_loss: pulumi.Input[_builtins.float]
        """
        The validation loss associated with the validator.
        """
elif False:
    CustomModelValidationMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationMetricArgs:
    def __init__(__self__, *,
                 validation_loss: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @_builtins.property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> pulumi.Input[_builtins.float]:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")

    @validation_loss.setter
    def validation_loss(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "validation_loss", value)


if not MYPY:
    class CustomModelVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        VPC configuration security group IDs.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        VPC configuration subnets.
        """
elif False:
    CustomModelVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: VPC configuration security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class GuardrailContentPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgsDict']]]]
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
elif False:
    GuardrailContentPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]] filters_configs: Set of content filter configs in content policy.
               See Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @_builtins.property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]:
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContentPolicyConfigFiltersConfigArgsDict(TypedDict):
        input_strength: pulumi.Input[_builtins.str]
        """
        Strength for filters.
        """
        output_strength: pulumi.Input[_builtins.str]
        """
        Strength for filters.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContentPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input[_builtins.str],
                 output_strength: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] input_strength: Strength for filters.
        :param pulumi.Input[_builtins.str] output_strength: Strength for filters.
        :param pulumi.Input[_builtins.str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input[_builtins.str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_strength", value)

    @_builtins.property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input[_builtins.str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_strength", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict']]]]
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]] filters_configs: List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @_builtins.property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]:
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict(TypedDict):
        threshold: pulumi.Input[_builtins.float]
        """
        The threshold for this filter.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[_builtins.float],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.float] threshold: The threshold for this filter.
        :param pulumi.Input[_builtins.str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigArgsDict(TypedDict):
        pii_entities_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict']]]]
        """
        List of entities. See PII Entities Config for more information.
        """
        regexes_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict']]]]
        """
        List of regex. See Regexes Config for more information.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]] = None,
                 regexes_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @_builtins.property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @pii_entities_configs.setter
    def pii_entities_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]):
        pulumi.set(self, "pii_entities_configs", value)

    @_builtins.property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")

    @regexes_configs.setter
    def regexes_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]):
        pulumi.set(self, "regexes_configs", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Options for sensitive information action.
        """
        type: pulumi.Input[_builtins.str]
        """
        The currently supported PII entities.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Options for sensitive information action.
        :param pulumi.Input[_builtins.str] type: The currently supported PII entities.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Options for sensitive information action.
        """
        name: pulumi.Input[_builtins.str]
        """
        The regex name.
        """
        pattern: pulumi.Input[_builtins.str]
        """
        The regex pattern.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regex description.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Options for sensitive information action.
        :param pulumi.Input[_builtins.str] name: The regex name.
        :param pulumi.Input[_builtins.str] pattern: The regex pattern.
        :param pulumi.Input[_builtins.str] description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GuardrailTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GuardrailTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GuardrailTopicPolicyConfigArgsDict(TypedDict):
        topics_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgsDict']]]]
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
elif False:
    GuardrailTopicPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 topics_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @_builtins.property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")

    @topics_configs.setter
    def topics_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]):
        pulumi.set(self, "topics_configs", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTopicsConfigArgsDict(TypedDict):
        definition: pulumi.Input[_builtins.str]
        """
        Definition of topic in topic policy.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of topic in topic policy.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of topic in a policy.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of text examples.
        """
elif False:
    GuardrailTopicPolicyConfigTopicsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTopicsConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] definition: Definition of topic in topic policy.
        :param pulumi.Input[_builtins.str] name: Name of topic in topic policy.
        :param pulumi.Input[_builtins.str] type: Type of topic in a policy.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> pulumi.Input[_builtins.str]:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "definition", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "examples", value)


if not MYPY:
    class GuardrailVersionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    GuardrailVersionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailVersionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GuardrailWordPolicyConfigArgsDict(TypedDict):
        managed_word_lists_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgsDict']]]]
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        words_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgsDict']]]]
        """
        List of custom word configs. See Words Config for more information.
        """
elif False:
    GuardrailWordPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]] = None,
                 words_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @_builtins.property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @managed_word_lists_configs.setter
    def managed_word_lists_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_configs", value)

    @_builtins.property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")

    @words_configs.setter
    def words_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]):
        pulumi.set(self, "words_configs", value)


if not MYPY:
    class GuardrailWordPolicyConfigManagedWordListsConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Options for managed words.
        """
elif False:
    GuardrailWordPolicyConfigManagedWordListsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigManagedWordListsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Options for managed words.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailWordPolicyConfigWordsConfigArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        The custom word text.
        """
elif False:
    GuardrailWordPolicyConfigWordsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigWordsConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class InferenceProfileModelArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)


if not MYPY:
    class InferenceProfileModelSourceArgsDict(TypedDict):
        copy_from: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the model.
        """
elif False:
    InferenceProfileModelSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileModelSourceArgs:
    def __init__(__self__, *,
                 copy_from: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] copy_from: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @_builtins.property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "copy_from")

    @copy_from.setter
    def copy_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "copy_from", value)


if not MYPY:
    class InferenceProfileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    InferenceProfileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceProfileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ProvisionedModelThroughputTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProvisionedModelThroughputTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionedModelThroughputTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryArgsDict(TypedDict):
        agent_name: _builtins.str
        """
        Name of agent to which the version belongs.
        """
        agent_status: _builtins.str
        """
        Status of the agent to which the version belongs.
        """
        agent_version: _builtins.str
        """
        Version of the agent.
        """
        created_at: _builtins.str
        """
        Time at which the version was created.
        """
        description: _builtins.str
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        updated_at: _builtins.str
        """
        Time at which the version was last updated.
        """
        guardrail_configurations: NotRequired[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict']]
elif False:
    GetAgentAgentVersionsAgentVersionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryArgs:
    def __init__(__self__, *,
                 agent_name: _builtins.str,
                 agent_status: _builtins.str,
                 agent_version: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 updated_at: _builtins.str,
                 guardrail_configurations: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']] = None):
        """
        :param _builtins.str agent_name: Name of agent to which the version belongs.
        :param _builtins.str agent_status: Status of the agent to which the version belongs.
        :param _builtins.str agent_version: Version of the agent.
        :param _builtins.str created_at: Time at which the version was created.
        :param _builtins.str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param _builtins.str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @_builtins.property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> _builtins.str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @agent_name.setter
    def agent_name(self, value: _builtins.str):
        pulumi.set(self, "agent_name", value)

    @_builtins.property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> _builtins.str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @agent_status.setter
    def agent_status(self, value: _builtins.str):
        pulumi.set(self, "agent_status", value)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> _builtins.str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: _builtins.str):
        pulumi.set(self, "agent_version", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: _builtins.str):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configurations")

    @guardrail_configurations.setter
    def guardrail_configurations(self, value: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configurations", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: _builtins.str
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: _builtins.str
        """
        Version of the guardrail.
        """
elif False:
    GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: _builtins.str,
                 guardrail_version: _builtins.str):
        """
        :param _builtins.str guardrail_identifier: Unique identifier of the guardrail.
        :param _builtins.str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> _builtins.str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: _builtins.str):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> _builtins.str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: _builtins.str):
        pulumi.set(self, "guardrail_version", value)


