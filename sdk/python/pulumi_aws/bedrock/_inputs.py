# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAgentActionGroupActionGroupExecutorArgs',
    'AgentAgentActionGroupActionGroupExecutorArgsDict',
    'AgentAgentActionGroupApiSchemaArgs',
    'AgentAgentActionGroupApiSchemaArgsDict',
    'AgentAgentActionGroupApiSchemaS3Args',
    'AgentAgentActionGroupApiSchemaS3ArgsDict',
    'AgentAgentActionGroupFunctionSchemaArgs',
    'AgentAgentActionGroupFunctionSchemaArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict',
    'AgentAgentActionGroupTimeoutsArgs',
    'AgentAgentActionGroupTimeoutsArgsDict',
    'AgentAgentAliasRoutingConfigurationArgs',
    'AgentAgentAliasRoutingConfigurationArgsDict',
    'AgentAgentAliasTimeoutsArgs',
    'AgentAgentAliasTimeoutsArgsDict',
    'AgentAgentGuardrailConfigurationArgs',
    'AgentAgentGuardrailConfigurationArgsDict',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgs',
    'AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict',
    'AgentAgentPromptOverrideConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict',
    'AgentAgentTimeoutsArgs',
    'AgentAgentTimeoutsArgsDict',
    'AgentDataSourceDataSourceConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationArgsDict',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs',
    'AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict',
    'AgentDataSourceServerSideEncryptionConfigurationArgs',
    'AgentDataSourceServerSideEncryptionConfigurationArgsDict',
    'AgentDataSourceTimeoutsArgs',
    'AgentDataSourceTimeoutsArgsDict',
    'AgentDataSourceVectorIngestionConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict',
    'AgentKnowledgeBaseTimeoutsArgs',
    'AgentKnowledgeBaseTimeoutsArgsDict',
    'CustomModelOutputDataConfigArgs',
    'CustomModelOutputDataConfigArgsDict',
    'CustomModelTimeoutsArgs',
    'CustomModelTimeoutsArgsDict',
    'CustomModelTrainingDataConfigArgs',
    'CustomModelTrainingDataConfigArgsDict',
    'CustomModelTrainingMetricArgs',
    'CustomModelTrainingMetricArgsDict',
    'CustomModelValidationDataConfigArgs',
    'CustomModelValidationDataConfigArgsDict',
    'CustomModelValidationDataConfigValidatorArgs',
    'CustomModelValidationDataConfigValidatorArgsDict',
    'CustomModelValidationMetricArgs',
    'CustomModelValidationMetricArgsDict',
    'CustomModelVpcConfigArgs',
    'CustomModelVpcConfigArgsDict',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContentPolicyConfigArgsDict',
    'GuardrailContentPolicyConfigFiltersConfigArgs',
    'GuardrailContentPolicyConfigFiltersConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgs',
    'GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict',
    'GuardrailTimeoutsArgs',
    'GuardrailTimeoutsArgsDict',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailTopicPolicyConfigArgsDict',
    'GuardrailTopicPolicyConfigTopicsConfigArgs',
    'GuardrailTopicPolicyConfigTopicsConfigArgsDict',
    'GuardrailVersionTimeoutsArgs',
    'GuardrailVersionTimeoutsArgsDict',
    'GuardrailWordPolicyConfigArgs',
    'GuardrailWordPolicyConfigArgsDict',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgs',
    'GuardrailWordPolicyConfigManagedWordListsConfigArgsDict',
    'GuardrailWordPolicyConfigWordsConfigArgs',
    'GuardrailWordPolicyConfigWordsConfigArgsDict',
    'ProvisionedModelThroughputTimeoutsArgs',
    'ProvisionedModelThroughputTimeoutsArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryArgs',
    'GetAgentAgentVersionsAgentVersionSummaryArgsDict',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAgentActionGroupActionGroupExecutorArgsDict(TypedDict):
        custom_control: NotRequired[pulumi.Input[str]]
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        lambda_: NotRequired[pulumi.Input[str]]
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
elif False:
    AgentAgentActionGroupActionGroupExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupActionGroupExecutorArgs:
    def __init__(__self__, *,
                 custom_control: Optional[pulumi.Input[str]] = None,
                 lambda_: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param pulumi.Input[str] lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[pulumi.Input[str]]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_control", value)

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaArgsDict(TypedDict):
        payload: NotRequired[pulumi.Input[str]]
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        s3: NotRequired[pulumi.Input['AgentAgentActionGroupApiSchemaS3ArgsDict']]
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
elif False:
    AgentAgentActionGroupApiSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaArgs:
    def __init__(__self__, *,
                 payload: Optional[pulumi.Input[str]] = None,
                 s3: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']] = None):
        """
        :param pulumi.Input[str] payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param pulumi.Input['AgentAgentActionGroupApiSchemaS3Args'] s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['AgentAgentActionGroupApiSchemaS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentAgentActionGroupApiSchemaS3ArgsDict(TypedDict):
        s3_bucket_name: NotRequired[pulumi.Input[str]]
        """
        Name of the S3 bucket.
        """
        s3_object_key: NotRequired[pulumi.Input[str]]
        """
        S3 object key containing the resource.
        """
elif False:
    AgentAgentActionGroupApiSchemaS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupApiSchemaS3Args:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[str]] = None,
                 s3_object_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_bucket_name: Name of the S3 bucket.
        :param pulumi.Input[str] s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[str]]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_object_key", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaArgsDict(TypedDict):
        member_functions: NotRequired[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict']]
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaArgs:
    def __init__(__self__, *,
                 member_functions: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']] = None):
        """
        :param pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs'] member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")

    @member_functions.setter
    def member_functions(self, value: Optional[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs']]):
        pulumi.set(self, "member_functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict(TypedDict):
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict']]]]
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs:
    def __init__(__self__, *,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs']]]]):
        pulumi.set(self, "functions", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the function.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the function and its purpose.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict']]]]
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name for the function.
        :param pulumi.Input[str] description: Description of the function and its purpose.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict(TypedDict):
        map_block_key: pulumi.Input[str]
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        type: pulumi.Input[str]
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
elif False:
    AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs:
    def __init__(__self__, *,
                 map_block_key: pulumi.Input[str],
                 type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param pulumi.Input[str] type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param pulumi.Input[str] description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param pulumi.Input[bool] required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> pulumi.Input[str]:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @map_block_key.setter
    def map_block_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "map_block_key", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentAgentActionGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentActionGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentActionGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentAliasRoutingConfigurationArgsDict(TypedDict):
        agent_version: pulumi.Input[str]
        """
        Version of the agent with which the alias is associated.
        """
        provisioned_throughput: pulumi.Input[str]
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
elif False:
    AgentAgentAliasRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasRoutingConfigurationArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[str],
                 provisioned_throughput: pulumi.Input[str]):
        """
        :param pulumi.Input[str] agent_version: Version of the agent with which the alias is associated.
        :param pulumi.Input[str] provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[str]:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent_version", value)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> pulumi.Input[str]:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: pulumi.Input[str]):
        pulumi.set(self, "provisioned_throughput", value)


if not MYPY:
    class AgentAgentAliasTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentAliasTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentAliasTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: pulumi.Input[str]
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: pulumi.Input[str]
        """
        Version of the guardrail.
        """
elif False:
    AgentAgentGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: pulumi.Input[str],
                 guardrail_version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] guardrail_identifier: Unique identifier of the guardrail.
        :param pulumi.Input[str] guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> pulumi.Input[str]:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "guardrail_identifier", value)

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> pulumi.Input[str]:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentKnowledgeBaseAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentKnowledgeBaseAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationArgsDict(TypedDict):
        override_lambda: pulumi.Input[str]
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict']]]
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
elif False:
    AgentAgentPromptOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 override_lambda: pulumi.Input[str],
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        """
        :param pulumi.Input[str] override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> pulumi.Input[str]:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: pulumi.Input[str]):
        pulumi.set(self, "override_lambda", value)

    @property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict(TypedDict):
        base_prompt_template: pulumi.Input[str]
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict']]]
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        parser_mode: pulumi.Input[str]
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_creation_mode: pulumi.Input[str]
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        prompt_state: pulumi.Input[str]
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        prompt_type: pulumi.Input[str]
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationArgs:
    def __init__(__self__, *,
                 base_prompt_template: pulumi.Input[str],
                 inference_configurations: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]],
                 parser_mode: pulumi.Input[str],
                 prompt_creation_mode: pulumi.Input[str],
                 prompt_state: pulumi.Input[str],
                 prompt_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param pulumi.Input[str] parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[str] prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param pulumi.Input[str] prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[str] prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> pulumi.Input[str]:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_prompt_template", value)

    @property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @inference_configurations.setter
    def inference_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs']]]):
        pulumi.set(self, "inference_configurations", value)

    @property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> pulumi.Input[str]:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "parser_mode", value)

    @property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> pulumi.Input[str]:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "prompt_creation_mode", value)

    @property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> pulumi.Input[str]:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: pulumi.Input[str]):
        pulumi.set(self, "prompt_state", value)

    @property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> pulumi.Input[str]:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "prompt_type", value)


if not MYPY:
    class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict(TypedDict):
        max_length: pulumi.Input[int]
        """
        Maximum number of tokens to allow in the generated response.
        """
        stop_sequences: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        temperature: pulumi.Input[float]
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        top_k: pulumi.Input[int]
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        top_p: pulumi.Input[float]
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
elif False:
    AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_length: pulumi.Input[int],
                 stop_sequences: pulumi.Input[Sequence[pulumi.Input[str]]],
                 temperature: pulumi.Input[float],
                 top_k: pulumi.Input[int],
                 top_p: pulumi.Input[float]):
        """
        :param pulumi.Input[int] max_length: Maximum number of tokens to allow in the generated response.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param pulumi.Input[float] temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param pulumi.Input[int] top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param pulumi.Input[float] top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[int]:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stop_sequences", value)

    @property
    @pulumi.getter
    def temperature(self) -> pulumi.Input[float]:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: pulumi.Input[float]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> pulumi.Input[int]:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: pulumi.Input[int]):
        pulumi.set(self, "top_k", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> pulumi.Input[float]:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: pulumi.Input[float]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentAgentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentAgentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAgentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of storage for the data source. Valid values: `S3`.
        """
        s3_configuration: NotRequired[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict']]
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
elif False:
    AgentDataSourceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 s3_configuration: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] type: Type of storage for the data source. Valid values: `S3`.
        :param pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs'] s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of storage for the data source. Valid values: `S3`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['AgentDataSourceDataSourceConfigurationS3ConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)


if not MYPY:
    class AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict(TypedDict):
        bucket_arn: pulumi.Input[str]
        """
        ARN of the bucket that contains the data source.
        """
        bucket_owner_account_id: NotRequired[pulumi.Input[str]]
        """
        Bucket account owner ID for the S3 bucket.
        """
        inclusion_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
elif False:
    AgentDataSourceDataSourceConfigurationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceDataSourceConfigurationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[str],
                 bucket_owner_account_id: Optional[pulumi.Input[str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] bucket_arn: ARN of the bucket that contains the data source.
        :param pulumi.Input[str] bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[str]:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_arn", value)

    @property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


if not MYPY:
    class AgentDataSourceServerSideEncryptionConfigurationArgsDict(TypedDict):
        kms_key_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
elif False:
    AgentDataSourceServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class AgentDataSourceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    AgentDataSourceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationArgsDict(TypedDict):
        chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict']]
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        custom_transformation_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict']]
        """
        Configuration for custom transformation of data source documents.
        """
        parsing_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict']]
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs'] custom_transformation_configuration: Configuration for custom transformation of data source documents.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs'] parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]:
        """
        Configuration for custom transformation of data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict(TypedDict):
        chunking_strategy: pulumi.Input[str]
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        fixed_size_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        hierarchical_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        semantic_chunking_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input[str],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input[str]:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "chunking_strategy", value)

    @property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[int]
        """
        Maximum number of tokens to include in a chunk.
        """
        overlap_percentage: pulumi.Input[int]
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[int],
                 overlap_percentage: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_tokens: Maximum number of tokens to include in a chunk.
        :param pulumi.Input[int] overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[int]:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_tokens", value)

    @property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[int]:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "overlap_percentage", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict(TypedDict):
        level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict']]]
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        overlap_tokens: pulumi.Input[float]
        """
        The number of tokens to repeat across chunks in the same layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[float]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param pulumi.Input[float] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[float]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[float]):
        pulumi.set(self, "overlap_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict(TypedDict):
        max_tokens: pulumi.Input[float]
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[float]):
        """
        :param pulumi.Input[float] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[float]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict(TypedDict):
        breakpoint_percentile_threshold: pulumi.Input[float]
        """
        The dissimilarity threshold for splitting chunks.
        """
        buffer_size: pulumi.Input[float]
        """
        The buffer size.
        """
        max_token: pulumi.Input[float]
        """
        The maximum number of tokens a chunk can contain.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[float],
                 buffer_size: pulumi.Input[float],
                 max_token: pulumi.Input[float]):
        """
        :param pulumi.Input[float] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[float] buffer_size: The buffer size.
        :param pulumi.Input[float] max_token: The maximum number of tokens a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[float]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[float]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[float]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> pulumi.Input[float]:
        """
        The maximum number of tokens a chunk can contain.
        """
        return pulumi.get(self, "max_token")

    @max_token.setter
    def max_token(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_token", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict(TypedDict):
        intermediate_storage: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict']]
        """
        The intermediate storage for custom transformation.
        """
        transformation: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict']]
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']] = None,
                 transformation: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs'] intermediate_storage: The intermediate storage for custom transformation.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs'] transformation: A custom processing step for documents moving through the data source ingestion pipeline.
        """
        if intermediate_storage is not None:
            pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)

    @property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]:
        """
        The intermediate storage for custom transformation.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs']]):
        pulumi.set(self, "intermediate_storage", value)

    @property
    @pulumi.getter
    def transformation(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]:
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
        return pulumi.get(self, "transformation")

    @transformation.setter
    def transformation(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs']]):
        pulumi.set(self, "transformation", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict(TypedDict):
        s3_location: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict']]
        """
        Configuration block for intermedia S3 storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs'] s3_location: Configuration block for intermedia S3 storage.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]:
        """
        Configuration block for intermedia S3 storage.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict(TypedDict):
        uri: pulumi.Input[str]
        """
        S3 URI for intermediate storage.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] uri: S3 URI for intermediate storage.
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        S3 URI for intermediate storage.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict(TypedDict):
        step_to_apply: pulumi.Input[str]
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        transformation_function: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict']]
        """
        The lambda function that processes documents.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input[str],
                 transformation_function: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']] = None):
        """
        :param pulumi.Input[str] step_to_apply: When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs'] transformation_function: The lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        if transformation_function is not None:
            pulumi.set(__self__, "transformation_function", transformation_function)

    @property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input[str]:
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input[str]):
        pulumi.set(self, "step_to_apply", value)

    @property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]:
        """
        The lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs']]):
        pulumi.set(self, "transformation_function", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict(TypedDict):
        transformation_lambda_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict']]
        """
        The configuration of the lambda function.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']] = None):
        """
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The configuration of the lambda function.
        """
        if transformation_lambda_configuration is not None:
            pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]:
        """
        The configuration of the lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs']]):
        pulumi.set(self, "transformation_lambda_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict(TypedDict):
        lambda_arn: pulumi.Input[str]
        """
        The ARN of the lambda to use for custom transformation.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] lambda_arn: The ARN of the lambda to use for custom transformation.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the lambda to use for custom transformation.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict(TypedDict):
        parsing_strategy: pulumi.Input[str]
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict']]
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input[str],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input[str]:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "parsing_strategy", value)

    @property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict(TypedDict):
        model_arn: pulumi.Input[str]
        """
        The ARN of the model used to parse documents
        """
        parsing_prompt: NotRequired[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict']]
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[str],
                 parsing_prompt: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']] = None):
        """
        :param pulumi.Input[str] model_arn: The ARN of the model used to parse documents
        :param pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_arn", value)

    @property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


if not MYPY:
    class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict(TypedDict):
        parsing_prompt_string: pulumi.Input[str]
        """
        Instructions for interpreting the contents of the document.
        """
elif False:
    AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_string: pulumi.Input[str]):
        """
        :param pulumi.Input[str] parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> pulumi.Input[str]:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")

    @parsing_prompt_string.setter
    def parsing_prompt_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "parsing_prompt_string", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        vector_knowledge_base_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict']]
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 vector_knowledge_base_configuration: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        :param pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]:
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict(TypedDict):
        embedding_model_arn: pulumi.Input[str]
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
elif False:
    AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)

    @property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[str]:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "embedding_model_arn", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        opensearch_serverless_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        pinecone_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        rds_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict']]
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        redis_enterprise_cloud_configuration: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict']]
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 opensearch_serverless_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']] = None,
                 redis_enterprise_cloud_configuration: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] type: Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs'] opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs'] pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs'] rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs'] redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)

    @property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")

    @redis_enterprise_cloud_configuration.setter
    def redis_enterprise_cloud_configuration(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs']]):
        pulumi.set(self, "redis_enterprise_cloud_configuration", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict(TypedDict):
        collection_arn: pulumi.Input[str]
        """
        ARN of the OpenSearch Service vector store.
        """
        vector_index_name: pulumi.Input[str]
        """
        Name of the vector store.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[str],
                 vector_index_name: pulumi.Input[str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[str] collection_arn: ARN of the OpenSearch Service vector store.
        :param pulumi.Input[str] vector_index_name: Name of the vector store.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[str]:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection_arn", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[str]:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_index_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[str]] = None,
                 text_field: Optional[pulumi.Input[str]] = None,
                 vector_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict(TypedDict):
        connection_string: pulumi.Input[str]
        """
        Endpoint URL for your index management page.
        """
        credentials_secret_arn: pulumi.Input[str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace to be used to write new data to your database.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[str],
                 credentials_secret_arn: pulumi.Input[str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_string: Endpoint URL for your index management page.
        :param pulumi.Input[str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param pulumi.Input[str] namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[str]:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[str]] = None,
                 text_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        database_name: pulumi.Input[str]
        """
        Name of your Amazon RDS database.
        """
        resource_arn: pulumi.Input[str]
        """
        ARN of the vector store.
        """
        table_name: pulumi.Input[str]
        """
        Name of the table in the database.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict']]
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[str],
                 database_name: pulumi.Input[str],
                 resource_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[str] database_name: Name of your Amazon RDS database.
        :param pulumi.Input[str] resource_arn: ARN of the vector store.
        :param pulumi.Input[str] table_name: Name of the table in the database.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs'] field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: pulumi.Input[str]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        primary_key_field: pulumi.Input[str]
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        text_field: pulumi.Input[str]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[str]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[str],
                 primary_key_field: pulumi.Input[str],
                 text_field: pulumi.Input[str],
                 vector_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[str]:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_key_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict(TypedDict):
        credentials_secret_arn: pulumi.Input[str]
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        endpoint: pulumi.Input[str]
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        vector_index_name: pulumi.Input[str]
        """
        Name of the vector index.
        """
        field_mapping: NotRequired[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict']]
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 vector_index_name: pulumi.Input[str],
                 field_mapping: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']] = None):
        """
        :param pulumi.Input[str] credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param pulumi.Input[str] endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param pulumi.Input[str] vector_index_name: Name of the vector index.
        :param pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs'] field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[str]:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_index_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: Optional[pulumi.Input['AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs']]):
        pulumi.set(self, "field_mapping", value)


if not MYPY:
    class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict(TypedDict):
        metadata_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: NotRequired[pulumi.Input[str]]
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: Optional[pulumi.Input[str]] = None,
                 text_field: Optional[pulumi.Input[str]] = None,
                 vector_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class AgentKnowledgeBaseTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AgentKnowledgeBaseTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CustomModelOutputDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[str]
        """
        The S3 URI where the output data is stored.
        """
elif False:
    CustomModelOutputDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelOutputDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    CustomModelTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class CustomModelTrainingDataConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[str]
        """
        The S3 URI where the training data is stored.
        """
elif False:
    CustomModelTrainingDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingDataConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelTrainingMetricArgsDict(TypedDict):
        training_loss: pulumi.Input[float]
        """
        Loss metric associated with the customization job.
        """
elif False:
    CustomModelTrainingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelTrainingMetricArgs:
    def __init__(__self__, *,
                 training_loss: pulumi.Input[float]):
        """
        :param pulumi.Input[float] training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> pulumi.Input[float]:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")

    @training_loss.setter
    def training_loss(self, value: pulumi.Input[float]):
        pulumi.set(self, "training_loss", value)


if not MYPY:
    class CustomModelValidationDataConfigArgsDict(TypedDict):
        validators: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgsDict']]]]
        """
        Information about the validators.
        """
elif False:
    CustomModelValidationDataConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigArgs:
    def __init__(__self__, *,
                 validators: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")

    @validators.setter
    def validators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomModelValidationDataConfigValidatorArgs']]]]):
        pulumi.set(self, "validators", value)


if not MYPY:
    class CustomModelValidationDataConfigValidatorArgsDict(TypedDict):
        s3_uri: pulumi.Input[str]
        """
        The S3 URI where the validation data is stored.
        """
elif False:
    CustomModelValidationDataConfigValidatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationDataConfigValidatorArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str]):
        """
        :param pulumi.Input[str] s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class CustomModelValidationMetricArgsDict(TypedDict):
        validation_loss: pulumi.Input[float]
        """
        The validation loss associated with the validator.
        """
elif False:
    CustomModelValidationMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelValidationMetricArgs:
    def __init__(__self__, *,
                 validation_loss: pulumi.Input[float]):
        """
        :param pulumi.Input[float] validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> pulumi.Input[float]:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")

    @validation_loss.setter
    def validation_loss(self, value: pulumi.Input[float]):
        pulumi.set(self, "validation_loss", value)


if not MYPY:
    class CustomModelVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        VPC configuration security group IDs.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        VPC configuration subnets.
        """
elif False:
    CustomModelVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomModelVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: VPC configuration security group IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class GuardrailContentPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgsDict']]]]
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
elif False:
    GuardrailContentPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]] filters_configs: Set of content filter configs in content policy.
               See Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]:
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContentPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContentPolicyConfigFiltersConfigArgsDict(TypedDict):
        input_strength: pulumi.Input[str]
        """
        Strength for filters.
        """
        output_strength: pulumi.Input[str]
        """
        Strength for filters.
        """
        type: pulumi.Input[str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContentPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input[str],
                 output_strength: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] input_strength: Strength for filters.
        :param pulumi.Input[str] output_strength: Strength for filters.
        :param pulumi.Input[str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input[str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_strength", value)

    @property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input[str]:
        """
        Strength for filters.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_strength", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigArgsDict(TypedDict):
        filters_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict']]]]
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]] filters_configs: List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]:
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")

    @filters_configs.setter
    def filters_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs']]]]):
        pulumi.set(self, "filters_configs", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict(TypedDict):
        threshold: pulumi.Input[float]
        """
        The threshold for this filter.
        """
        type: pulumi.Input[str]
        """
        Type of contextual grounding filter.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigFiltersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigFiltersConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[float],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[float] threshold: The threshold for this filter.
        :param pulumi.Input[str] type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigArgsDict(TypedDict):
        pii_entities_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict']]]]
        """
        List of entities. See PII Entities Config for more information.
        """
        regexes_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict']]]]
        """
        List of regex. See Regexes Config for more information.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]] = None,
                 regexes_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @pii_entities_configs.setter
    def pii_entities_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs']]]]):
        pulumi.set(self, "pii_entities_configs", value)

    @property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")

    @regexes_configs.setter
    def regexes_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs']]]]):
        pulumi.set(self, "regexes_configs", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Options for sensitive information action.
        """
        type: pulumi.Input[str]
        """
        The currently supported PII entities.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: Options for sensitive information action.
        :param pulumi.Input[str] type: The currently supported PII entities.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Options for sensitive information action.
        """
        name: pulumi.Input[str]
        """
        The regex name.
        """
        pattern: pulumi.Input[str]
        """
        The regex pattern.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The regex description.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigRegexesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Options for sensitive information action.
        :param pulumi.Input[str] name: The regex name.
        :param pulumi.Input[str] pattern: The regex pattern.
        :param pulumi.Input[str] description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GuardrailTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    GuardrailTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class GuardrailTopicPolicyConfigArgsDict(TypedDict):
        topics_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgsDict']]]]
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
elif False:
    GuardrailTopicPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 topics_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")

    @topics_configs.setter
    def topics_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailTopicPolicyConfigTopicsConfigArgs']]]]):
        pulumi.set(self, "topics_configs", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTopicsConfigArgsDict(TypedDict):
        definition: pulumi.Input[str]
        """
        Definition of topic in topic policy.
        """
        name: pulumi.Input[str]
        """
        Name of topic in topic policy.
        """
        type: pulumi.Input[str]
        """
        Type of topic in a policy.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of text examples.
        """
elif False:
    GuardrailTopicPolicyConfigTopicsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTopicsConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] definition: Definition of topic in topic policy.
        :param pulumi.Input[str] name: Name of topic in topic policy.
        :param pulumi.Input[str] type: Type of topic in a policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "examples", value)


if not MYPY:
    class GuardrailVersionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    GuardrailVersionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailVersionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GuardrailWordPolicyConfigArgsDict(TypedDict):
        managed_word_lists_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgsDict']]]]
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        words_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgsDict']]]]
        """
        List of custom word configs. See Words Config for more information.
        """
elif False:
    GuardrailWordPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]] = None,
                 words_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @managed_word_lists_configs.setter
    def managed_word_lists_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigManagedWordListsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_configs", value)

    @property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")

    @words_configs.setter
    def words_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordPolicyConfigWordsConfigArgs']]]]):
        pulumi.set(self, "words_configs", value)


if not MYPY:
    class GuardrailWordPolicyConfigManagedWordListsConfigArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Options for managed words.
        """
elif False:
    GuardrailWordPolicyConfigManagedWordListsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigManagedWordListsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Options for managed words.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GuardrailWordPolicyConfigWordsConfigArgsDict(TypedDict):
        text: pulumi.Input[str]
        """
        The custom word text.
        """
elif False:
    GuardrailWordPolicyConfigWordsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigWordsConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str]):
        """
        :param pulumi.Input[str] text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ProvisionedModelThroughputTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ProvisionedModelThroughputTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisionedModelThroughputTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryArgsDict(TypedDict):
        agent_name: str
        """
        Name of agent to which the version belongs.
        """
        agent_status: str
        """
        Status of the agent to which the version belongs.
        """
        agent_version: str
        """
        Version of the agent.
        """
        created_at: str
        """
        Time at which the version was created.
        """
        description: str
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        updated_at: str
        """
        Time at which the version was last updated.
        """
        guardrail_configurations: NotRequired[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict']]
elif False:
    GetAgentAgentVersionsAgentVersionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryArgs:
    def __init__(__self__, *,
                 agent_name: str,
                 agent_status: str,
                 agent_version: str,
                 created_at: str,
                 description: str,
                 updated_at: str,
                 guardrail_configurations: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']] = None):
        """
        :param str agent_name: Name of agent to which the version belongs.
        :param str agent_status: Status of the agent to which the version belongs.
        :param str agent_version: Version of the agent.
        :param str created_at: Time at which the version was created.
        :param str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @agent_name.setter
    def agent_name(self, value: str):
        pulumi.set(self, "agent_name", value)

    @property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @agent_status.setter
    def agent_status(self, value: str):
        pulumi.set(self, "agent_status", value)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: str):
        pulumi.set(self, "agent_version", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: str):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: str):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configurations")

    @guardrail_configurations.setter
    def guardrail_configurations(self, value: Optional[Sequence['GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configurations", value)


if not MYPY:
    class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict(TypedDict):
        guardrail_identifier: str
        """
        Unique identifier of the guardrail.
        """
        guardrail_version: str
        """
        Version of the guardrail.
        """
elif False:
    GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: str,
                 guardrail_version: str):
        """
        :param str guardrail_identifier: Unique identifier of the guardrail.
        :param str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: str):
        pulumi.set(self, "guardrail_identifier", value)

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: str):
        pulumi.set(self, "guardrail_version", value)


