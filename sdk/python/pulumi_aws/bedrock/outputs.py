# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AgentAgentActionGroupActionGroupExecutor',
    'AgentAgentActionGroupApiSchema',
    'AgentAgentActionGroupApiSchemaS3',
    'AgentAgentActionGroupFunctionSchema',
    'AgentAgentActionGroupFunctionSchemaMemberFunctions',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter',
    'AgentAgentActionGroupTimeouts',
    'AgentAgentAliasRoutingConfiguration',
    'AgentAgentAliasTimeouts',
    'AgentAgentCollaboratorAgentDescriptor',
    'AgentAgentCollaboratorTimeouts',
    'AgentAgentGuardrailConfiguration',
    'AgentAgentKnowledgeBaseAssociationTimeouts',
    'AgentAgentMemoryConfiguration',
    'AgentAgentPromptOverrideConfiguration',
    'AgentAgentPromptOverrideConfigurationPromptConfiguration',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration',
    'AgentAgentTimeouts',
    'AgentDataSourceDataSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationConfluenceConfiguration',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter',
    'AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationS3Configuration',
    'AgentDataSourceDataSourceConfigurationSalesforceConfiguration',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter',
    'AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationSharePointConfiguration',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter',
    'AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationWebConfiguration',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration',
    'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration',
    'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrl',
    'AgentDataSourceServerSideEncryptionConfiguration',
    'AgentDataSourceTimeouts',
    'AgentDataSourceVectorIngestionConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3Location',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction',
    'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt',
    'AgentKnowledgeBaseKnowledgeBaseConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3Location',
    'AgentKnowledgeBaseStorageConfiguration',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfiguration',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationRdsConfiguration',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping',
    'AgentKnowledgeBaseTimeouts',
    'CustomModelOutputDataConfig',
    'CustomModelTimeouts',
    'CustomModelTrainingDataConfig',
    'CustomModelTrainingMetric',
    'CustomModelValidationDataConfig',
    'CustomModelValidationDataConfigValidator',
    'CustomModelValidationMetric',
    'CustomModelVpcConfig',
    'GuardrailContentPolicyConfig',
    'GuardrailContentPolicyConfigFiltersConfig',
    'GuardrailContextualGroundingPolicyConfig',
    'GuardrailContextualGroundingPolicyConfigFiltersConfig',
    'GuardrailSensitiveInformationPolicyConfig',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfig',
    'GuardrailTimeouts',
    'GuardrailTopicPolicyConfig',
    'GuardrailTopicPolicyConfigTopicsConfig',
    'GuardrailVersionTimeouts',
    'GuardrailWordPolicyConfig',
    'GuardrailWordPolicyConfigManagedWordListsConfig',
    'GuardrailWordPolicyConfigWordsConfig',
    'InferenceProfileModel',
    'InferenceProfileModelSource',
    'InferenceProfileTimeouts',
    'ProvisionedModelThroughputTimeouts',
    'GetAgentAgentVersionsAgentVersionSummaryResult',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult',
    'GetCustomModelOutputDataConfigResult',
    'GetCustomModelTrainingDataConfigResult',
    'GetCustomModelTrainingMetricResult',
    'GetCustomModelValidationDataConfigResult',
    'GetCustomModelValidationDataConfigValidatorResult',
    'GetCustomModelValidationMetricResult',
    'GetCustomModelsModelSummaryResult',
    'GetInferenceProfileModelResult',
    'GetInferenceProfilesInferenceProfileSummaryResult',
    'GetInferenceProfilesInferenceProfileSummaryModelResult',
]

@pulumi.output_type
class AgentAgentActionGroupActionGroupExecutor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customControl":
            suggest = "custom_control"
        elif key == "lambda":
            suggest = "lambda_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupActionGroupExecutor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupActionGroupExecutor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupActionGroupExecutor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_control: Optional[builtins.str] = None,
                 lambda_: Optional[builtins.str] = None):
        """
        :param builtins.str custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param builtins.str lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[builtins.str]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[builtins.str]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")


@pulumi.output_type
class AgentAgentActionGroupApiSchema(dict):
    def __init__(__self__, *,
                 payload: Optional[builtins.str] = None,
                 s3: Optional['outputs.AgentAgentActionGroupApiSchemaS3'] = None):
        """
        :param builtins.str payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param 'AgentAgentActionGroupApiSchemaS3Args' s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def payload(self) -> Optional[builtins.str]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.AgentAgentActionGroupApiSchemaS3']:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class AgentAgentActionGroupApiSchemaS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3ObjectKey":
            suggest = "s3_object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupApiSchemaS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupApiSchemaS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupApiSchemaS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: Optional[builtins.str] = None,
                 s3_object_key: Optional[builtins.str] = None):
        """
        :param builtins.str s3_bucket_name: Name of the S3 bucket.
        :param builtins.str s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[builtins.str]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[builtins.str]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberFunctions":
            suggest = "member_functions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupFunctionSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupFunctionSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupFunctionSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 member_functions: Optional['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctions'] = None):
        """
        :param 'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs' member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctions']:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctions(dict):
    def __init__(__self__, *,
                 functions: Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction']] = None):
        """
        :param Sequence['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs'] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction']]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 description: Optional[builtins.str] = None,
                 parameters: Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter']] = None):
        """
        :param builtins.str name: Name for the function.
        :param builtins.str description: Description of the function and its purpose.
        :param Sequence['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs'] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter']]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapBlockKey":
            suggest = "map_block_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 map_block_key: builtins.str,
                 type: builtins.str,
                 description: Optional[builtins.str] = None,
                 required: Optional[builtins.bool] = None):
        """
        :param builtins.str map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param builtins.str type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param builtins.str description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param builtins.bool required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> builtins.str:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def required(self) -> Optional[builtins.bool]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class AgentAgentActionGroupTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentAliasRoutingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentVersion":
            suggest = "agent_version"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentAliasRoutingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentAliasRoutingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentAliasRoutingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_version: builtins.str,
                 provisioned_throughput: builtins.str):
        """
        :param builtins.str agent_version: Version of the agent with which the alias is associated.
        :param builtins.str provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> builtins.str:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> builtins.str:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")


@pulumi.output_type
class AgentAgentAliasTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentCollaboratorAgentDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasArn":
            suggest = "alias_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentCollaboratorAgentDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentCollaboratorAgentDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentCollaboratorAgentDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_arn: builtins.str):
        """
        :param builtins.str alias_arn: ARN of the Alias of an Agent to use as the collaborator.
        """
        pulumi.set(__self__, "alias_arn", alias_arn)

    @property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> builtins.str:
        """
        ARN of the Alias of an Agent to use as the collaborator.
        """
        return pulumi.get(self, "alias_arn")


@pulumi.output_type
class AgentAgentCollaboratorTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentGuardrailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guardrailIdentifier":
            suggest = "guardrail_identifier"
        elif key == "guardrailVersion":
            suggest = "guardrail_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentGuardrailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentGuardrailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentGuardrailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guardrail_identifier: builtins.str,
                 guardrail_version: builtins.str):
        """
        :param builtins.str guardrail_identifier: Unique identifier of the guardrail.
        :param builtins.str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> builtins.str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> builtins.str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class AgentAgentKnowledgeBaseAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentMemoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledMemoryTypes":
            suggest = "enabled_memory_types"
        elif key == "storageDays":
            suggest = "storage_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentMemoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentMemoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentMemoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_memory_types: Sequence[builtins.str],
                 storage_days: builtins.int):
        """
        :param Sequence[builtins.str] enabled_memory_types: The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        :param builtins.int storage_days: The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        pulumi.set(__self__, "storage_days", storage_days)

    @property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> Sequence[builtins.str]:
        """
        The type of memory being stored by the agent. See [AWS API documentation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_MemoryConfiguration.html) for possible values.
        """
        return pulumi.get(self, "enabled_memory_types")

    @property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> builtins.int:
        """
        The number of days the agent is configured to retain the conversational context. Minimum value of 0, maximum value of 30.
        """
        return pulumi.get(self, "storage_days")


@pulumi.output_type
class AgentAgentPromptOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideLambda":
            suggest = "override_lambda"
        elif key == "promptConfigurations":
            suggest = "prompt_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override_lambda: builtins.str,
                 prompt_configurations: Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfiguration']):
        """
        :param builtins.str override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param Sequence['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs'] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> builtins.str:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfiguration']:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")


@pulumi.output_type
class AgentAgentPromptOverrideConfigurationPromptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePromptTemplate":
            suggest = "base_prompt_template"
        elif key == "inferenceConfigurations":
            suggest = "inference_configurations"
        elif key == "parserMode":
            suggest = "parser_mode"
        elif key == "promptCreationMode":
            suggest = "prompt_creation_mode"
        elif key == "promptState":
            suggest = "prompt_state"
        elif key == "promptType":
            suggest = "prompt_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfigurationPromptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_prompt_template: builtins.str,
                 inference_configurations: Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration'],
                 parser_mode: builtins.str,
                 prompt_creation_mode: builtins.str,
                 prompt_state: builtins.str,
                 prompt_type: builtins.str):
        """
        :param builtins.str base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param Sequence['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs'] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param builtins.str parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param builtins.str prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param builtins.str prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param builtins.str prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> builtins.str:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration']:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> builtins.str:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> builtins.str:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> builtins.str:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> builtins.str:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")


@pulumi.output_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxLength":
            suggest = "max_length"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topK":
            suggest = "top_k"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_length: builtins.int,
                 stop_sequences: Sequence[builtins.str],
                 temperature: builtins.float,
                 top_k: builtins.int,
                 top_p: builtins.float):
        """
        :param builtins.int max_length: Maximum number of tokens to allow in the generated response.
        :param Sequence[builtins.str] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param builtins.float temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param builtins.int top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param builtins.float top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> builtins.int:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Sequence[builtins.str]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @property
    @pulumi.getter
    def temperature(self) -> builtins.float:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> builtins.int:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> builtins.float:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class AgentAgentTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentDataSourceDataSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confluenceConfiguration":
            suggest = "confluence_configuration"
        elif key == "s3Configuration":
            suggest = "s3_configuration"
        elif key == "salesforceConfiguration":
            suggest = "salesforce_configuration"
        elif key == "sharePointConfiguration":
            suggest = "share_point_configuration"
        elif key == "webConfiguration":
            suggest = "web_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 confluence_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfiguration'] = None,
                 s3_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationS3Configuration'] = None,
                 salesforce_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfiguration'] = None,
                 share_point_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfiguration'] = None,
                 web_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfiguration'] = None):
        """
        :param builtins.str type: Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        :param 'AgentDataSourceDataSourceConfigurationConfluenceConfigurationArgs' confluence_configuration: Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        :param 'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs' s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        :param 'AgentDataSourceDataSourceConfigurationSalesforceConfigurationArgs' salesforce_configuration: Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        :param 'AgentDataSourceDataSourceConfigurationSharePointConfigurationArgs' share_point_configuration: Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        :param 'AgentDataSourceDataSourceConfigurationWebConfigurationArgs' web_configuration: Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of storage for the data source. Valid values: `S3`, `WEB`, `CONFLUENCE`, `SALESFORCE`, `SHAREPOINT`, `CUSTOM`, `REDSHIFT_METADATA`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfiguration']:
        """
        Details about the configuration of the Confluence data source. See `confluence_data_source_configuration` block for details.
        """
        return pulumi.get(self, "confluence_configuration")

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationS3Configuration']:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")

    @property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfiguration']:
        """
        Details about the configuration of the Salesforce data source. See `salesforce_data_source_configuration` block for details.
        """
        return pulumi.get(self, "salesforce_configuration")

    @property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfiguration']:
        """
        Details about the configuration of the SharePoint data source. See `share_point_data_source_configuration` block for details.
        """
        return pulumi.get(self, "share_point_configuration")

    @property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfiguration']:
        """
        Details about the configuration of the web data source. See `web_data_source_configuration` block for details.
        """
        return pulumi.get(self, "web_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerConfiguration":
            suggest = "crawler_configuration"
        elif key == "sourceConfiguration":
            suggest = "source_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationConfluenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration'] = None,
                 source_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration'] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration']:
        return pulumi.get(self, "crawler_configuration")

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration']:
        return pulumi.get(self, "source_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration'] = None):
        """
        :param 'AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationArgs' filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration']:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternObjectFilters":
            suggest = "pattern_object_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 pattern_object_filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']] = None):
        """
        :param builtins.str type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param Sequence['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs'] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']] = None):
        """
        :param Sequence['AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs'] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: builtins.str,
                 exclusion_filters: Optional[Sequence[builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> builtins.str:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "inclusion_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostType":
            suggest = "host_type"
        elif key == "hostUrl":
            suggest = "host_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationConfluenceConfigurationSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 credentials_secret_arn: builtins.str,
                 host_type: builtins.str,
                 host_url: builtins.str):
        """
        :param builtins.str auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param builtins.str host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param builtins.str host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> builtins.str:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> builtins.str:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "bucketOwnerAccountId":
            suggest = "bucket_owner_account_id"
        elif key == "inclusionPrefixes":
            suggest = "inclusion_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: builtins.str,
                 bucket_owner_account_id: Optional[builtins.str] = None,
                 inclusion_prefixes: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str bucket_arn: ARN of the bucket that contains the data source.
        :param builtins.str bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param Sequence[builtins.str] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> builtins.str:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[builtins.str]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerConfiguration":
            suggest = "crawler_configuration"
        elif key == "sourceConfiguration":
            suggest = "source_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSalesforceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration'] = None,
                 source_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration'] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration']:
        return pulumi.get(self, "crawler_configuration")

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration']:
        return pulumi.get(self, "source_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration'] = None):
        """
        :param 'AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationArgs' filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration']:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternObjectFilters":
            suggest = "pattern_object_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 pattern_object_filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']] = None):
        """
        :param builtins.str type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param Sequence['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs'] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']] = None):
        """
        :param Sequence['AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs'] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: builtins.str,
                 exclusion_filters: Optional[Sequence[builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> builtins.str:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "inclusion_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostUrl":
            suggest = "host_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSalesforceConfigurationSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 credentials_secret_arn: builtins.str,
                 host_url: builtins.str):
        """
        :param builtins.str auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param builtins.str host_url: The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> builtins.str:
        """
        The Salesforce host URL or instance URL. Pattern: `^https://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "host_url")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerConfiguration":
            suggest = "crawler_configuration"
        elif key == "sourceConfiguration":
            suggest = "source_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSharePointConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration'] = None,
                 source_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration'] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration']:
        return pulumi.get(self, "crawler_configuration")

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration']:
        return pulumi.get(self, "source_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration'] = None):
        """
        :param 'AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationArgs' filter_configuration: The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration']:
        """
        The Salesforce standard object configuration. See `filter_configuration` block for details.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternObjectFilters":
            suggest = "pattern_object_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 pattern_object_filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']] = None):
        """
        :param builtins.str type: The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param Sequence['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterArgs'] pattern_object_filters: The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filters is not None:
            pulumi.set(__self__, "pattern_object_filters", pattern_object_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="patternObjectFilters")
    def pattern_object_filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter']]:
        """
        The configuration of filtering certain objects or content types of the data source. See `pattern_object_filter` block for details.
        """
        return pulumi.get(self, "pattern_object_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']] = None):
        """
        :param Sequence['AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilterArgs'] filters: The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.
               
               Each filter object should contain the following configuration:
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter']]:
        """
        The configuration of specific filters applied to your data source content. Minimum of 1 filter and maximum of 25 filters.

        Each filter object should contain the following configuration:
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationCrawlerConfigurationFilterConfigurationPatternObjectFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: builtins.str,
                 exclusion_filters: Optional[Sequence[builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> builtins.str:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "inclusion_filters")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostType":
            suggest = "host_type"
        elif key == "siteUrls":
            suggest = "site_urls"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationSharePointConfigurationSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 credentials_secret_arn: builtins.str,
                 domain: builtins.str,
                 host_type: builtins.str,
                 site_urls: Sequence[builtins.str],
                 tenant_id: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        :param builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        :param builtins.str domain: The domain of your SharePoint instance or site URL/URLs.
        :param builtins.str host_type: The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        :param Sequence[builtins.str] site_urls: A list of one or more SharePoint site URLs.
        :param builtins.str tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The supported authentication type to authenticate and connect to your SharePoint site. Valid values: `OAUTH2_CLIENT_CREDENTIALS`, `OAUTH2_SHAREPOINT_APP_ONLY_CLIENT_CREDENTIALS`.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration. Pattern: ^arn:aws(|-cn|-us-gov):secretsmanager:[a-z0-9-]{1,20}:([0-9]{12}|):secret:[a-zA-Z0-9!/_+=.@-]{1,512}$.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> builtins.str:
        """
        The supported host type, whether online/cloud or server/on-premises. Valid values: `ONLINE`.
        """
        return pulumi.get(self, "host_type")

    @property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> Sequence[builtins.str]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerConfiguration":
            suggest = "crawler_configuration"
        elif key == "sourceConfiguration":
            suggest = "source_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationWebConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration'] = None,
                 source_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration'] = None):
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration']:
        return pulumi.get(self, "crawler_configuration")

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration']:
        return pulumi.get(self, "source_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerLimits":
            suggest = "crawler_limits"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_limits: Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits'] = None,
                 exclusion_filters: Optional[Sequence[builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[builtins.str]] = None,
                 scope: Optional[builtins.str] = None,
                 user_agent: Optional[builtins.str] = None):
        """
        :param 'AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimitsArgs' crawler_limits: Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        :param Sequence[builtins.str] exclusion_filters: List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        :param Sequence[builtins.str] inclusion_filters: List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        :param builtins.str scope: Scope of what is crawled for your URLs.
        :param builtins.str user_agent: String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits']:
        """
        Configuration of crawl limits for the web URLs. See `crawler_limits` block for details.
        """
        return pulumi.get(self, "crawler_limits")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        List of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        List of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern.
        """
        return pulumi.get(self, "inclusion_filters")

    @property
    @pulumi.getter
    def scope(self) -> Optional[builtins.str]:
        """
        Scope of what is crawled for your URLs.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[builtins.str]:
        """
        String used for identifying the crawler or a bot when it accesses a web server. Default value is `bedrockbot_UUID`.
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPages":
            suggest = "max_pages"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationCrawlerConfigurationCrawlerLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pages: Optional[builtins.int] = None,
                 rate_limit: Optional[builtins.int] = None):
        """
        :param builtins.int max_pages: Max number of web pages crawled from your source URLs, up to 25,000 pages.
        :param builtins.int rate_limit: Max rate at which pages are crawled, up to 300 per minute per host.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[builtins.int]:
        """
        Max number of web pages crawled from your source URLs, up to 25,000 pages.
        """
        return pulumi.get(self, "max_pages")

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[builtins.int]:
        """
        Max rate at which pages are crawled, up to 300 per minute per host.
        """
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlConfiguration":
            suggest = "url_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration'] = None):
        """
        :param 'AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationArgs' url_configuration: The URL configuration of your web data source. See `url_configuration` block for details.
        """
        if url_configuration is not None:
            pulumi.set(__self__, "url_configuration", url_configuration)

    @property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration']:
        """
        The URL configuration of your web data source. See `url_configuration` block for details.
        """
        return pulumi.get(self, "url_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "seedUrls":
            suggest = "seed_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 seed_urls: Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrl']] = None):
        """
        :param Sequence['AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrlArgs'] seed_urls: List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        if seed_urls is not None:
            pulumi.set(__self__, "seed_urls", seed_urls)

    @property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Optional[Sequence['outputs.AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrl']]:
        """
        List of one or more seed URLs to crawl. See `seed_urls` block for details.
        """
        return pulumi.get(self, "seed_urls")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationWebConfigurationSourceConfigurationUrlConfigurationSeedUrl(dict):
    def __init__(__self__, *,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.str url: Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        Seed or starting point URL. Must match the pattern `^https?://[A-Za-z0-9][^\\s]*$`.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AgentDataSourceServerSideEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceServerSideEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[builtins.str] = None):
        """
        :param builtins.str kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[builtins.str]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class AgentDataSourceTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingConfiguration":
            suggest = "chunking_configuration"
        elif key == "customTransformationConfiguration":
            suggest = "custom_transformation_configuration"
        elif key == "parsingConfiguration":
            suggest = "parsing_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfiguration'] = None,
                 custom_transformation_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration'] = None,
                 parsing_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfiguration'] = None):
        """
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs' chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationArgs' custom_transformation_configuration: Configuration for custom transformation of data source documents.
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs' parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfiguration']:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration']:
        """
        Configuration for custom transformation of data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfiguration']:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingStrategy":
            suggest = "chunking_strategy"
        elif key == "fixedSizeChunkingConfiguration":
            suggest = "fixed_size_chunking_configuration"
        elif key == "hierarchicalChunkingConfiguration":
            suggest = "hierarchical_chunking_configuration"
        elif key == "semanticChunkingConfiguration":
            suggest = "semantic_chunking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_strategy: builtins.str,
                 fixed_size_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration'] = None,
                 hierarchical_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration'] = None,
                 semantic_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration'] = None):
        """
        :param builtins.str chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs' fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs' hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs' semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> builtins.str:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration']:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration']:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration']:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "overlapPercentage":
            suggest = "overlap_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: builtins.int,
                 overlap_percentage: builtins.int):
        """
        :param builtins.int max_tokens: Maximum number of tokens to include in a chunk.
        :param builtins.int overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> builtins.int:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> builtins.int:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelConfigurations":
            suggest = "level_configurations"
        elif key == "overlapTokens":
            suggest = "overlap_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_configurations: Sequence['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration'],
                 overlap_tokens: builtins.int):
        """
        :param Sequence['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs'] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param builtins.int overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> Sequence['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration']:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> builtins.int:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: builtins.int):
        """
        :param builtins.int max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> builtins.int:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakpointPercentileThreshold":
            suggest = "breakpoint_percentile_threshold"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "maxToken":
            suggest = "max_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakpoint_percentile_threshold: builtins.int,
                 buffer_size: builtins.int,
                 max_token: builtins.int):
        """
        :param builtins.int breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param builtins.int buffer_size: The buffer size.
        :param builtins.int max_token: The maximum number of tokens a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> builtins.int:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> builtins.int:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> builtins.int:
        """
        The maximum number of tokens a chunk can contain.
        """
        return pulumi.get(self, "max_token")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateStorage":
            suggest = "intermediate_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_storage: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage'] = None,
                 transformation: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation'] = None):
        """
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageArgs' intermediate_storage: The intermediate storage for custom transformation.
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationArgs' transformation: A custom processing step for documents moving through the data source ingestion pipeline.
        """
        if intermediate_storage is not None:
            pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        if transformation is not None:
            pulumi.set(__self__, "transformation", transformation)

    @property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage']:
        """
        The intermediate storage for custom transformation.
        """
        return pulumi.get(self, "intermediate_storage")

    @property
    @pulumi.getter
    def transformation(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation']:
        """
        A custom processing step for documents moving through the data source ingestion pipeline.
        """
        return pulumi.get(self, "transformation")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_location: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3Location'] = None):
        """
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3LocationArgs' s3_location: Configuration block for intermedia S3 storage.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3Location']:
        """
        Configuration block for intermedia S3 storage.
        """
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationIntermediateStorageS3Location(dict):
    def __init__(__self__, *,
                 uri: builtins.str):
        """
        :param builtins.str uri: S3 URI for intermediate storage.
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        S3 URI for intermediate storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepToApply":
            suggest = "step_to_apply"
        elif key == "transformationFunction":
            suggest = "transformation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_to_apply: builtins.str,
                 transformation_function: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction'] = None):
        """
        :param builtins.str step_to_apply: When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionArgs' transformation_function: The lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        if transformation_function is not None:
            pulumi.set(__self__, "transformation_function", transformation_function)

    @property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> builtins.str:
        """
        When the service applies the transformation. Currently only `POST_CHUNKING` is supported.
        """
        return pulumi.get(self, "step_to_apply")

    @property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction']:
        """
        The lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationLambdaConfiguration":
            suggest = "transformation_lambda_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_lambda_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration'] = None):
        """
        :param 'AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfigurationArgs' transformation_lambda_configuration: The configuration of the lambda function.
        """
        if transformation_lambda_configuration is not None:
            pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration']:
        """
        The configuration of the lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationCustomTransformationConfigurationTransformationTransformationFunctionTransformationLambdaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: builtins.str):
        """
        :param builtins.str lambda_arn: The ARN of the lambda to use for custom transformation.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> builtins.str:
        """
        The ARN of the lambda to use for custom transformation.
        """
        return pulumi.get(self, "lambda_arn")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingStrategy":
            suggest = "parsing_strategy"
        elif key == "bedrockFoundationModelConfiguration":
            suggest = "bedrock_foundation_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_strategy: builtins.str,
                 bedrock_foundation_model_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration'] = None):
        """
        :param builtins.str parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs' bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> builtins.str:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration']:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "parsingPrompt":
            suggest = "parsing_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: builtins.str,
                 parsing_prompt: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt'] = None):
        """
        :param builtins.str model_arn: The ARN of the model used to parse documents
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs' parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> builtins.str:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt']:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingPromptString":
            suggest = "parsing_prompt_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_prompt_string: builtins.str):
        """
        :param builtins.str parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> builtins.str:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vectorKnowledgeBaseConfiguration":
            suggest = "vector_knowledge_base_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 vector_knowledge_base_configuration: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration'] = None):
        """
        :param builtins.str type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs' vector_knowledge_base_configuration: Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration']:
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingModelArn":
            suggest = "embedding_model_arn"
        elif key == "embeddingModelConfiguration":
            suggest = "embedding_model_configuration"
        elif key == "supplementalDataStorageConfiguration":
            suggest = "supplemental_data_storage_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_model_arn: builtins.str,
                 embedding_model_configuration: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration'] = None,
                 supplemental_data_storage_configuration: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration'] = None):
        """
        :param builtins.str embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationArgs' embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationArgs' supplemental_data_storage_configuration: supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> builtins.str:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration']:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.  See `embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration']:
        """
        supplemental_data_storage_configuration.  See `supplemental_data_storage_configuration` block for details.
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bedrockEmbeddingModelConfiguration":
            suggest = "bedrock_embedding_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration'] = None):
        """
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfigurationArgs' bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration']:
        """
        The vector configuration details on the Bedrock embeddings model.  See `bedrock_embedding_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingDataType":
            suggest = "embedding_data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationEmbeddingModelConfigurationBedrockEmbeddingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[builtins.int] = None,
                 embedding_data_type: Optional[builtins.str] = None):
        """
        :param builtins.int dimensions: Dimension details for the vector configuration used on the Bedrock embeddings model.
        :param builtins.str embedding_data_type: Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[builtins.int]:
        """
        Dimension details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional[builtins.str]:
        """
        Data type for the vectors when using a model to convert text into vector embeddings. The model must support the specified data type for vector embeddings.  Valid values are `FLOAT32` and `BINARY`.
        """
        return pulumi.get(self, "embedding_data_type")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageLocations":
            suggest = "storage_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_locations: Optional[Sequence['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation']] = None):
        """
        :param Sequence['AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationArgs'] storage_locations: A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        if storage_locations is not None:
            pulumi.set(__self__, "storage_locations", storage_locations)

    @property
    @pulumi.getter(name="storageLocations")
    def storage_locations(self) -> Optional[Sequence['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation']]:
        """
        A storage location specification for images extracted from multimodal documents in your data source.  See `storage_location` block for details.
        """
        return pulumi.get(self, "storage_locations")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 s3_location: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3Location'] = None):
        """
        :param builtins.str type: Storage service used for this location. `S3` is the only valid value.
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3LocationArgs' s3_location: Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Storage service used for this location. `S3` is the only valid value.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3Location']:
        """
        Contains information about the Amazon S3 location for the extracted images.  See `s3_location` block for details.
        """
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationSupplementalDataStorageConfigurationStorageLocationS3Location(dict):
    def __init__(__self__, *,
                 uri: builtins.str):
        """
        :param builtins.str uri: URI of the location.
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        URI of the location.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchServerlessConfiguration":
            suggest = "opensearch_serverless_configuration"
        elif key == "pineconeConfiguration":
            suggest = "pinecone_configuration"
        elif key == "rdsConfiguration":
            suggest = "rds_configuration"
        elif key == "redisEnterpriseCloudConfiguration":
            suggest = "redis_enterprise_cloud_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 opensearch_serverless_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration'] = None,
                 pinecone_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfiguration'] = None,
                 rds_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfiguration'] = None,
                 redis_enterprise_cloud_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration'] = None):
        """
        :param builtins.str type: Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        :param 'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs' opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs' pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs' rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs' redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration']:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfiguration']:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfiguration']:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration']:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionArn":
            suggest = "collection_arn"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_arn: builtins.str,
                 vector_index_name: builtins.str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping'] = None):
        """
        :param builtins.str collection_arn: ARN of the OpenSearch Service vector store.
        :param builtins.str vector_index_name: Name of the vector store.
        :param 'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> builtins.str:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> builtins.str:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[builtins.str] = None,
                 text_field: Optional[builtins.str] = None,
                 vector_field: Optional[builtins.str] = None):
        """
        :param builtins.str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param builtins.str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param builtins.str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationPineconeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: builtins.str,
                 credentials_secret_arn: builtins.str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping'] = None,
                 namespace: Optional[builtins.str] = None):
        """
        :param builtins.str connection_string: Endpoint URL for your index management page.
        :param builtins.str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param 'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param builtins.str namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> builtins.str:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[builtins.str] = None,
                 text_field: Optional[builtins.str] = None):
        """
        :param builtins.str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param builtins.str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "resourceArn":
            suggest = "resource_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_secret_arn: builtins.str,
                 database_name: builtins.str,
                 resource_arn: builtins.str,
                 table_name: builtins.str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping'] = None):
        """
        :param builtins.str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param builtins.str database_name: Name of your Amazon RDS database.
        :param builtins.str resource_arn: ARN of the vector store.
        :param builtins.str table_name: Name of the table in the database.
        :param 'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs' field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> builtins.str:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> builtins.str:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping']:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "primaryKeyField":
            suggest = "primary_key_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: builtins.str,
                 primary_key_field: builtins.str,
                 text_field: builtins.str,
                 vector_field: builtins.str):
        """
        :param builtins.str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param builtins.str primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param builtins.str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param builtins.str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> builtins.str:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> builtins.str:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> builtins.str:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> builtins.str:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_secret_arn: builtins.str,
                 endpoint: builtins.str,
                 vector_index_name: builtins.str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping'] = None):
        """
        :param builtins.str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param builtins.str endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param builtins.str vector_index_name: Name of the vector index.
        :param 'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> builtins.str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> builtins.str:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[builtins.str] = None,
                 text_field: Optional[builtins.str] = None,
                 vector_field: Optional[builtins.str] = None):
        """
        :param builtins.str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param builtins.str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param builtins.str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[builtins.str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CustomModelOutputDataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelOutputDataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelOutputDataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelOutputDataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class CustomModelTrainingDataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelTrainingDataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelTrainingDataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelTrainingDataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelTrainingMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trainingLoss":
            suggest = "training_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelTrainingMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelTrainingMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelTrainingMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 training_loss: builtins.float):
        """
        :param builtins.float training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> builtins.float:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")


@pulumi.output_type
class CustomModelValidationDataConfig(dict):
    def __init__(__self__, *,
                 validators: Optional[Sequence['outputs.CustomModelValidationDataConfigValidator']] = None):
        """
        :param Sequence['CustomModelValidationDataConfigValidatorArgs'] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Optional[Sequence['outputs.CustomModelValidationDataConfigValidator']]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")


@pulumi.output_type
class CustomModelValidationDataConfigValidator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelValidationDataConfigValidator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelValidationDataConfigValidator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelValidationDataConfigValidator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelValidationMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationLoss":
            suggest = "validation_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelValidationMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelValidationMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelValidationMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validation_loss: builtins.float):
        """
        :param builtins.float validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> builtins.float:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")


@pulumi.output_type
class CustomModelVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[builtins.str],
                 subnet_ids: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] security_group_ids: VPC configuration security group IDs.
        :param Sequence[builtins.str] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[builtins.str]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[builtins.str]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GuardrailContentPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfigs":
            suggest = "filters_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_configs: Optional[Sequence['outputs.GuardrailContentPolicyConfigFiltersConfig']] = None):
        """
        :param Sequence['GuardrailContentPolicyConfigFiltersConfigArgs'] filters_configs: Set of content filter configs in content policy.
               See Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[Sequence['outputs.GuardrailContentPolicyConfigFiltersConfig']]:
        """
        Set of content filter configs in content policy.
        See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")


@pulumi.output_type
class GuardrailContentPolicyConfigFiltersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputStrength":
            suggest = "input_strength"
        elif key == "outputStrength":
            suggest = "output_strength"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfigFiltersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfigFiltersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfigFiltersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_strength: builtins.str,
                 output_strength: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str input_strength: Strength for filters.
        :param builtins.str output_strength: Strength for filters.
        :param builtins.str type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> builtins.str:
        """
        Strength for filters.
        """
        return pulumi.get(self, "input_strength")

    @property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> builtins.str:
        """
        Strength for filters.
        """
        return pulumi.get(self, "output_strength")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailContextualGroundingPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfigs":
            suggest = "filters_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContextualGroundingPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_configs: Optional[Sequence['outputs.GuardrailContextualGroundingPolicyConfigFiltersConfig']] = None):
        """
        :param Sequence['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs'] filters_configs: List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[Sequence['outputs.GuardrailContextualGroundingPolicyConfigFiltersConfig']]:
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")


@pulumi.output_type
class GuardrailContextualGroundingPolicyConfigFiltersConfig(dict):
    def __init__(__self__, *,
                 threshold: builtins.float,
                 type: builtins.str):
        """
        :param builtins.float threshold: The threshold for this filter.
        :param builtins.str type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def threshold(self) -> builtins.float:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "piiEntitiesConfigs":
            suggest = "pii_entities_configs"
        elif key == "regexesConfigs":
            suggest = "regexes_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailSensitiveInformationPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pii_entities_configs: Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig']] = None,
                 regexes_configs: Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigRegexesConfig']] = None):
        """
        :param Sequence['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs'] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param Sequence['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs'] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig']]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigRegexesConfig']]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig(dict):
    def __init__(__self__, *,
                 action: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str action: Options for sensitive information action.
        :param builtins.str type: The currently supported PII entities.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfig(dict):
    def __init__(__self__, *,
                 action: builtins.str,
                 name: builtins.str,
                 pattern: builtins.str,
                 description: Optional[builtins.str] = None):
        """
        :param builtins.str action: Options for sensitive information action.
        :param builtins.str name: The regex name.
        :param builtins.str pattern: The regex pattern.
        :param builtins.str description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> builtins.str:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GuardrailTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GuardrailTopicPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicsConfigs":
            suggest = "topics_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailTopicPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topics_configs: Optional[Sequence['outputs.GuardrailTopicPolicyConfigTopicsConfig']] = None):
        """
        :param Sequence['GuardrailTopicPolicyConfigTopicsConfigArgs'] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[Sequence['outputs.GuardrailTopicPolicyConfigTopicsConfig']]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")


@pulumi.output_type
class GuardrailTopicPolicyConfigTopicsConfig(dict):
    def __init__(__self__, *,
                 definition: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 examples: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str definition: Definition of topic in topic policy.
        :param builtins.str name: Name of topic in topic policy.
        :param builtins.str type: Type of topic in a policy.
        :param Sequence[builtins.str] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @property
    @pulumi.getter
    def definition(self) -> builtins.str:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def examples(self) -> Optional[Sequence[builtins.str]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")


@pulumi.output_type
class GuardrailVersionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class GuardrailWordPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedWordListsConfigs":
            suggest = "managed_word_lists_configs"
        elif key == "wordsConfigs":
            suggest = "words_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailWordPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[Sequence['outputs.GuardrailWordPolicyConfigManagedWordListsConfig']] = None,
                 words_configs: Optional[Sequence['outputs.GuardrailWordPolicyConfigWordsConfig']] = None):
        """
        :param Sequence['GuardrailWordPolicyConfigManagedWordListsConfigArgs'] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param Sequence['GuardrailWordPolicyConfigWordsConfigArgs'] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[Sequence['outputs.GuardrailWordPolicyConfigManagedWordListsConfig']]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[Sequence['outputs.GuardrailWordPolicyConfigWordsConfig']]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")


@pulumi.output_type
class GuardrailWordPolicyConfigManagedWordListsConfig(dict):
    def __init__(__self__, *,
                 type: builtins.str):
        """
        :param builtins.str type: Options for managed words.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailWordPolicyConfigWordsConfig(dict):
    def __init__(__self__, *,
                 text: builtins.str):
        """
        :param builtins.str text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> builtins.str:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class InferenceProfileModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceProfileModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceProfileModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceProfileModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: builtins.str):
        """
        :param builtins.str model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")


@pulumi.output_type
class InferenceProfileModelSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyFrom":
            suggest = "copy_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceProfileModelSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceProfileModelSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceProfileModelSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_from: builtins.str):
        """
        :param builtins.str copy_from: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "copy_from")


@pulumi.output_type
class InferenceProfileTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ProvisionedModelThroughputTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class GetAgentAgentVersionsAgentVersionSummaryResult(dict):
    def __init__(__self__, *,
                 agent_name: builtins.str,
                 agent_status: builtins.str,
                 agent_version: builtins.str,
                 created_at: builtins.str,
                 description: builtins.str,
                 updated_at: builtins.str,
                 guardrail_configurations: Optional[Sequence['outputs.GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult']] = None):
        """
        :param builtins.str agent_name: Name of agent to which the version belongs.
        :param builtins.str agent_status: Status of the agent to which the version belongs.
        :param builtins.str agent_version: Version of the agent.
        :param builtins.str created_at: Time at which the version was created.
        :param builtins.str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param builtins.str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> builtins.str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> builtins.str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> builtins.str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> builtins.str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['outputs.GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult']]:
        return pulumi.get(self, "guardrail_configurations")


@pulumi.output_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult(dict):
    def __init__(__self__, *,
                 guardrail_identifier: builtins.str,
                 guardrail_version: builtins.str):
        """
        :param builtins.str guardrail_identifier: Unique identifier of the guardrail.
        :param builtins.str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> builtins.str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> builtins.str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class GetCustomModelOutputDataConfigResult(dict):
    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelTrainingDataConfigResult(dict):
    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelTrainingMetricResult(dict):
    def __init__(__self__, *,
                 training_loss: builtins.float):
        """
        :param builtins.float training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> builtins.float:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")


@pulumi.output_type
class GetCustomModelValidationDataConfigResult(dict):
    def __init__(__self__, *,
                 validators: Sequence['outputs.GetCustomModelValidationDataConfigValidatorResult']):
        """
        :param Sequence['GetCustomModelValidationDataConfigValidatorArgs'] validators: Information about the validators.
        """
        pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Sequence['outputs.GetCustomModelValidationDataConfigValidatorResult']:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")


@pulumi.output_type
class GetCustomModelValidationDataConfigValidatorResult(dict):
    def __init__(__self__, *,
                 s3_uri: builtins.str):
        """
        :param builtins.str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> builtins.str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelValidationMetricResult(dict):
    def __init__(__self__, *,
                 validation_loss: builtins.float):
        """
        :param builtins.float validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> builtins.float:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")


@pulumi.output_type
class GetCustomModelsModelSummaryResult(dict):
    def __init__(__self__, *,
                 creation_time: builtins.str,
                 model_arn: builtins.str,
                 model_name: builtins.str):
        """
        :param builtins.str creation_time: Creation time of the model.
        :param builtins.str model_arn: The ARN of the custom model.
        :param builtins.str model_name: The name of the custom model.
        """
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "model_arn", model_arn)
        pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> builtins.str:
        """
        Creation time of the model.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> builtins.str:
        """
        The ARN of the custom model.
        """
        return pulumi.get(self, "model_arn")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> builtins.str:
        """
        The name of the custom model.
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class GetInferenceProfileModelResult(dict):
    def __init__(__self__, *,
                 model_arn: builtins.str):
        """
        :param builtins.str model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")


@pulumi.output_type
class GetInferenceProfilesInferenceProfileSummaryResult(dict):
    def __init__(__self__, *,
                 created_at: builtins.str,
                 description: builtins.str,
                 inference_profile_arn: builtins.str,
                 inference_profile_id: builtins.str,
                 inference_profile_name: builtins.str,
                 models: Sequence['outputs.GetInferenceProfilesInferenceProfileSummaryModelResult'],
                 status: builtins.str,
                 type: builtins.str,
                 updated_at: builtins.str):
        """
        :param builtins.str created_at: The time at which the inference profile was created.
        :param builtins.str description: The description of the inference profile.
        :param builtins.str inference_profile_arn: The Amazon Resource Name (ARN) of the inference profile.
        :param builtins.str inference_profile_id: The unique identifier of the inference profile.
        :param builtins.str inference_profile_name: The name of the inference profile.
        :param Sequence['GetInferenceProfilesInferenceProfileSummaryModelArgs'] models: A list of information about each model in the inference profile. See `models`.
        :param builtins.str status: The status of the inference profile. `ACTIVE` means that the inference profile is available to use.
        :param builtins.str type: The type of the inference profile. `SYSTEM_DEFINED` means that the inference profile is defined by Amazon Bedrock.
        :param builtins.str updated_at: The time at which the inference profile was last updated.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "inference_profile_arn", inference_profile_arn)
        pulumi.set(__self__, "inference_profile_id", inference_profile_id)
        pulumi.set(__self__, "inference_profile_name", inference_profile_name)
        pulumi.set(__self__, "models", models)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The time at which the inference profile was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The description of the inference profile.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="inferenceProfileArn")
    def inference_profile_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the inference profile.
        """
        return pulumi.get(self, "inference_profile_arn")

    @property
    @pulumi.getter(name="inferenceProfileId")
    def inference_profile_id(self) -> builtins.str:
        """
        The unique identifier of the inference profile.
        """
        return pulumi.get(self, "inference_profile_id")

    @property
    @pulumi.getter(name="inferenceProfileName")
    def inference_profile_name(self) -> builtins.str:
        """
        The name of the inference profile.
        """
        return pulumi.get(self, "inference_profile_name")

    @property
    @pulumi.getter
    def models(self) -> Sequence['outputs.GetInferenceProfilesInferenceProfileSummaryModelResult']:
        """
        A list of information about each model in the inference profile. See `models`.
        """
        return pulumi.get(self, "models")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        The status of the inference profile. `ACTIVE` means that the inference profile is available to use.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the inference profile. `SYSTEM_DEFINED` means that the inference profile is defined by Amazon Bedrock.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> builtins.str:
        """
        The time at which the inference profile was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetInferenceProfilesInferenceProfileSummaryModelResult(dict):
    def __init__(__self__, *,
                 model_arn: builtins.str):
        """
        :param builtins.str model_arn: The Amazon Resource Name (ARN) of the model.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> builtins.str:
        """
        The Amazon Resource Name (ARN) of the model.
        """
        return pulumi.get(self, "model_arn")


