# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AgentAgentActionGroupActionGroupExecutor',
    'AgentAgentActionGroupApiSchema',
    'AgentAgentActionGroupApiSchemaS3',
    'AgentAgentActionGroupFunctionSchema',
    'AgentAgentActionGroupFunctionSchemaMemberFunctions',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction',
    'AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter',
    'AgentAgentAliasRoutingConfiguration',
    'AgentAgentAliasTimeouts',
    'AgentAgentKnowledgeBaseAssociationTimeouts',
    'AgentAgentPromptOverrideConfiguration',
    'AgentAgentPromptOverrideConfigurationPromptConfiguration',
    'AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration',
    'AgentAgentTimeouts',
    'AgentDataSourceDataSourceConfiguration',
    'AgentDataSourceDataSourceConfigurationS3Configuration',
    'AgentDataSourceServerSideEncryptionConfiguration',
    'AgentDataSourceTimeouts',
    'AgentDataSourceVectorIngestionConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration',
    'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration',
    'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt',
    'AgentKnowledgeBaseKnowledgeBaseConfiguration',
    'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration',
    'AgentKnowledgeBaseStorageConfiguration',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration',
    'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfiguration',
    'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationRdsConfiguration',
    'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration',
    'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping',
    'AgentKnowledgeBaseTimeouts',
    'CustomModelOutputDataConfig',
    'CustomModelTimeouts',
    'CustomModelTrainingDataConfig',
    'CustomModelTrainingMetric',
    'CustomModelValidationDataConfig',
    'CustomModelValidationDataConfigValidator',
    'CustomModelValidationMetric',
    'CustomModelVpcConfig',
    'GuardrailContentPolicyConfig',
    'GuardrailContentPolicyConfigFiltersConfig',
    'GuardrailContextualGroundingPolicyConfig',
    'GuardrailContextualGroundingPolicyConfigFiltersConfig',
    'GuardrailSensitiveInformationPolicyConfig',
    'GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig',
    'GuardrailSensitiveInformationPolicyConfigRegexesConfig',
    'GuardrailTimeouts',
    'GuardrailTopicPolicyConfig',
    'GuardrailTopicPolicyConfigTopicsConfig',
    'GuardrailWordPolicyConfig',
    'GuardrailWordPolicyConfigManagedWordListsConfig',
    'GuardrailWordPolicyConfigWordsConfig',
    'ProvisionedModelThroughputTimeouts',
    'GetAgentAgentVersionsAgentVersionSummaryResult',
    'GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult',
    'GetCustomModelOutputDataConfigResult',
    'GetCustomModelTrainingDataConfigResult',
    'GetCustomModelTrainingMetricResult',
    'GetCustomModelValidationDataConfigResult',
    'GetCustomModelValidationDataConfigValidatorResult',
    'GetCustomModelValidationMetricResult',
    'GetCustomModelsModelSummaryResult',
]

@pulumi.output_type
class AgentAgentActionGroupActionGroupExecutor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customControl":
            suggest = "custom_control"
        elif key == "lambda":
            suggest = "lambda_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupActionGroupExecutor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupActionGroupExecutor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupActionGroupExecutor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_control: Optional[str] = None,
                 lambda_: Optional[str] = None):
        """
        :param str custom_control: Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
               To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
               Only one of `custom_control` or `lambda` can be specified.
        :param str lambda_: ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
               Only one of `lambda` or `custom_control` can be specified.
        """
        if custom_control is not None:
            pulumi.set(__self__, "custom_control", custom_control)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)

    @property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> Optional[str]:
        """
        Custom control method for handling the information elicited from the user. Valid values: `RETURN_CONTROL`.
        To skip using a Lambda function and instead return the predicted action group, in addition to the parameters and information required for it, in the `InvokeAgent` response, specify `RETURN_CONTROL`.
        Only one of `custom_control` or `lambda` can be specified.
        """
        return pulumi.get(self, "custom_control")

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[str]:
        """
        ARN of the Lambda function containing the business logic that is carried out upon invoking the action.
        Only one of `lambda` or `custom_control` can be specified.
        """
        return pulumi.get(self, "lambda_")


@pulumi.output_type
class AgentAgentActionGroupApiSchema(dict):
    def __init__(__self__, *,
                 payload: Optional[str] = None,
                 s3: Optional['outputs.AgentAgentActionGroupApiSchemaS3'] = None):
        """
        :param str payload: JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
               Only one of `payload` or `s3` can be specified.
        :param 'AgentAgentActionGroupApiSchemaS3Args' s3: Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
               Only one of `s3` or `payload` can be specified.
        """
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        """
        JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        Only one of `payload` or `s3` can be specified.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.AgentAgentActionGroupApiSchemaS3']:
        """
        Details about the S3 object containing the OpenAPI schema for the action group. See `s3` Block for details.
        Only one of `s3` or `payload` can be specified.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class AgentAgentActionGroupApiSchemaS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3ObjectKey":
            suggest = "s3_object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupApiSchemaS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupApiSchemaS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupApiSchemaS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: Optional[str] = None,
                 s3_object_key: Optional[str] = None):
        """
        :param str s3_bucket_name: Name of the S3 bucket.
        :param str s3_object_key: S3 object key containing the resource.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[str]:
        """
        Name of the S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[str]:
        """
        S3 object key containing the resource.
        """
        return pulumi.get(self, "s3_object_key")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberFunctions":
            suggest = "member_functions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupFunctionSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupFunctionSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupFunctionSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 member_functions: Optional['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctions'] = None):
        """
        :param 'AgentAgentActionGroupFunctionSchemaMemberFunctionsArgs' member_functions: Contains a list of functions.
               Each function describes and action in the action group.
               See `member_functions` Block for details.
        """
        if member_functions is not None:
            pulumi.set(__self__, "member_functions", member_functions)

    @property
    @pulumi.getter(name="memberFunctions")
    def member_functions(self) -> Optional['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctions']:
        """
        Contains a list of functions.
        Each function describes and action in the action group.
        See `member_functions` Block for details.
        """
        return pulumi.get(self, "member_functions")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctions(dict):
    def __init__(__self__, *,
                 functions: Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction']] = None):
        """
        :param Sequence['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionArgs'] functions: Functions that each define an action in the action group. See `functions` Block for details.
        """
        if functions is not None:
            pulumi.set(__self__, "functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction']]:
        """
        Functions that each define an action in the action group. See `functions` Block for details.
        """
        return pulumi.get(self, "functions")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunction(dict):
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter']] = None):
        """
        :param str name: Name for the function.
        :param str description: Description of the function and its purpose.
        :param Sequence['AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameterArgs'] parameters: Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the function.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the function and its purpose.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter']]:
        """
        Parameters that the agent elicits from the user to fulfill the function. See `parameters` Block for details.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapBlockKey":
            suggest = "map_block_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentActionGroupFunctionSchemaMemberFunctionsFunctionParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 map_block_key: str,
                 type: str,
                 description: Optional[str] = None,
                 required: Optional[bool] = None):
        """
        :param str map_block_key: Name of the parameter.
               
               **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        :param str type: Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        :param str description: Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        :param bool required: Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        pulumi.set(__self__, "map_block_key", map_block_key)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter(name="mapBlockKey")
    def map_block_key(self) -> str:
        """
        Name of the parameter.

        **Note:** The argument name `map_block_key` may seem out of context, but is necessary for backward compatibility reasons in the provider.
        """
        return pulumi.get(self, "map_block_key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Data type of the parameter. Valid values: `string`, `number`, `integer`, `boolean`, `array`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the parameter is required for the agent to complete the function for action group invocation.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class AgentAgentAliasRoutingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentVersion":
            suggest = "agent_version"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentAliasRoutingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentAliasRoutingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentAliasRoutingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_version: str,
                 provisioned_throughput: str):
        """
        :param str agent_version: Version of the agent with which the alias is associated.
        :param str provisioned_throughput: ARN of the Provisioned Throughput assigned to the agent alias.
        """
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> str:
        """
        Version of the agent with which the alias is associated.
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> str:
        """
        ARN of the Provisioned Throughput assigned to the agent alias.
        """
        return pulumi.get(self, "provisioned_throughput")


@pulumi.output_type
class AgentAgentAliasTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentKnowledgeBaseAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentAgentPromptOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideLambda":
            suggest = "override_lambda"
        elif key == "promptConfigurations":
            suggest = "prompt_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override_lambda: str,
                 prompt_configurations: Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfiguration']):
        """
        :param str override_lambda: ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        :param Sequence['AgentAgentPromptOverrideConfigurationPromptConfigurationArgs'] prompt_configurations: Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        pulumi.set(__self__, "override_lambda", override_lambda)
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)

    @property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> str:
        """
        ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the `prompt_configurations` block must contain a `parser_mode` value that is set to `OVERRIDDEN`.
        """
        return pulumi.get(self, "override_lambda")

    @property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfiguration']:
        """
        Configurations to override a prompt template in one part of an agent sequence. See `prompt_configurations` Block for details.
        """
        return pulumi.get(self, "prompt_configurations")


@pulumi.output_type
class AgentAgentPromptOverrideConfigurationPromptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePromptTemplate":
            suggest = "base_prompt_template"
        elif key == "inferenceConfigurations":
            suggest = "inference_configurations"
        elif key == "parserMode":
            suggest = "parser_mode"
        elif key == "promptCreationMode":
            suggest = "prompt_creation_mode"
        elif key == "promptState":
            suggest = "prompt_state"
        elif key == "promptType":
            suggest = "prompt_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfigurationPromptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_prompt_template: str,
                 inference_configurations: Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration'],
                 parser_mode: str,
                 prompt_creation_mode: str,
                 prompt_state: str,
                 prompt_type: str):
        """
        :param str base_prompt_template: prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        :param Sequence['AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfigurationArgs'] inference_configurations: Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        :param str parser_mode: Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param str prompt_creation_mode: Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        :param str prompt_state: Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        :param str prompt_type: Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        pulumi.set(__self__, "inference_configurations", inference_configurations)
        pulumi.set(__self__, "parser_mode", parser_mode)
        pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        pulumi.set(__self__, "prompt_state", prompt_state)
        pulumi.set(__self__, "prompt_type", prompt_type)

    @property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> str:
        """
        prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        """
        return pulumi.get(self, "base_prompt_template")

    @property
    @pulumi.getter(name="inferenceConfigurations")
    def inference_configurations(self) -> Sequence['outputs.AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration']:
        """
        Inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `prompt_type`. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). See `inference_configuration` Block for details.
        """
        return pulumi.get(self, "inference_configurations")

    @property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> str:
        """
        Whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `prompt_type`. If you set the argument as `OVERRIDDEN`, the `override_lambda` argument in the `prompt_override_configuration` block must be specified with the ARN of a Lambda function. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "parser_mode")

    @property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> str:
        """
        Whether to override the default prompt template for this `prompt_type`. Set this argument to `OVERRIDDEN` to use the prompt that you provide in the `base_prompt_template`. If you leave it as `DEFAULT`, the agent uses a default prompt template. Valid values: `DEFAULT`, `OVERRIDDEN`.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> str:
        """
        Whether to allow the agent to carry out the step specified in the `prompt_type`. If you set this argument to `DISABLED`, the agent skips that step. Valid Values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "prompt_state")

    @property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> str:
        """
        Step in the agent sequence that this prompt configuration applies to. Valid values: `PRE_PROCESSING`, `ORCHESTRATION`, `POST_PROCESSING`, `KNOWLEDGE_BASE_RESPONSE_GENERATION`.
        """
        return pulumi.get(self, "prompt_type")


@pulumi.output_type
class AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxLength":
            suggest = "max_length"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topK":
            suggest = "top_k"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAgentPromptOverrideConfigurationPromptConfigurationInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_length: int,
                 stop_sequences: Sequence[str],
                 temperature: float,
                 top_k: int,
                 top_p: float):
        """
        :param int max_length: Maximum number of tokens to allow in the generated response.
        :param Sequence[str] stop_sequences: List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        :param float temperature: Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        :param int top_k: Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        :param float top_p: Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "stop_sequences", stop_sequences)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_k", top_k)
        pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> int:
        """
        Maximum number of tokens to allow in the generated response.
        """
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Sequence[str]:
        """
        List of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        """
        return pulumi.get(self, "stop_sequences")

    @property
    @pulumi.getter
    def temperature(self) -> float:
        """
        Likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        """
        return pulumi.get(self, "temperature")

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> int:
        """
        Number of top most-likely candidates, between 0 and 500, from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_k")

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> float:
        """
        Top percentage of the probability distribution of next tokens, between 0 and 1 (denoting 0% and 100%), from which the model chooses the next token in the sequence.
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class AgentAgentTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AgentDataSourceDataSourceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Configuration":
            suggest = "s3_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 s3_configuration: Optional['outputs.AgentDataSourceDataSourceConfigurationS3Configuration'] = None):
        """
        :param str type: Type of storage for the data source. Valid values: `S3`.
        :param 'AgentDataSourceDataSourceConfigurationS3ConfigurationArgs' s3_configuration: Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of storage for the data source. Valid values: `S3`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional['outputs.AgentDataSourceDataSourceConfigurationS3Configuration']:
        """
        Details about the configuration of the S3 object containing the data source. See `s3_data_source_configuration` block for details.
        """
        return pulumi.get(self, "s3_configuration")


@pulumi.output_type
class AgentDataSourceDataSourceConfigurationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "bucketOwnerAccountId":
            suggest = "bucket_owner_account_id"
        elif key == "inclusionPrefixes":
            suggest = "inclusion_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceDataSourceConfigurationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceDataSourceConfigurationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceDataSourceConfigurationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: str,
                 bucket_owner_account_id: Optional[str] = None,
                 inclusion_prefixes: Optional[Sequence[str]] = None):
        """
        :param str bucket_arn: ARN of the bucket that contains the data source.
        :param str bucket_owner_account_id: Bucket account owner ID for the S3 bucket.
        :param Sequence[str] inclusion_prefixes: List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> str:
        """
        ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[str]:
        """
        Bucket account owner ID for the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        """
        return pulumi.get(self, "inclusion_prefixes")


@pulumi.output_type
class AgentDataSourceServerSideEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceServerSideEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[str] = None):
        """
        :param str kms_key_arn: ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class AgentDataSourceTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingConfiguration":
            suggest = "chunking_configuration"
        elif key == "parsingConfiguration":
            suggest = "parsing_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfiguration'] = None,
                 parsing_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfiguration'] = None):
        """
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationArgs' chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationArgs' parsing_configuration: Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfiguration']:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. See `chunking_configuration` block for details.
        """
        return pulumi.get(self, "chunking_configuration")

    @property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfiguration']:
        """
        Configuration for custom parsing of data source documents. See `parsing_configuration` block for details.
        """
        return pulumi.get(self, "parsing_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingStrategy":
            suggest = "chunking_strategy"
        elif key == "fixedSizeChunkingConfiguration":
            suggest = "fixed_size_chunking_configuration"
        elif key == "hierarchicalChunkingConfiguration":
            suggest = "hierarchical_chunking_configuration"
        elif key == "semanticChunkingConfiguration":
            suggest = "semantic_chunking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_strategy: str,
                 fixed_size_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration'] = None,
                 hierarchical_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration'] = None,
                 semantic_chunking_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration'] = None):
        """
        :param str chunking_strategy: Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfigurationArgs' fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationArgs' hierarchical_chunking_configuration: Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        :param 'AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfigurationArgs' semantic_chunking_configuration: Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> str:
        """
        Option for chunking your source data, either in fixed-sized chunks or as one chunk. Valid values: `FIXED_SIZE`, `HIERARCHICAL`, `SEMANTIC`, `NONE`.
        """
        return pulumi.get(self, "chunking_strategy")

    @property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration']:
        """
        Configurations for when you choose fixed-size chunking. Requires chunking_strategy as `FIXED_SIZE`. See `fixed_size_chunking_configuration` for details.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration']:
        """
        Configurations for when you choose hierarchical chunking. Requires chunking_strategy as `HIERARCHICAL`. See `hierarchical_chunking_configuration` for details.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration']:
        """
        Configurations for when you choose semantic chunking. Requires chunking_strategy as `SEMANTIC`. See `semantic_chunking_configuration` for details.
        """
        return pulumi.get(self, "semantic_chunking_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "overlapPercentage":
            suggest = "overlap_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationFixedSizeChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: int,
                 overlap_percentage: int):
        """
        :param int max_tokens: Maximum number of tokens to include in a chunk.
        :param int overlap_percentage: Percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> int:
        """
        Maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> int:
        """
        Percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelConfigurations":
            suggest = "level_configurations"
        elif key == "overlapTokens":
            suggest = "overlap_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_configurations: Sequence['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration'],
                 overlap_tokens: float):
        """
        :param Sequence['AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfigurationArgs'] level_configurations: Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        :param float overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> Sequence['outputs.AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration']:
        """
        Maximum number of tokens to include in a chunk. Must contain two `level_configurations`. See `level_configurations` for details.
        """
        return pulumi.get(self, "level_configurations")

    @property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> float:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationHierarchicalChunkingConfigurationLevelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: float):
        """
        :param float max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> float:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakpointPercentileThreshold":
            suggest = "breakpoint_percentile_threshold"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "maxToken":
            suggest = "max_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationChunkingConfigurationSemanticChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakpoint_percentile_threshold: float,
                 buffer_size: float,
                 max_token: float):
        """
        :param float breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param float buffer_size: The buffer size.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_token", max_token)

    @property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> float:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> float:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @property
    @pulumi.getter(name="maxToken")
    def max_token(self) -> float:
        return pulumi.get(self, "max_token")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingStrategy":
            suggest = "parsing_strategy"
        elif key == "bedrockFoundationModelConfiguration":
            suggest = "bedrock_foundation_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_strategy: str,
                 bedrock_foundation_model_configuration: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration'] = None):
        """
        :param str parsing_strategy: Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationArgs' bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> str:
        """
        Currently only `BEDROCK_FOUNDATION_MODEL` is supported
        """
        return pulumi.get(self, "parsing_strategy")

    @property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration']:
        """
        Settings for a foundation model used to parse documents in a data source. See `bedrock_foundation_model_configuration` block for details.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "parsingPrompt":
            suggest = "parsing_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: str,
                 parsing_prompt: Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt'] = None):
        """
        :param str model_arn: The ARN of the model used to parse documents
        :param 'AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPromptArgs' parsing_prompt: Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> str:
        """
        The ARN of the model used to parse documents
        """
        return pulumi.get(self, "model_arn")

    @property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional['outputs.AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt']:
        """
        Instructions for interpreting the contents of the document. See `parsing_prompt` block for details.
        """
        return pulumi.get(self, "parsing_prompt")


@pulumi.output_type
class AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingPromptString":
            suggest = "parsing_prompt_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentDataSourceVectorIngestionConfigurationParsingConfigurationBedrockFoundationModelConfigurationParsingPrompt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_prompt_string: str):
        """
        :param str parsing_prompt_string: Instructions for interpreting the contents of the document.
        """
        pulumi.set(__self__, "parsing_prompt_string", parsing_prompt_string)

    @property
    @pulumi.getter(name="parsingPromptString")
    def parsing_prompt_string(self) -> str:
        """
        Instructions for interpreting the contents of the document.
        """
        return pulumi.get(self, "parsing_prompt_string")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vectorKnowledgeBaseConfiguration":
            suggest = "vector_knowledge_base_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 vector_knowledge_base_configuration: Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration'] = None):
        """
        :param str type: Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        :param 'AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfigurationArgs' vector_knowledge_base_configuration: Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of data that the data source is converted into for the knowledge base. Valid Values: `VECTOR`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional['outputs.AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration']:
        """
        Details about the embeddings model that'sused to convert the data source. See `vector_knowledge_base_configuration` block for details.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")


@pulumi.output_type
class AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingModelArn":
            suggest = "embedding_model_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseKnowledgeBaseConfigurationVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_model_arn: str):
        """
        :param str embedding_model_arn: ARN of the model used to create vector embeddings for the knowledge base.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)

    @property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> str:
        """
        ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchServerlessConfiguration":
            suggest = "opensearch_serverless_configuration"
        elif key == "pineconeConfiguration":
            suggest = "pinecone_configuration"
        elif key == "rdsConfiguration":
            suggest = "rds_configuration"
        elif key == "redisEnterpriseCloudConfiguration":
            suggest = "redis_enterprise_cloud_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 opensearch_serverless_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration'] = None,
                 pinecone_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfiguration'] = None,
                 rds_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfiguration'] = None,
                 redis_enterprise_cloud_configuration: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration'] = None):
        """
        :param str type: Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        :param 'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationArgs' opensearch_serverless_configuration: The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationArgs' pinecone_configuration: The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationRdsConfigurationArgs' rds_configuration: Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        :param 'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationArgs' redis_enterprise_cloud_configuration: The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        pulumi.set(__self__, "type", type)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)
        if redis_enterprise_cloud_configuration is not None:
            pulumi.set(__self__, "redis_enterprise_cloud_configuration", redis_enterprise_cloud_configuration)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Vector store service in which the knowledge base is stored. Valid Values: `OPENSEARCH_SERVERLESS`, `PINECONE`, `REDIS_ENTERPRISE_CLOUD`, `RDS`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration']:
        """
        The storage configuration of the knowledge base in Amazon OpenSearch Service. See `opensearch_serverless_configuration` block for details.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfiguration']:
        """
        The storage configuration of the knowledge base in Pinecone. See `pinecone_configuration` block for details.
        """
        return pulumi.get(self, "pinecone_configuration")

    @property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfiguration']:
        """
        Details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup.html). See `rds_configuration` block for details.
        """
        return pulumi.get(self, "rds_configuration")

    @property
    @pulumi.getter(name="redisEnterpriseCloudConfiguration")
    def redis_enterprise_cloud_configuration(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration']:
        """
        The storage configuration of the knowledge base in Redis Enterprise Cloud. See `redis_enterprise_cloud_configuration` block for details.
        """
        return pulumi.get(self, "redis_enterprise_cloud_configuration")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionArn":
            suggest = "collection_arn"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_arn: str,
                 vector_index_name: str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping'] = None):
        """
        :param str collection_arn: ARN of the OpenSearch Service vector store.
        :param str vector_index_name: Name of the vector store.
        :param 'AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> str:
        """
        ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> str:
        """
        Name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationOpensearchServerlessConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[str] = None,
                 text_field: Optional[str] = None,
                 vector_field: Optional[str] = None):
        """
        :param str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationPineconeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: str,
                 credentials_secret_arn: str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping'] = None,
                 namespace: Optional[str] = None):
        """
        :param str connection_string: Endpoint URL for your index management page.
        :param str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param 'AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        :param str namespace: Namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        Endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationPineconeConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[str] = None,
                 text_field: Optional[str] = None):
        """
        :param str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "resourceArn":
            suggest = "resource_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_secret_arn: str,
                 database_name: str,
                 resource_arn: str,
                 table_name: str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping'] = None):
        """
        :param str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param str database_name: Name of your Amazon RDS database.
        :param str resource_arn: ARN of the vector store.
        :param str table_name: Name of the table in the database.
        :param 'AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMappingArgs' field_mapping: Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> str:
        """
        ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping']:
        """
        Names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "primaryKeyField":
            suggest = "primary_key_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRdsConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: str,
                 primary_key_field: str,
                 text_field: str,
                 vector_field: str):
        """
        :param str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param str primary_key_field: Name of the field in which Amazon Bedrock stores the ID for each entry.
        :param str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> str:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> str:
        """
        Name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> str:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> str:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_secret_arn: str,
                 endpoint: str,
                 vector_index_name: str,
                 field_mapping: Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping'] = None):
        """
        :param str credentials_secret_arn: ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        :param str endpoint: Endpoint URL of the Redis Enterprise Cloud database.
        :param str vector_index_name: Name of the vector index.
        :param 'AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMappingArgs' field_mapping: The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if field_mapping is not None:
            pulumi.set(__self__, "field_mapping", field_mapping)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> str:
        """
        ARN of the secret that you created in AWS Secrets Manager that is linked to your Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Endpoint URL of the Redis Enterprise Cloud database.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> str:
        """
        Name of the vector index.
        """
        return pulumi.get(self, "vector_index_name")

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> Optional['outputs.AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping']:
        """
        The names of the fields to which to map information about the vector store. This block supports the following arguments:
        """
        return pulumi.get(self, "field_mapping")


@pulumi.output_type
class AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBaseStorageConfigurationRedisEnterpriseCloudConfigurationFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: Optional[str] = None,
                 text_field: Optional[str] = None,
                 vector_field: Optional[str] = None):
        """
        :param str metadata_field: Name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param str text_field: Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param str vector_field: Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        if metadata_field is not None:
            pulumi.set(__self__, "metadata_field", metadata_field)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[str]:
        """
        Name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class AgentKnowledgeBaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class CustomModelOutputDataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelOutputDataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelOutputDataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelOutputDataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the output data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the output data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class CustomModelTrainingDataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelTrainingDataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelTrainingDataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelTrainingDataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the training data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the training data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelTrainingMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trainingLoss":
            suggest = "training_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelTrainingMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelTrainingMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelTrainingMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 training_loss: float):
        """
        :param float training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> float:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")


@pulumi.output_type
class CustomModelValidationDataConfig(dict):
    def __init__(__self__, *,
                 validators: Optional[Sequence['outputs.CustomModelValidationDataConfigValidator']] = None):
        """
        :param Sequence['CustomModelValidationDataConfigValidatorArgs'] validators: Information about the validators.
        """
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Optional[Sequence['outputs.CustomModelValidationDataConfigValidator']]:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")


@pulumi.output_type
class CustomModelValidationDataConfigValidator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Uri":
            suggest = "s3_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelValidationDataConfigValidator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelValidationDataConfigValidator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelValidationDataConfigValidator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the validation data is stored.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the validation data is stored.
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class CustomModelValidationMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationLoss":
            suggest = "validation_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelValidationMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelValidationMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelValidationMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validation_loss: float):
        """
        :param float validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> float:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")


@pulumi.output_type
class CustomModelVpcConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[str],
                 subnet_ids: Sequence[str]):
        """
        :param Sequence[str] security_group_ids: VPC configuration security group IDs.
        :param Sequence[str] subnet_ids: VPC configuration subnets.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        VPC configuration security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        """
        VPC configuration subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GuardrailContentPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfigs":
            suggest = "filters_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_configs: Optional[Sequence['outputs.GuardrailContentPolicyConfigFiltersConfig']] = None):
        """
        :param Sequence['GuardrailContentPolicyConfigFiltersConfigArgs'] filters_configs: List of content filter configs in content policy. See Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[Sequence['outputs.GuardrailContentPolicyConfigFiltersConfig']]:
        """
        List of content filter configs in content policy. See Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")


@pulumi.output_type
class GuardrailContentPolicyConfigFiltersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputStrength":
            suggest = "input_strength"
        elif key == "outputStrength":
            suggest = "output_strength"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfigFiltersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfigFiltersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfigFiltersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_strength: str,
                 output_strength: str,
                 type: str):
        """
        :param str input_strength: Strength for filters.
        :param str output_strength: Strength for filters.
        :param str type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> str:
        """
        Strength for filters.
        """
        return pulumi.get(self, "input_strength")

    @property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> str:
        """
        Strength for filters.
        """
        return pulumi.get(self, "output_strength")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailContextualGroundingPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfigs":
            suggest = "filters_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContextualGroundingPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_configs: Optional[Sequence['outputs.GuardrailContextualGroundingPolicyConfigFiltersConfig']] = None):
        """
        :param Sequence['GuardrailContextualGroundingPolicyConfigFiltersConfigArgs'] filters_configs: List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        if filters_configs is not None:
            pulumi.set(__self__, "filters_configs", filters_configs)

    @property
    @pulumi.getter(name="filtersConfigs")
    def filters_configs(self) -> Optional[Sequence['outputs.GuardrailContextualGroundingPolicyConfigFiltersConfig']]:
        """
        List of contextual grounding filter configs. See Contextual Grounding Filters Config for more information.
        """
        return pulumi.get(self, "filters_configs")


@pulumi.output_type
class GuardrailContextualGroundingPolicyConfigFiltersConfig(dict):
    def __init__(__self__, *,
                 threshold: float,
                 type: str):
        """
        :param float threshold: The threshold for this filter.
        :param str type: Type of contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of contextual grounding filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "piiEntitiesConfigs":
            suggest = "pii_entities_configs"
        elif key == "regexesConfigs":
            suggest = "regexes_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailSensitiveInformationPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pii_entities_configs: Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig']] = None,
                 regexes_configs: Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigRegexesConfig']] = None):
        """
        :param Sequence['GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfigArgs'] pii_entities_configs: List of entities. See PII Entities Config for more information.
        :param Sequence['GuardrailSensitiveInformationPolicyConfigRegexesConfigArgs'] regexes_configs: List of regex. See Regexes Config for more information.
        """
        if pii_entities_configs is not None:
            pulumi.set(__self__, "pii_entities_configs", pii_entities_configs)
        if regexes_configs is not None:
            pulumi.set(__self__, "regexes_configs", regexes_configs)

    @property
    @pulumi.getter(name="piiEntitiesConfigs")
    def pii_entities_configs(self) -> Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig']]:
        """
        List of entities. See PII Entities Config for more information.
        """
        return pulumi.get(self, "pii_entities_configs")

    @property
    @pulumi.getter(name="regexesConfigs")
    def regexes_configs(self) -> Optional[Sequence['outputs.GuardrailSensitiveInformationPolicyConfigRegexesConfig']]:
        """
        List of regex. See Regexes Config for more information.
        """
        return pulumi.get(self, "regexes_configs")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfigPiiEntitiesConfig(dict):
    def __init__(__self__, *,
                 action: str,
                 type: str):
        """
        :param str action: Options for sensitive information action.
        :param str type: The currently supported PII entities.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The currently supported PII entities.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfigRegexesConfig(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 pattern: str,
                 description: Optional[str] = None):
        """
        :param str action: Options for sensitive information action.
        :param str name: The regex name.
        :param str pattern: The regex pattern.
        :param str description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Options for sensitive information action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GuardrailTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GuardrailTopicPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicsConfigs":
            suggest = "topics_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailTopicPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topics_configs: Optional[Sequence['outputs.GuardrailTopicPolicyConfigTopicsConfig']] = None):
        """
        :param Sequence['GuardrailTopicPolicyConfigTopicsConfigArgs'] topics_configs: List of topic configs in topic policy. See Topics Config for more information.
        """
        if topics_configs is not None:
            pulumi.set(__self__, "topics_configs", topics_configs)

    @property
    @pulumi.getter(name="topicsConfigs")
    def topics_configs(self) -> Optional[Sequence['outputs.GuardrailTopicPolicyConfigTopicsConfig']]:
        """
        List of topic configs in topic policy. See Topics Config for more information.
        """
        return pulumi.get(self, "topics_configs")


@pulumi.output_type
class GuardrailTopicPolicyConfigTopicsConfig(dict):
    def __init__(__self__, *,
                 definition: str,
                 name: str,
                 type: str,
                 examples: Optional[Sequence[str]] = None):
        """
        :param str definition: Definition of topic in topic policy.
        :param str name: Name of topic in topic policy.
        :param str type: Type of topic in a policy.
        :param Sequence[str] examples: List of text examples.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @property
    @pulumi.getter
    def definition(self) -> str:
        """
        Definition of topic in topic policy.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of topic in topic policy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def examples(self) -> Optional[Sequence[str]]:
        """
        List of text examples.
        """
        return pulumi.get(self, "examples")


@pulumi.output_type
class GuardrailWordPolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedWordListsConfigs":
            suggest = "managed_word_lists_configs"
        elif key == "wordsConfigs":
            suggest = "words_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailWordPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_word_lists_configs: Optional[Sequence['outputs.GuardrailWordPolicyConfigManagedWordListsConfig']] = None,
                 words_configs: Optional[Sequence['outputs.GuardrailWordPolicyConfigWordsConfig']] = None):
        """
        :param Sequence['GuardrailWordPolicyConfigManagedWordListsConfigArgs'] managed_word_lists_configs: A config for the list of managed words. See Managed Word Lists Config for more information.
        :param Sequence['GuardrailWordPolicyConfigWordsConfigArgs'] words_configs: List of custom word configs. See Words Config for more information.
        """
        if managed_word_lists_configs is not None:
            pulumi.set(__self__, "managed_word_lists_configs", managed_word_lists_configs)
        if words_configs is not None:
            pulumi.set(__self__, "words_configs", words_configs)

    @property
    @pulumi.getter(name="managedWordListsConfigs")
    def managed_word_lists_configs(self) -> Optional[Sequence['outputs.GuardrailWordPolicyConfigManagedWordListsConfig']]:
        """
        A config for the list of managed words. See Managed Word Lists Config for more information.
        """
        return pulumi.get(self, "managed_word_lists_configs")

    @property
    @pulumi.getter(name="wordsConfigs")
    def words_configs(self) -> Optional[Sequence['outputs.GuardrailWordPolicyConfigWordsConfig']]:
        """
        List of custom word configs. See Words Config for more information.
        """
        return pulumi.get(self, "words_configs")


@pulumi.output_type
class GuardrailWordPolicyConfigManagedWordListsConfig(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Options for managed words.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Options for managed words.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GuardrailWordPolicyConfigWordsConfig(dict):
    def __init__(__self__, *,
                 text: str):
        """
        :param str text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ProvisionedModelThroughputTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class GetAgentAgentVersionsAgentVersionSummaryResult(dict):
    def __init__(__self__, *,
                 agent_name: str,
                 agent_status: str,
                 agent_version: str,
                 created_at: str,
                 description: str,
                 updated_at: str,
                 guardrail_configurations: Optional[Sequence['outputs.GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult']] = None):
        """
        :param str agent_name: Name of agent to which the version belongs.
        :param str agent_status: Status of the agent to which the version belongs.
        :param str agent_version: Version of the agent.
        :param str created_at: Time at which the version was created.
        :param str description: Description of the version of the agent.
               * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        :param str updated_at: Time at which the version was last updated.
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "agent_status", agent_status)
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "updated_at", updated_at)
        if guardrail_configurations is not None:
            pulumi.set(__self__, "guardrail_configurations", guardrail_configurations)

    @property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> str:
        """
        Name of agent to which the version belongs.
        """
        return pulumi.get(self, "agent_name")

    @property
    @pulumi.getter(name="agentStatus")
    def agent_status(self) -> str:
        """
        Status of the agent to which the version belongs.
        """
        return pulumi.get(self, "agent_status")

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> str:
        """
        Version of the agent.
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Time at which the version was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the version of the agent.
        * `GuardrailConfiguration` - Details aout the guardrail associated with the agent. See Guardrail Configuration
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Time at which the version was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="guardrailConfigurations")
    def guardrail_configurations(self) -> Optional[Sequence['outputs.GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult']]:
        return pulumi.get(self, "guardrail_configurations")


@pulumi.output_type
class GetAgentAgentVersionsAgentVersionSummaryGuardrailConfigurationResult(dict):
    def __init__(__self__, *,
                 guardrail_identifier: str,
                 guardrail_version: str):
        """
        :param str guardrail_identifier: Unique identifier of the guardrail.
        :param str guardrail_version: Version of the guardrail.
        """
        pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> str:
        """
        Unique identifier of the guardrail.
        """
        return pulumi.get(self, "guardrail_identifier")

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> str:
        """
        Version of the guardrail.
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class GetCustomModelOutputDataConfigResult(dict):
    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelTrainingDataConfigResult(dict):
    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelTrainingMetricResult(dict):
    def __init__(__self__, *,
                 training_loss: float):
        """
        :param float training_loss: Loss metric associated with the customization job.
        """
        pulumi.set(__self__, "training_loss", training_loss)

    @property
    @pulumi.getter(name="trainingLoss")
    def training_loss(self) -> float:
        """
        Loss metric associated with the customization job.
        """
        return pulumi.get(self, "training_loss")


@pulumi.output_type
class GetCustomModelValidationDataConfigResult(dict):
    def __init__(__self__, *,
                 validators: Sequence['outputs.GetCustomModelValidationDataConfigValidatorResult']):
        """
        :param Sequence['GetCustomModelValidationDataConfigValidatorArgs'] validators: Information about the validators.
        """
        pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def validators(self) -> Sequence['outputs.GetCustomModelValidationDataConfigValidatorResult']:
        """
        Information about the validators.
        """
        return pulumi.get(self, "validators")


@pulumi.output_type
class GetCustomModelValidationDataConfigValidatorResult(dict):
    def __init__(__self__, *,
                 s3_uri: str):
        """
        :param str s3_uri: The S3 URI where the validation data is stored..
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> str:
        """
        The S3 URI where the validation data is stored..
        """
        return pulumi.get(self, "s3_uri")


@pulumi.output_type
class GetCustomModelValidationMetricResult(dict):
    def __init__(__self__, *,
                 validation_loss: float):
        """
        :param float validation_loss: The validation loss associated with the validator.
        """
        pulumi.set(__self__, "validation_loss", validation_loss)

    @property
    @pulumi.getter(name="validationLoss")
    def validation_loss(self) -> float:
        """
        The validation loss associated with the validator.
        """
        return pulumi.get(self, "validation_loss")


@pulumi.output_type
class GetCustomModelsModelSummaryResult(dict):
    def __init__(__self__, *,
                 creation_time: str,
                 model_arn: str,
                 model_name: str):
        """
        :param str creation_time: Creation time of the model.
        :param str model_arn: The ARN of the custom model.
        :param str model_name: The name of the custom model.
        """
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "model_arn", model_arn)
        pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> str:
        """
        Creation time of the model.
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> str:
        """
        The ARN of the custom model.
        """
        return pulumi.get(self, "model_arn")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> str:
        """
        The name of the custom model.
        """
        return pulumi.get(self, "model_name")


