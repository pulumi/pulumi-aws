# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ApplicationAppSourceArgs',
    'ApplicationEnvironmentArgs',
    'ApplicationSslConfigurationArgs',
    'CustomLayerCloudwatchConfigurationArgs',
    'CustomLayerCloudwatchConfigurationLogStreamArgs',
    'CustomLayerEbsVolumeArgs',
    'CustomLayerLoadBasedAutoScalingArgs',
    'CustomLayerLoadBasedAutoScalingDownscalingArgs',
    'CustomLayerLoadBasedAutoScalingUpscalingArgs',
    'EcsClusterLayerCloudwatchConfigurationArgs',
    'EcsClusterLayerCloudwatchConfigurationLogStreamArgs',
    'EcsClusterLayerEbsVolumeArgs',
    'EcsClusterLayerLoadBasedAutoScalingArgs',
    'EcsClusterLayerLoadBasedAutoScalingDownscalingArgs',
    'EcsClusterLayerLoadBasedAutoScalingUpscalingArgs',
    'GangliaLayerCloudwatchConfigurationArgs',
    'GangliaLayerCloudwatchConfigurationLogStreamArgs',
    'GangliaLayerEbsVolumeArgs',
    'GangliaLayerLoadBasedAutoScalingArgs',
    'GangliaLayerLoadBasedAutoScalingDownscalingArgs',
    'GangliaLayerLoadBasedAutoScalingUpscalingArgs',
    'HaproxyLayerCloudwatchConfigurationArgs',
    'HaproxyLayerCloudwatchConfigurationLogStreamArgs',
    'HaproxyLayerEbsVolumeArgs',
    'HaproxyLayerLoadBasedAutoScalingArgs',
    'HaproxyLayerLoadBasedAutoScalingDownscalingArgs',
    'HaproxyLayerLoadBasedAutoScalingUpscalingArgs',
    'InstanceEbsBlockDeviceArgs',
    'InstanceEphemeralBlockDeviceArgs',
    'InstanceRootBlockDeviceArgs',
    'JavaAppLayerCloudwatchConfigurationArgs',
    'JavaAppLayerCloudwatchConfigurationLogStreamArgs',
    'JavaAppLayerEbsVolumeArgs',
    'JavaAppLayerLoadBasedAutoScalingArgs',
    'JavaAppLayerLoadBasedAutoScalingDownscalingArgs',
    'JavaAppLayerLoadBasedAutoScalingUpscalingArgs',
    'MemcachedLayerCloudwatchConfigurationArgs',
    'MemcachedLayerCloudwatchConfigurationLogStreamArgs',
    'MemcachedLayerEbsVolumeArgs',
    'MemcachedLayerLoadBasedAutoScalingArgs',
    'MemcachedLayerLoadBasedAutoScalingDownscalingArgs',
    'MemcachedLayerLoadBasedAutoScalingUpscalingArgs',
    'MysqlLayerCloudwatchConfigurationArgs',
    'MysqlLayerCloudwatchConfigurationLogStreamArgs',
    'MysqlLayerEbsVolumeArgs',
    'MysqlLayerLoadBasedAutoScalingArgs',
    'MysqlLayerLoadBasedAutoScalingDownscalingArgs',
    'MysqlLayerLoadBasedAutoScalingUpscalingArgs',
    'NodejsAppLayerCloudwatchConfigurationArgs',
    'NodejsAppLayerCloudwatchConfigurationLogStreamArgs',
    'NodejsAppLayerEbsVolumeArgs',
    'NodejsAppLayerLoadBasedAutoScalingArgs',
    'NodejsAppLayerLoadBasedAutoScalingDownscalingArgs',
    'NodejsAppLayerLoadBasedAutoScalingUpscalingArgs',
    'PhpAppLayerCloudwatchConfigurationArgs',
    'PhpAppLayerCloudwatchConfigurationLogStreamArgs',
    'PhpAppLayerEbsVolumeArgs',
    'PhpAppLayerLoadBasedAutoScalingArgs',
    'PhpAppLayerLoadBasedAutoScalingDownscalingArgs',
    'PhpAppLayerLoadBasedAutoScalingUpscalingArgs',
    'RailsAppLayerCloudwatchConfigurationArgs',
    'RailsAppLayerCloudwatchConfigurationLogStreamArgs',
    'RailsAppLayerEbsVolumeArgs',
    'RailsAppLayerLoadBasedAutoScalingArgs',
    'RailsAppLayerLoadBasedAutoScalingDownscalingArgs',
    'RailsAppLayerLoadBasedAutoScalingUpscalingArgs',
    'StackCustomCookbooksSourceArgs',
    'StaticWebLayerCloudwatchConfigurationArgs',
    'StaticWebLayerCloudwatchConfigurationLogStreamArgs',
    'StaticWebLayerEbsVolumeArgs',
    'StaticWebLayerLoadBasedAutoScalingArgs',
    'StaticWebLayerLoadBasedAutoScalingDownscalingArgs',
    'StaticWebLayerLoadBasedAutoScalingUpscalingArgs',
]

@pulumi.input_type
class ApplicationAppSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[str]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of source to use. For example, "archive".
        :param pulumi.Input[str] password: Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        :param pulumi.Input[str] revision: For sources that are version-aware, the revision to use.
        :param pulumi.Input[str] ssh_key: SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        :param pulumi.Input[str] url: The URL where the app resource can be found.
        :param pulumi.Input[str] username: Username to use when authenticating to the source.
        """
        ApplicationAppSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            password=password,
            revision=revision,
            ssh_key=ssh_key,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             revision: Optional[pulumi.Input[str]] = None,
             ssh_key: Optional[pulumi.Input[str]] = None,
             url: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if ssh_key is None and 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']

        _setter("type", type)
        if password is not None:
            _setter("password", password)
        if revision is not None:
            _setter("revision", revision)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of source to use. For example, "archive".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[str]]:
        """
        For sources that are version-aware, the revision to use.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL where the app resource can be found.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to use when authenticating to the source.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ApplicationEnvironmentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 secure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] key: Variable name.
        :param pulumi.Input[str] value: Variable value.
        :param pulumi.Input[bool] secure: Set visibility of the variable value to `true` or `false`.
        """
        ApplicationEnvironmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
            secure=secure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             secure: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)
        if secure is not None:
            _setter("secure", secure)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Variable name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        Set visibility of the variable value to `true` or `false`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)


@pulumi.input_type
class ApplicationSslConfigurationArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 chain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate: The contents of the certificate's domain.crt file.
        :param pulumi.Input[str] private_key: The private key; the contents of the certificate's domain.key file.
        :param pulumi.Input[str] chain: Can be used to specify an intermediate certificate authority key or client authentication.
        """
        ApplicationSslConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            private_key=private_key,
            chain=chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             chain: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate is None:
            raise TypeError("Missing 'certificate' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")

        _setter("certificate", certificate)
        _setter("private_key", private_key)
        if chain is not None:
            _setter("chain", chain)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The contents of the certificate's domain.crt file.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        The private key; the contents of the certificate's domain.key file.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def chain(self) -> Optional[pulumi.Input[str]]:
        """
        Can be used to specify an intermediate certificate authority key or client authentication.
        """
        return pulumi.get(self, "chain")

    @chain.setter
    def chain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chain", value)


@pulumi.input_type
class CustomLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['CustomLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CustomLayerCloudwatchConfigurationLogStreamArgs']]] log_streams: A block the specifies how an opsworks logs look like. See Log Streams.
        """
        CustomLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['CustomLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomLayerCloudwatchConfigurationLogStreamArgs']]]]:
        """
        A block the specifies how an opsworks logs look like. See Log Streams.
        """
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class CustomLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file: Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
        :param pulumi.Input[str] log_group_name: Specifies the destination log group. A log group is created automatically if it doesn't already exist.
        :param pulumi.Input[int] batch_count: Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
        :param pulumi.Input[int] batch_size: Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
        :param pulumi.Input[int] buffer_duration: Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
        :param pulumi.Input[str] datetime_format: Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
        :param pulumi.Input[str] encoding: Specifies the encoding of the log file so that the file can be read correctly. The default is `utf_8`.
        :param pulumi.Input[str] file_fingerprint_lines: Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
        :param pulumi.Input[str] initial_position: Specifies where to start to read data (`start_of_file` or `end_of_file`). The default is `start_of_file`.
        :param pulumi.Input[str] multiline_start_pattern: Specifies the pattern for identifying the start of a log message.
        :param pulumi.Input[str] time_zone: Specifies the time zone of log event time stamps.
        """
        CustomLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        """
        Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*).
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        """
        Specifies the destination log group. A log group is created automatically if it doesn't already exist.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the max number of log events in a batch, up to `10000`. The default value is `1000`.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum size of log events in a batch, in bytes, up to `1048576` bytes. The default value is `32768` bytes.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the time duration for the batching of log events. The minimum value is `5000` and default value is `5000`.
        """
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies how the timestamp is extracted from logs. For more information, see the CloudWatch Logs Agent Reference (https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
        """
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the encoding of the log file so that the file can be read correctly. The default is `utf_8`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as `1`, `2-5`. The default value is `1`.
        """
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where to start to read data (`start_of_file` or `end_of_file`). The default is `start_of_file`.
        """
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the pattern for identifying the start of a log message.
        """
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time zone of log event time stamps.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class CustomLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[bool] encrypted: Encrypt the volume.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        CustomLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Encrypt the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CustomLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        """
        :param pulumi.Input['CustomLayerLoadBasedAutoScalingDownscalingArgs'] downscaling: The downscaling settings, as defined below, used for load-based autoscaling
        :param pulumi.Input[bool] enable: Whether load-based auto scaling is enabled for the layer.
        :param pulumi.Input['CustomLayerLoadBasedAutoScalingUpscalingArgs'] upscaling: The upscaling settings, as defined below, used for load-based autoscaling
        """
        CustomLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingDownscalingArgs']]:
        """
        The downscaling settings, as defined below, used for load-based autoscaling
        """
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether load-based auto scaling is enabled for the layer.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingUpscalingArgs']]:
        """
        The upscaling settings, as defined below, used for load-based autoscaling
        """
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['CustomLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class CustomLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alarms: Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
        :param pulumi.Input[float] cpu_threshold: The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        :param pulumi.Input[int] ignore_metrics_time: The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
        :param pulumi.Input[int] instance_count: The number of instances to add or remove when the load exceeds a threshold.
        :param pulumi.Input[float] load_threshold: The load threshold. A value of -1 disables the threshold.
        :param pulumi.Input[float] memory_threshold: The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        :param pulumi.Input[int] thresholds_wait_time: The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        """
        CustomLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
        """
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
        """
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of instances to add or remove when the load exceeds a threshold.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The load threshold. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        """
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class CustomLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alarms: Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
        :param pulumi.Input[float] cpu_threshold: The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        :param pulumi.Input[int] ignore_metrics_time: The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
        :param pulumi.Input[int] instance_count: The number of instances to add or remove when the load exceeds a threshold.
        :param pulumi.Input[float] load_threshold: The load threshold. A value of -1 disables the threshold.
        :param pulumi.Input[float] memory_threshold: The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        :param pulumi.Input[int] thresholds_wait_time: The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        """
        CustomLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack.
        """
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events.
        """
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of instances to add or remove when the load exceeds a threshold.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The load threshold. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        """
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        """
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class EcsClusterLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['EcsClusterLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        EcsClusterLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['EcsClusterLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EcsClusterLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EcsClusterLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class EcsClusterLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        EcsClusterLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class EcsClusterLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        EcsClusterLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EcsClusterLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        EcsClusterLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['EcsClusterLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class EcsClusterLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        EcsClusterLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class EcsClusterLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        EcsClusterLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class GangliaLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['GangliaLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        GangliaLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['GangliaLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GangliaLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GangliaLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class GangliaLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        GangliaLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class GangliaLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        GangliaLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GangliaLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        GangliaLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['GangliaLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class GangliaLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        GangliaLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class GangliaLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        GangliaLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class HaproxyLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['HaproxyLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        HaproxyLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['HaproxyLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HaproxyLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HaproxyLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class HaproxyLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        HaproxyLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class HaproxyLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        HaproxyLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class HaproxyLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        HaproxyLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['HaproxyLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class HaproxyLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        HaproxyLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class HaproxyLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        HaproxyLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class InstanceEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        InstanceEbsBlockDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            delete_on_termination=delete_on_termination,
            iops=iops,
            snapshot_id=snapshot_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[pulumi.Input[str]] = None,
             delete_on_termination: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             volume_size: Optional[pulumi.Input[int]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("device_name", device_name)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if iops is not None:
            _setter("iops", iops)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class InstanceEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        InstanceEphemeralBlockDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[pulumi.Input[str]] = None,
             virtual_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_name is None and 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if device_name is None:
            raise TypeError("Missing 'device_name' argument")
        if virtual_name is None and 'virtualName' in kwargs:
            virtual_name = kwargs['virtualName']
        if virtual_name is None:
            raise TypeError("Missing 'virtual_name' argument")

        _setter("device_name", device_name)
        _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class InstanceRootBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        InstanceRootBlockDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            iops=iops,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             volume_size: Optional[pulumi.Input[int]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_on_termination is None and 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if volume_size is None and 'volumeSize' in kwargs:
            volume_size = kwargs['volumeSize']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if iops is not None:
            _setter("iops", iops)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class JavaAppLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['JavaAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        JavaAppLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['JavaAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaAppLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaAppLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class JavaAppLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        JavaAppLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class JavaAppLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        JavaAppLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class JavaAppLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        JavaAppLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['JavaAppLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class JavaAppLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        JavaAppLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class JavaAppLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        JavaAppLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class MemcachedLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['MemcachedLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        MemcachedLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['MemcachedLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MemcachedLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MemcachedLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class MemcachedLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        MemcachedLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class MemcachedLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        MemcachedLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MemcachedLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        MemcachedLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['MemcachedLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class MemcachedLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        MemcachedLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class MemcachedLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        MemcachedLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class MysqlLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['MysqlLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        MysqlLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['MysqlLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MysqlLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MysqlLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class MysqlLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        MysqlLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class MysqlLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        MysqlLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MysqlLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        MysqlLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['MysqlLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class MysqlLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        MysqlLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class MysqlLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        MysqlLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class NodejsAppLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['NodejsAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        NodejsAppLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['NodejsAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodejsAppLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodejsAppLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class NodejsAppLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        NodejsAppLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class NodejsAppLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        NodejsAppLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NodejsAppLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        NodejsAppLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['NodejsAppLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class NodejsAppLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        NodejsAppLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class NodejsAppLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        NodejsAppLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class PhpAppLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['PhpAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        PhpAppLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['PhpAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PhpAppLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PhpAppLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class PhpAppLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        PhpAppLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class PhpAppLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        PhpAppLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PhpAppLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        PhpAppLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['PhpAppLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class PhpAppLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        PhpAppLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class PhpAppLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        PhpAppLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class RailsAppLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['RailsAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        RailsAppLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['RailsAppLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RailsAppLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RailsAppLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class RailsAppLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        RailsAppLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class RailsAppLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        RailsAppLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RailsAppLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        RailsAppLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['RailsAppLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class RailsAppLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        RailsAppLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class RailsAppLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        RailsAppLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class StackCustomCookbooksSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 url: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[str]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of source to use. For example, "archive".
        :param pulumi.Input[str] url: The URL where the cookbooks resource can be found.
        :param pulumi.Input[str] password: Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
        :param pulumi.Input[str] revision: For sources that are version-aware, the revision to use.
        :param pulumi.Input[str] ssh_key: SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        :param pulumi.Input[str] username: Username to use when authenticating to the source.
        """
        StackCustomCookbooksSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            url=url,
            password=password,
            revision=revision,
            ssh_key=ssh_key,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             url: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             revision: Optional[pulumi.Input[str]] = None,
             ssh_key: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if ssh_key is None and 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']

        _setter("type", type)
        _setter("url", url)
        if password is not None:
            _setter("password", password)
        if revision is not None:
            _setter("revision", revision)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of source to use. For example, "archive".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL where the cookbooks resource can be found.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[str]]:
        """
        For sources that are version-aware, the revision to use.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration.
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to use when authenticating to the source.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class StaticWebLayerCloudwatchConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['StaticWebLayerCloudwatchConfigurationLogStreamArgs']]]] = None):
        StaticWebLayerCloudwatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            log_streams=log_streams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             log_streams: Optional[pulumi.Input[Sequence[pulumi.Input['StaticWebLayerCloudwatchConfigurationLogStreamArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_streams is None and 'logStreams' in kwargs:
            log_streams = kwargs['logStreams']

        if enabled is not None:
            _setter("enabled", enabled)
        if log_streams is not None:
            _setter("log_streams", log_streams)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StaticWebLayerCloudwatchConfigurationLogStreamArgs']]]]:
        return pulumi.get(self, "log_streams")

    @log_streams.setter
    def log_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StaticWebLayerCloudwatchConfigurationLogStreamArgs']]]]):
        pulumi.set(self, "log_streams", value)


@pulumi.input_type
class StaticWebLayerCloudwatchConfigurationLogStreamArgs:
    def __init__(__self__, *,
                 file: pulumi.Input[str],
                 log_group_name: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_duration: Optional[pulumi.Input[int]] = None,
                 datetime_format: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
                 initial_position: Optional[pulumi.Input[str]] = None,
                 multiline_start_pattern: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        StaticWebLayerCloudwatchConfigurationLogStreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            log_group_name=log_group_name,
            batch_count=batch_count,
            batch_size=batch_size,
            buffer_duration=buffer_duration,
            datetime_format=datetime_format,
            encoding=encoding,
            file_fingerprint_lines=file_fingerprint_lines,
            initial_position=initial_position,
            multiline_start_pattern=multiline_start_pattern,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input[str]] = None,
             log_group_name: Optional[pulumi.Input[str]] = None,
             batch_count: Optional[pulumi.Input[int]] = None,
             batch_size: Optional[pulumi.Input[int]] = None,
             buffer_duration: Optional[pulumi.Input[int]] = None,
             datetime_format: Optional[pulumi.Input[str]] = None,
             encoding: Optional[pulumi.Input[str]] = None,
             file_fingerprint_lines: Optional[pulumi.Input[str]] = None,
             initial_position: Optional[pulumi.Input[str]] = None,
             multiline_start_pattern: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file is None:
            raise TypeError("Missing 'file' argument")
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if batch_count is None and 'batchCount' in kwargs:
            batch_count = kwargs['batchCount']
        if batch_size is None and 'batchSize' in kwargs:
            batch_size = kwargs['batchSize']
        if buffer_duration is None and 'bufferDuration' in kwargs:
            buffer_duration = kwargs['bufferDuration']
        if datetime_format is None and 'datetimeFormat' in kwargs:
            datetime_format = kwargs['datetimeFormat']
        if file_fingerprint_lines is None and 'fileFingerprintLines' in kwargs:
            file_fingerprint_lines = kwargs['fileFingerprintLines']
        if initial_position is None and 'initialPosition' in kwargs:
            initial_position = kwargs['initialPosition']
        if multiline_start_pattern is None and 'multilineStartPattern' in kwargs:
            multiline_start_pattern = kwargs['multilineStartPattern']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("file", file)
        _setter("log_group_name", log_group_name)
        if batch_count is not None:
            _setter("batch_count", batch_count)
        if batch_size is not None:
            _setter("batch_size", batch_size)
        if buffer_duration is not None:
            _setter("buffer_duration", buffer_duration)
        if datetime_format is not None:
            _setter("datetime_format", datetime_format)
        if encoding is not None:
            _setter("encoding", encoding)
        if file_fingerprint_lines is not None:
            _setter("file_fingerprint_lines", file_fingerprint_lines)
        if initial_position is not None:
            _setter("initial_position", initial_position)
        if multiline_start_pattern is not None:
            _setter("multiline_start_pattern", multiline_start_pattern)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def file(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: pulumi.Input[str]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferDuration")
    def buffer_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "buffer_duration")

    @buffer_duration.setter
    def buffer_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_duration", value)

    @property
    @pulumi.getter(name="datetimeFormat")
    def datetime_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datetime_format")

    @datetime_format.setter
    def datetime_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_format", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fileFingerprintLines")
    def file_fingerprint_lines(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_fingerprint_lines")

    @file_fingerprint_lines.setter
    def file_fingerprint_lines(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_fingerprint_lines", value)

    @property
    @pulumi.getter(name="initialPosition")
    def initial_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "initial_position")

    @initial_position.setter
    def initial_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_position", value)

    @property
    @pulumi.getter(name="multilineStartPattern")
    def multiline_start_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multiline_start_pattern")

    @multiline_start_pattern.setter
    def multiline_start_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multiline_start_pattern", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class StaticWebLayerEbsVolumeArgs:
    def __init__(__self__, *,
                 mount_point: pulumi.Input[str],
                 number_of_disks: pulumi.Input[int],
                 size: pulumi.Input[int],
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 raid_level: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mount_point: The path to mount the EBS volume on the layer's instances.
        :param pulumi.Input[int] number_of_disks: The number of disks to use for the EBS volume.
        :param pulumi.Input[int] size: The size of the volume in gigabytes.
        :param pulumi.Input[int] iops: For PIOPS volumes, the IOPS per disk.
        :param pulumi.Input[str] raid_level: The RAID level to use for the volume.
        :param pulumi.Input[str] type: The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        StaticWebLayerEbsVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            size=size,
            encrypted=encrypted,
            iops=iops,
            raid_level=raid_level,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[pulumi.Input[str]] = None,
             number_of_disks: Optional[pulumi.Input[int]] = None,
             size: Optional[pulumi.Input[int]] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             raid_level: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if number_of_disks is None and 'numberOfDisks' in kwargs:
            number_of_disks = kwargs['numberOfDisks']
        if number_of_disks is None:
            raise TypeError("Missing 'number_of_disks' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if raid_level is None and 'raidLevel' in kwargs:
            raid_level = kwargs['raidLevel']

        _setter("mount_point", mount_point)
        _setter("number_of_disks", number_of_disks)
        _setter("size", size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> pulumi.Input[str]:
        """
        The path to mount the EBS volume on the layer's instances.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_point", value)

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> pulumi.Input[int]:
        """
        The number of disks to use for the EBS volume.
        """
        return pulumi.get(self, "number_of_disks")

    @number_of_disks.setter
    def number_of_disks(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_disks", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        For PIOPS volumes, the IOPS per disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[pulumi.Input[str]]:
        """
        The RAID level to use for the volume.
        """
        return pulumi.get(self, "raid_level")

    @raid_level.setter
    def raid_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raid_level", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume to create. This may be `standard` (the default), `io1` or `gp2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class StaticWebLayerLoadBasedAutoScalingArgs:
    def __init__(__self__, *,
                 downscaling: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingDownscalingArgs']] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 upscaling: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingUpscalingArgs']] = None):
        StaticWebLayerLoadBasedAutoScalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            downscaling=downscaling,
            enable=enable,
            upscaling=upscaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             downscaling: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingDownscalingArgs']] = None,
             enable: Optional[pulumi.Input[bool]] = None,
             upscaling: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingUpscalingArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if downscaling is not None:
            _setter("downscaling", downscaling)
        if enable is not None:
            _setter("enable", enable)
        if upscaling is not None:
            _setter("upscaling", upscaling)

    @property
    @pulumi.getter
    def downscaling(self) -> Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingDownscalingArgs']]:
        return pulumi.get(self, "downscaling")

    @downscaling.setter
    def downscaling(self, value: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingDownscalingArgs']]):
        pulumi.set(self, "downscaling", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def upscaling(self) -> Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingUpscalingArgs']]:
        return pulumi.get(self, "upscaling")

    @upscaling.setter
    def upscaling(self, value: Optional[pulumi.Input['StaticWebLayerLoadBasedAutoScalingUpscalingArgs']]):
        pulumi.set(self, "upscaling", value)


@pulumi.input_type
class StaticWebLayerLoadBasedAutoScalingDownscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        StaticWebLayerLoadBasedAutoScalingDownscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


@pulumi.input_type
class StaticWebLayerLoadBasedAutoScalingUpscalingArgs:
    def __init__(__self__, *,
                 alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cpu_threshold: Optional[pulumi.Input[float]] = None,
                 ignore_metrics_time: Optional[pulumi.Input[int]] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 load_threshold: Optional[pulumi.Input[float]] = None,
                 memory_threshold: Optional[pulumi.Input[float]] = None,
                 thresholds_wait_time: Optional[pulumi.Input[int]] = None):
        StaticWebLayerLoadBasedAutoScalingUpscalingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarms=alarms,
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cpu_threshold: Optional[pulumi.Input[float]] = None,
             ignore_metrics_time: Optional[pulumi.Input[int]] = None,
             instance_count: Optional[pulumi.Input[int]] = None,
             load_threshold: Optional[pulumi.Input[float]] = None,
             memory_threshold: Optional[pulumi.Input[float]] = None,
             thresholds_wait_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_threshold is None and 'cpuThreshold' in kwargs:
            cpu_threshold = kwargs['cpuThreshold']
        if ignore_metrics_time is None and 'ignoreMetricsTime' in kwargs:
            ignore_metrics_time = kwargs['ignoreMetricsTime']
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if load_threshold is None and 'loadThreshold' in kwargs:
            load_threshold = kwargs['loadThreshold']
        if memory_threshold is None and 'memoryThreshold' in kwargs:
            memory_threshold = kwargs['memoryThreshold']
        if thresholds_wait_time is None and 'thresholdsWaitTime' in kwargs:
            thresholds_wait_time = kwargs['thresholdsWaitTime']

        if alarms is not None:
            _setter("alarms", alarms)
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarms", value)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ignore_metrics_time")

    @ignore_metrics_time.setter
    def ignore_metrics_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ignore_metrics_time", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "load_threshold")

    @load_threshold.setter
    def load_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "load_threshold", value)

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold")

    @memory_threshold.setter
    def memory_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold", value)

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "thresholds_wait_time")

    @thresholds_wait_time.setter
    def thresholds_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thresholds_wait_time", value)


