# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BudgetActionActionThresholdArgs',
    'BudgetActionActionThresholdArgsDict',
    'BudgetActionDefinitionArgs',
    'BudgetActionDefinitionArgsDict',
    'BudgetActionDefinitionIamActionDefinitionArgs',
    'BudgetActionDefinitionIamActionDefinitionArgsDict',
    'BudgetActionDefinitionScpActionDefinitionArgs',
    'BudgetActionDefinitionScpActionDefinitionArgsDict',
    'BudgetActionDefinitionSsmActionDefinitionArgs',
    'BudgetActionDefinitionSsmActionDefinitionArgsDict',
    'BudgetActionSubscriberArgs',
    'BudgetActionSubscriberArgsDict',
    'BudgetAutoAdjustDataArgs',
    'BudgetAutoAdjustDataArgsDict',
    'BudgetAutoAdjustDataHistoricalOptionsArgs',
    'BudgetAutoAdjustDataHistoricalOptionsArgsDict',
    'BudgetCostFilterArgs',
    'BudgetCostFilterArgsDict',
    'BudgetCostTypesArgs',
    'BudgetCostTypesArgsDict',
    'BudgetNotificationArgs',
    'BudgetNotificationArgsDict',
    'BudgetPlannedLimitArgs',
    'BudgetPlannedLimitArgsDict',
]

MYPY = False

if not MYPY:
    class BudgetActionActionThresholdArgsDict(TypedDict):
        action_threshold_type: pulumi.Input[builtins.str]
        """
        The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        """
        action_threshold_value: pulumi.Input[builtins.float]
        """
        The threshold of a notification.
        """
elif False:
    BudgetActionActionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionActionThresholdArgs:
    def __init__(__self__, *,
                 action_threshold_type: pulumi.Input[builtins.str],
                 action_threshold_value: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.str] action_threshold_type: The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        :param pulumi.Input[builtins.float] action_threshold_value: The threshold of a notification.
        """
        pulumi.set(__self__, "action_threshold_type", action_threshold_type)
        pulumi.set(__self__, "action_threshold_value", action_threshold_value)

    @property
    @pulumi.getter(name="actionThresholdType")
    def action_threshold_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "action_threshold_type")

    @action_threshold_type.setter
    def action_threshold_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action_threshold_type", value)

    @property
    @pulumi.getter(name="actionThresholdValue")
    def action_threshold_value(self) -> pulumi.Input[builtins.float]:
        """
        The threshold of a notification.
        """
        return pulumi.get(self, "action_threshold_value")

    @action_threshold_value.setter
    def action_threshold_value(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "action_threshold_value", value)


if not MYPY:
    class BudgetActionDefinitionArgsDict(TypedDict):
        iam_action_definition: NotRequired[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgsDict']]
        """
        The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        """
        scp_action_definition: NotRequired[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgsDict']]
        """
        The service control policies (SCPs) action definition details. See SCP Action Definition.
        """
        ssm_action_definition: NotRequired[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgsDict']]
        """
        The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
elif False:
    BudgetActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionDefinitionArgs:
    def __init__(__self__, *,
                 iam_action_definition: Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']] = None,
                 scp_action_definition: Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']] = None,
                 ssm_action_definition: Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']] = None):
        """
        :param pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs'] iam_action_definition: The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        :param pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs'] scp_action_definition: The service control policies (SCPs) action definition details. See SCP Action Definition.
        :param pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs'] ssm_action_definition: The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        if iam_action_definition is not None:
            pulumi.set(__self__, "iam_action_definition", iam_action_definition)
        if scp_action_definition is not None:
            pulumi.set(__self__, "scp_action_definition", scp_action_definition)
        if ssm_action_definition is not None:
            pulumi.set(__self__, "ssm_action_definition", ssm_action_definition)

    @property
    @pulumi.getter(name="iamActionDefinition")
    def iam_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']]:
        """
        The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        """
        return pulumi.get(self, "iam_action_definition")

    @iam_action_definition.setter
    def iam_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']]):
        pulumi.set(self, "iam_action_definition", value)

    @property
    @pulumi.getter(name="scpActionDefinition")
    def scp_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']]:
        """
        The service control policies (SCPs) action definition details. See SCP Action Definition.
        """
        return pulumi.get(self, "scp_action_definition")

    @scp_action_definition.setter
    def scp_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']]):
        pulumi.set(self, "scp_action_definition", value)

    @property
    @pulumi.getter(name="ssmActionDefinition")
    def ssm_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']]:
        """
        The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        return pulumi.get(self, "ssm_action_definition")

    @ssm_action_definition.setter
    def ssm_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']]):
        pulumi.set(self, "ssm_action_definition", value)


if not MYPY:
    class BudgetActionDefinitionIamActionDefinitionArgsDict(TypedDict):
        policy_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the policy to be attached.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of groups to be attached. There must be at least one group.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of roles to be attached. There must be at least one role.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of users to be attached. There must be at least one user.
        """
elif False:
    BudgetActionDefinitionIamActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionDefinitionIamActionDefinitionArgs:
    def __init__(__self__, *,
                 policy_arn: pulumi.Input[builtins.str],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] policy_arn: The Amazon Resource Name (ARN) of the policy to be attached.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] groups: A list of groups to be attached. There must be at least one group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] roles: A list of roles to be attached. There must be at least one role.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] users: A list of users to be attached. There must be at least one user.
        """
        pulumi.set(__self__, "policy_arn", policy_arn)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="policyArn")
    def policy_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the policy to be attached.
        """
        return pulumi.get(self, "policy_arn")

    @policy_arn.setter
    def policy_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "policy_arn", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of groups to be attached. There must be at least one group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of roles to be attached. There must be at least one role.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of users to be attached. There must be at least one user.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class BudgetActionDefinitionScpActionDefinitionArgsDict(TypedDict):
        policy_id: pulumi.Input[builtins.str]
        """
        The policy ID attached.
        """
        target_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of target IDs.
        """
elif False:
    BudgetActionDefinitionScpActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionDefinitionScpActionDefinitionArgs:
    def __init__(__self__, *,
                 policy_id: pulumi.Input[builtins.str],
                 target_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] policy_id: The policy ID attached.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_ids: A list of target IDs.
        """
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Input[builtins.str]:
        """
        The policy ID attached.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of target IDs.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "target_ids", value)


if not MYPY:
    class BudgetActionDefinitionSsmActionDefinitionArgsDict(TypedDict):
        action_sub_type: pulumi.Input[builtins.str]
        """
        The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        """
        instance_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The EC2 and RDS instance IDs.
        """
        region: pulumi.Input[builtins.str]
        """
        The Region to run the SSM document.
        """
elif False:
    BudgetActionDefinitionSsmActionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionDefinitionSsmActionDefinitionArgs:
    def __init__(__self__, *,
                 action_sub_type: pulumi.Input[builtins.str],
                 instance_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 region: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] action_sub_type: The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] instance_ids: The EC2 and RDS instance IDs.
        :param pulumi.Input[builtins.str] region: The Region to run the SSM document.
        """
        pulumi.set(__self__, "action_sub_type", action_sub_type)
        pulumi.set(__self__, "instance_ids", instance_ids)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="actionSubType")
    def action_sub_type(self) -> pulumi.Input[builtins.str]:
        """
        The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        """
        return pulumi.get(self, "action_sub_type")

    @action_sub_type.setter
    def action_sub_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action_sub_type", value)

    @property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The EC2 and RDS instance IDs.
        """
        return pulumi.get(self, "instance_ids")

    @instance_ids.setter
    def instance_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "instance_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The Region to run the SSM document.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class BudgetActionSubscriberArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
        """
        The address that AWS sends budget notifications to, either an SNS topic or an email.
        """
        subscription_type: pulumi.Input[builtins.str]
        """
        The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
elif False:
    BudgetActionSubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetActionSubscriberArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 subscription_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] address: The address that AWS sends budget notifications to, either an SNS topic or an email.
        :param pulumi.Input[builtins.str] subscription_type: The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subscription_type", subscription_type)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The address that AWS sends budget notifications to, either an SNS topic or an email.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="subscriptionType")
    def subscription_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        return pulumi.get(self, "subscription_type")

    @subscription_type.setter
    def subscription_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subscription_type", value)


if not MYPY:
    class BudgetAutoAdjustDataArgsDict(TypedDict):
        auto_adjust_type: pulumi.Input[builtins.str]
        """
        (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
        """
        historical_options: NotRequired[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgsDict']]
        """
        (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        """
        last_auto_adjust_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Optional) - The last time that your budget was auto-adjusted.
        """
elif False:
    BudgetAutoAdjustDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAutoAdjustDataArgs:
    def __init__(__self__, *,
                 auto_adjust_type: pulumi.Input[builtins.str],
                 historical_options: Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']] = None,
                 last_auto_adjust_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auto_adjust_type: (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
        :param pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs'] historical_options: (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        :param pulumi.Input[builtins.str] last_auto_adjust_time: (Optional) - The last time that your budget was auto-adjusted.
        """
        pulumi.set(__self__, "auto_adjust_type", auto_adjust_type)
        if historical_options is not None:
            pulumi.set(__self__, "historical_options", historical_options)
        if last_auto_adjust_time is not None:
            pulumi.set(__self__, "last_auto_adjust_time", last_auto_adjust_time)

    @property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> pulumi.Input[builtins.str]:
        """
        (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
        """
        return pulumi.get(self, "auto_adjust_type")

    @auto_adjust_type.setter
    def auto_adjust_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auto_adjust_type", value)

    @property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']]:
        """
        (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        """
        return pulumi.get(self, "historical_options")

    @historical_options.setter
    def historical_options(self, value: Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']]):
        pulumi.set(self, "historical_options", value)

    @property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Optional) - The last time that your budget was auto-adjusted.
        """
        return pulumi.get(self, "last_auto_adjust_time")

    @last_auto_adjust_time.setter
    def last_auto_adjust_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_auto_adjust_time", value)


if not MYPY:
    class BudgetAutoAdjustDataHistoricalOptionsArgsDict(TypedDict):
        budget_adjustment_period: pulumi.Input[builtins.int]
        """
        (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        """
        lookback_available_periods: NotRequired[pulumi.Input[builtins.int]]
        """
        (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
elif False:
    BudgetAutoAdjustDataHistoricalOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAutoAdjustDataHistoricalOptionsArgs:
    def __init__(__self__, *,
                 budget_adjustment_period: pulumi.Input[builtins.int],
                 lookback_available_periods: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] budget_adjustment_period: (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        :param pulumi.Input[builtins.int] lookback_available_periods: (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        pulumi.set(__self__, "budget_adjustment_period", budget_adjustment_period)
        if lookback_available_periods is not None:
            pulumi.set(__self__, "lookback_available_periods", lookback_available_periods)

    @property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> pulumi.Input[builtins.int]:
        """
        (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        """
        return pulumi.get(self, "budget_adjustment_period")

    @budget_adjustment_period.setter
    def budget_adjustment_period(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "budget_adjustment_period", value)

    @property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        return pulumi.get(self, "lookback_available_periods")

    @lookback_available_periods.setter
    def lookback_available_periods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lookback_available_periods", value)


if not MYPY:
    class BudgetCostFilterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of a budget. Unique within accounts.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    BudgetCostFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetCostFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] name: The name of a budget. Unique within accounts.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of a budget. Unique within accounts.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class BudgetCostTypesArgsDict(TypedDict):
        include_credit: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`
        """
        include_discount: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether a budget includes discounts. Defaults to `true`
        """
        include_other_subscription: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        """
        include_recurring: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        """
        include_refund: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`
        """
        include_subscription: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        """
        include_support: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`
        """
        include_tax: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`
        """
        include_upfront: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        """
        use_amortized: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether a budget uses the amortized rate. Defaults to `false`
        """
        use_blended: NotRequired[pulumi.Input[builtins.bool]]
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
elif False:
    BudgetCostTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetCostTypesArgs:
    def __init__(__self__, *,
                 include_credit: Optional[pulumi.Input[builtins.bool]] = None,
                 include_discount: Optional[pulumi.Input[builtins.bool]] = None,
                 include_other_subscription: Optional[pulumi.Input[builtins.bool]] = None,
                 include_recurring: Optional[pulumi.Input[builtins.bool]] = None,
                 include_refund: Optional[pulumi.Input[builtins.bool]] = None,
                 include_subscription: Optional[pulumi.Input[builtins.bool]] = None,
                 include_support: Optional[pulumi.Input[builtins.bool]] = None,
                 include_tax: Optional[pulumi.Input[builtins.bool]] = None,
                 include_upfront: Optional[pulumi.Input[builtins.bool]] = None,
                 use_amortized: Optional[pulumi.Input[builtins.bool]] = None,
                 use_blended: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_discount: Whether a budget includes discounts. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        :param pulumi.Input[builtins.bool] use_amortized: Whether a budget uses the amortized rate. Defaults to `false`
        :param pulumi.Input[builtins.bool] use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        if include_credit is not None:
            pulumi.set(__self__, "include_credit", include_credit)
        if include_discount is not None:
            pulumi.set(__self__, "include_discount", include_discount)
        if include_other_subscription is not None:
            pulumi.set(__self__, "include_other_subscription", include_other_subscription)
        if include_recurring is not None:
            pulumi.set(__self__, "include_recurring", include_recurring)
        if include_refund is not None:
            pulumi.set(__self__, "include_refund", include_refund)
        if include_subscription is not None:
            pulumi.set(__self__, "include_subscription", include_subscription)
        if include_support is not None:
            pulumi.set(__self__, "include_support", include_support)
        if include_tax is not None:
            pulumi.set(__self__, "include_tax", include_tax)
        if include_upfront is not None:
            pulumi.set(__self__, "include_upfront", include_upfront)
        if use_amortized is not None:
            pulumi.set(__self__, "use_amortized", use_amortized)
        if use_blended is not None:
            pulumi.set(__self__, "use_blended", use_blended)

    @property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_credit")

    @include_credit.setter
    def include_credit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_credit", value)

    @property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether a budget includes discounts. Defaults to `true`
        """
        return pulumi.get(self, "include_discount")

    @include_discount.setter
    def include_discount(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_discount", value)

    @property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_other_subscription")

    @include_other_subscription.setter
    def include_other_subscription(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_other_subscription", value)

    @property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_recurring")

    @include_recurring.setter
    def include_recurring(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_recurring", value)

    @property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_refund")

    @include_refund.setter
    def include_refund(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_refund", value)

    @property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_subscription")

    @include_subscription.setter
    def include_subscription(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_subscription", value)

    @property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_support")

    @include_support.setter
    def include_support(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_support", value)

    @property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_tax")

    @include_tax.setter
    def include_tax(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_tax", value)

    @property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_upfront")

    @include_upfront.setter
    def include_upfront(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_upfront", value)

    @property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether a budget uses the amortized rate. Defaults to `false`
        """
        return pulumi.get(self, "use_amortized")

    @use_amortized.setter
    def use_amortized(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_amortized", value)

    @property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        return pulumi.get(self, "use_blended")

    @use_blended.setter
    def use_blended(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_blended", value)


if not MYPY:
    class BudgetNotificationArgsDict(TypedDict):
        comparison_operator: pulumi.Input[builtins.str]
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        notification_type: pulumi.Input[builtins.str]
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        """
        threshold: pulumi.Input[builtins.float]
        """
        (Required) Threshold when the notification should be sent.
        """
        threshold_type: pulumi.Input[builtins.str]
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        subscriber_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        subscriber_sns_topic_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
elif False:
    BudgetNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetNotificationArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[builtins.str],
                 notification_type: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.float],
                 threshold_type: pulumi.Input[builtins.str],
                 subscriber_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subscriber_sns_topic_arns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param pulumi.Input[builtins.str] notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        :param pulumi.Input[builtins.float] threshold: (Required) Threshold when the notification should be sent.
        :param pulumi.Input[builtins.str] threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "notification_type", notification_type)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "threshold_type", threshold_type)
        if subscriber_email_addresses is not None:
            pulumi.set(__self__, "subscriber_email_addresses", subscriber_email_addresses)
        if subscriber_sns_topic_arns is not None:
            pulumi.set(__self__, "subscriber_sns_topic_arns", subscriber_sns_topic_arns)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[builtins.str]:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> pulumi.Input[builtins.str]:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "notification_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> pulumi.Input[builtins.str]:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "threshold_type", value)

    @property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @subscriber_email_addresses.setter
    def subscriber_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subscriber_email_addresses", value)

    @property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")

    @subscriber_sns_topic_arns.setter
    def subscriber_sns_topic_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subscriber_sns_topic_arns", value)


if not MYPY:
    class BudgetPlannedLimitArgsDict(TypedDict):
        amount: pulumi.Input[builtins.str]
        """
        (Required) The amount of cost or usage being measured for a budget.
        """
        start_time: pulumi.Input[builtins.str]
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        unit: pulumi.Input[builtins.str]
        """
        (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
elif False:
    BudgetPlannedLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetPlannedLimitArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[builtins.str],
                 start_time: pulumi.Input[builtins.str],
                 unit: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] amount: (Required) The amount of cost or usage being measured for a budget.
        :param pulumi.Input[builtins.str] start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param pulumi.Input[builtins.str] unit: (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[builtins.str]:
        """
        (Required) The amount of cost or usage being measured for a budget.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[builtins.str]:
        """
        (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "unit", value)


