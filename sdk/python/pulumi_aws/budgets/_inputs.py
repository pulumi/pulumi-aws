# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BudgetActionActionThresholdArgs',
    'BudgetActionDefinitionArgs',
    'BudgetActionDefinitionIamActionDefinitionArgs',
    'BudgetActionDefinitionScpActionDefinitionArgs',
    'BudgetActionDefinitionSsmActionDefinitionArgs',
    'BudgetActionSubscriberArgs',
    'BudgetAutoAdjustDataArgs',
    'BudgetAutoAdjustDataHistoricalOptionsArgs',
    'BudgetCostFilterArgs',
    'BudgetCostTypesArgs',
    'BudgetNotificationArgs',
    'BudgetPlannedLimitArgs',
]

@pulumi.input_type
class BudgetActionActionThresholdArgs:
    def __init__(__self__, *,
                 action_threshold_type: pulumi.Input[str],
                 action_threshold_value: pulumi.Input[float]):
        """
        :param pulumi.Input[str] action_threshold_type: The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        :param pulumi.Input[float] action_threshold_value: The threshold of a notification.
        """
        BudgetActionActionThresholdArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_threshold_type=action_threshold_type,
            action_threshold_value=action_threshold_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_threshold_type: Optional[pulumi.Input[str]] = None,
             action_threshold_value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_threshold_type is None and 'actionThresholdType' in kwargs:
            action_threshold_type = kwargs['actionThresholdType']
        if action_threshold_type is None:
            raise TypeError("Missing 'action_threshold_type' argument")
        if action_threshold_value is None and 'actionThresholdValue' in kwargs:
            action_threshold_value = kwargs['actionThresholdValue']
        if action_threshold_value is None:
            raise TypeError("Missing 'action_threshold_value' argument")

        _setter("action_threshold_type", action_threshold_type)
        _setter("action_threshold_value", action_threshold_value)

    @property
    @pulumi.getter(name="actionThresholdType")
    def action_threshold_type(self) -> pulumi.Input[str]:
        """
        The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "action_threshold_type")

    @action_threshold_type.setter
    def action_threshold_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_threshold_type", value)

    @property
    @pulumi.getter(name="actionThresholdValue")
    def action_threshold_value(self) -> pulumi.Input[float]:
        """
        The threshold of a notification.
        """
        return pulumi.get(self, "action_threshold_value")

    @action_threshold_value.setter
    def action_threshold_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "action_threshold_value", value)


@pulumi.input_type
class BudgetActionDefinitionArgs:
    def __init__(__self__, *,
                 iam_action_definition: Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']] = None,
                 scp_action_definition: Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']] = None,
                 ssm_action_definition: Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']] = None):
        """
        :param pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs'] iam_action_definition: The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        :param pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs'] scp_action_definition: The service control policies (SCPs) action definition details. See SCP Action Definition.
        :param pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs'] ssm_action_definition: The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        BudgetActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iam_action_definition=iam_action_definition,
            scp_action_definition=scp_action_definition,
            ssm_action_definition=ssm_action_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iam_action_definition: Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']] = None,
             scp_action_definition: Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']] = None,
             ssm_action_definition: Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if iam_action_definition is None and 'iamActionDefinition' in kwargs:
            iam_action_definition = kwargs['iamActionDefinition']
        if scp_action_definition is None and 'scpActionDefinition' in kwargs:
            scp_action_definition = kwargs['scpActionDefinition']
        if ssm_action_definition is None and 'ssmActionDefinition' in kwargs:
            ssm_action_definition = kwargs['ssmActionDefinition']

        if iam_action_definition is not None:
            _setter("iam_action_definition", iam_action_definition)
        if scp_action_definition is not None:
            _setter("scp_action_definition", scp_action_definition)
        if ssm_action_definition is not None:
            _setter("ssm_action_definition", ssm_action_definition)

    @property
    @pulumi.getter(name="iamActionDefinition")
    def iam_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']]:
        """
        The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        """
        return pulumi.get(self, "iam_action_definition")

    @iam_action_definition.setter
    def iam_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionIamActionDefinitionArgs']]):
        pulumi.set(self, "iam_action_definition", value)

    @property
    @pulumi.getter(name="scpActionDefinition")
    def scp_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']]:
        """
        The service control policies (SCPs) action definition details. See SCP Action Definition.
        """
        return pulumi.get(self, "scp_action_definition")

    @scp_action_definition.setter
    def scp_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionScpActionDefinitionArgs']]):
        pulumi.set(self, "scp_action_definition", value)

    @property
    @pulumi.getter(name="ssmActionDefinition")
    def ssm_action_definition(self) -> Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']]:
        """
        The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        return pulumi.get(self, "ssm_action_definition")

    @ssm_action_definition.setter
    def ssm_action_definition(self, value: Optional[pulumi.Input['BudgetActionDefinitionSsmActionDefinitionArgs']]):
        pulumi.set(self, "ssm_action_definition", value)


@pulumi.input_type
class BudgetActionDefinitionIamActionDefinitionArgs:
    def __init__(__self__, *,
                 policy_arn: pulumi.Input[str],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] policy_arn: The Amazon Resource Name (ARN) of the policy to be attached.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: A list of groups to be attached. There must be at least one group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: A list of roles to be attached. There must be at least one role.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: A list of users to be attached. There must be at least one user.
        """
        BudgetActionDefinitionIamActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_arn=policy_arn,
            groups=groups,
            roles=roles,
            users=users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_arn: Optional[pulumi.Input[str]] = None,
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_arn is None and 'policyArn' in kwargs:
            policy_arn = kwargs['policyArn']
        if policy_arn is None:
            raise TypeError("Missing 'policy_arn' argument")

        _setter("policy_arn", policy_arn)
        if groups is not None:
            _setter("groups", groups)
        if roles is not None:
            _setter("roles", roles)
        if users is not None:
            _setter("users", users)

    @property
    @pulumi.getter(name="policyArn")
    def policy_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the policy to be attached.
        """
        return pulumi.get(self, "policy_arn")

    @policy_arn.setter
    def policy_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_arn", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of groups to be attached. There must be at least one group.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of roles to be attached. There must be at least one role.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of users to be attached. There must be at least one user.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class BudgetActionDefinitionScpActionDefinitionArgs:
    def __init__(__self__, *,
                 policy_id: pulumi.Input[str],
                 target_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] policy_id: The policy ID attached.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ids: A list of target IDs.
        """
        BudgetActionDefinitionScpActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_id=policy_id,
            target_ids=target_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_id: Optional[pulumi.Input[str]] = None,
             target_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")

        _setter("policy_id", policy_id)
        _setter("target_ids", target_ids)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Input[str]:
        """
        The policy ID attached.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of target IDs.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_ids", value)


@pulumi.input_type
class BudgetActionDefinitionSsmActionDefinitionArgs:
    def __init__(__self__, *,
                 action_sub_type: pulumi.Input[str],
                 instance_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action_sub_type: The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] instance_ids: The EC2 and RDS instance IDs.
        :param pulumi.Input[str] region: The Region to run the SSM document.
        """
        BudgetActionDefinitionSsmActionDefinitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_sub_type=action_sub_type,
            instance_ids=instance_ids,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_sub_type: Optional[pulumi.Input[str]] = None,
             instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_sub_type is None and 'actionSubType' in kwargs:
            action_sub_type = kwargs['actionSubType']
        if action_sub_type is None:
            raise TypeError("Missing 'action_sub_type' argument")
        if instance_ids is None and 'instanceIds' in kwargs:
            instance_ids = kwargs['instanceIds']
        if instance_ids is None:
            raise TypeError("Missing 'instance_ids' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("action_sub_type", action_sub_type)
        _setter("instance_ids", instance_ids)
        _setter("region", region)

    @property
    @pulumi.getter(name="actionSubType")
    def action_sub_type(self) -> pulumi.Input[str]:
        """
        The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        """
        return pulumi.get(self, "action_sub_type")

    @action_sub_type.setter
    def action_sub_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_sub_type", value)

    @property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The EC2 and RDS instance IDs.
        """
        return pulumi.get(self, "instance_ids")

    @instance_ids.setter
    def instance_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "instance_ids", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The Region to run the SSM document.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class BudgetActionSubscriberArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 subscription_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: The address that AWS sends budget notifications to, either an SNS topic or an email.
        :param pulumi.Input[str] subscription_type: The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        BudgetActionSubscriberArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            subscription_type=subscription_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             subscription_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if subscription_type is None and 'subscriptionType' in kwargs:
            subscription_type = kwargs['subscriptionType']
        if subscription_type is None:
            raise TypeError("Missing 'subscription_type' argument")

        _setter("address", address)
        _setter("subscription_type", subscription_type)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The address that AWS sends budget notifications to, either an SNS topic or an email.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="subscriptionType")
    def subscription_type(self) -> pulumi.Input[str]:
        """
        The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        return pulumi.get(self, "subscription_type")

    @subscription_type.setter
    def subscription_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_type", value)


@pulumi.input_type
class BudgetAutoAdjustDataArgs:
    def __init__(__self__, *,
                 auto_adjust_type: pulumi.Input[str],
                 historical_options: Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']] = None,
                 last_auto_adjust_time: Optional[pulumi.Input[str]] = None):
        BudgetAutoAdjustDataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_adjust_type=auto_adjust_type,
            historical_options=historical_options,
            last_auto_adjust_time=last_auto_adjust_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_adjust_type: Optional[pulumi.Input[str]] = None,
             historical_options: Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']] = None,
             last_auto_adjust_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_adjust_type is None and 'autoAdjustType' in kwargs:
            auto_adjust_type = kwargs['autoAdjustType']
        if auto_adjust_type is None:
            raise TypeError("Missing 'auto_adjust_type' argument")
        if historical_options is None and 'historicalOptions' in kwargs:
            historical_options = kwargs['historicalOptions']
        if last_auto_adjust_time is None and 'lastAutoAdjustTime' in kwargs:
            last_auto_adjust_time = kwargs['lastAutoAdjustTime']

        _setter("auto_adjust_type", auto_adjust_type)
        if historical_options is not None:
            _setter("historical_options", historical_options)
        if last_auto_adjust_time is not None:
            _setter("last_auto_adjust_time", last_auto_adjust_time)

    @property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "auto_adjust_type")

    @auto_adjust_type.setter
    def auto_adjust_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auto_adjust_type", value)

    @property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']]:
        return pulumi.get(self, "historical_options")

    @historical_options.setter
    def historical_options(self, value: Optional[pulumi.Input['BudgetAutoAdjustDataHistoricalOptionsArgs']]):
        pulumi.set(self, "historical_options", value)

    @property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_auto_adjust_time")

    @last_auto_adjust_time.setter
    def last_auto_adjust_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_auto_adjust_time", value)


@pulumi.input_type
class BudgetAutoAdjustDataHistoricalOptionsArgs:
    def __init__(__self__, *,
                 budget_adjustment_period: pulumi.Input[int],
                 lookback_available_periods: Optional[pulumi.Input[int]] = None):
        BudgetAutoAdjustDataHistoricalOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            budget_adjustment_period=budget_adjustment_period,
            lookback_available_periods=lookback_available_periods,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             budget_adjustment_period: Optional[pulumi.Input[int]] = None,
             lookback_available_periods: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if budget_adjustment_period is None and 'budgetAdjustmentPeriod' in kwargs:
            budget_adjustment_period = kwargs['budgetAdjustmentPeriod']
        if budget_adjustment_period is None:
            raise TypeError("Missing 'budget_adjustment_period' argument")
        if lookback_available_periods is None and 'lookbackAvailablePeriods' in kwargs:
            lookback_available_periods = kwargs['lookbackAvailablePeriods']

        _setter("budget_adjustment_period", budget_adjustment_period)
        if lookback_available_periods is not None:
            _setter("lookback_available_periods", lookback_available_periods)

    @property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> pulumi.Input[int]:
        return pulumi.get(self, "budget_adjustment_period")

    @budget_adjustment_period.setter
    def budget_adjustment_period(self, value: pulumi.Input[int]):
        pulumi.set(self, "budget_adjustment_period", value)

    @property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lookback_available_periods")

    @lookback_available_periods.setter
    def lookback_available_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_available_periods", value)


@pulumi.input_type
class BudgetCostFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name of a budget. Unique within accounts.
        """
        BudgetCostFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of a budget. Unique within accounts.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class BudgetCostTypesArgs:
    def __init__(__self__, *,
                 include_credit: Optional[pulumi.Input[bool]] = None,
                 include_discount: Optional[pulumi.Input[bool]] = None,
                 include_other_subscription: Optional[pulumi.Input[bool]] = None,
                 include_recurring: Optional[pulumi.Input[bool]] = None,
                 include_refund: Optional[pulumi.Input[bool]] = None,
                 include_subscription: Optional[pulumi.Input[bool]] = None,
                 include_support: Optional[pulumi.Input[bool]] = None,
                 include_tax: Optional[pulumi.Input[bool]] = None,
                 include_upfront: Optional[pulumi.Input[bool]] = None,
                 use_amortized: Optional[pulumi.Input[bool]] = None,
                 use_blended: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_discount: Whether a budget includes discounts. Defaults to `true`
        :param pulumi.Input[bool] include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        :param pulumi.Input[bool] use_amortized: Whether a budget uses the amortized rate. Defaults to `false`
        :param pulumi.Input[bool] use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        BudgetCostTypesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_credit=include_credit,
            include_discount=include_discount,
            include_other_subscription=include_other_subscription,
            include_recurring=include_recurring,
            include_refund=include_refund,
            include_subscription=include_subscription,
            include_support=include_support,
            include_tax=include_tax,
            include_upfront=include_upfront,
            use_amortized=use_amortized,
            use_blended=use_blended,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_credit: Optional[pulumi.Input[bool]] = None,
             include_discount: Optional[pulumi.Input[bool]] = None,
             include_other_subscription: Optional[pulumi.Input[bool]] = None,
             include_recurring: Optional[pulumi.Input[bool]] = None,
             include_refund: Optional[pulumi.Input[bool]] = None,
             include_subscription: Optional[pulumi.Input[bool]] = None,
             include_support: Optional[pulumi.Input[bool]] = None,
             include_tax: Optional[pulumi.Input[bool]] = None,
             include_upfront: Optional[pulumi.Input[bool]] = None,
             use_amortized: Optional[pulumi.Input[bool]] = None,
             use_blended: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if include_credit is None and 'includeCredit' in kwargs:
            include_credit = kwargs['includeCredit']
        if include_discount is None and 'includeDiscount' in kwargs:
            include_discount = kwargs['includeDiscount']
        if include_other_subscription is None and 'includeOtherSubscription' in kwargs:
            include_other_subscription = kwargs['includeOtherSubscription']
        if include_recurring is None and 'includeRecurring' in kwargs:
            include_recurring = kwargs['includeRecurring']
        if include_refund is None and 'includeRefund' in kwargs:
            include_refund = kwargs['includeRefund']
        if include_subscription is None and 'includeSubscription' in kwargs:
            include_subscription = kwargs['includeSubscription']
        if include_support is None and 'includeSupport' in kwargs:
            include_support = kwargs['includeSupport']
        if include_tax is None and 'includeTax' in kwargs:
            include_tax = kwargs['includeTax']
        if include_upfront is None and 'includeUpfront' in kwargs:
            include_upfront = kwargs['includeUpfront']
        if use_amortized is None and 'useAmortized' in kwargs:
            use_amortized = kwargs['useAmortized']
        if use_blended is None and 'useBlended' in kwargs:
            use_blended = kwargs['useBlended']

        if include_credit is not None:
            _setter("include_credit", include_credit)
        if include_discount is not None:
            _setter("include_discount", include_discount)
        if include_other_subscription is not None:
            _setter("include_other_subscription", include_other_subscription)
        if include_recurring is not None:
            _setter("include_recurring", include_recurring)
        if include_refund is not None:
            _setter("include_refund", include_refund)
        if include_subscription is not None:
            _setter("include_subscription", include_subscription)
        if include_support is not None:
            _setter("include_support", include_support)
        if include_tax is not None:
            _setter("include_tax", include_tax)
        if include_upfront is not None:
            _setter("include_upfront", include_upfront)
        if use_amortized is not None:
            _setter("use_amortized", use_amortized)
        if use_blended is not None:
            _setter("use_blended", use_blended)

    @property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_credit")

    @include_credit.setter
    def include_credit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_credit", value)

    @property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a budget includes discounts. Defaults to `true`
        """
        return pulumi.get(self, "include_discount")

    @include_discount.setter
    def include_discount(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_discount", value)

    @property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_other_subscription")

    @include_other_subscription.setter
    def include_other_subscription(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_other_subscription", value)

    @property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_recurring")

    @include_recurring.setter
    def include_recurring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_recurring", value)

    @property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_refund")

    @include_refund.setter
    def include_refund(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_refund", value)

    @property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_subscription")

    @include_subscription.setter
    def include_subscription(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subscription", value)

    @property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_support")

    @include_support.setter
    def include_support(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_support", value)

    @property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_tax")

    @include_tax.setter
    def include_tax(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_tax", value)

    @property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_upfront")

    @include_upfront.setter
    def include_upfront(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_upfront", value)

    @property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a budget uses the amortized rate. Defaults to `false`
        """
        return pulumi.get(self, "use_amortized")

    @use_amortized.setter
    def use_amortized(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_amortized", value)

    @property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        return pulumi.get(self, "use_blended")

    @use_blended.setter
    def use_blended(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_blended", value)


@pulumi.input_type
class BudgetNotificationArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[str],
                 notification_type: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 threshold_type: pulumi.Input[str],
                 subscriber_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscriber_sns_topic_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param pulumi.Input[str] notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        :param pulumi.Input[float] threshold: (Required) Threshold when the notification should be sent.
        :param pulumi.Input[str] threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        BudgetNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            notification_type=notification_type,
            threshold=threshold,
            threshold_type=threshold_type,
            subscriber_email_addresses=subscriber_email_addresses,
            subscriber_sns_topic_arns=subscriber_sns_topic_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[pulumi.Input[str]] = None,
             notification_type: Optional[pulumi.Input[str]] = None,
             threshold: Optional[pulumi.Input[float]] = None,
             threshold_type: Optional[pulumi.Input[str]] = None,
             subscriber_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             subscriber_sns_topic_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if notification_type is None and 'notificationType' in kwargs:
            notification_type = kwargs['notificationType']
        if notification_type is None:
            raise TypeError("Missing 'notification_type' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if threshold_type is None and 'thresholdType' in kwargs:
            threshold_type = kwargs['thresholdType']
        if threshold_type is None:
            raise TypeError("Missing 'threshold_type' argument")
        if subscriber_email_addresses is None and 'subscriberEmailAddresses' in kwargs:
            subscriber_email_addresses = kwargs['subscriberEmailAddresses']
        if subscriber_sns_topic_arns is None and 'subscriberSnsTopicArns' in kwargs:
            subscriber_sns_topic_arns = kwargs['subscriberSnsTopicArns']

        _setter("comparison_operator", comparison_operator)
        _setter("notification_type", notification_type)
        _setter("threshold", threshold)
        _setter("threshold_type", threshold_type)
        if subscriber_email_addresses is not None:
            _setter("subscriber_email_addresses", subscriber_email_addresses)
        if subscriber_sns_topic_arns is not None:
            _setter("subscriber_sns_topic_arns", subscriber_sns_topic_arns)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[str]:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> pulumi.Input[str]:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "notification_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> pulumi.Input[str]:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "threshold_type", value)

    @property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @subscriber_email_addresses.setter
    def subscriber_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subscriber_email_addresses", value)

    @property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")

    @subscriber_sns_topic_arns.setter
    def subscriber_sns_topic_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subscriber_sns_topic_arns", value)


@pulumi.input_type
class BudgetPlannedLimitArgs:
    def __init__(__self__, *,
                 amount: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 unit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] amount: (Required) The amount of cost or usage being measured for a budget.
        :param pulumi.Input[str] start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param pulumi.Input[str] unit: (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        BudgetPlannedLimitArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            start_time=start_time,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[pulumi.Input[str]] = None,
             start_time: Optional[pulumi.Input[str]] = None,
             unit: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if unit is None:
            raise TypeError("Missing 'unit' argument")

        _setter("amount", amount)
        _setter("start_time", start_time)
        _setter("unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> pulumi.Input[str]:
        """
        (Required) The amount of cost or usage being measured for a budget.
        """
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: pulumi.Input[str]):
        pulumi.set(self, "amount", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)


