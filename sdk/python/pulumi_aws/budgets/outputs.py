# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BudgetActionActionThreshold',
    'BudgetActionDefinition',
    'BudgetActionDefinitionIamActionDefinition',
    'BudgetActionDefinitionScpActionDefinition',
    'BudgetActionDefinitionSsmActionDefinition',
    'BudgetActionSubscriber',
    'BudgetAutoAdjustData',
    'BudgetAutoAdjustDataHistoricalOptions',
    'BudgetCostFilter',
    'BudgetCostTypes',
    'BudgetFilterExpression',
    'BudgetFilterExpressionAnd',
    'BudgetFilterExpressionAndAnd',
    'BudgetFilterExpressionAndAndCostCategories',
    'BudgetFilterExpressionAndAndDimensions',
    'BudgetFilterExpressionAndAndTags',
    'BudgetFilterExpressionAndCostCategories',
    'BudgetFilterExpressionAndDimensions',
    'BudgetFilterExpressionAndNot',
    'BudgetFilterExpressionAndNotCostCategories',
    'BudgetFilterExpressionAndNotDimensions',
    'BudgetFilterExpressionAndNotTags',
    'BudgetFilterExpressionAndOr',
    'BudgetFilterExpressionAndOrCostCategories',
    'BudgetFilterExpressionAndOrDimensions',
    'BudgetFilterExpressionAndOrTags',
    'BudgetFilterExpressionAndTags',
    'BudgetFilterExpressionCostCategories',
    'BudgetFilterExpressionDimensions',
    'BudgetFilterExpressionNot',
    'BudgetFilterExpressionNotAnd',
    'BudgetFilterExpressionNotAndCostCategories',
    'BudgetFilterExpressionNotAndDimensions',
    'BudgetFilterExpressionNotAndTags',
    'BudgetFilterExpressionNotCostCategories',
    'BudgetFilterExpressionNotDimensions',
    'BudgetFilterExpressionNotNot',
    'BudgetFilterExpressionNotNotCostCategories',
    'BudgetFilterExpressionNotNotDimensions',
    'BudgetFilterExpressionNotNotTags',
    'BudgetFilterExpressionNotOr',
    'BudgetFilterExpressionNotOrCostCategories',
    'BudgetFilterExpressionNotOrDimensions',
    'BudgetFilterExpressionNotOrTags',
    'BudgetFilterExpressionNotTags',
    'BudgetFilterExpressionOr',
    'BudgetFilterExpressionOrAnd',
    'BudgetFilterExpressionOrAndCostCategories',
    'BudgetFilterExpressionOrAndDimensions',
    'BudgetFilterExpressionOrAndTags',
    'BudgetFilterExpressionOrCostCategories',
    'BudgetFilterExpressionOrDimensions',
    'BudgetFilterExpressionOrNot',
    'BudgetFilterExpressionOrNotCostCategories',
    'BudgetFilterExpressionOrNotDimensions',
    'BudgetFilterExpressionOrNotTags',
    'BudgetFilterExpressionOrOr',
    'BudgetFilterExpressionOrOrCostCategories',
    'BudgetFilterExpressionOrOrDimensions',
    'BudgetFilterExpressionOrOrTags',
    'BudgetFilterExpressionOrTags',
    'BudgetFilterExpressionTags',
    'BudgetNotification',
    'BudgetPlannedLimit',
    'GetBudgetAutoAdjustDataResult',
    'GetBudgetAutoAdjustDataHistoricalOptionResult',
    'GetBudgetBudgetLimitResult',
    'GetBudgetCalculatedSpendResult',
    'GetBudgetCalculatedSpendActualSpendResult',
    'GetBudgetCostFilterResult',
    'GetBudgetCostTypeResult',
    'GetBudgetNotificationResult',
    'GetBudgetPlannedLimitResult',
]

@pulumi.output_type
class BudgetActionActionThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionThresholdType":
            suggest = "action_threshold_type"
        elif key == "actionThresholdValue":
            suggest = "action_threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionActionThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionActionThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionActionThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_threshold_type: _builtins.str,
                 action_threshold_value: _builtins.float):
        """
        :param _builtins.str action_threshold_type: The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        :param _builtins.float action_threshold_value: The threshold of a notification.
        """
        pulumi.set(__self__, "action_threshold_type", action_threshold_type)
        pulumi.set(__self__, "action_threshold_value", action_threshold_value)

    @_builtins.property
    @pulumi.getter(name="actionThresholdType")
    def action_threshold_type(self) -> _builtins.str:
        """
        The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "action_threshold_type")

    @_builtins.property
    @pulumi.getter(name="actionThresholdValue")
    def action_threshold_value(self) -> _builtins.float:
        """
        The threshold of a notification.
        """
        return pulumi.get(self, "action_threshold_value")


@pulumi.output_type
class BudgetActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamActionDefinition":
            suggest = "iam_action_definition"
        elif key == "scpActionDefinition":
            suggest = "scp_action_definition"
        elif key == "ssmActionDefinition":
            suggest = "ssm_action_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_action_definition: Optional['outputs.BudgetActionDefinitionIamActionDefinition'] = None,
                 scp_action_definition: Optional['outputs.BudgetActionDefinitionScpActionDefinition'] = None,
                 ssm_action_definition: Optional['outputs.BudgetActionDefinitionSsmActionDefinition'] = None):
        """
        :param 'BudgetActionDefinitionIamActionDefinitionArgs' iam_action_definition: The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        :param 'BudgetActionDefinitionScpActionDefinitionArgs' scp_action_definition: The service control policies (SCPs) action definition details. See SCP Action Definition.
        :param 'BudgetActionDefinitionSsmActionDefinitionArgs' ssm_action_definition: The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        if iam_action_definition is not None:
            pulumi.set(__self__, "iam_action_definition", iam_action_definition)
        if scp_action_definition is not None:
            pulumi.set(__self__, "scp_action_definition", scp_action_definition)
        if ssm_action_definition is not None:
            pulumi.set(__self__, "ssm_action_definition", ssm_action_definition)

    @_builtins.property
    @pulumi.getter(name="iamActionDefinition")
    def iam_action_definition(self) -> Optional['outputs.BudgetActionDefinitionIamActionDefinition']:
        """
        The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        """
        return pulumi.get(self, "iam_action_definition")

    @_builtins.property
    @pulumi.getter(name="scpActionDefinition")
    def scp_action_definition(self) -> Optional['outputs.BudgetActionDefinitionScpActionDefinition']:
        """
        The service control policies (SCPs) action definition details. See SCP Action Definition.
        """
        return pulumi.get(self, "scp_action_definition")

    @_builtins.property
    @pulumi.getter(name="ssmActionDefinition")
    def ssm_action_definition(self) -> Optional['outputs.BudgetActionDefinitionSsmActionDefinition']:
        """
        The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        return pulumi.get(self, "ssm_action_definition")


@pulumi.output_type
class BudgetActionDefinitionIamActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyArn":
            suggest = "policy_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionIamActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionIamActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionIamActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_arn: _builtins.str,
                 groups: Optional[Sequence[_builtins.str]] = None,
                 roles: Optional[Sequence[_builtins.str]] = None,
                 users: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str policy_arn: The Amazon Resource Name (ARN) of the policy to be attached.
        :param Sequence[_builtins.str] groups: A list of groups to be attached. There must be at least one group.
        :param Sequence[_builtins.str] roles: A list of roles to be attached. There must be at least one role.
        :param Sequence[_builtins.str] users: A list of users to be attached. There must be at least one user.
        """
        pulumi.set(__self__, "policy_arn", policy_arn)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="policyArn")
    def policy_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the policy to be attached.
        """
        return pulumi.get(self, "policy_arn")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of groups to be attached. There must be at least one group.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of roles to be attached. There must be at least one role.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of users to be attached. There must be at least one user.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class BudgetActionDefinitionScpActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyId":
            suggest = "policy_id"
        elif key == "targetIds":
            suggest = "target_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionScpActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionScpActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionScpActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_id: _builtins.str,
                 target_ids: Sequence[_builtins.str]):
        """
        :param _builtins.str policy_id: The policy ID attached.
        :param Sequence[_builtins.str] target_ids: A list of target IDs.
        """
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "target_ids", target_ids)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        The policy ID attached.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[_builtins.str]:
        """
        A list of target IDs.
        """
        return pulumi.get(self, "target_ids")


@pulumi.output_type
class BudgetActionDefinitionSsmActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionSubType":
            suggest = "action_sub_type"
        elif key == "instanceIds":
            suggest = "instance_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionSsmActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionSsmActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionSsmActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_sub_type: _builtins.str,
                 instance_ids: Sequence[_builtins.str],
                 region: _builtins.str):
        """
        :param _builtins.str action_sub_type: The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        :param Sequence[_builtins.str] instance_ids: The EC2 and RDS instance IDs.
        :param _builtins.str region: The Region to run the SSM document.
        """
        pulumi.set(__self__, "action_sub_type", action_sub_type)
        pulumi.set(__self__, "instance_ids", instance_ids)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="actionSubType")
    def action_sub_type(self) -> _builtins.str:
        """
        The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        """
        return pulumi.get(self, "action_sub_type")

    @_builtins.property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Sequence[_builtins.str]:
        """
        The EC2 and RDS instance IDs.
        """
        return pulumi.get(self, "instance_ids")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The Region to run the SSM document.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class BudgetActionSubscriber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionType":
            suggest = "subscription_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionSubscriber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionSubscriber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionSubscriber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 subscription_type: _builtins.str):
        """
        :param _builtins.str address: The address that AWS sends budget notifications to, either an SNS topic or an email.
        :param _builtins.str subscription_type: The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subscription_type", subscription_type)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The address that AWS sends budget notifications to, either an SNS topic or an email.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="subscriptionType")
    def subscription_type(self) -> _builtins.str:
        """
        The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        return pulumi.get(self, "subscription_type")


@pulumi.output_type
class BudgetAutoAdjustData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoAdjustType":
            suggest = "auto_adjust_type"
        elif key == "historicalOptions":
            suggest = "historical_options"
        elif key == "lastAutoAdjustTime":
            suggest = "last_auto_adjust_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAutoAdjustData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAutoAdjustData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAutoAdjustData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_adjust_type: _builtins.str,
                 historical_options: Optional['outputs.BudgetAutoAdjustDataHistoricalOptions'] = None,
                 last_auto_adjust_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str auto_adjust_type: (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
        :param 'BudgetAutoAdjustDataHistoricalOptionsArgs' historical_options: (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        :param _builtins.str last_auto_adjust_time: (Optional) - The last time that your budget was auto-adjusted.
        """
        pulumi.set(__self__, "auto_adjust_type", auto_adjust_type)
        if historical_options is not None:
            pulumi.set(__self__, "historical_options", historical_options)
        if last_auto_adjust_time is not None:
            pulumi.set(__self__, "last_auto_adjust_time", last_auto_adjust_time)

    @_builtins.property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> _builtins.str:
        """
        (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`
        """
        return pulumi.get(self, "auto_adjust_type")

    @_builtins.property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Optional['outputs.BudgetAutoAdjustDataHistoricalOptions']:
        """
        (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        """
        return pulumi.get(self, "historical_options")

    @_builtins.property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> Optional[_builtins.str]:
        """
        (Optional) - The last time that your budget was auto-adjusted.
        """
        return pulumi.get(self, "last_auto_adjust_time")


@pulumi.output_type
class BudgetAutoAdjustDataHistoricalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "budgetAdjustmentPeriod":
            suggest = "budget_adjustment_period"
        elif key == "lookbackAvailablePeriods":
            suggest = "lookback_available_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAutoAdjustDataHistoricalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAutoAdjustDataHistoricalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAutoAdjustDataHistoricalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 budget_adjustment_period: _builtins.int,
                 lookback_available_periods: Optional[_builtins.int] = None):
        """
        :param _builtins.int budget_adjustment_period: (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        :param _builtins.int lookback_available_periods: (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        pulumi.set(__self__, "budget_adjustment_period", budget_adjustment_period)
        if lookback_available_periods is not None:
            pulumi.set(__self__, "lookback_available_periods", lookback_available_periods)

    @_builtins.property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> _builtins.int:
        """
        (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        """
        return pulumi.get(self, "budget_adjustment_period")

    @_builtins.property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> Optional[_builtins.int]:
        """
        (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        return pulumi.get(self, "lookback_available_periods")


@pulumi.output_type
class BudgetCostFilter(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of a budget. Unique within accounts.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a budget. Unique within accounts.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetCostTypes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeCredit":
            suggest = "include_credit"
        elif key == "includeDiscount":
            suggest = "include_discount"
        elif key == "includeOtherSubscription":
            suggest = "include_other_subscription"
        elif key == "includeRecurring":
            suggest = "include_recurring"
        elif key == "includeRefund":
            suggest = "include_refund"
        elif key == "includeSubscription":
            suggest = "include_subscription"
        elif key == "includeSupport":
            suggest = "include_support"
        elif key == "includeTax":
            suggest = "include_tax"
        elif key == "includeUpfront":
            suggest = "include_upfront"
        elif key == "useAmortized":
            suggest = "use_amortized"
        elif key == "useBlended":
            suggest = "use_blended"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetCostTypes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetCostTypes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetCostTypes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_credit: Optional[_builtins.bool] = None,
                 include_discount: Optional[_builtins.bool] = None,
                 include_other_subscription: Optional[_builtins.bool] = None,
                 include_recurring: Optional[_builtins.bool] = None,
                 include_refund: Optional[_builtins.bool] = None,
                 include_subscription: Optional[_builtins.bool] = None,
                 include_support: Optional[_builtins.bool] = None,
                 include_tax: Optional[_builtins.bool] = None,
                 include_upfront: Optional[_builtins.bool] = None,
                 use_amortized: Optional[_builtins.bool] = None,
                 use_blended: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`
        :param _builtins.bool include_discount: Whether a budget includes discounts. Defaults to `true`
        :param _builtins.bool include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        :param _builtins.bool include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        :param _builtins.bool include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`
        :param _builtins.bool include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        :param _builtins.bool include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`
        :param _builtins.bool include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`
        :param _builtins.bool include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        :param _builtins.bool use_amortized: Whether a budget uses the amortized rate. Defaults to `false`
        :param _builtins.bool use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        if include_credit is not None:
            pulumi.set(__self__, "include_credit", include_credit)
        if include_discount is not None:
            pulumi.set(__self__, "include_discount", include_discount)
        if include_other_subscription is not None:
            pulumi.set(__self__, "include_other_subscription", include_other_subscription)
        if include_recurring is not None:
            pulumi.set(__self__, "include_recurring", include_recurring)
        if include_refund is not None:
            pulumi.set(__self__, "include_refund", include_refund)
        if include_subscription is not None:
            pulumi.set(__self__, "include_subscription", include_subscription)
        if include_support is not None:
            pulumi.set(__self__, "include_support", include_support)
        if include_tax is not None:
            pulumi.set(__self__, "include_tax", include_tax)
        if include_upfront is not None:
            pulumi.set(__self__, "include_upfront", include_upfront)
        if use_amortized is not None:
            pulumi.set(__self__, "use_amortized", use_amortized)
        if use_blended is not None:
            pulumi.set(__self__, "use_blended", use_blended)

    @_builtins.property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_credit")

    @_builtins.property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> Optional[_builtins.bool]:
        """
        Whether a budget includes discounts. Defaults to `true`
        """
        return pulumi.get(self, "include_discount")

    @_builtins.property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_other_subscription")

    @_builtins.property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_recurring")

    @_builtins.property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_refund")

    @_builtins.property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_subscription")

    @_builtins.property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_support")

    @_builtins.property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_tax")

    @_builtins.property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_upfront")

    @_builtins.property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> Optional[_builtins.bool]:
        """
        Whether a budget uses the amortized rate. Defaults to `false`
        """
        return pulumi.get(self, "use_amortized")

    @_builtins.property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> Optional[_builtins.bool]:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        return pulumi.get(self, "use_blended")


@pulumi.output_type
class BudgetFilterExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.BudgetFilterExpressionAnd']] = None,
                 cost_categories: Optional['outputs.BudgetFilterExpressionCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionDimensions'] = None,
                 not_: Optional['outputs.BudgetFilterExpressionNot'] = None,
                 ors: Optional[Sequence['outputs.BudgetFilterExpressionOr']] = None,
                 tags: Optional['outputs.BudgetFilterExpressionTags'] = None):
        """
        :param Sequence['BudgetFilterExpressionAndArgs'] ands: (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionNotArgs' not_: (Optional) A single filter expression to negate. Must contain exactly one root.
        :param Sequence['BudgetFilterExpressionOrArgs'] ors: (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.BudgetFilterExpressionAnd']]:
        """
        (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ands")

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.BudgetFilterExpressionNot']:
        """
        (Optional) A single filter expression to negate. Must contain exactly one root.
        """
        return pulumi.get(self, "not_")

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.BudgetFilterExpressionOr']]:
        """
        (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.BudgetFilterExpressionAndAnd']] = None,
                 cost_categories: Optional['outputs.BudgetFilterExpressionAndCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionAndDimensions'] = None,
                 not_: Optional['outputs.BudgetFilterExpressionAndNot'] = None,
                 ors: Optional[Sequence['outputs.BudgetFilterExpressionAndOr']] = None,
                 tags: Optional['outputs.BudgetFilterExpressionAndTags'] = None):
        """
        :param Sequence['BudgetFilterExpressionAndAndArgs'] ands: (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionAndCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionAndDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionAndNotArgs' not_: (Optional) A single filter expression to negate. Must contain exactly one root.
        :param Sequence['BudgetFilterExpressionAndOrArgs'] ors: (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionAndTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.BudgetFilterExpressionAndAnd']]:
        """
        (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ands")

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionAndCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionAndDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.BudgetFilterExpressionAndNot']:
        """
        (Optional) A single filter expression to negate. Must contain exactly one root.
        """
        return pulumi.get(self, "not_")

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.BudgetFilterExpressionAndOr']]:
        """
        (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionAndTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionAndAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionAndAndCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionAndAndDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionAndAndTags'] = None):
        """
        :param 'BudgetFilterExpressionAndAndCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionAndAndDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionAndAndTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionAndAndCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionAndAndDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionAndAndTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionAndAndCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndAndCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndAndCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndAndCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndAndDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndAndDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndAndDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndAndDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionAndAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionAndNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionAndNotCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionAndNotDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionAndNotTags'] = None):
        """
        :param 'BudgetFilterExpressionAndNotCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionAndNotDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionAndNotTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionAndNotCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionAndNotDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionAndNotTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionAndNotCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndNotCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndNotCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndNotCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndNotDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndNotDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndNotDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndNotDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionAndNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionAndOrCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionAndOrDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionAndOrTags'] = None):
        """
        :param 'BudgetFilterExpressionAndOrCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionAndOrDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionAndOrTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionAndOrCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionAndOrDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionAndOrTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionAndOrCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndOrCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndOrCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndOrCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndOrDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndOrDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndOrDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndOrDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionAndOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.BudgetFilterExpressionNotAnd']] = None,
                 cost_categories: Optional['outputs.BudgetFilterExpressionNotCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionNotDimensions'] = None,
                 not_: Optional['outputs.BudgetFilterExpressionNotNot'] = None,
                 ors: Optional[Sequence['outputs.BudgetFilterExpressionNotOr']] = None,
                 tags: Optional['outputs.BudgetFilterExpressionNotTags'] = None):
        """
        :param Sequence['BudgetFilterExpressionNotAndArgs'] ands: (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionNotCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionNotDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionNotNotArgs' not_: (Optional) A single filter expression to negate. Must contain exactly one root.
        :param Sequence['BudgetFilterExpressionNotOrArgs'] ors: (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionNotTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.BudgetFilterExpressionNotAnd']]:
        """
        (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ands")

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionNotCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionNotDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.BudgetFilterExpressionNotNot']:
        """
        (Optional) A single filter expression to negate. Must contain exactly one root.
        """
        return pulumi.get(self, "not_")

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.BudgetFilterExpressionNotOr']]:
        """
        (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionNotTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionNotAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionNotAndCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionNotAndDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionNotAndTags'] = None):
        """
        :param 'BudgetFilterExpressionNotAndCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionNotAndDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionNotAndTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionNotAndCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionNotAndDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionNotAndTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionNotAndCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotAndCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotAndCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotAndCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotAndDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotAndDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotAndDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotAndDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionNotAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionNotNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionNotNotCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionNotNotDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionNotNotTags'] = None):
        """
        :param 'BudgetFilterExpressionNotNotCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionNotNotDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionNotNotTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionNotNotCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionNotNotDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionNotNotTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionNotNotCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotNotCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotNotCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotNotCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotNotDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotNotDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotNotDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotNotDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionNotNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionNotOrCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionNotOrDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionNotOrTags'] = None):
        """
        :param 'BudgetFilterExpressionNotOrCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionNotOrDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionNotOrTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionNotOrCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionNotOrDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionNotOrTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionNotOrCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotOrCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotOrCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotOrCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotOrDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotOrDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotOrDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotOrDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionNotOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.BudgetFilterExpressionOrAnd']] = None,
                 cost_categories: Optional['outputs.BudgetFilterExpressionOrCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionOrDimensions'] = None,
                 not_: Optional['outputs.BudgetFilterExpressionOrNot'] = None,
                 ors: Optional[Sequence['outputs.BudgetFilterExpressionOrOr']] = None,
                 tags: Optional['outputs.BudgetFilterExpressionOrTags'] = None):
        """
        :param Sequence['BudgetFilterExpressionOrAndArgs'] ands: (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionOrCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionOrDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionOrNotArgs' not_: (Optional) A single filter expression to negate. Must contain exactly one root.
        :param Sequence['BudgetFilterExpressionOrOrArgs'] ors: (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        :param 'BudgetFilterExpressionOrTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.BudgetFilterExpressionOrAnd']]:
        """
        (Optional) A list of filter expressions to combine with AND logic. Each `and` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ands")

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionOrCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionOrDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.BudgetFilterExpressionOrNot']:
        """
        (Optional) A single filter expression to negate. Must contain exactly one root.
        """
        return pulumi.get(self, "not_")

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.BudgetFilterExpressionOrOr']]:
        """
        (Optional) A list of filter expressions to combine with OR logic. Each `or` block is one operand and must itself contain exactly one root.
        """
        return pulumi.get(self, "ors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionOrTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionOrAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionOrAndCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionOrAndDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionOrAndTags'] = None):
        """
        :param 'BudgetFilterExpressionOrAndCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionOrAndDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionOrAndTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionOrAndCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionOrAndDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionOrAndTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionOrAndCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrAndCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrAndCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrAndCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrAndDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrAndDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrAndDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrAndDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionOrAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionOrNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionOrNotCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionOrNotDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionOrNotTags'] = None):
        """
        :param 'BudgetFilterExpressionOrNotCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionOrNotDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionOrNotTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionOrNotCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionOrNotDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionOrNotTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionOrNotCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrNotCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrNotCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrNotCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrNotDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrNotDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrNotDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrNotDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionOrNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategories":
            suggest = "cost_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_categories: Optional['outputs.BudgetFilterExpressionOrOrCostCategories'] = None,
                 dimensions: Optional['outputs.BudgetFilterExpressionOrOrDimensions'] = None,
                 tags: Optional['outputs.BudgetFilterExpressionOrOrTags'] = None):
        """
        :param 'BudgetFilterExpressionOrOrCostCategoriesArgs' cost_categories: (Optional) A Cost Category Filter block.
        :param 'BudgetFilterExpressionOrOrDimensionsArgs' dimensions: (Optional) A Dimension Filter block.
        :param 'BudgetFilterExpressionOrOrTagsArgs' tags: Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_categories is not None:
            pulumi.set(__self__, "cost_categories", cost_categories)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Optional['outputs.BudgetFilterExpressionOrOrCostCategories']:
        """
        (Optional) A Cost Category Filter block.
        """
        return pulumi.get(self, "cost_categories")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.BudgetFilterExpressionOrOrDimensions']:
        """
        (Optional) A Dimension Filter block.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.BudgetFilterExpressionOrOrTags']:
        """
        Map of tags assigned to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BudgetFilterExpressionOrOrCostCategories(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrOrCostCategories. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrOrCostCategories.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrOrCostCategories.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrOrDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrOrDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrOrDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrOrDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 match_options: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")


@pulumi.output_type
class BudgetFilterExpressionOrOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterExpressionTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilterExpressionTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilterExpressionTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilterExpressionTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: (Optional) The cost category key to filter on.
        :param Sequence[_builtins.str] match_options: (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        :param Sequence[_builtins.str] values: (Optional) A list of cost category values to match. At least one value is required.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (Optional) The cost category key to filter on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) The match options for the cost category filter. Valid values are `EQUALS`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `GREATER_THAN_OR_EQUAL`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`. Note: `ABSENT` is not supported due to AWS API contradictions (it requires values to be absent but also cannot have values set).
        """
        return pulumi.get(self, "match_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) A list of cost category values to match. At least one value is required.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "notificationType":
            suggest = "notification_type"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "subscriberEmailAddresses":
            suggest = "subscriber_email_addresses"
        elif key == "subscriberSnsTopicArns":
            suggest = "subscriber_sns_topic_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 notification_type: _builtins.str,
                 threshold: _builtins.float,
                 threshold_type: _builtins.str,
                 subscriber_email_addresses: Optional[Sequence[_builtins.str]] = None,
                 subscriber_sns_topic_arns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param _builtins.str notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        :param _builtins.float threshold: (Required) Threshold when the notification should be sent.
        :param _builtins.str threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        :param Sequence[_builtins.str] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param Sequence[_builtins.str] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "notification_type", notification_type)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "threshold_type", threshold_type)
        if subscriber_email_addresses is not None:
            pulumi.set(__self__, "subscriber_email_addresses", subscriber_email_addresses)
        if subscriber_sns_topic_arns is not None:
            pulumi.set(__self__, "subscriber_sns_topic_arns", subscriber_sns_topic_arns)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> _builtins.str:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")

    @_builtins.property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @_builtins.property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")


@pulumi.output_type
class BudgetPlannedLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetPlannedLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetPlannedLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetPlannedLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: _builtins.str,
                 start_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str amount: (Required) The amount of cost or usage being measured for a budget.
        :param _builtins.str start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param _builtins.str unit: (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.str:
        """
        (Required) The amount of cost or usage being measured for a budget.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetAutoAdjustDataResult(dict):
    def __init__(__self__, *,
                 auto_adjust_type: _builtins.str,
                 historical_options: Sequence['outputs.GetBudgetAutoAdjustDataHistoricalOptionResult'],
                 last_auto_adjust_time: _builtins.str):
        """
        :param _builtins.str auto_adjust_type: (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`.
        :param Sequence['GetBudgetAutoAdjustDataHistoricalOptionArgs'] historical_options: (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        :param _builtins.str last_auto_adjust_time: (Optional) - The last time that your budget was auto-adjusted.
        """
        pulumi.set(__self__, "auto_adjust_type", auto_adjust_type)
        pulumi.set(__self__, "historical_options", historical_options)
        pulumi.set(__self__, "last_auto_adjust_time", last_auto_adjust_time)

    @_builtins.property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> _builtins.str:
        """
        (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`.
        """
        return pulumi.get(self, "auto_adjust_type")

    @_builtins.property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Sequence['outputs.GetBudgetAutoAdjustDataHistoricalOptionResult']:
        """
        (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        """
        return pulumi.get(self, "historical_options")

    @_builtins.property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> _builtins.str:
        """
        (Optional) - The last time that your budget was auto-adjusted.
        """
        return pulumi.get(self, "last_auto_adjust_time")


@pulumi.output_type
class GetBudgetAutoAdjustDataHistoricalOptionResult(dict):
    def __init__(__self__, *,
                 budget_adjustment_period: _builtins.int,
                 lookback_available_periods: _builtins.int):
        """
        :param _builtins.int budget_adjustment_period: (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        :param _builtins.int lookback_available_periods: (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        pulumi.set(__self__, "budget_adjustment_period", budget_adjustment_period)
        pulumi.set(__self__, "lookback_available_periods", lookback_available_periods)

    @_builtins.property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> _builtins.int:
        """
        (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        """
        return pulumi.get(self, "budget_adjustment_period")

    @_builtins.property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> _builtins.int:
        """
        (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        return pulumi.get(self, "lookback_available_periods")


@pulumi.output_type
class GetBudgetBudgetLimitResult(dict):
    def __init__(__self__, *,
                 amount: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param _builtins.str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetCalculatedSpendResult(dict):
    def __init__(__self__, *,
                 actual_spends: Sequence['outputs.GetBudgetCalculatedSpendActualSpendResult']):
        pulumi.set(__self__, "actual_spends", actual_spends)

    @_builtins.property
    @pulumi.getter(name="actualSpends")
    def actual_spends(self) -> Sequence['outputs.GetBudgetCalculatedSpendActualSpendResult']:
        return pulumi.get(self, "actual_spends")


@pulumi.output_type
class GetBudgetCalculatedSpendActualSpendResult(dict):
    def __init__(__self__, *,
                 amount: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param _builtins.str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetCostFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of a budget. Unique within accounts.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a budget. Unique within accounts.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBudgetCostTypeResult(dict):
    def __init__(__self__, *,
                 include_credit: _builtins.bool,
                 include_discount: _builtins.bool,
                 include_other_subscription: _builtins.bool,
                 include_recurring: _builtins.bool,
                 include_refund: _builtins.bool,
                 include_subscription: _builtins.bool,
                 include_support: _builtins.bool,
                 include_tax: _builtins.bool,
                 include_upfront: _builtins.bool,
                 use_amortized: _builtins.bool,
                 use_blended: _builtins.bool):
        """
        :param _builtins.bool include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`.
        :param _builtins.bool include_discount: Whether a budget includes discounts. Defaults to `true`.
        :param _builtins.bool include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`.
        :param _builtins.bool include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`.
        :param _builtins.bool include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`.
        :param _builtins.bool include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`.
        :param _builtins.bool include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`.
        :param _builtins.bool include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`.
        :param _builtins.bool include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`.
        :param _builtins.bool use_amortized: Whether a budget uses the amortized rate. Defaults to `false`.
        :param _builtins.bool use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`.
        """
        pulumi.set(__self__, "include_credit", include_credit)
        pulumi.set(__self__, "include_discount", include_discount)
        pulumi.set(__self__, "include_other_subscription", include_other_subscription)
        pulumi.set(__self__, "include_recurring", include_recurring)
        pulumi.set(__self__, "include_refund", include_refund)
        pulumi.set(__self__, "include_subscription", include_subscription)
        pulumi.set(__self__, "include_support", include_support)
        pulumi.set(__self__, "include_tax", include_tax)
        pulumi.set(__self__, "include_upfront", include_upfront)
        pulumi.set(__self__, "use_amortized", use_amortized)
        pulumi.set(__self__, "use_blended", use_blended)

    @_builtins.property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> _builtins.bool:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_credit")

    @_builtins.property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> _builtins.bool:
        """
        Whether a budget includes discounts. Defaults to `true`.
        """
        return pulumi.get(self, "include_discount")

    @_builtins.property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> _builtins.bool:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_other_subscription")

    @_builtins.property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> _builtins.bool:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_recurring")

    @_builtins.property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> _builtins.bool:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_refund")

    @_builtins.property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> _builtins.bool:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_subscription")

    @_builtins.property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> _builtins.bool:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_support")

    @_builtins.property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> _builtins.bool:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_tax")

    @_builtins.property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> _builtins.bool:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_upfront")

    @_builtins.property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> _builtins.bool:
        """
        Whether a budget uses the amortized rate. Defaults to `false`.
        """
        return pulumi.get(self, "use_amortized")

    @_builtins.property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> _builtins.bool:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`.
        """
        return pulumi.get(self, "use_blended")


@pulumi.output_type
class GetBudgetNotificationResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 notification_type: _builtins.str,
                 subscriber_email_addresses: Sequence[_builtins.str],
                 subscriber_sns_topic_arns: Sequence[_builtins.str],
                 threshold: _builtins.float,
                 threshold_type: _builtins.str):
        """
        :param _builtins.str comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param _builtins.str notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`.
        :param Sequence[_builtins.str] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param Sequence[_builtins.str] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        :param _builtins.float threshold: (Required) Threshold when the notification should be sent.
        :param _builtins.str threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "notification_type", notification_type)
        pulumi.set(__self__, "subscriber_email_addresses", subscriber_email_addresses)
        pulumi.set(__self__, "subscriber_sns_topic_arns", subscriber_sns_topic_arns)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "threshold_type", threshold_type)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`.
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Sequence[_builtins.str]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @_builtins.property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Sequence[_builtins.str]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> _builtins.str:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class GetBudgetPlannedLimitResult(dict):
    def __init__(__self__, *,
                 amount: _builtins.str,
                 start_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param _builtins.str start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param _builtins.str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> _builtins.str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


