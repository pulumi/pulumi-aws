# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'BudgetActionActionThreshold',
    'BudgetActionDefinition',
    'BudgetActionDefinitionIamActionDefinition',
    'BudgetActionDefinitionScpActionDefinition',
    'BudgetActionDefinitionSsmActionDefinition',
    'BudgetActionSubscriber',
    'BudgetAutoAdjustData',
    'BudgetAutoAdjustDataHistoricalOptions',
    'BudgetCostFilter',
    'BudgetCostTypes',
    'BudgetNotification',
    'BudgetPlannedLimit',
    'GetBudgetAutoAdjustDataResult',
    'GetBudgetAutoAdjustDataHistoricalOptionResult',
    'GetBudgetBudgetLimitResult',
    'GetBudgetCalculatedSpendResult',
    'GetBudgetCalculatedSpendActualSpendResult',
    'GetBudgetCostFilterResult',
    'GetBudgetCostTypeResult',
    'GetBudgetNotificationResult',
    'GetBudgetPlannedLimitResult',
]

@pulumi.output_type
class BudgetActionActionThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionThresholdType":
            suggest = "action_threshold_type"
        elif key == "actionThresholdValue":
            suggest = "action_threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionActionThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionActionThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionActionThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_threshold_type: str,
                 action_threshold_value: float):
        """
        :param str action_threshold_type: The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        :param float action_threshold_value: The threshold of a notification.
        """
        BudgetActionActionThreshold._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_threshold_type=action_threshold_type,
            action_threshold_value=action_threshold_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_threshold_type: Optional[str] = None,
             action_threshold_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_threshold_type is None and 'actionThresholdType' in kwargs:
            action_threshold_type = kwargs['actionThresholdType']
        if action_threshold_type is None:
            raise TypeError("Missing 'action_threshold_type' argument")
        if action_threshold_value is None and 'actionThresholdValue' in kwargs:
            action_threshold_value = kwargs['actionThresholdValue']
        if action_threshold_value is None:
            raise TypeError("Missing 'action_threshold_value' argument")

        _setter("action_threshold_type", action_threshold_type)
        _setter("action_threshold_value", action_threshold_value)

    @property
    @pulumi.getter(name="actionThresholdType")
    def action_threshold_type(self) -> str:
        """
        The type of threshold for a notification. Valid values are `PERCENTAGE` or `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "action_threshold_type")

    @property
    @pulumi.getter(name="actionThresholdValue")
    def action_threshold_value(self) -> float:
        """
        The threshold of a notification.
        """
        return pulumi.get(self, "action_threshold_value")


@pulumi.output_type
class BudgetActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamActionDefinition":
            suggest = "iam_action_definition"
        elif key == "scpActionDefinition":
            suggest = "scp_action_definition"
        elif key == "ssmActionDefinition":
            suggest = "ssm_action_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_action_definition: Optional['outputs.BudgetActionDefinitionIamActionDefinition'] = None,
                 scp_action_definition: Optional['outputs.BudgetActionDefinitionScpActionDefinition'] = None,
                 ssm_action_definition: Optional['outputs.BudgetActionDefinitionSsmActionDefinition'] = None):
        """
        :param 'BudgetActionDefinitionIamActionDefinitionArgs' iam_action_definition: The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        :param 'BudgetActionDefinitionScpActionDefinitionArgs' scp_action_definition: The service control policies (SCPs) action definition details. See SCP Action Definition.
        :param 'BudgetActionDefinitionSsmActionDefinitionArgs' ssm_action_definition: The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        BudgetActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iam_action_definition=iam_action_definition,
            scp_action_definition=scp_action_definition,
            ssm_action_definition=ssm_action_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iam_action_definition: Optional['outputs.BudgetActionDefinitionIamActionDefinition'] = None,
             scp_action_definition: Optional['outputs.BudgetActionDefinitionScpActionDefinition'] = None,
             ssm_action_definition: Optional['outputs.BudgetActionDefinitionSsmActionDefinition'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if iam_action_definition is None and 'iamActionDefinition' in kwargs:
            iam_action_definition = kwargs['iamActionDefinition']
        if scp_action_definition is None and 'scpActionDefinition' in kwargs:
            scp_action_definition = kwargs['scpActionDefinition']
        if ssm_action_definition is None and 'ssmActionDefinition' in kwargs:
            ssm_action_definition = kwargs['ssmActionDefinition']

        if iam_action_definition is not None:
            _setter("iam_action_definition", iam_action_definition)
        if scp_action_definition is not None:
            _setter("scp_action_definition", scp_action_definition)
        if ssm_action_definition is not None:
            _setter("ssm_action_definition", ssm_action_definition)

    @property
    @pulumi.getter(name="iamActionDefinition")
    def iam_action_definition(self) -> Optional['outputs.BudgetActionDefinitionIamActionDefinition']:
        """
        The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
        """
        return pulumi.get(self, "iam_action_definition")

    @property
    @pulumi.getter(name="scpActionDefinition")
    def scp_action_definition(self) -> Optional['outputs.BudgetActionDefinitionScpActionDefinition']:
        """
        The service control policies (SCPs) action definition details. See SCP Action Definition.
        """
        return pulumi.get(self, "scp_action_definition")

    @property
    @pulumi.getter(name="ssmActionDefinition")
    def ssm_action_definition(self) -> Optional['outputs.BudgetActionDefinitionSsmActionDefinition']:
        """
        The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
        """
        return pulumi.get(self, "ssm_action_definition")


@pulumi.output_type
class BudgetActionDefinitionIamActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyArn":
            suggest = "policy_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionIamActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionIamActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionIamActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_arn: str,
                 groups: Optional[Sequence[str]] = None,
                 roles: Optional[Sequence[str]] = None,
                 users: Optional[Sequence[str]] = None):
        """
        :param str policy_arn: The Amazon Resource Name (ARN) of the policy to be attached.
        :param Sequence[str] groups: A list of groups to be attached. There must be at least one group.
        :param Sequence[str] roles: A list of roles to be attached. There must be at least one role.
        :param Sequence[str] users: A list of users to be attached. There must be at least one user.
        """
        BudgetActionDefinitionIamActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_arn=policy_arn,
            groups=groups,
            roles=roles,
            users=users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_arn: Optional[str] = None,
             groups: Optional[Sequence[str]] = None,
             roles: Optional[Sequence[str]] = None,
             users: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_arn is None and 'policyArn' in kwargs:
            policy_arn = kwargs['policyArn']
        if policy_arn is None:
            raise TypeError("Missing 'policy_arn' argument")

        _setter("policy_arn", policy_arn)
        if groups is not None:
            _setter("groups", groups)
        if roles is not None:
            _setter("roles", roles)
        if users is not None:
            _setter("users", users)

    @property
    @pulumi.getter(name="policyArn")
    def policy_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the policy to be attached.
        """
        return pulumi.get(self, "policy_arn")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        A list of groups to be attached. There must be at least one group.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        A list of roles to be attached. There must be at least one role.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence[str]]:
        """
        A list of users to be attached. There must be at least one user.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class BudgetActionDefinitionScpActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyId":
            suggest = "policy_id"
        elif key == "targetIds":
            suggest = "target_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionScpActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionScpActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionScpActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_id: str,
                 target_ids: Sequence[str]):
        """
        :param str policy_id: The policy ID attached.
        :param Sequence[str] target_ids: A list of target IDs.
        """
        BudgetActionDefinitionScpActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_id=policy_id,
            target_ids=target_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_id: Optional[str] = None,
             target_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if policy_id is None:
            raise TypeError("Missing 'policy_id' argument")
        if target_ids is None and 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if target_ids is None:
            raise TypeError("Missing 'target_ids' argument")

        _setter("policy_id", policy_id)
        _setter("target_ids", target_ids)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> str:
        """
        The policy ID attached.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        A list of target IDs.
        """
        return pulumi.get(self, "target_ids")


@pulumi.output_type
class BudgetActionDefinitionSsmActionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionSubType":
            suggest = "action_sub_type"
        elif key == "instanceIds":
            suggest = "instance_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionDefinitionSsmActionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionDefinitionSsmActionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionDefinitionSsmActionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_sub_type: str,
                 instance_ids: Sequence[str],
                 region: str):
        """
        :param str action_sub_type: The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        :param Sequence[str] instance_ids: The EC2 and RDS instance IDs.
        :param str region: The Region to run the SSM document.
        """
        BudgetActionDefinitionSsmActionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_sub_type=action_sub_type,
            instance_ids=instance_ids,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_sub_type: Optional[str] = None,
             instance_ids: Optional[Sequence[str]] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_sub_type is None and 'actionSubType' in kwargs:
            action_sub_type = kwargs['actionSubType']
        if action_sub_type is None:
            raise TypeError("Missing 'action_sub_type' argument")
        if instance_ids is None and 'instanceIds' in kwargs:
            instance_ids = kwargs['instanceIds']
        if instance_ids is None:
            raise TypeError("Missing 'instance_ids' argument")
        if region is None:
            raise TypeError("Missing 'region' argument")

        _setter("action_sub_type", action_sub_type)
        _setter("instance_ids", instance_ids)
        _setter("region", region)

    @property
    @pulumi.getter(name="actionSubType")
    def action_sub_type(self) -> str:
        """
        The action subType. Valid values are `STOP_EC2_INSTANCES` or `STOP_RDS_INSTANCES`.
        """
        return pulumi.get(self, "action_sub_type")

    @property
    @pulumi.getter(name="instanceIds")
    def instance_ids(self) -> Sequence[str]:
        """
        The EC2 and RDS instance IDs.
        """
        return pulumi.get(self, "instance_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The Region to run the SSM document.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class BudgetActionSubscriber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionType":
            suggest = "subscription_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetActionSubscriber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetActionSubscriber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetActionSubscriber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 subscription_type: str):
        """
        :param str address: The address that AWS sends budget notifications to, either an SNS topic or an email.
        :param str subscription_type: The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        BudgetActionSubscriber._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            subscription_type=subscription_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             subscription_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address is None:
            raise TypeError("Missing 'address' argument")
        if subscription_type is None and 'subscriptionType' in kwargs:
            subscription_type = kwargs['subscriptionType']
        if subscription_type is None:
            raise TypeError("Missing 'subscription_type' argument")

        _setter("address", address)
        _setter("subscription_type", subscription_type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address that AWS sends budget notifications to, either an SNS topic or an email.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="subscriptionType")
    def subscription_type(self) -> str:
        """
        The type of notification that AWS sends to a subscriber. Valid values are `SNS` or `EMAIL`.
        """
        return pulumi.get(self, "subscription_type")


@pulumi.output_type
class BudgetAutoAdjustData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoAdjustType":
            suggest = "auto_adjust_type"
        elif key == "historicalOptions":
            suggest = "historical_options"
        elif key == "lastAutoAdjustTime":
            suggest = "last_auto_adjust_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAutoAdjustData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAutoAdjustData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAutoAdjustData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_adjust_type: str,
                 historical_options: Optional['outputs.BudgetAutoAdjustDataHistoricalOptions'] = None,
                 last_auto_adjust_time: Optional[str] = None):
        BudgetAutoAdjustData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_adjust_type=auto_adjust_type,
            historical_options=historical_options,
            last_auto_adjust_time=last_auto_adjust_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_adjust_type: Optional[str] = None,
             historical_options: Optional['outputs.BudgetAutoAdjustDataHistoricalOptions'] = None,
             last_auto_adjust_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_adjust_type is None and 'autoAdjustType' in kwargs:
            auto_adjust_type = kwargs['autoAdjustType']
        if auto_adjust_type is None:
            raise TypeError("Missing 'auto_adjust_type' argument")
        if historical_options is None and 'historicalOptions' in kwargs:
            historical_options = kwargs['historicalOptions']
        if last_auto_adjust_time is None and 'lastAutoAdjustTime' in kwargs:
            last_auto_adjust_time = kwargs['lastAutoAdjustTime']

        _setter("auto_adjust_type", auto_adjust_type)
        if historical_options is not None:
            _setter("historical_options", historical_options)
        if last_auto_adjust_time is not None:
            _setter("last_auto_adjust_time", last_auto_adjust_time)

    @property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> str:
        return pulumi.get(self, "auto_adjust_type")

    @property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Optional['outputs.BudgetAutoAdjustDataHistoricalOptions']:
        return pulumi.get(self, "historical_options")

    @property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> Optional[str]:
        return pulumi.get(self, "last_auto_adjust_time")


@pulumi.output_type
class BudgetAutoAdjustDataHistoricalOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "budgetAdjustmentPeriod":
            suggest = "budget_adjustment_period"
        elif key == "lookbackAvailablePeriods":
            suggest = "lookback_available_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAutoAdjustDataHistoricalOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAutoAdjustDataHistoricalOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAutoAdjustDataHistoricalOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 budget_adjustment_period: int,
                 lookback_available_periods: Optional[int] = None):
        BudgetAutoAdjustDataHistoricalOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            budget_adjustment_period=budget_adjustment_period,
            lookback_available_periods=lookback_available_periods,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             budget_adjustment_period: Optional[int] = None,
             lookback_available_periods: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if budget_adjustment_period is None and 'budgetAdjustmentPeriod' in kwargs:
            budget_adjustment_period = kwargs['budgetAdjustmentPeriod']
        if budget_adjustment_period is None:
            raise TypeError("Missing 'budget_adjustment_period' argument")
        if lookback_available_periods is None and 'lookbackAvailablePeriods' in kwargs:
            lookback_available_periods = kwargs['lookbackAvailablePeriods']

        _setter("budget_adjustment_period", budget_adjustment_period)
        if lookback_available_periods is not None:
            _setter("lookback_available_periods", lookback_available_periods)

    @property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> int:
        return pulumi.get(self, "budget_adjustment_period")

    @property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> Optional[int]:
        return pulumi.get(self, "lookback_available_periods")


@pulumi.output_type
class BudgetCostFilter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of a budget. Unique within accounts.
        """
        BudgetCostFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a budget. Unique within accounts.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetCostTypes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeCredit":
            suggest = "include_credit"
        elif key == "includeDiscount":
            suggest = "include_discount"
        elif key == "includeOtherSubscription":
            suggest = "include_other_subscription"
        elif key == "includeRecurring":
            suggest = "include_recurring"
        elif key == "includeRefund":
            suggest = "include_refund"
        elif key == "includeSubscription":
            suggest = "include_subscription"
        elif key == "includeSupport":
            suggest = "include_support"
        elif key == "includeTax":
            suggest = "include_tax"
        elif key == "includeUpfront":
            suggest = "include_upfront"
        elif key == "useAmortized":
            suggest = "use_amortized"
        elif key == "useBlended":
            suggest = "use_blended"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetCostTypes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetCostTypes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetCostTypes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_credit: Optional[bool] = None,
                 include_discount: Optional[bool] = None,
                 include_other_subscription: Optional[bool] = None,
                 include_recurring: Optional[bool] = None,
                 include_refund: Optional[bool] = None,
                 include_subscription: Optional[bool] = None,
                 include_support: Optional[bool] = None,
                 include_tax: Optional[bool] = None,
                 include_upfront: Optional[bool] = None,
                 use_amortized: Optional[bool] = None,
                 use_blended: Optional[bool] = None):
        """
        :param bool include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`
        :param bool include_discount: Whether a budget includes discounts. Defaults to `true`
        :param bool include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        :param bool include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        :param bool include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`
        :param bool include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        :param bool include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`
        :param bool include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`
        :param bool include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        :param bool use_amortized: Whether a budget uses the amortized rate. Defaults to `false`
        :param bool use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        BudgetCostTypes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_credit=include_credit,
            include_discount=include_discount,
            include_other_subscription=include_other_subscription,
            include_recurring=include_recurring,
            include_refund=include_refund,
            include_subscription=include_subscription,
            include_support=include_support,
            include_tax=include_tax,
            include_upfront=include_upfront,
            use_amortized=use_amortized,
            use_blended=use_blended,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_credit: Optional[bool] = None,
             include_discount: Optional[bool] = None,
             include_other_subscription: Optional[bool] = None,
             include_recurring: Optional[bool] = None,
             include_refund: Optional[bool] = None,
             include_subscription: Optional[bool] = None,
             include_support: Optional[bool] = None,
             include_tax: Optional[bool] = None,
             include_upfront: Optional[bool] = None,
             use_amortized: Optional[bool] = None,
             use_blended: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if include_credit is None and 'includeCredit' in kwargs:
            include_credit = kwargs['includeCredit']
        if include_discount is None and 'includeDiscount' in kwargs:
            include_discount = kwargs['includeDiscount']
        if include_other_subscription is None and 'includeOtherSubscription' in kwargs:
            include_other_subscription = kwargs['includeOtherSubscription']
        if include_recurring is None and 'includeRecurring' in kwargs:
            include_recurring = kwargs['includeRecurring']
        if include_refund is None and 'includeRefund' in kwargs:
            include_refund = kwargs['includeRefund']
        if include_subscription is None and 'includeSubscription' in kwargs:
            include_subscription = kwargs['includeSubscription']
        if include_support is None and 'includeSupport' in kwargs:
            include_support = kwargs['includeSupport']
        if include_tax is None and 'includeTax' in kwargs:
            include_tax = kwargs['includeTax']
        if include_upfront is None and 'includeUpfront' in kwargs:
            include_upfront = kwargs['includeUpfront']
        if use_amortized is None and 'useAmortized' in kwargs:
            use_amortized = kwargs['useAmortized']
        if use_blended is None and 'useBlended' in kwargs:
            use_blended = kwargs['useBlended']

        if include_credit is not None:
            _setter("include_credit", include_credit)
        if include_discount is not None:
            _setter("include_discount", include_discount)
        if include_other_subscription is not None:
            _setter("include_other_subscription", include_other_subscription)
        if include_recurring is not None:
            _setter("include_recurring", include_recurring)
        if include_refund is not None:
            _setter("include_refund", include_refund)
        if include_subscription is not None:
            _setter("include_subscription", include_subscription)
        if include_support is not None:
            _setter("include_support", include_support)
        if include_tax is not None:
            _setter("include_tax", include_tax)
        if include_upfront is not None:
            _setter("include_upfront", include_upfront)
        if use_amortized is not None:
            _setter("use_amortized", use_amortized)
        if use_blended is not None:
            _setter("use_blended", use_blended)

    @property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> Optional[bool]:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_credit")

    @property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> Optional[bool]:
        """
        Whether a budget includes discounts. Defaults to `true`
        """
        return pulumi.get(self, "include_discount")

    @property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> Optional[bool]:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_other_subscription")

    @property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> Optional[bool]:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_recurring")

    @property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> Optional[bool]:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_refund")

    @property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> Optional[bool]:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_subscription")

    @property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> Optional[bool]:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_support")

    @property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> Optional[bool]:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_tax")

    @property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> Optional[bool]:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`
        """
        return pulumi.get(self, "include_upfront")

    @property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> Optional[bool]:
        """
        Whether a budget uses the amortized rate. Defaults to `false`
        """
        return pulumi.get(self, "use_amortized")

    @property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> Optional[bool]:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`
        """
        return pulumi.get(self, "use_blended")


@pulumi.output_type
class BudgetNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "notificationType":
            suggest = "notification_type"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "subscriberEmailAddresses":
            suggest = "subscriber_email_addresses"
        elif key == "subscriberSnsTopicArns":
            suggest = "subscriber_sns_topic_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 notification_type: str,
                 threshold: float,
                 threshold_type: str,
                 subscriber_email_addresses: Optional[Sequence[str]] = None,
                 subscriber_sns_topic_arns: Optional[Sequence[str]] = None):
        """
        :param str comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param str notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        :param float threshold: (Required) Threshold when the notification should be sent.
        :param str threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        :param Sequence[str] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param Sequence[str] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        BudgetNotification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            notification_type=notification_type,
            threshold=threshold,
            threshold_type=threshold_type,
            subscriber_email_addresses=subscriber_email_addresses,
            subscriber_sns_topic_arns=subscriber_sns_topic_arns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             notification_type: Optional[str] = None,
             threshold: Optional[float] = None,
             threshold_type: Optional[str] = None,
             subscriber_email_addresses: Optional[Sequence[str]] = None,
             subscriber_sns_topic_arns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if notification_type is None and 'notificationType' in kwargs:
            notification_type = kwargs['notificationType']
        if notification_type is None:
            raise TypeError("Missing 'notification_type' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if threshold_type is None and 'thresholdType' in kwargs:
            threshold_type = kwargs['thresholdType']
        if threshold_type is None:
            raise TypeError("Missing 'threshold_type' argument")
        if subscriber_email_addresses is None and 'subscriberEmailAddresses' in kwargs:
            subscriber_email_addresses = kwargs['subscriberEmailAddresses']
        if subscriber_sns_topic_arns is None and 'subscriberSnsTopicArns' in kwargs:
            subscriber_sns_topic_arns = kwargs['subscriberSnsTopicArns']

        _setter("comparison_operator", comparison_operator)
        _setter("notification_type", notification_type)
        _setter("threshold", threshold)
        _setter("threshold_type", threshold_type)
        if subscriber_email_addresses is not None:
            _setter("subscriber_email_addresses", subscriber_email_addresses)
        if subscriber_sns_topic_arns is not None:
            _setter("subscriber_sns_topic_arns", subscriber_sns_topic_arns)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> str:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`
        """
        return pulumi.get(self, "notification_type")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> str:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Optional[Sequence[str]]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Optional[Sequence[str]]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")


@pulumi.output_type
class BudgetPlannedLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetPlannedLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetPlannedLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetPlannedLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amount: str,
                 start_time: str,
                 unit: str):
        """
        :param str amount: (Required) The amount of cost or usage being measured for a budget.
        :param str start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param str unit: (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        BudgetPlannedLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            start_time=start_time,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             start_time: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if unit is None:
            raise TypeError("Missing 'unit' argument")

        _setter("amount", amount)
        _setter("start_time", start_time)
        _setter("unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> str:
        """
        (Required) The amount of cost or usage being measured for a budget.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        (Required) The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See [Spend](http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/data-type-spend.html) documentation.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetAutoAdjustDataResult(dict):
    def __init__(__self__, *,
                 auto_adjust_type: str,
                 historical_options: Sequence['outputs.GetBudgetAutoAdjustDataHistoricalOptionResult'],
                 last_auto_adjust_time: str):
        """
        :param str auto_adjust_type: (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`.
        :param Sequence['GetBudgetAutoAdjustDataHistoricalOptionArgs'] historical_options: (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        :param str last_auto_adjust_time: (Optional) - The last time that your budget was auto-adjusted.
        """
        GetBudgetAutoAdjustDataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_adjust_type=auto_adjust_type,
            historical_options=historical_options,
            last_auto_adjust_time=last_auto_adjust_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_adjust_type: Optional[str] = None,
             historical_options: Optional[Sequence['outputs.GetBudgetAutoAdjustDataHistoricalOptionResult']] = None,
             last_auto_adjust_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_adjust_type is None and 'autoAdjustType' in kwargs:
            auto_adjust_type = kwargs['autoAdjustType']
        if auto_adjust_type is None:
            raise TypeError("Missing 'auto_adjust_type' argument")
        if historical_options is None and 'historicalOptions' in kwargs:
            historical_options = kwargs['historicalOptions']
        if historical_options is None:
            raise TypeError("Missing 'historical_options' argument")
        if last_auto_adjust_time is None and 'lastAutoAdjustTime' in kwargs:
            last_auto_adjust_time = kwargs['lastAutoAdjustTime']
        if last_auto_adjust_time is None:
            raise TypeError("Missing 'last_auto_adjust_time' argument")

        _setter("auto_adjust_type", auto_adjust_type)
        _setter("historical_options", historical_options)
        _setter("last_auto_adjust_time", last_auto_adjust_time)

    @property
    @pulumi.getter(name="autoAdjustType")
    def auto_adjust_type(self) -> str:
        """
        (Required) - The string that defines whether your budget auto-adjusts based on historical or forecasted data. Valid values: `FORECAST`,`HISTORICAL`.
        """
        return pulumi.get(self, "auto_adjust_type")

    @property
    @pulumi.getter(name="historicalOptions")
    def historical_options(self) -> Sequence['outputs.GetBudgetAutoAdjustDataHistoricalOptionResult']:
        """
        (Optional) - Configuration block of Historical Options. Required for `auto_adjust_type` of `HISTORICAL` Configuration block that defines the historical data that your auto-adjusting budget is based on.
        """
        return pulumi.get(self, "historical_options")

    @property
    @pulumi.getter(name="lastAutoAdjustTime")
    def last_auto_adjust_time(self) -> str:
        """
        (Optional) - The last time that your budget was auto-adjusted.
        """
        return pulumi.get(self, "last_auto_adjust_time")


@pulumi.output_type
class GetBudgetAutoAdjustDataHistoricalOptionResult(dict):
    def __init__(__self__, *,
                 budget_adjustment_period: int,
                 lookback_available_periods: int):
        """
        :param int budget_adjustment_period: (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        :param int lookback_available_periods: (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        GetBudgetAutoAdjustDataHistoricalOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            budget_adjustment_period=budget_adjustment_period,
            lookback_available_periods=lookback_available_periods,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             budget_adjustment_period: Optional[int] = None,
             lookback_available_periods: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if budget_adjustment_period is None and 'budgetAdjustmentPeriod' in kwargs:
            budget_adjustment_period = kwargs['budgetAdjustmentPeriod']
        if budget_adjustment_period is None:
            raise TypeError("Missing 'budget_adjustment_period' argument")
        if lookback_available_periods is None and 'lookbackAvailablePeriods' in kwargs:
            lookback_available_periods = kwargs['lookbackAvailablePeriods']
        if lookback_available_periods is None:
            raise TypeError("Missing 'lookback_available_periods' argument")

        _setter("budget_adjustment_period", budget_adjustment_period)
        _setter("lookback_available_periods", lookback_available_periods)

    @property
    @pulumi.getter(name="budgetAdjustmentPeriod")
    def budget_adjustment_period(self) -> int:
        """
        (Required) - The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount.
        """
        return pulumi.get(self, "budget_adjustment_period")

    @property
    @pulumi.getter(name="lookbackAvailablePeriods")
    def lookback_available_periods(self) -> int:
        """
        (Optional) - The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current budget limit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the `budget_adjustment_period` and your historical cost data.
        """
        return pulumi.get(self, "lookback_available_periods")


@pulumi.output_type
class GetBudgetBudgetLimitResult(dict):
    def __init__(__self__, *,
                 amount: str,
                 unit: str):
        """
        :param str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        GetBudgetBudgetLimitResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if unit is None:
            raise TypeError("Missing 'unit' argument")

        _setter("amount", amount)
        _setter("unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetCalculatedSpendResult(dict):
    def __init__(__self__, *,
                 actual_spends: Sequence['outputs.GetBudgetCalculatedSpendActualSpendResult']):
        GetBudgetCalculatedSpendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_spends=actual_spends,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_spends: Optional[Sequence['outputs.GetBudgetCalculatedSpendActualSpendResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actual_spends is None and 'actualSpends' in kwargs:
            actual_spends = kwargs['actualSpends']
        if actual_spends is None:
            raise TypeError("Missing 'actual_spends' argument")

        _setter("actual_spends", actual_spends)

    @property
    @pulumi.getter(name="actualSpends")
    def actual_spends(self) -> Sequence['outputs.GetBudgetCalculatedSpendActualSpendResult']:
        return pulumi.get(self, "actual_spends")


@pulumi.output_type
class GetBudgetCalculatedSpendActualSpendResult(dict):
    def __init__(__self__, *,
                 amount: str,
                 unit: str):
        """
        :param str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        GetBudgetCalculatedSpendActualSpendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if unit is None:
            raise TypeError("Missing 'unit' argument")

        _setter("amount", amount)
        _setter("unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetBudgetCostFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of a budget. Unique within accounts.
               
               The following arguments are optional:
        """
        GetBudgetCostFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a budget. Unique within accounts.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBudgetCostTypeResult(dict):
    def __init__(__self__, *,
                 include_credit: bool,
                 include_discount: bool,
                 include_other_subscription: bool,
                 include_recurring: bool,
                 include_refund: bool,
                 include_subscription: bool,
                 include_support: bool,
                 include_tax: bool,
                 include_upfront: bool,
                 use_amortized: bool,
                 use_blended: bool):
        """
        :param bool include_credit: A boolean value whether to include credits in the cost budget. Defaults to `true`.
        :param bool include_discount: Whether a budget includes discounts. Defaults to `true`.
        :param bool include_other_subscription: A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`.
        :param bool include_recurring: A boolean value whether to include recurring costs in the cost budget. Defaults to `true`.
        :param bool include_refund: A boolean value whether to include refunds in the cost budget. Defaults to `true`.
        :param bool include_subscription: A boolean value whether to include subscriptions in the cost budget. Defaults to `true`.
        :param bool include_support: A boolean value whether to include support costs in the cost budget. Defaults to `true`.
        :param bool include_tax: A boolean value whether to include tax in the cost budget. Defaults to `true`.
        :param bool include_upfront: A boolean value whether to include upfront costs in the cost budget. Defaults to `true`.
        :param bool use_amortized: Whether a budget uses the amortized rate. Defaults to `false`.
        :param bool use_blended: A boolean value whether to use blended costs in the cost budget. Defaults to `false`.
        """
        GetBudgetCostTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_credit=include_credit,
            include_discount=include_discount,
            include_other_subscription=include_other_subscription,
            include_recurring=include_recurring,
            include_refund=include_refund,
            include_subscription=include_subscription,
            include_support=include_support,
            include_tax=include_tax,
            include_upfront=include_upfront,
            use_amortized=use_amortized,
            use_blended=use_blended,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_credit: Optional[bool] = None,
             include_discount: Optional[bool] = None,
             include_other_subscription: Optional[bool] = None,
             include_recurring: Optional[bool] = None,
             include_refund: Optional[bool] = None,
             include_subscription: Optional[bool] = None,
             include_support: Optional[bool] = None,
             include_tax: Optional[bool] = None,
             include_upfront: Optional[bool] = None,
             use_amortized: Optional[bool] = None,
             use_blended: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if include_credit is None and 'includeCredit' in kwargs:
            include_credit = kwargs['includeCredit']
        if include_credit is None:
            raise TypeError("Missing 'include_credit' argument")
        if include_discount is None and 'includeDiscount' in kwargs:
            include_discount = kwargs['includeDiscount']
        if include_discount is None:
            raise TypeError("Missing 'include_discount' argument")
        if include_other_subscription is None and 'includeOtherSubscription' in kwargs:
            include_other_subscription = kwargs['includeOtherSubscription']
        if include_other_subscription is None:
            raise TypeError("Missing 'include_other_subscription' argument")
        if include_recurring is None and 'includeRecurring' in kwargs:
            include_recurring = kwargs['includeRecurring']
        if include_recurring is None:
            raise TypeError("Missing 'include_recurring' argument")
        if include_refund is None and 'includeRefund' in kwargs:
            include_refund = kwargs['includeRefund']
        if include_refund is None:
            raise TypeError("Missing 'include_refund' argument")
        if include_subscription is None and 'includeSubscription' in kwargs:
            include_subscription = kwargs['includeSubscription']
        if include_subscription is None:
            raise TypeError("Missing 'include_subscription' argument")
        if include_support is None and 'includeSupport' in kwargs:
            include_support = kwargs['includeSupport']
        if include_support is None:
            raise TypeError("Missing 'include_support' argument")
        if include_tax is None and 'includeTax' in kwargs:
            include_tax = kwargs['includeTax']
        if include_tax is None:
            raise TypeError("Missing 'include_tax' argument")
        if include_upfront is None and 'includeUpfront' in kwargs:
            include_upfront = kwargs['includeUpfront']
        if include_upfront is None:
            raise TypeError("Missing 'include_upfront' argument")
        if use_amortized is None and 'useAmortized' in kwargs:
            use_amortized = kwargs['useAmortized']
        if use_amortized is None:
            raise TypeError("Missing 'use_amortized' argument")
        if use_blended is None and 'useBlended' in kwargs:
            use_blended = kwargs['useBlended']
        if use_blended is None:
            raise TypeError("Missing 'use_blended' argument")

        _setter("include_credit", include_credit)
        _setter("include_discount", include_discount)
        _setter("include_other_subscription", include_other_subscription)
        _setter("include_recurring", include_recurring)
        _setter("include_refund", include_refund)
        _setter("include_subscription", include_subscription)
        _setter("include_support", include_support)
        _setter("include_tax", include_tax)
        _setter("include_upfront", include_upfront)
        _setter("use_amortized", use_amortized)
        _setter("use_blended", use_blended)

    @property
    @pulumi.getter(name="includeCredit")
    def include_credit(self) -> bool:
        """
        A boolean value whether to include credits in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_credit")

    @property
    @pulumi.getter(name="includeDiscount")
    def include_discount(self) -> bool:
        """
        Whether a budget includes discounts. Defaults to `true`.
        """
        return pulumi.get(self, "include_discount")

    @property
    @pulumi.getter(name="includeOtherSubscription")
    def include_other_subscription(self) -> bool:
        """
        A boolean value whether to include other subscription costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_other_subscription")

    @property
    @pulumi.getter(name="includeRecurring")
    def include_recurring(self) -> bool:
        """
        A boolean value whether to include recurring costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_recurring")

    @property
    @pulumi.getter(name="includeRefund")
    def include_refund(self) -> bool:
        """
        A boolean value whether to include refunds in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_refund")

    @property
    @pulumi.getter(name="includeSubscription")
    def include_subscription(self) -> bool:
        """
        A boolean value whether to include subscriptions in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_subscription")

    @property
    @pulumi.getter(name="includeSupport")
    def include_support(self) -> bool:
        """
        A boolean value whether to include support costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_support")

    @property
    @pulumi.getter(name="includeTax")
    def include_tax(self) -> bool:
        """
        A boolean value whether to include tax in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_tax")

    @property
    @pulumi.getter(name="includeUpfront")
    def include_upfront(self) -> bool:
        """
        A boolean value whether to include upfront costs in the cost budget. Defaults to `true`.
        """
        return pulumi.get(self, "include_upfront")

    @property
    @pulumi.getter(name="useAmortized")
    def use_amortized(self) -> bool:
        """
        Whether a budget uses the amortized rate. Defaults to `false`.
        """
        return pulumi.get(self, "use_amortized")

    @property
    @pulumi.getter(name="useBlended")
    def use_blended(self) -> bool:
        """
        A boolean value whether to use blended costs in the cost budget. Defaults to `false`.
        """
        return pulumi.get(self, "use_blended")


@pulumi.output_type
class GetBudgetNotificationResult(dict):
    def __init__(__self__, *,
                 comparison_operator: str,
                 notification_type: str,
                 subscriber_email_addresses: Sequence[str],
                 subscriber_sns_topic_arns: Sequence[str],
                 threshold: float,
                 threshold_type: str):
        """
        :param str comparison_operator: (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        :param str notification_type: (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`.
        :param Sequence[str] subscriber_email_addresses: (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        :param Sequence[str] subscriber_sns_topic_arns: (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        :param float threshold: (Required) Threshold when the notification should be sent.
        :param str threshold_type: (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        GetBudgetNotificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            notification_type=notification_type,
            subscriber_email_addresses=subscriber_email_addresses,
            subscriber_sns_topic_arns=subscriber_sns_topic_arns,
            threshold=threshold,
            threshold_type=threshold_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             notification_type: Optional[str] = None,
             subscriber_email_addresses: Optional[Sequence[str]] = None,
             subscriber_sns_topic_arns: Optional[Sequence[str]] = None,
             threshold: Optional[float] = None,
             threshold_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if notification_type is None and 'notificationType' in kwargs:
            notification_type = kwargs['notificationType']
        if notification_type is None:
            raise TypeError("Missing 'notification_type' argument")
        if subscriber_email_addresses is None and 'subscriberEmailAddresses' in kwargs:
            subscriber_email_addresses = kwargs['subscriberEmailAddresses']
        if subscriber_email_addresses is None:
            raise TypeError("Missing 'subscriber_email_addresses' argument")
        if subscriber_sns_topic_arns is None and 'subscriberSnsTopicArns' in kwargs:
            subscriber_sns_topic_arns = kwargs['subscriberSnsTopicArns']
        if subscriber_sns_topic_arns is None:
            raise TypeError("Missing 'subscriber_sns_topic_arns' argument")
        if threshold is None:
            raise TypeError("Missing 'threshold' argument")
        if threshold_type is None and 'thresholdType' in kwargs:
            threshold_type = kwargs['thresholdType']
        if threshold_type is None:
            raise TypeError("Missing 'threshold_type' argument")

        _setter("comparison_operator", comparison_operator)
        _setter("notification_type", notification_type)
        _setter("subscriber_email_addresses", subscriber_email_addresses)
        _setter("subscriber_sns_topic_arns", subscriber_sns_topic_arns)
        _setter("threshold", threshold)
        _setter("threshold_type", threshold_type)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        (Required) Comparison operator to use to evaluate the condition. Can be `LESS_THAN`, `EQUAL_TO` or `GREATER_THAN`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> str:
        """
        (Required) What kind of budget value to notify on. Can be `ACTUAL` or `FORECASTED`.
        """
        return pulumi.get(self, "notification_type")

    @property
    @pulumi.getter(name="subscriberEmailAddresses")
    def subscriber_email_addresses(self) -> Sequence[str]:
        """
        (Optional) E-Mail addresses to notify. Either this or `subscriber_sns_topic_arns` is required.
        """
        return pulumi.get(self, "subscriber_email_addresses")

    @property
    @pulumi.getter(name="subscriberSnsTopicArns")
    def subscriber_sns_topic_arns(self) -> Sequence[str]:
        """
        (Optional) SNS topics to notify. Either this or `subscriber_email_addresses` is required.
        """
        return pulumi.get(self, "subscriber_sns_topic_arns")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        (Required) Threshold when the notification should be sent.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> str:
        """
        (Required) What kind of threshold is defined. Can be `PERCENTAGE` OR `ABSOLUTE_VALUE`.
        """
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class GetBudgetPlannedLimitResult(dict):
    def __init__(__self__, *,
                 amount: str,
                 start_time: str,
                 unit: str):
        """
        :param str amount: The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        :param str start_time: (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        :param str unit: The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        GetBudgetPlannedLimitResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amount=amount,
            start_time=start_time,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amount: Optional[str] = None,
             start_time: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amount is None:
            raise TypeError("Missing 'amount' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")
        if unit is None:
            raise TypeError("Missing 'unit' argument")

        _setter("amount", amount)
        _setter("start_time", start_time)
        _setter("unit", unit)

    @property
    @pulumi.getter
    def amount(self) -> str:
        """
        The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        (Required) The start time of the budget limit. Format: `2017-01-01_12:00`. See [PlannedBudgetLimits](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_budgets_Budget.html#awscostmanagement-Type-budgets_Budget-PlannedBudgetLimits) documentation.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP. Length Constraints: Minimum length of `1`. Maximum length of `2147483647`.
        """
        return pulumi.get(self, "unit")


