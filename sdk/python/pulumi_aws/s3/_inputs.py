# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from .. import iam
from .. import iam as _iam
from ._enums import *

__all__ = [
    'AccessPointPublicAccessBlockConfigurationArgs',
    'AccessPointPublicAccessBlockConfigurationArgsDict',
    'AccessPointVpcConfigurationArgs',
    'AccessPointVpcConfigurationArgsDict',
    'AnalyticsConfigurationFilterArgs',
    'AnalyticsConfigurationFilterArgsDict',
    'AnalyticsConfigurationStorageClassAnalysisArgs',
    'AnalyticsConfigurationStorageClassAnalysisArgsDict',
    'AnalyticsConfigurationStorageClassAnalysisDataExportArgs',
    'AnalyticsConfigurationStorageClassAnalysisDataExportArgsDict',
    'AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs',
    'AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgsDict',
    'AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs',
    'AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgsDict',
    'BucketAclAccessControlPolicyArgs',
    'BucketAclAccessControlPolicyArgsDict',
    'BucketAclAccessControlPolicyGrantArgs',
    'BucketAclAccessControlPolicyGrantArgsDict',
    'BucketAclAccessControlPolicyGrantGranteeArgs',
    'BucketAclAccessControlPolicyGrantGranteeArgsDict',
    'BucketAclAccessControlPolicyOwnerArgs',
    'BucketAclAccessControlPolicyOwnerArgsDict',
    'BucketAclV2AccessControlPolicyArgs',
    'BucketAclV2AccessControlPolicyArgsDict',
    'BucketAclV2AccessControlPolicyGrantArgs',
    'BucketAclV2AccessControlPolicyGrantArgsDict',
    'BucketAclV2AccessControlPolicyGrantGranteeArgs',
    'BucketAclV2AccessControlPolicyGrantGranteeArgsDict',
    'BucketAclV2AccessControlPolicyOwnerArgs',
    'BucketAclV2AccessControlPolicyOwnerArgsDict',
    'BucketCorsConfigurationCorsRuleArgs',
    'BucketCorsConfigurationCorsRuleArgsDict',
    'BucketCorsConfigurationV2CorsRuleArgs',
    'BucketCorsConfigurationV2CorsRuleArgsDict',
    'BucketCorsRuleArgs',
    'BucketCorsRuleArgsDict',
    'BucketGrantArgs',
    'BucketGrantArgsDict',
    'BucketIntelligentTieringConfigurationFilterArgs',
    'BucketIntelligentTieringConfigurationFilterArgsDict',
    'BucketIntelligentTieringConfigurationTieringArgs',
    'BucketIntelligentTieringConfigurationTieringArgsDict',
    'BucketLifecycleConfigurationRuleArgs',
    'BucketLifecycleConfigurationRuleArgsDict',
    'BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs',
    'BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict',
    'BucketLifecycleConfigurationRuleExpirationArgs',
    'BucketLifecycleConfigurationRuleExpirationArgsDict',
    'BucketLifecycleConfigurationRuleFilterArgs',
    'BucketLifecycleConfigurationRuleFilterArgsDict',
    'BucketLifecycleConfigurationRuleFilterAndArgs',
    'BucketLifecycleConfigurationRuleFilterAndArgsDict',
    'BucketLifecycleConfigurationRuleFilterTagArgs',
    'BucketLifecycleConfigurationRuleFilterTagArgsDict',
    'BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs',
    'BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict',
    'BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs',
    'BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgsDict',
    'BucketLifecycleConfigurationRuleTransitionArgs',
    'BucketLifecycleConfigurationRuleTransitionArgsDict',
    'BucketLifecycleConfigurationTimeoutsArgs',
    'BucketLifecycleConfigurationTimeoutsArgsDict',
    'BucketLifecycleConfigurationV2RuleArgs',
    'BucketLifecycleConfigurationV2RuleArgsDict',
    'BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs',
    'BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgsDict',
    'BucketLifecycleConfigurationV2RuleExpirationArgs',
    'BucketLifecycleConfigurationV2RuleExpirationArgsDict',
    'BucketLifecycleConfigurationV2RuleFilterArgs',
    'BucketLifecycleConfigurationV2RuleFilterArgsDict',
    'BucketLifecycleConfigurationV2RuleFilterAndArgs',
    'BucketLifecycleConfigurationV2RuleFilterAndArgsDict',
    'BucketLifecycleConfigurationV2RuleFilterTagArgs',
    'BucketLifecycleConfigurationV2RuleFilterTagArgsDict',
    'BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs',
    'BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgsDict',
    'BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs',
    'BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgsDict',
    'BucketLifecycleConfigurationV2RuleTransitionArgs',
    'BucketLifecycleConfigurationV2RuleTransitionArgsDict',
    'BucketLifecycleConfigurationV2TimeoutsArgs',
    'BucketLifecycleConfigurationV2TimeoutsArgsDict',
    'BucketLifecycleRuleArgs',
    'BucketLifecycleRuleArgsDict',
    'BucketLifecycleRuleExpirationArgs',
    'BucketLifecycleRuleExpirationArgsDict',
    'BucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'BucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'BucketLifecycleRuleNoncurrentVersionTransitionArgs',
    'BucketLifecycleRuleNoncurrentVersionTransitionArgsDict',
    'BucketLifecycleRuleTransitionArgs',
    'BucketLifecycleRuleTransitionArgsDict',
    'BucketLoggingArgs',
    'BucketLoggingArgsDict',
    'BucketLoggingTargetGrantArgs',
    'BucketLoggingTargetGrantArgsDict',
    'BucketLoggingTargetGrantGranteeArgs',
    'BucketLoggingTargetGrantGranteeArgsDict',
    'BucketLoggingTargetObjectKeyFormatArgs',
    'BucketLoggingTargetObjectKeyFormatArgsDict',
    'BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs',
    'BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgsDict',
    'BucketLoggingTargetObjectKeyFormatSimplePrefixArgs',
    'BucketLoggingTargetObjectKeyFormatSimplePrefixArgsDict',
    'BucketLoggingV2TargetGrantArgs',
    'BucketLoggingV2TargetGrantArgsDict',
    'BucketLoggingV2TargetGrantGranteeArgs',
    'BucketLoggingV2TargetGrantGranteeArgsDict',
    'BucketLoggingV2TargetObjectKeyFormatArgs',
    'BucketLoggingV2TargetObjectKeyFormatArgsDict',
    'BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs',
    'BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgsDict',
    'BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs',
    'BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationArgs',
    'BucketMetadataConfigurationMetadataConfigurationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationDestinationArgs',
    'BucketMetadataConfigurationMetadataConfigurationDestinationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs',
    'BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs',
    'BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgsDict',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs',
    'BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgsDict',
    'BucketMetadataConfigurationTimeoutsArgs',
    'BucketMetadataConfigurationTimeoutsArgsDict',
    'BucketMetricFilterArgs',
    'BucketMetricFilterArgsDict',
    'BucketNotificationLambdaFunctionArgs',
    'BucketNotificationLambdaFunctionArgsDict',
    'BucketNotificationQueueArgs',
    'BucketNotificationQueueArgsDict',
    'BucketNotificationTopicArgs',
    'BucketNotificationTopicArgsDict',
    'BucketObjectLockConfigurationArgs',
    'BucketObjectLockConfigurationArgsDict',
    'BucketObjectLockConfigurationRuleArgs',
    'BucketObjectLockConfigurationRuleArgsDict',
    'BucketObjectLockConfigurationRuleDefaultRetentionArgs',
    'BucketObjectLockConfigurationRuleDefaultRetentionArgsDict',
    'BucketObjectLockConfigurationV2RuleArgs',
    'BucketObjectLockConfigurationV2RuleArgsDict',
    'BucketObjectLockConfigurationV2RuleDefaultRetentionArgs',
    'BucketObjectLockConfigurationV2RuleDefaultRetentionArgsDict',
    'BucketObjectv2OverrideProviderArgs',
    'BucketObjectv2OverrideProviderArgsDict',
    'BucketObjectv2OverrideProviderDefaultTagsArgs',
    'BucketObjectv2OverrideProviderDefaultTagsArgsDict',
    'BucketOwnershipControlsRuleArgs',
    'BucketOwnershipControlsRuleArgsDict',
    'BucketReplicationConfigRuleArgs',
    'BucketReplicationConfigRuleArgsDict',
    'BucketReplicationConfigRuleDeleteMarkerReplicationArgs',
    'BucketReplicationConfigRuleDeleteMarkerReplicationArgsDict',
    'BucketReplicationConfigRuleDestinationArgs',
    'BucketReplicationConfigRuleDestinationArgsDict',
    'BucketReplicationConfigRuleDestinationAccessControlTranslationArgs',
    'BucketReplicationConfigRuleDestinationAccessControlTranslationArgsDict',
    'BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs',
    'BucketReplicationConfigRuleDestinationEncryptionConfigurationArgsDict',
    'BucketReplicationConfigRuleDestinationMetricsArgs',
    'BucketReplicationConfigRuleDestinationMetricsArgsDict',
    'BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs',
    'BucketReplicationConfigRuleDestinationMetricsEventThresholdArgsDict',
    'BucketReplicationConfigRuleDestinationReplicationTimeArgs',
    'BucketReplicationConfigRuleDestinationReplicationTimeArgsDict',
    'BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs',
    'BucketReplicationConfigRuleDestinationReplicationTimeTimeArgsDict',
    'BucketReplicationConfigRuleExistingObjectReplicationArgs',
    'BucketReplicationConfigRuleExistingObjectReplicationArgsDict',
    'BucketReplicationConfigRuleFilterArgs',
    'BucketReplicationConfigRuleFilterArgsDict',
    'BucketReplicationConfigRuleFilterAndArgs',
    'BucketReplicationConfigRuleFilterAndArgsDict',
    'BucketReplicationConfigRuleFilterTagArgs',
    'BucketReplicationConfigRuleFilterTagArgsDict',
    'BucketReplicationConfigRuleSourceSelectionCriteriaArgs',
    'BucketReplicationConfigRuleSourceSelectionCriteriaArgsDict',
    'BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs',
    'BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgsDict',
    'BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs',
    'BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict',
    'BucketReplicationConfigurationArgs',
    'BucketReplicationConfigurationArgsDict',
    'BucketReplicationConfigurationRuleArgs',
    'BucketReplicationConfigurationRuleArgsDict',
    'BucketReplicationConfigurationRuleDestinationArgs',
    'BucketReplicationConfigurationRuleDestinationArgsDict',
    'BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs',
    'BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict',
    'BucketReplicationConfigurationRuleDestinationMetricsArgs',
    'BucketReplicationConfigurationRuleDestinationMetricsArgsDict',
    'BucketReplicationConfigurationRuleDestinationReplicationTimeArgs',
    'BucketReplicationConfigurationRuleDestinationReplicationTimeArgsDict',
    'BucketReplicationConfigurationRuleFilterArgs',
    'BucketReplicationConfigurationRuleFilterArgsDict',
    'BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs',
    'BucketReplicationConfigurationRuleSourceSelectionCriteriaArgsDict',
    'BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs',
    'BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict',
    'BucketServerSideEncryptionConfigurationArgs',
    'BucketServerSideEncryptionConfigurationArgsDict',
    'BucketServerSideEncryptionConfigurationRuleArgs',
    'BucketServerSideEncryptionConfigurationRuleArgsDict',
    'BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs',
    'BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict',
    'BucketServerSideEncryptionConfigurationV2RuleArgs',
    'BucketServerSideEncryptionConfigurationV2RuleArgsDict',
    'BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs',
    'BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgsDict',
    'BucketV2CorsRuleArgs',
    'BucketV2CorsRuleArgsDict',
    'BucketV2GrantArgs',
    'BucketV2GrantArgsDict',
    'BucketV2LifecycleRuleArgs',
    'BucketV2LifecycleRuleArgsDict',
    'BucketV2LifecycleRuleExpirationArgs',
    'BucketV2LifecycleRuleExpirationArgsDict',
    'BucketV2LifecycleRuleNoncurrentVersionExpirationArgs',
    'BucketV2LifecycleRuleNoncurrentVersionExpirationArgsDict',
    'BucketV2LifecycleRuleNoncurrentVersionTransitionArgs',
    'BucketV2LifecycleRuleNoncurrentVersionTransitionArgsDict',
    'BucketV2LifecycleRuleTransitionArgs',
    'BucketV2LifecycleRuleTransitionArgsDict',
    'BucketV2LoggingArgs',
    'BucketV2LoggingArgsDict',
    'BucketV2ObjectLockConfigurationArgs',
    'BucketV2ObjectLockConfigurationArgsDict',
    'BucketV2ObjectLockConfigurationRuleArgs',
    'BucketV2ObjectLockConfigurationRuleArgsDict',
    'BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs',
    'BucketV2ObjectLockConfigurationRuleDefaultRetentionArgsDict',
    'BucketV2ReplicationConfigurationArgs',
    'BucketV2ReplicationConfigurationArgsDict',
    'BucketV2ReplicationConfigurationRuleArgs',
    'BucketV2ReplicationConfigurationRuleArgsDict',
    'BucketV2ReplicationConfigurationRuleDestinationArgs',
    'BucketV2ReplicationConfigurationRuleDestinationArgsDict',
    'BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs',
    'BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict',
    'BucketV2ReplicationConfigurationRuleDestinationMetricArgs',
    'BucketV2ReplicationConfigurationRuleDestinationMetricArgsDict',
    'BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs',
    'BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgsDict',
    'BucketV2ReplicationConfigurationRuleFilterArgs',
    'BucketV2ReplicationConfigurationRuleFilterArgsDict',
    'BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs',
    'BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgsDict',
    'BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs',
    'BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgsDict',
    'BucketV2ServerSideEncryptionConfigurationArgs',
    'BucketV2ServerSideEncryptionConfigurationArgsDict',
    'BucketV2ServerSideEncryptionConfigurationRuleArgs',
    'BucketV2ServerSideEncryptionConfigurationRuleArgsDict',
    'BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs',
    'BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict',
    'BucketV2VersioningArgs',
    'BucketV2VersioningArgsDict',
    'BucketV2WebsiteArgs',
    'BucketV2WebsiteArgsDict',
    'BucketVersioningArgs',
    'BucketVersioningArgsDict',
    'BucketVersioningV2VersioningConfigurationArgs',
    'BucketVersioningV2VersioningConfigurationArgsDict',
    'BucketVersioningVersioningConfigurationArgs',
    'BucketVersioningVersioningConfigurationArgsDict',
    'BucketWebsiteArgs',
    'BucketWebsiteArgsDict',
    'BucketWebsiteConfigurationErrorDocumentArgs',
    'BucketWebsiteConfigurationErrorDocumentArgsDict',
    'BucketWebsiteConfigurationIndexDocumentArgs',
    'BucketWebsiteConfigurationIndexDocumentArgsDict',
    'BucketWebsiteConfigurationRedirectAllRequestsToArgs',
    'BucketWebsiteConfigurationRedirectAllRequestsToArgsDict',
    'BucketWebsiteConfigurationRoutingRuleArgs',
    'BucketWebsiteConfigurationRoutingRuleArgsDict',
    'BucketWebsiteConfigurationRoutingRuleConditionArgs',
    'BucketWebsiteConfigurationRoutingRuleConditionArgsDict',
    'BucketWebsiteConfigurationRoutingRuleRedirectArgs',
    'BucketWebsiteConfigurationRoutingRuleRedirectArgsDict',
    'BucketWebsiteConfigurationV2ErrorDocumentArgs',
    'BucketWebsiteConfigurationV2ErrorDocumentArgsDict',
    'BucketWebsiteConfigurationV2IndexDocumentArgs',
    'BucketWebsiteConfigurationV2IndexDocumentArgsDict',
    'BucketWebsiteConfigurationV2RedirectAllRequestsToArgs',
    'BucketWebsiteConfigurationV2RedirectAllRequestsToArgsDict',
    'BucketWebsiteConfigurationV2RoutingRuleArgs',
    'BucketWebsiteConfigurationV2RoutingRuleArgsDict',
    'BucketWebsiteConfigurationV2RoutingRuleConditionArgs',
    'BucketWebsiteConfigurationV2RoutingRuleConditionArgsDict',
    'BucketWebsiteConfigurationV2RoutingRuleRedirectArgs',
    'BucketWebsiteConfigurationV2RoutingRuleRedirectArgsDict',
    'DirectoryBucketLocationArgs',
    'DirectoryBucketLocationArgsDict',
    'InventoryDestinationArgs',
    'InventoryDestinationArgsDict',
    'InventoryDestinationBucketArgs',
    'InventoryDestinationBucketArgsDict',
    'InventoryDestinationBucketEncryptionArgs',
    'InventoryDestinationBucketEncryptionArgsDict',
    'InventoryDestinationBucketEncryptionSseKmsArgs',
    'InventoryDestinationBucketEncryptionSseKmsArgsDict',
    'InventoryDestinationBucketEncryptionSseS3Args',
    'InventoryDestinationBucketEncryptionSseS3ArgsDict',
    'InventoryFilterArgs',
    'InventoryFilterArgsDict',
    'InventoryScheduleArgs',
    'InventoryScheduleArgsDict',
    'ObjectCopyGrantArgs',
    'ObjectCopyGrantArgsDict',
    'ObjectCopyOverrideProviderArgs',
    'ObjectCopyOverrideProviderArgsDict',
    'ObjectCopyOverrideProviderDefaultTagsArgs',
    'ObjectCopyOverrideProviderDefaultTagsArgsDict',
    'PolicyDocumentArgs',
    'PolicyDocumentArgsDict',
]

MYPY = False

if not MYPY:
    class AccessPointPublicAccessBlockConfigurationArgsDict(TypedDict):
        block_public_acls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing policies or ACLs. When set to `true` causes the following behavior:
        * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
        * PUT Object calls fail if the request includes a public ACL.
        * PUT Bucket calls fail if the request includes a public ACL.
        """
        block_public_policy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing bucket policies. When set to `true` causes Amazon S3 to:
        * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
        """
        ignore_public_acls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to `true` causes Amazon S3 to:
        * Ignore all public ACLs on buckets in this account and any objects that they contain.
        """
        restrict_public_buckets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to `true`:
        * Only the bucket owner and AWS Services can access buckets with public policies.
        """
elif False:
    AccessPointPublicAccessBlockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPointPublicAccessBlockConfigurationArgs:
    def __init__(__self__, *,
                 block_public_acls: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_public_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_public_acls: Optional[pulumi.Input[_builtins.bool]] = None,
                 restrict_public_buckets: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] block_public_acls: Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing policies or ACLs. When set to `true` causes the following behavior:
               * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
               * PUT Object calls fail if the request includes a public ACL.
               * PUT Bucket calls fail if the request includes a public ACL.
        :param pulumi.Input[_builtins.bool] block_public_policy: Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing bucket policies. When set to `true` causes Amazon S3 to:
               * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
        :param pulumi.Input[_builtins.bool] ignore_public_acls: Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to `true` causes Amazon S3 to:
               * Ignore all public ACLs on buckets in this account and any objects that they contain.
        :param pulumi.Input[_builtins.bool] restrict_public_buckets: Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to `true`:
               * Only the bucket owner and AWS Services can access buckets with public policies.
        """
        if block_public_acls is not None:
            pulumi.set(__self__, "block_public_acls", block_public_acls)
        if block_public_policy is not None:
            pulumi.set(__self__, "block_public_policy", block_public_policy)
        if ignore_public_acls is not None:
            pulumi.set(__self__, "ignore_public_acls", ignore_public_acls)
        if restrict_public_buckets is not None:
            pulumi.set(__self__, "restrict_public_buckets", restrict_public_buckets)

    @_builtins.property
    @pulumi.getter(name="blockPublicAcls")
    def block_public_acls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing policies or ACLs. When set to `true` causes the following behavior:
        * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
        * PUT Object calls fail if the request includes a public ACL.
        * PUT Bucket calls fail if the request includes a public ACL.
        """
        return pulumi.get(self, "block_public_acls")

    @block_public_acls.setter
    def block_public_acls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_public_acls", value)

    @_builtins.property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect existing bucket policies. When set to `true` causes Amazon S3 to:
        * Reject calls to PUT Bucket policy if the specified bucket policy allows public access.
        """
        return pulumi.get(self, "block_public_policy")

    @block_public_policy.setter
    def block_public_policy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_public_policy", value)

    @_builtins.property
    @pulumi.getter(name="ignorePublicAcls")
    def ignore_public_acls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to `true`. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to `true` causes Amazon S3 to:
        * Ignore all public ACLs on buckets in this account and any objects that they contain.
        """
        return pulumi.get(self, "ignore_public_acls")

    @ignore_public_acls.setter
    def ignore_public_acls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_public_acls", value)

    @_builtins.property
    @pulumi.getter(name="restrictPublicBuckets")
    def restrict_public_buckets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to `true`. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to `true`:
        * Only the bucket owner and AWS Services can access buckets with public policies.
        """
        return pulumi.get(self, "restrict_public_buckets")

    @restrict_public_buckets.setter
    def restrict_public_buckets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restrict_public_buckets", value)


if not MYPY:
    class AccessPointVpcConfigurationArgsDict(TypedDict):
        vpc_id: pulumi.Input[_builtins.str]
        """
        This access point will only allow connections from the specified VPC ID.
        """
elif False:
    AccessPointVpcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPointVpcConfigurationArgs:
    def __init__(__self__, *,
                 vpc_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] vpc_id: This access point will only allow connections from the specified VPC ID.
        """
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        This access point will only allow connections from the specified VPC ID.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class AnalyticsConfigurationFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object prefix for filtering.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Set of object tags for filtering.
        """
elif False:
    AnalyticsConfigurationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticsConfigurationFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Object prefix for filtering.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Set of object tags for filtering.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object prefix for filtering.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Set of object tags for filtering.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnalyticsConfigurationStorageClassAnalysisArgsDict(TypedDict):
        data_export: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportArgsDict']
        """
        Data export configuration (documented below).
        """
elif False:
    AnalyticsConfigurationStorageClassAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticsConfigurationStorageClassAnalysisArgs:
    def __init__(__self__, *,
                 data_export: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportArgs']):
        """
        :param pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportArgs'] data_export: Data export configuration (documented below).
        """
        pulumi.set(__self__, "data_export", data_export)

    @_builtins.property
    @pulumi.getter(name="dataExport")
    def data_export(self) -> pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportArgs']:
        """
        Data export configuration (documented below).
        """
        return pulumi.get(self, "data_export")

    @data_export.setter
    def data_export(self, value: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportArgs']):
        pulumi.set(self, "data_export", value)


if not MYPY:
    class AnalyticsConfigurationStorageClassAnalysisDataExportArgsDict(TypedDict):
        destination: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgsDict']
        """
        Specifies the destination for the exported analytics data (documented below).
        """
        output_schema_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema version of exported analytics data. Allowed values: `V_1`. Default value: `V_1`.
        """
elif False:
    AnalyticsConfigurationStorageClassAnalysisDataExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticsConfigurationStorageClassAnalysisDataExportArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs'],
                 output_schema_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs'] destination: Specifies the destination for the exported analytics data (documented below).
        :param pulumi.Input[_builtins.str] output_schema_version: Schema version of exported analytics data. Allowed values: `V_1`. Default value: `V_1`.
        """
        pulumi.set(__self__, "destination", destination)
        if output_schema_version is not None:
            pulumi.set(__self__, "output_schema_version", output_schema_version)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs']:
        """
        Specifies the destination for the exported analytics data (documented below).
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="outputSchemaVersion")
    def output_schema_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema version of exported analytics data. Allowed values: `V_1`. Default value: `V_1`.
        """
        return pulumi.get(self, "output_schema_version")

    @output_schema_version.setter
    def output_schema_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_schema_version", value)


if not MYPY:
    class AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgsDict(TypedDict):
        s3_bucket_destination: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgsDict']
        """
        Analytics data export currently only supports an S3 bucket destination (documented below).
        """
elif False:
    AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticsConfigurationStorageClassAnalysisDataExportDestinationArgs:
    def __init__(__self__, *,
                 s3_bucket_destination: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs']):
        """
        :param pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs'] s3_bucket_destination: Analytics data export currently only supports an S3 bucket destination (documented below).
        """
        pulumi.set(__self__, "s3_bucket_destination", s3_bucket_destination)

    @_builtins.property
    @pulumi.getter(name="s3BucketDestination")
    def s3_bucket_destination(self) -> pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs']:
        """
        Analytics data export currently only supports an S3 bucket destination (documented below).
        """
        return pulumi.get(self, "s3_bucket_destination")

    @s3_bucket_destination.setter
    def s3_bucket_destination(self, value: pulumi.Input['AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs']):
        pulumi.set(self, "s3_bucket_destination", value)


if not MYPY:
    class AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgsDict(TypedDict):
        bucket_arn: pulumi.Input[_builtins.str]
        """
        ARN of the destination bucket.
        """
        bucket_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID that owns the destination bucket.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output format of exported analytics data. Allowed values: `CSV`. Default value: `CSV`.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix to append to exported analytics data.
        """
elif False:
    AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticsConfigurationStorageClassAnalysisDataExportDestinationS3BucketDestinationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 bucket_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_arn: ARN of the destination bucket.
        :param pulumi.Input[_builtins.str] bucket_account_id: Account ID that owns the destination bucket.
        :param pulumi.Input[_builtins.str] format: Output format of exported analytics data. Allowed values: `CSV`. Default value: `CSV`.
        :param pulumi.Input[_builtins.str] prefix: Prefix to append to exported analytics data.
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_account_id is not None:
            pulumi.set(__self__, "bucket_account_id", bucket_account_id)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the destination bucket.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="bucketAccountId")
    def bucket_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID that owns the destination bucket.
        """
        return pulumi.get(self, "bucket_account_id")

    @bucket_account_id.setter
    def bucket_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_account_id", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output format of exported analytics data. Allowed values: `CSV`. Default value: `CSV`.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix to append to exported analytics data.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class BucketAclAccessControlPolicyArgsDict(TypedDict):
        owner: pulumi.Input['BucketAclAccessControlPolicyOwnerArgsDict']
        """
        Configuration block for the bucket owner's display name and ID. See below.
        """
        grants: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketAclAccessControlPolicyGrantArgsDict']]]]
        """
        Set of `grant` configuration blocks. See below.
        """
elif False:
    BucketAclAccessControlPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclAccessControlPolicyArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input['BucketAclAccessControlPolicyOwnerArgs'],
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclAccessControlPolicyGrantArgs']]]] = None):
        """
        :param pulumi.Input['BucketAclAccessControlPolicyOwnerArgs'] owner: Configuration block for the bucket owner's display name and ID. See below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketAclAccessControlPolicyGrantArgs']]] grants: Set of `grant` configuration blocks. See below.
        """
        pulumi.set(__self__, "owner", owner)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input['BucketAclAccessControlPolicyOwnerArgs']:
        """
        Configuration block for the bucket owner's display name and ID. See below.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input['BucketAclAccessControlPolicyOwnerArgs']):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclAccessControlPolicyGrantArgs']]]]:
        """
        Set of `grant` configuration blocks. See below.
        """
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclAccessControlPolicyGrantArgs']]]]):
        pulumi.set(self, "grants", value)


if not MYPY:
    class BucketAclAccessControlPolicyGrantArgsDict(TypedDict):
        permission: pulumi.Input[_builtins.str]
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        """
        grantee: NotRequired[pulumi.Input['BucketAclAccessControlPolicyGrantGranteeArgsDict']]
        """
        Configuration block for the person being granted permissions. See below.
        """
elif False:
    BucketAclAccessControlPolicyGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclAccessControlPolicyGrantArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[_builtins.str],
                 grantee: Optional[pulumi.Input['BucketAclAccessControlPolicyGrantGranteeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] permission: Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        :param pulumi.Input['BucketAclAccessControlPolicyGrantGranteeArgs'] grantee: Configuration block for the person being granted permissions. See below.
        """
        pulumi.set(__self__, "permission", permission)
        if grantee is not None:
            pulumi.set(__self__, "grantee", grantee)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter
    def grantee(self) -> Optional[pulumi.Input['BucketAclAccessControlPolicyGrantGranteeArgs']]:
        """
        Configuration block for the person being granted permissions. See below.
        """
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: Optional[pulumi.Input['BucketAclAccessControlPolicyGrantGranteeArgs']]):
        pulumi.set(self, "grantee", value)


if not MYPY:
    class BucketAclAccessControlPolicyGrantGranteeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the owner.
        """
        email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user ID of the grantee.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the grantee group.
        """
elif False:
    BucketAclAccessControlPolicyGrantGranteeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclAccessControlPolicyGrantGranteeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        :param pulumi.Input[_builtins.str] display_name: Display name of the owner.
        :param pulumi.Input[_builtins.str] email_address: Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        :param pulumi.Input[_builtins.str] id: Canonical user ID of the grantee.
        :param pulumi.Input[_builtins.str] uri: URI of the grantee group.
        """
        pulumi.set(__self__, "type", type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the owner.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user ID of the grantee.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the grantee group.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketAclAccessControlPolicyOwnerArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        ID of the owner.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the owner.
        """
elif False:
    BucketAclAccessControlPolicyOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclAccessControlPolicyOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the owner.
        :param pulumi.Input[_builtins.str] display_name: Display name of the owner.
        """
        pulumi.set(__self__, "id", id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the owner.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the owner.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class BucketAclV2AccessControlPolicyArgsDict(TypedDict):
        owner: pulumi.Input['BucketAclV2AccessControlPolicyOwnerArgsDict']
        """
        Configuration block for the bucket owner's display name and ID. See below.
        """
        grants: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketAclV2AccessControlPolicyGrantArgsDict']]]]
        """
        Set of `grant` configuration blocks. See below.
        """
elif False:
    BucketAclV2AccessControlPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclV2AccessControlPolicyArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input['BucketAclV2AccessControlPolicyOwnerArgs'],
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclV2AccessControlPolicyGrantArgs']]]] = None):
        """
        :param pulumi.Input['BucketAclV2AccessControlPolicyOwnerArgs'] owner: Configuration block for the bucket owner's display name and ID. See below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketAclV2AccessControlPolicyGrantArgs']]] grants: Set of `grant` configuration blocks. See below.
        """
        pulumi.set(__self__, "owner", owner)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input['BucketAclV2AccessControlPolicyOwnerArgs']:
        """
        Configuration block for the bucket owner's display name and ID. See below.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input['BucketAclV2AccessControlPolicyOwnerArgs']):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclV2AccessControlPolicyGrantArgs']]]]:
        """
        Set of `grant` configuration blocks. See below.
        """
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketAclV2AccessControlPolicyGrantArgs']]]]):
        pulumi.set(self, "grants", value)


if not MYPY:
    class BucketAclV2AccessControlPolicyGrantArgsDict(TypedDict):
        permission: pulumi.Input[_builtins.str]
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        """
        grantee: NotRequired[pulumi.Input['BucketAclV2AccessControlPolicyGrantGranteeArgsDict']]
        """
        Configuration block for the person being granted permissions. See below.
        """
elif False:
    BucketAclV2AccessControlPolicyGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclV2AccessControlPolicyGrantArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[_builtins.str],
                 grantee: Optional[pulumi.Input['BucketAclV2AccessControlPolicyGrantGranteeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] permission: Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        :param pulumi.Input['BucketAclV2AccessControlPolicyGrantGranteeArgs'] grantee: Configuration block for the person being granted permissions. See below.
        """
        pulumi.set(__self__, "permission", permission)
        if grantee is not None:
            pulumi.set(__self__, "grantee", grantee)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `WRITE`, `WRITE_ACP`, `READ`, `READ_ACP`. See [What permissions can I grant?](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#permissions) for more details about what each permission means in the context of buckets.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter
    def grantee(self) -> Optional[pulumi.Input['BucketAclV2AccessControlPolicyGrantGranteeArgs']]:
        """
        Configuration block for the person being granted permissions. See below.
        """
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: Optional[pulumi.Input['BucketAclV2AccessControlPolicyGrantGranteeArgs']]):
        pulumi.set(self, "grantee", value)


if not MYPY:
    class BucketAclV2AccessControlPolicyGrantGranteeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the owner.
        """
        email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user ID of the grantee.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the grantee group.
        """
elif False:
    BucketAclV2AccessControlPolicyGrantGranteeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclV2AccessControlPolicyGrantGranteeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        :param pulumi.Input[_builtins.str] display_name: Display name of the owner.
        :param pulumi.Input[_builtins.str] email_address: Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        :param pulumi.Input[_builtins.str] id: Canonical user ID of the grantee.
        :param pulumi.Input[_builtins.str] uri: URI of the grantee group.
        """
        pulumi.set(__self__, "type", type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the owner.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user ID of the grantee.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the grantee group.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketAclV2AccessControlPolicyOwnerArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        ID of the owner.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the owner.
        """
elif False:
    BucketAclV2AccessControlPolicyOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAclV2AccessControlPolicyOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: ID of the owner.
        :param pulumi.Input[_builtins.str] display_name: Display name of the owner.
        """
        pulumi.set(__self__, "id", id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the owner.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the owner.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class BucketCorsConfigurationCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
elif False:
    BucketCorsConfigurationCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorsConfigurationCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Set of origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[_builtins.int] max_age_seconds: Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketCorsConfigurationV2CorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
elif False:
    BucketCorsConfigurationV2CorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorsConfigurationV2CorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Set of origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[_builtins.int] max_age_seconds: Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are `GET`, `PUT`, `HEAD`, `POST`, and `DELETE`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of Headers that are specified in the `Access-Control-Request-Headers` header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of headers allowed.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    BucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: One or more origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: List of headers allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        :param pulumi.Input[_builtins.int] max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of headers allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketGrantArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uri address to grant for. Used only when `type` is `Group`.
        """
elif False:
    BucketGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketGrantArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        :param pulumi.Input[_builtins.str] type: Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        :param pulumi.Input[_builtins.str] id: Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        :param pulumi.Input[_builtins.str] uri: Uri address to grant for. Used only when `type` is `Group`.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uri address to grant for. Used only when `type` is `Group`.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketIntelligentTieringConfigurationFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix that identifies the subset of objects to which the configuration applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        All of these tags must exist in the object's tag set in order for the configuration to apply.
        """
elif False:
    BucketIntelligentTieringConfigurationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIntelligentTieringConfigurationFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Object key name prefix that identifies the subset of objects to which the configuration applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: All of these tags must exist in the object's tag set in order for the configuration to apply.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix that identifies the subset of objects to which the configuration applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        All of these tags must exist in the object's tag set in order for the configuration to apply.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketIntelligentTieringConfigurationTieringArgsDict(TypedDict):
        access_tier: pulumi.Input[_builtins.str]
        """
        S3 Intelligent-Tiering access tier. Valid values: `ARCHIVE_ACCESS`, `DEEP_ARCHIVE_ACCESS`.
        """
        days: pulumi.Input[_builtins.int]
        """
        Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
        """
elif False:
    BucketIntelligentTieringConfigurationTieringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIntelligentTieringConfigurationTieringArgs:
    def __init__(__self__, *,
                 access_tier: pulumi.Input[_builtins.str],
                 days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] access_tier: S3 Intelligent-Tiering access tier. Valid values: `ARCHIVE_ACCESS`, `DEEP_ARCHIVE_ACCESS`.
        :param pulumi.Input[_builtins.int] days: Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
        """
        pulumi.set(__self__, "access_tier", access_tier)
        pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="accessTier")
    def access_tier(self) -> pulumi.Input[_builtins.str]:
        """
        S3 Intelligent-Tiering access tier. Valid values: `ARCHIVE_ACCESS`, `DEEP_ARCHIVE_ACCESS`.
        """
        return pulumi.get(self, "access_tier")

    @access_tier.setter
    def access_tier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_tier", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[_builtins.int]:
        """
        Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        status: pulumi.Input[_builtins.str]
        """
        Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        """
        abort_incomplete_multipart_upload: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict']]
        """
        Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        """
        expiration: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleExpirationArgsDict']]
        """
        Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        """
        filter: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleFilterArgsDict']]
        """
        Configuration block used to identify objects that a Lifecycle Rule applies to.
        See below.
        If not specified, the `rule` will default to using `prefix`.
        One of `filter` or `prefix` should be specified.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict']]
        """
        Configuration block that specifies when noncurrent object versions expire. See below.
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        **DEPRECATED** Use `filter` instead.
        This has been deprecated by Amazon S3.
        Prefix identifying one or more objects to which the rule applies.
        Defaults to an empty string (`""`) if `filter` is not specified.
        One of `prefix` or `filter` should be specified.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleTransitionArgsDict']]]]
        """
        Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
elif False:
    BucketLifecycleConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 abort_incomplete_multipart_upload: Optional[pulumi.Input['BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']] = None,
                 expiration: Optional[pulumi.Input['BucketLifecycleConfigurationRuleExpirationArgs']] = None,
                 filter: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterArgs']] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[_builtins.str] status: Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        :param pulumi.Input['BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs'] abort_incomplete_multipart_upload: Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        :param pulumi.Input['BucketLifecycleConfigurationRuleExpirationArgs'] expiration: Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        :param pulumi.Input['BucketLifecycleConfigurationRuleFilterArgs'] filter: Configuration block used to identify objects that a Lifecycle Rule applies to.
               See below.
               If not specified, the `rule` will default to using `prefix`.
               One of `filter` or `prefix` should be specified.
        :param pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Configuration block that specifies when noncurrent object versions expire. See below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        :param pulumi.Input[_builtins.str] prefix: **DEPRECATED** Use `filter` instead.
               This has been deprecated by Amazon S3.
               Prefix identifying one or more objects to which the rule applies.
               Defaults to an empty string (`""`) if `filter` is not specified.
               One of `prefix` or `filter` should be specified.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleTransitionArgs']]] transitions: Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        if abort_incomplete_multipart_upload is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            warnings.warn("""Specify a prefix using 'filter' instead""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Specify a prefix using 'filter' instead""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']]:
        """
        Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @abort_incomplete_multipart_upload.setter
    def abort_incomplete_multipart_upload(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']]):
        pulumi.set(self, "abort_incomplete_multipart_upload", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleExpirationArgs']]:
        """
        Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterArgs']]:
        """
        Configuration block used to identify objects that a Lifecycle Rule applies to.
        See below.
        If not specified, the `rule` will default to using `prefix`.
        One of `filter` or `prefix` should be specified.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']]:
        """
        Configuration block that specifies when noncurrent object versions expire. See below.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs']]]]:
        """
        Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Specify a prefix using 'filter' instead""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **DEPRECATED** Use `filter` instead.
        This has been deprecated by Amazon S3.
        Prefix identifying one or more objects to which the rule applies.
        Defaults to an empty string (`""`) if `filter` is not specified.
        One of `prefix` or `filter` should be specified.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleTransitionArgs']]]]:
        """
        Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict(TypedDict):
        days_after_initiation: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
elif False:
    BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs:
    def __init__(__self__, *,
                 days_after_initiation: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days_after_initiation: Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        if days_after_initiation is not None:
            pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @_builtins.property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        return pulumi.get(self, "days_after_initiation")

    @days_after_initiation.setter
    def days_after_initiation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days_after_initiation", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
elif False:
    BucketLifecycleConfigurationRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] date: Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        :param pulumi.Input[_builtins.int] days: Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        :param pulumi.Input[_builtins.bool] expired_object_delete_marker: Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleFilterArgsDict(TypedDict):
        and_: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleFilterAndArgsDict']]
        """
        Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        """
        object_size_greater_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        object_size_less_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum object size (in bytes) to which the rule applies.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        """
        tag: NotRequired[pulumi.Input['BucketLifecycleConfigurationRuleFilterTagArgsDict']]
        """
        Configuration block for specifying a tag key and value. See below.
        """
elif False:
    BucketLifecycleConfigurationRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleFilterArgs:
    def __init__(__self__, *,
                 and_: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterAndArgs']] = None,
                 object_size_greater_than: Optional[pulumi.Input[_builtins.int]] = None,
                 object_size_less_than: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterTagArgs']] = None):
        """
        :param pulumi.Input['BucketLifecycleConfigurationRuleFilterAndArgs'] and_: Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        :param pulumi.Input[_builtins.int] object_size_greater_than: Minimum object size (in bytes) to which the rule applies.
        :param pulumi.Input[_builtins.int] object_size_less_than: Maximum object size (in bytes) to which the rule applies.
        :param pulumi.Input[_builtins.str] prefix: Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        :param pulumi.Input['BucketLifecycleConfigurationRuleFilterTagArgs'] tag: Configuration block for specifying a tag key and value. See below.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterAndArgs']]:
        """
        Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        """
        return pulumi.get(self, "and_")

    @and_.setter
    def and_(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterAndArgs']]):
        pulumi.set(self, "and_", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_less_than", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterTagArgs']]:
        """
        Configuration block for specifying a tag key and value. See below.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationRuleFilterTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleFilterAndArgsDict(TypedDict):
        object_size_greater_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        """
        object_size_less_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum object size to which the rule applies. Value must be at least `1` if specified.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of resource tags.
        All of these tags must exist in the object's tag set in order for the rule to apply.
        If set, must contain at least one key-value pair.
        """
elif False:
    BucketLifecycleConfigurationRuleFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleFilterAndArgs:
    def __init__(__self__, *,
                 object_size_greater_than: Optional[pulumi.Input[_builtins.int]] = None,
                 object_size_less_than: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] object_size_greater_than: Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        :param pulumi.Input[_builtins.int] object_size_less_than: Maximum object size to which the rule applies. Value must be at least `1` if specified.
        :param pulumi.Input[_builtins.str] prefix: Prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Key-value map of resource tags.
               All of these tags must exist in the object's tag set in order for the rule to apply.
               If set, must contain at least one key-value pair.
        """
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        """
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum object size to which the rule applies. Value must be at least `1` if specified.
        """
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_less_than", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of resource tags.
        All of these tags must exist in the object's tag set in order for the rule to apply.
        If set, must contain at least one key-value pair.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleFilterTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Name of the object key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the tag.
        """
elif False:
    BucketLifecycleConfigurationRuleFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Name of the object key.
        :param pulumi.Input[_builtins.str] value: Value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the object key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        noncurrent_days: pulumi.Input[_builtins.int]
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        """
        newer_noncurrent_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
elif False:
    BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 noncurrent_days: pulumi.Input[_builtins.int],
                 newer_noncurrent_versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] noncurrent_days: Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        :param pulumi.Input[_builtins.int] newer_noncurrent_versions: Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        pulumi.set(__self__, "noncurrent_days", noncurrent_days)
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)

    @_builtins.property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> pulumi.Input[_builtins.int]:
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "noncurrent_days", value)

    @_builtins.property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        noncurrent_days: pulumi.Input[_builtins.int]
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        """
        storage_class: pulumi.Input[_builtins.str]
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        newer_noncurrent_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
elif False:
    BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 noncurrent_days: pulumi.Input[_builtins.int],
                 storage_class: pulumi.Input[_builtins.str],
                 newer_noncurrent_versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] noncurrent_days: Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        :param pulumi.Input[_builtins.str] storage_class: Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        :param pulumi.Input[_builtins.int] newer_noncurrent_versions: Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        pulumi.set(__self__, "noncurrent_days", noncurrent_days)
        pulumi.set(__self__, "storage_class", storage_class)
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)

    @_builtins.property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> pulumi.Input[_builtins.int]:
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "noncurrent_days", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


if not MYPY:
    class BucketLifecycleConfigurationRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
elif False:
    BucketLifecycleConfigurationRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        :param pulumi.Input[_builtins.str] date: Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        :param pulumi.Input[_builtins.int] days: Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    BucketLifecycleConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        status: pulumi.Input[_builtins.str]
        """
        Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        """
        abort_incomplete_multipart_upload: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgsDict']]
        """
        Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        """
        expiration: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleExpirationArgsDict']]
        """
        Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        """
        filter: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterArgsDict']]
        """
        Configuration block used to identify objects that a Lifecycle Rule applies to.
        See below.
        If not specified, the `rule` will default to using `prefix`.
        One of `filter` or `prefix` should be specified.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgsDict']]
        """
        Configuration block that specifies when noncurrent object versions expire. See below.
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        **DEPRECATED** Use `filter` instead.
        This has been deprecated by Amazon S3.
        Prefix identifying one or more objects to which the rule applies.
        Defaults to an empty string (`""`) if `filter` is not specified.
        One of `prefix` or `filter` should be specified.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleTransitionArgsDict']]]]
        """
        Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
elif False:
    BucketLifecycleConfigurationV2RuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 abort_incomplete_multipart_upload: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs']] = None,
                 expiration: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleExpirationArgs']] = None,
                 filter: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterArgs']] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs']] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[_builtins.str] status: Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs'] abort_incomplete_multipart_upload: Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleExpirationArgs'] expiration: Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleFilterArgs'] filter: Configuration block used to identify objects that a Lifecycle Rule applies to.
               See below.
               If not specified, the `rule` will default to using `prefix`.
               One of `filter` or `prefix` should be specified.
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Configuration block that specifies when noncurrent object versions expire. See below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        :param pulumi.Input[_builtins.str] prefix: **DEPRECATED** Use `filter` instead.
               This has been deprecated by Amazon S3.
               Prefix identifying one or more objects to which the rule applies.
               Defaults to an empty string (`""`) if `filter` is not specified.
               One of `prefix` or `filter` should be specified.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleTransitionArgs']]] transitions: Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        if abort_incomplete_multipart_upload is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            warnings.warn("""Specify a prefix using 'filter' instead""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Specify a prefix using 'filter' instead""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the rule is currently being applied. Valid values: `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs']]:
        """
        Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @abort_incomplete_multipart_upload.setter
    def abort_incomplete_multipart_upload(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs']]):
        pulumi.set(self, "abort_incomplete_multipart_upload", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleExpirationArgs']]:
        """
        Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterArgs']]:
        """
        Configuration block used to identify objects that a Lifecycle Rule applies to.
        See below.
        If not specified, the `rule` will default to using `prefix`.
        One of `filter` or `prefix` should be specified.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs']]:
        """
        Configuration block that specifies when noncurrent object versions expire. See below.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs']]]]:
        """
        Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Specify a prefix using 'filter' instead""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **DEPRECATED** Use `filter` instead.
        This has been deprecated by Amazon S3.
        Prefix identifying one or more objects to which the rule applies.
        Defaults to an empty string (`""`) if `filter` is not specified.
        One of `prefix` or `filter` should be specified.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleTransitionArgs']]]]:
        """
        Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleConfigurationV2RuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgsDict(TypedDict):
        days_after_initiation: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
elif False:
    BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleAbortIncompleteMultipartUploadArgs:
    def __init__(__self__, *,
                 days_after_initiation: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days_after_initiation: Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        if days_after_initiation is not None:
            pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @_builtins.property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        return pulumi.get(self, "days_after_initiation")

    @days_after_initiation.setter
    def days_after_initiation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days_after_initiation", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
elif False:
    BucketLifecycleConfigurationV2RuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] date: Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        :param pulumi.Input[_builtins.int] days: Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        :param pulumi.Input[_builtins.bool] expired_object_delete_marker: Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the object is to be moved or deleted. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to `true`, the delete marker will be expired; if set to `false` the policy takes no action.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleFilterArgsDict(TypedDict):
        and_: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterAndArgsDict']]
        """
        Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        """
        object_size_greater_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        object_size_less_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum object size (in bytes) to which the rule applies.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        """
        tag: NotRequired[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterTagArgsDict']]
        """
        Configuration block for specifying a tag key and value. See below.
        """
elif False:
    BucketLifecycleConfigurationV2RuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleFilterArgs:
    def __init__(__self__, *,
                 and_: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterAndArgs']] = None,
                 object_size_greater_than: Optional[pulumi.Input[_builtins.int]] = None,
                 object_size_less_than: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterTagArgs']] = None):
        """
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleFilterAndArgs'] and_: Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        :param pulumi.Input[_builtins.int] object_size_greater_than: Minimum object size (in bytes) to which the rule applies.
        :param pulumi.Input[_builtins.int] object_size_less_than: Maximum object size (in bytes) to which the rule applies.
        :param pulumi.Input[_builtins.str] prefix: Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        :param pulumi.Input['BucketLifecycleConfigurationV2RuleFilterTagArgs'] tag: Configuration block for specifying a tag key and value. See below.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterAndArgs']]:
        """
        Configuration block used to apply a logical `AND` to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the `and` block.
        """
        return pulumi.get(self, "and_")

    @and_.setter
    def and_(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterAndArgs']]):
        pulumi.set(self, "and_", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum object size (in bytes) to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_less_than", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix identifying one or more objects to which the rule applies. Defaults to an empty string (`""`) if not specified.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterTagArgs']]:
        """
        Configuration block for specifying a tag key and value. See below.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BucketLifecycleConfigurationV2RuleFilterTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleFilterAndArgsDict(TypedDict):
        object_size_greater_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        """
        object_size_less_than: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum object size to which the rule applies. Value must be at least `1` if specified.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of resource tags.
        All of these tags must exist in the object's tag set in order for the rule to apply.
        If set, must contain at least one key-value pair.
        """
elif False:
    BucketLifecycleConfigurationV2RuleFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleFilterAndArgs:
    def __init__(__self__, *,
                 object_size_greater_than: Optional[pulumi.Input[_builtins.int]] = None,
                 object_size_less_than: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] object_size_greater_than: Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        :param pulumi.Input[_builtins.int] object_size_less_than: Maximum object size to which the rule applies. Value must be at least `1` if specified.
        :param pulumi.Input[_builtins.str] prefix: Prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Key-value map of resource tags.
               All of these tags must exist in the object's tag set in order for the rule to apply.
               If set, must contain at least one key-value pair.
        """
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum object size to which the rule applies. Value must be at least `0` if specified. Defaults to 128000 (128 KB) for all `storage_class` values unless `transition_default_minimum_object_size` specifies otherwise.
        """
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_greater_than", value)

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum object size to which the rule applies. Value must be at least `1` if specified.
        """
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "object_size_less_than", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of resource tags.
        All of these tags must exist in the object's tag set in order for the rule to apply.
        If set, must contain at least one key-value pair.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleFilterTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Name of the object key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the tag.
        """
elif False:
    BucketLifecycleConfigurationV2RuleFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Name of the object key.
        :param pulumi.Input[_builtins.str] value: Value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the object key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgsDict(TypedDict):
        noncurrent_days: pulumi.Input[_builtins.int]
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        """
        newer_noncurrent_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
elif False:
    BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 noncurrent_days: pulumi.Input[_builtins.int],
                 newer_noncurrent_versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] noncurrent_days: Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        :param pulumi.Input[_builtins.int] newer_noncurrent_versions: Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        pulumi.set(__self__, "noncurrent_days", noncurrent_days)
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)

    @_builtins.property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> pulumi.Input[_builtins.int]:
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action. Must be a positive integer.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "noncurrent_days", value)

    @_builtins.property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgsDict(TypedDict):
        noncurrent_days: pulumi.Input[_builtins.int]
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        """
        storage_class: pulumi.Input[_builtins.str]
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        newer_noncurrent_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
elif False:
    BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 noncurrent_days: pulumi.Input[_builtins.int],
                 storage_class: pulumi.Input[_builtins.str],
                 newer_noncurrent_versions: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] noncurrent_days: Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        :param pulumi.Input[_builtins.str] storage_class: Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        :param pulumi.Input[_builtins.int] newer_noncurrent_versions: Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        pulumi.set(__self__, "noncurrent_days", noncurrent_days)
        pulumi.set(__self__, "storage_class", storage_class)
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)

    @_builtins.property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> pulumi.Input[_builtins.int]:
        """
        Number of days an object is noncurrent before Amazon S3 can perform the associated action.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "noncurrent_days", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


if not MYPY:
    class BucketLifecycleConfigurationV2RuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
elif False:
    BucketLifecycleConfigurationV2RuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2RuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        :param pulumi.Input[_builtins.str] date: Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        :param pulumi.Input[_builtins.int] days: Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Class of storage used to store the object. Valid Values: `GLACIER`, `STANDARD_IA`, `ONEZONE_IA`, `INTELLIGENT_TIERING`, `DEEP_ARCHIVE`, `GLACIER_IR`.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date objects are transitioned to the specified storage class. The date value must be in [RFC3339 full-date format](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) e.g. `2023-08-22`.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both `days` and `date` are not specified, defaults to `0`. Valid values depend on `storage_class`, see [Transition objects using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-transition-general-considerations.html) for more details.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleConfigurationV2TimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    BucketLifecycleConfigurationV2TimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleConfigurationV2TimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class BucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies lifecycle rule status.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        expiration: NotRequired[pulumi.Input['BucketLifecycleRuleExpirationArgsDict']]
        """
        Specifies a period in the object's expire. See Expiration below for details.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]
        """
        Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies object tags key and value.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgsDict']]]]
        """
        Specifies a period in the object's transitions. See Transition below for details.
        """
elif False:
    BucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expiration: Optional[pulumi.Input['BucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[_builtins.int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        :param pulumi.Input['BucketLifecycleRuleExpirationArgs'] expiration: Specifies a period in the object's expire. See Expiration below for details.
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        :param pulumi.Input[_builtins.str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Specifies object tags key and value.
        :param pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]] transitions: Specifies a period in the object's transitions. See Transition below for details.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['BucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a period in the object's expire. See Expiration below for details.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['BucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['BucketLifecycleRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]:
        """
        Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]]:
        """
        Specifies a period in the object's transitions. See Transition below for details.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class BucketLifecycleRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
elif False:
    BucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        :param pulumi.Input[_builtins.bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class BucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days noncurrent object versions expire.
        """
elif False:
    BucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: Specifies the number of days noncurrent object versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days noncurrent object versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
elif False:
    BucketLifecycleRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLifecycleRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
elif False:
    BucketLifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        :param pulumi.Input[_builtins.str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketLoggingArgsDict(TypedDict):
        target_bucket: pulumi.Input[_builtins.str]
        """
        Name of the bucket that will receive the log objects.
        """
        target_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        To specify a key prefix for log objects.
        """
elif False:
    BucketLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingArgs:
    def __init__(__self__, *,
                 target_bucket: pulumi.Input[_builtins.str],
                 target_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target_bucket: Name of the bucket that will receive the log objects.
        :param pulumi.Input[_builtins.str] target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @_builtins.property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @target_bucket.setter
    def target_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_bucket", value)

    @_builtins.property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")

    @target_prefix.setter
    def target_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_prefix", value)


if not MYPY:
    class BucketLoggingTargetGrantArgsDict(TypedDict):
        grantee: pulumi.Input['BucketLoggingTargetGrantGranteeArgsDict']
        """
        Configuration block for the person being granted permissions. See below.
        """
        permission: pulumi.Input[_builtins.str]
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
elif False:
    BucketLoggingTargetGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingTargetGrantArgs:
    def __init__(__self__, *,
                 grantee: pulumi.Input['BucketLoggingTargetGrantGranteeArgs'],
                 permission: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['BucketLoggingTargetGrantGranteeArgs'] grantee: Configuration block for the person being granted permissions. See below.
        :param pulumi.Input[_builtins.str] permission: Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
        pulumi.set(__self__, "grantee", grantee)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def grantee(self) -> pulumi.Input['BucketLoggingTargetGrantGranteeArgs']:
        """
        Configuration block for the person being granted permissions. See below.
        """
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: pulumi.Input['BucketLoggingTargetGrantGranteeArgs']):
        pulumi.set(self, "grantee", value)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class BucketLoggingTargetGrantGranteeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user ID of the grantee.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the grantee group.
        """
elif False:
    BucketLoggingTargetGrantGranteeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingTargetGrantGranteeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        :param pulumi.Input[_builtins.str] email_address: Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        :param pulumi.Input[_builtins.str] id: Canonical user ID of the grantee.
        :param pulumi.Input[_builtins.str] uri: URI of the grantee group.
        """
        pulumi.set(__self__, "type", type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user ID of the grantee.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the grantee group.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketLoggingTargetObjectKeyFormatArgsDict(TypedDict):
        partitioned_prefix: NotRequired[pulumi.Input['BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgsDict']]
        """
        Partitioned S3 key for log objects. See below.
        """
        simple_prefix: NotRequired[pulumi.Input['BucketLoggingTargetObjectKeyFormatSimplePrefixArgsDict']]
        """
        Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
elif False:
    BucketLoggingTargetObjectKeyFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingTargetObjectKeyFormatArgs:
    def __init__(__self__, *,
                 partitioned_prefix: Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs']] = None,
                 simple_prefix: Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatSimplePrefixArgs']] = None):
        """
        :param pulumi.Input['BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs'] partitioned_prefix: Partitioned S3 key for log objects. See below.
        :param pulumi.Input['BucketLoggingTargetObjectKeyFormatSimplePrefixArgs'] simple_prefix: Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
        if partitioned_prefix is not None:
            pulumi.set(__self__, "partitioned_prefix", partitioned_prefix)
        if simple_prefix is not None:
            pulumi.set(__self__, "simple_prefix", simple_prefix)

    @_builtins.property
    @pulumi.getter(name="partitionedPrefix")
    def partitioned_prefix(self) -> Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs']]:
        """
        Partitioned S3 key for log objects. See below.
        """
        return pulumi.get(self, "partitioned_prefix")

    @partitioned_prefix.setter
    def partitioned_prefix(self, value: Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs']]):
        pulumi.set(self, "partitioned_prefix", value)

    @_builtins.property
    @pulumi.getter(name="simplePrefix")
    def simple_prefix(self) -> Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatSimplePrefixArgs']]:
        """
        Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
        return pulumi.get(self, "simple_prefix")

    @simple_prefix.setter
    def simple_prefix(self, value: Optional[pulumi.Input['BucketLoggingTargetObjectKeyFormatSimplePrefixArgs']]):
        pulumi.set(self, "simple_prefix", value)


if not MYPY:
    class BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgsDict(TypedDict):
        partition_date_source: pulumi.Input[_builtins.str]
        """
        Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
elif False:
    BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingTargetObjectKeyFormatPartitionedPrefixArgs:
    def __init__(__self__, *,
                 partition_date_source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] partition_date_source: Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
        pulumi.set(__self__, "partition_date_source", partition_date_source)

    @_builtins.property
    @pulumi.getter(name="partitionDateSource")
    def partition_date_source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
        return pulumi.get(self, "partition_date_source")

    @partition_date_source.setter
    def partition_date_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "partition_date_source", value)


if not MYPY:
    class BucketLoggingTargetObjectKeyFormatSimplePrefixArgsDict(TypedDict):
        pass
elif False:
    BucketLoggingTargetObjectKeyFormatSimplePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingTargetObjectKeyFormatSimplePrefixArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BucketLoggingV2TargetGrantArgsDict(TypedDict):
        grantee: pulumi.Input['BucketLoggingV2TargetGrantGranteeArgsDict']
        """
        Configuration block for the person being granted permissions. See below.
        """
        permission: pulumi.Input[_builtins.str]
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
elif False:
    BucketLoggingV2TargetGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingV2TargetGrantArgs:
    def __init__(__self__, *,
                 grantee: pulumi.Input['BucketLoggingV2TargetGrantGranteeArgs'],
                 permission: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['BucketLoggingV2TargetGrantGranteeArgs'] grantee: Configuration block for the person being granted permissions. See below.
        :param pulumi.Input[_builtins.str] permission: Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
        pulumi.set(__self__, "grantee", grantee)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def grantee(self) -> pulumi.Input['BucketLoggingV2TargetGrantGranteeArgs']:
        """
        Configuration block for the person being granted permissions. See below.
        """
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: pulumi.Input['BucketLoggingV2TargetGrantGranteeArgs']):
        pulumi.set(self, "grantee", value)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Logging permissions assigned to the grantee for the bucket. Valid values: `FULL_CONTROL`, `READ`, `WRITE`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class BucketLoggingV2TargetGrantGranteeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        email_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user ID of the grantee.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the grantee group.
        """
elif False:
    BucketLoggingV2TargetGrantGranteeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingV2TargetGrantGranteeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_address: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        :param pulumi.Input[_builtins.str] email_address: Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        :param pulumi.Input[_builtins.str] id: Canonical user ID of the grantee.
        :param pulumi.Input[_builtins.str] uri: URI of the grantee group.
        """
        pulumi.set(__self__, "type", type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee. Valid values: `CanonicalUser`, `AmazonCustomerByEmail`, `Group`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the grantee. See [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) for supported AWS regions where this argument can be specified.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_address", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user ID of the grantee.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the grantee group.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketLoggingV2TargetObjectKeyFormatArgsDict(TypedDict):
        partitioned_prefix: NotRequired[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgsDict']]
        """
        Partitioned S3 key for log objects. See below.
        """
        simple_prefix: NotRequired[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgsDict']]
        """
        Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
elif False:
    BucketLoggingV2TargetObjectKeyFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingV2TargetObjectKeyFormatArgs:
    def __init__(__self__, *,
                 partitioned_prefix: Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs']] = None,
                 simple_prefix: Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs']] = None):
        """
        :param pulumi.Input['BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs'] partitioned_prefix: Partitioned S3 key for log objects. See below.
        :param pulumi.Input['BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs'] simple_prefix: Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
        if partitioned_prefix is not None:
            pulumi.set(__self__, "partitioned_prefix", partitioned_prefix)
        if simple_prefix is not None:
            pulumi.set(__self__, "simple_prefix", simple_prefix)

    @_builtins.property
    @pulumi.getter(name="partitionedPrefix")
    def partitioned_prefix(self) -> Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs']]:
        """
        Partitioned S3 key for log objects. See below.
        """
        return pulumi.get(self, "partitioned_prefix")

    @partitioned_prefix.setter
    def partitioned_prefix(self, value: Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs']]):
        pulumi.set(self, "partitioned_prefix", value)

    @_builtins.property
    @pulumi.getter(name="simplePrefix")
    def simple_prefix(self) -> Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs']]:
        """
        Use the simple format for S3 keys for log objects. To use, set `simple_prefix {}`.
        """
        return pulumi.get(self, "simple_prefix")

    @simple_prefix.setter
    def simple_prefix(self, value: Optional[pulumi.Input['BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs']]):
        pulumi.set(self, "simple_prefix", value)


if not MYPY:
    class BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgsDict(TypedDict):
        partition_date_source: pulumi.Input[_builtins.str]
        """
        Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
elif False:
    BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingV2TargetObjectKeyFormatPartitionedPrefixArgs:
    def __init__(__self__, *,
                 partition_date_source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] partition_date_source: Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
        pulumi.set(__self__, "partition_date_source", partition_date_source)

    @_builtins.property
    @pulumi.getter(name="partitionDateSource")
    def partition_date_source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the partition date source for the partitioned prefix. Valid values: `EventTime`, `DeliveryTime`.
        """
        return pulumi.get(self, "partition_date_source")

    @partition_date_source.setter
    def partition_date_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "partition_date_source", value)


if not MYPY:
    class BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgsDict(TypedDict):
        pass
elif False:
    BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingV2TargetObjectKeyFormatSimplePrefixArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationDestinationArgsDict']]]]
        """
        Destination information for the S3 Metadata configuration.
        """
        inventory_table_configuration: NotRequired[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgsDict']]
        """
        Inventory table configuration. See `inventory_table_configuration` Block for details.
        """
        journal_table_configuration: NotRequired[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgsDict']]
        """
        Journal table configuration. See `journal_table_configuration` Block for details.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationDestinationArgs']]]] = None,
                 inventory_table_configuration: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs']] = None,
                 journal_table_configuration: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationDestinationArgs']]] destinations: Destination information for the S3 Metadata configuration.
        :param pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs'] inventory_table_configuration: Inventory table configuration. See `inventory_table_configuration` Block for details.
        :param pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs'] journal_table_configuration: Journal table configuration. See `journal_table_configuration` Block for details.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if inventory_table_configuration is not None:
            pulumi.set(__self__, "inventory_table_configuration", inventory_table_configuration)
        if journal_table_configuration is not None:
            pulumi.set(__self__, "journal_table_configuration", journal_table_configuration)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationDestinationArgs']]]]:
        """
        Destination information for the S3 Metadata configuration.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter(name="inventoryTableConfiguration")
    def inventory_table_configuration(self) -> Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs']]:
        """
        Inventory table configuration. See `inventory_table_configuration` Block for details.
        """
        return pulumi.get(self, "inventory_table_configuration")

    @inventory_table_configuration.setter
    def inventory_table_configuration(self, value: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs']]):
        pulumi.set(self, "inventory_table_configuration", value)

    @_builtins.property
    @pulumi.getter(name="journalTableConfiguration")
    def journal_table_configuration(self) -> Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs']]:
        """
        Journal table configuration. See `journal_table_configuration` Block for details.
        """
        return pulumi.get(self, "journal_table_configuration")

    @journal_table_configuration.setter
    def journal_table_configuration(self, value: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs']]):
        pulumi.set(self, "journal_table_configuration", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationDestinationArgsDict(TypedDict):
        table_bucket_arn: pulumi.Input[_builtins.str]
        """
        ARN of the table bucket where the metadata configuration is stored.
        """
        table_bucket_type: pulumi.Input[_builtins.str]
        """
        Type of the table bucket where the metadata configuration is stored.
        """
        table_namespace: pulumi.Input[_builtins.str]
        """
        Namespace in the table bucket where the metadata tables for the metadata configuration are stored.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationDestinationArgs:
    def __init__(__self__, *,
                 table_bucket_arn: pulumi.Input[_builtins.str],
                 table_bucket_type: pulumi.Input[_builtins.str],
                 table_namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] table_bucket_arn: ARN of the table bucket where the metadata configuration is stored.
        :param pulumi.Input[_builtins.str] table_bucket_type: Type of the table bucket where the metadata configuration is stored.
        :param pulumi.Input[_builtins.str] table_namespace: Namespace in the table bucket where the metadata tables for the metadata configuration are stored.
        """
        pulumi.set(__self__, "table_bucket_arn", table_bucket_arn)
        pulumi.set(__self__, "table_bucket_type", table_bucket_type)
        pulumi.set(__self__, "table_namespace", table_namespace)

    @_builtins.property
    @pulumi.getter(name="tableBucketArn")
    def table_bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the table bucket where the metadata configuration is stored.
        """
        return pulumi.get(self, "table_bucket_arn")

    @table_bucket_arn.setter
    def table_bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableBucketType")
    def table_bucket_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the table bucket where the metadata configuration is stored.
        """
        return pulumi.get(self, "table_bucket_type")

    @table_bucket_type.setter
    def table_bucket_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_bucket_type", value)

    @_builtins.property
    @pulumi.getter(name="tableNamespace")
    def table_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Namespace in the table bucket where the metadata tables for the metadata configuration are stored.
        """
        return pulumi.get(self, "table_namespace")

    @table_namespace.setter
    def table_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_namespace", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgsDict(TypedDict):
        configuration_state: pulumi.Input[_builtins.str]
        """
        Configuration state of the inventory table, indicating whether the inventory table is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        """
        encryption_configuration: NotRequired[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgsDict']]
        """
        Encryption configuration for the inventory table. See `encryption_configuration` Block for details.
        """
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inventory table ARN.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inventory table name.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationArgs:
    def __init__(__self__, *,
                 configuration_state: pulumi.Input[_builtins.str],
                 encryption_configuration: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs']] = None,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] configuration_state: Configuration state of the inventory table, indicating whether the inventory table is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        :param pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs'] encryption_configuration: Encryption configuration for the inventory table. See `encryption_configuration` Block for details.
        :param pulumi.Input[_builtins.str] table_arn: Inventory table ARN.
        :param pulumi.Input[_builtins.str] table_name: Inventory table name.
        """
        pulumi.set(__self__, "configuration_state", configuration_state)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="configurationState")
    def configuration_state(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration state of the inventory table, indicating whether the inventory table is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "configuration_state")

    @configuration_state.setter
    def configuration_state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "configuration_state", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs']]:
        """
        Encryption configuration for the inventory table. See `encryption_configuration` Block for details.
        """
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inventory table ARN.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inventory table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[_builtins.str]
        """
        Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationInventoryTableConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgsDict(TypedDict):
        encryption_configuration: NotRequired[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgsDict']]
        """
        Encryption configuration for the journal table. See `encryption_configuration` Block for details.
        """
        record_expiration: NotRequired[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgsDict']]
        """
        Journal table record expiration settings. See `record_expiration` Block for details.
        """
        table_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Journal table ARN.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Journal table name.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationArgs:
    def __init__(__self__, *,
                 encryption_configuration: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs']] = None,
                 record_expiration: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs']] = None,
                 table_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs'] encryption_configuration: Encryption configuration for the journal table. See `encryption_configuration` Block for details.
        :param pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs'] record_expiration: Journal table record expiration settings. See `record_expiration` Block for details.
        :param pulumi.Input[_builtins.str] table_arn: Journal table ARN.
        :param pulumi.Input[_builtins.str] table_name: Journal table name.
        """
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if record_expiration is not None:
            pulumi.set(__self__, "record_expiration", record_expiration)
        if table_arn is not None:
            pulumi.set(__self__, "table_arn", table_arn)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs']]:
        """
        Encryption configuration for the journal table. See `encryption_configuration` Block for details.
        """
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="recordExpiration")
    def record_expiration(self) -> Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs']]:
        """
        Journal table record expiration settings. See `record_expiration` Block for details.
        """
        return pulumi.get(self, "record_expiration")

    @record_expiration.setter
    def record_expiration(self, value: Optional[pulumi.Input['BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs']]):
        pulumi.set(self, "record_expiration", value)

    @_builtins.property
    @pulumi.getter(name="tableArn")
    def table_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Journal table ARN.
        """
        return pulumi.get(self, "table_arn")

    @table_arn.setter
    def table_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Journal table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[_builtins.str]
        """
        Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        Encryption type for the metadata table. Valid values: `aws:kms`, `AES256`.
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN when `sse_algorithm` is `aws:kms`.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgsDict(TypedDict):
        expiration: pulumi.Input[_builtins.str]
        """
        Whether journal table record expiration is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days to retain journal table records.
        """
elif False:
    BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationMetadataConfigurationJournalTableConfigurationRecordExpirationArgs:
    def __init__(__self__, *,
                 expiration: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] expiration: Whether journal table record expiration is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        :param pulumi.Input[_builtins.int] days: Number of days to retain journal table records.
        """
        pulumi.set(__self__, "expiration", expiration)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> pulumi.Input[_builtins.str]:
        """
        Whether journal table record expiration is enabled or disabled. Valid values: `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days to retain journal table records.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketMetadataConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    BucketMetadataConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetadataConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class BucketMetricFilterArgsDict(TypedDict):
        access_point: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 Access Point ARN for filtering (singular).
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object prefix for filtering (singular).
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Object tags for filtering (up to 10).
        """
elif False:
    BucketMetricFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketMetricFilterArgs:
    def __init__(__self__, *,
                 access_point: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] access_point: S3 Access Point ARN for filtering (singular).
        :param pulumi.Input[_builtins.str] prefix: Object prefix for filtering (singular).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Object tags for filtering (up to 10).
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 Access Point ARN for filtering (singular).
        """
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_point", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object prefix for filtering (singular).
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Object tags for filtering (up to 10).
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketNotificationLambdaFunctionArgsDict(TypedDict):
        events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        filter_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix.
        """
        filter_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name suffix.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for each of the notification configurations.
        """
        lambda_function_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lambda function ARN.
        """
elif False:
    BucketNotificationLambdaFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketNotificationLambdaFunctionArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 filter_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 lambda_function_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        :param pulumi.Input[_builtins.str] filter_prefix: Object key name prefix.
        :param pulumi.Input[_builtins.str] filter_suffix: Object key name suffix.
        :param pulumi.Input[_builtins.str] id: Unique identifier for each of the notification configurations.
        :param pulumi.Input[_builtins.str] lambda_function_arn: Lambda function ARN.
        """
        pulumi.set(__self__, "events", events)
        if filter_prefix is not None:
            pulumi.set(__self__, "filter_prefix", filter_prefix)
        if filter_suffix is not None:
            pulumi.set(__self__, "filter_suffix", filter_suffix)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lambda_function_arn is not None:
            pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)

    @_builtins.property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="filterPrefix")
    def filter_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix.
        """
        return pulumi.get(self, "filter_prefix")

    @filter_prefix.setter
    def filter_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_prefix", value)

    @_builtins.property
    @pulumi.getter(name="filterSuffix")
    def filter_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name suffix.
        """
        return pulumi.get(self, "filter_suffix")

    @filter_suffix.setter
    def filter_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_suffix", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for each of the notification configurations.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lambda function ARN.
        """
        return pulumi.get(self, "lambda_function_arn")

    @lambda_function_arn.setter
    def lambda_function_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_function_arn", value)


if not MYPY:
    class BucketNotificationQueueArgsDict(TypedDict):
        events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies [event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        queue_arn: pulumi.Input[_builtins.str]
        """
        SQS queue ARN.
        """
        filter_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix.
        """
        filter_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name suffix.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for each of the notification configurations.
        """
elif False:
    BucketNotificationQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketNotificationQueueArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 queue_arn: pulumi.Input[_builtins.str],
                 filter_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: Specifies [event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        :param pulumi.Input[_builtins.str] queue_arn: SQS queue ARN.
        :param pulumi.Input[_builtins.str] filter_prefix: Object key name prefix.
        :param pulumi.Input[_builtins.str] filter_suffix: Object key name suffix.
        :param pulumi.Input[_builtins.str] id: Unique identifier for each of the notification configurations.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "queue_arn", queue_arn)
        if filter_prefix is not None:
            pulumi.set(__self__, "filter_prefix", filter_prefix)
        if filter_suffix is not None:
            pulumi.set(__self__, "filter_suffix", filter_suffix)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies [event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> pulumi.Input[_builtins.str]:
        """
        SQS queue ARN.
        """
        return pulumi.get(self, "queue_arn")

    @queue_arn.setter
    def queue_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_arn", value)

    @_builtins.property
    @pulumi.getter(name="filterPrefix")
    def filter_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix.
        """
        return pulumi.get(self, "filter_prefix")

    @filter_prefix.setter
    def filter_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_prefix", value)

    @_builtins.property
    @pulumi.getter(name="filterSuffix")
    def filter_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name suffix.
        """
        return pulumi.get(self, "filter_suffix")

    @filter_suffix.setter
    def filter_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_suffix", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for each of the notification configurations.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BucketNotificationTopicArgsDict(TypedDict):
        events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        topic_arn: pulumi.Input[_builtins.str]
        """
        SNS topic ARN.
        """
        filter_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix.
        """
        filter_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name suffix.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for each of the notification configurations.
        """
elif False:
    BucketNotificationTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketNotificationTopicArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 topic_arn: pulumi.Input[_builtins.str],
                 filter_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        :param pulumi.Input[_builtins.str] topic_arn: SNS topic ARN.
        :param pulumi.Input[_builtins.str] filter_prefix: Object key name prefix.
        :param pulumi.Input[_builtins.str] filter_suffix: Object key name suffix.
        :param pulumi.Input[_builtins.str] id: Unique identifier for each of the notification configurations.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "topic_arn", topic_arn)
        if filter_prefix is not None:
            pulumi.set(__self__, "filter_prefix", filter_prefix)
        if filter_suffix is not None:
            pulumi.set(__self__, "filter_suffix", filter_suffix)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        [Event](http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations) for which to send notifications.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[_builtins.str]:
        """
        SNS topic ARN.
        """
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_arn", value)

    @_builtins.property
    @pulumi.getter(name="filterPrefix")
    def filter_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix.
        """
        return pulumi.get(self, "filter_prefix")

    @filter_prefix.setter
    def filter_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_prefix", value)

    @_builtins.property
    @pulumi.getter(name="filterSuffix")
    def filter_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name suffix.
        """
        return pulumi.get(self, "filter_suffix")

    @filter_suffix.setter
    def filter_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_suffix", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for each of the notification configurations.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BucketObjectLockConfigurationArgsDict(TypedDict):
        object_lock_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        """
        rule: NotRequired[pulumi.Input['BucketObjectLockConfigurationRuleArgsDict']]
        """
        Object Lock rule in place for this bucket (documented below).
        """
elif False:
    BucketObjectLockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectLockConfigurationArgs:
    def __init__(__self__, *,
                 object_lock_enabled: Optional[pulumi.Input[_builtins.str]] = None,
                 rule: Optional[pulumi.Input['BucketObjectLockConfigurationRuleArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] object_lock_enabled: Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        :param pulumi.Input['BucketObjectLockConfigurationRuleArgs'] rule: Object Lock rule in place for this bucket (documented below).
        """
        if object_lock_enabled is not None:
            warnings.warn("""object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""", DeprecationWarning)
            pulumi.log.warn("""object_lock_enabled is deprecated: object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""")
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if rule is not None:
            warnings.warn("""rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""", DeprecationWarning)
            pulumi.log.warn("""rule is deprecated: rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""")
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter(name="objectLockEnabled")
    @_utilities.deprecated("""object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""")
    def object_lock_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        """
        return pulumi.get(self, "object_lock_enabled")

    @object_lock_enabled.setter
    def object_lock_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_lock_enabled", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""")
    def rule(self) -> Optional[pulumi.Input['BucketObjectLockConfigurationRuleArgs']]:
        """
        Object Lock rule in place for this bucket (documented below).
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['BucketObjectLockConfigurationRuleArgs']]):
        pulumi.set(self, "rule", value)


if not MYPY:
    class BucketObjectLockConfigurationRuleArgsDict(TypedDict):
        default_retention: pulumi.Input['BucketObjectLockConfigurationRuleDefaultRetentionArgsDict']
        """
        Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
elif False:
    BucketObjectLockConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectLockConfigurationRuleArgs:
    def __init__(__self__, *,
                 default_retention: pulumi.Input['BucketObjectLockConfigurationRuleDefaultRetentionArgs']):
        """
        :param pulumi.Input['BucketObjectLockConfigurationRuleDefaultRetentionArgs'] default_retention: Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
        pulumi.set(__self__, "default_retention", default_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> pulumi.Input['BucketObjectLockConfigurationRuleDefaultRetentionArgs']:
        """
        Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: pulumi.Input['BucketObjectLockConfigurationRuleDefaultRetentionArgs']):
        pulumi.set(self, "default_retention", value)


if not MYPY:
    class BucketObjectLockConfigurationRuleDefaultRetentionArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days that you want to specify for the default retention period.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        """
        years: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of years that you want to specify for the default retention period.
        """
elif False:
    BucketObjectLockConfigurationRuleDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectLockConfigurationRuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 years: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: Number of days that you want to specify for the default retention period.
        :param pulumi.Input[_builtins.str] mode: Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        :param pulumi.Input[_builtins.int] years: Number of years that you want to specify for the default retention period.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days that you want to specify for the default retention period.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of years that you want to specify for the default retention period.
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class BucketObjectLockConfigurationV2RuleArgsDict(TypedDict):
        default_retention: pulumi.Input['BucketObjectLockConfigurationV2RuleDefaultRetentionArgsDict']
        """
        Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
elif False:
    BucketObjectLockConfigurationV2RuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectLockConfigurationV2RuleArgs:
    def __init__(__self__, *,
                 default_retention: pulumi.Input['BucketObjectLockConfigurationV2RuleDefaultRetentionArgs']):
        """
        :param pulumi.Input['BucketObjectLockConfigurationV2RuleDefaultRetentionArgs'] default_retention: Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
        pulumi.set(__self__, "default_retention", default_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> pulumi.Input['BucketObjectLockConfigurationV2RuleDefaultRetentionArgs']:
        """
        Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
        """
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: pulumi.Input['BucketObjectLockConfigurationV2RuleDefaultRetentionArgs']):
        pulumi.set(self, "default_retention", value)


if not MYPY:
    class BucketObjectLockConfigurationV2RuleDefaultRetentionArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days that you want to specify for the default retention period.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        """
        years: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of years that you want to specify for the default retention period.
        """
elif False:
    BucketObjectLockConfigurationV2RuleDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectLockConfigurationV2RuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 years: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: Number of days that you want to specify for the default retention period.
        :param pulumi.Input[_builtins.str] mode: Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        :param pulumi.Input[_builtins.int] years: Number of years that you want to specify for the default retention period.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days that you want to specify for the default retention period.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: `COMPLIANCE`, `GOVERNANCE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of years that you want to specify for the default retention period.
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class BucketObjectv2OverrideProviderArgsDict(TypedDict):
        default_tags: NotRequired[pulumi.Input['BucketObjectv2OverrideProviderDefaultTagsArgsDict']]
        """
        Override the provider `default_tags` configuration block.
        """
elif False:
    BucketObjectv2OverrideProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectv2OverrideProviderArgs:
    def __init__(__self__, *,
                 default_tags: Optional[pulumi.Input['BucketObjectv2OverrideProviderDefaultTagsArgs']] = None):
        """
        :param pulumi.Input['BucketObjectv2OverrideProviderDefaultTagsArgs'] default_tags: Override the provider `default_tags` configuration block.
        """
        if default_tags is not None:
            pulumi.set(__self__, "default_tags", default_tags)

    @_builtins.property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Optional[pulumi.Input['BucketObjectv2OverrideProviderDefaultTagsArgs']]:
        """
        Override the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Optional[pulumi.Input['BucketObjectv2OverrideProviderDefaultTagsArgs']]):
        pulumi.set(self, "default_tags", value)


if not MYPY:
    class BucketObjectv2OverrideProviderDefaultTagsArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    BucketObjectv2OverrideProviderDefaultTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectv2OverrideProviderDefaultTagsArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketOwnershipControlsRuleArgsDict(TypedDict):
        object_ownership: pulumi.Input[_builtins.str]
        """
        Object ownership. Valid values: `BucketOwnerPreferred`, `ObjectWriter` or `BucketOwnerEnforced`
        * `BucketOwnerPreferred` - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the `bucket-owner-full-control` canned ACL.
        * `ObjectWriter` - Uploading account will own the object if the object is uploaded with the `bucket-owner-full-control` canned ACL.
        * `BucketOwnerEnforced` - Bucket owner automatically owns and has full control over every object in the bucket. ACLs no longer affect permissions to data in the S3 bucket.
        """
elif False:
    BucketOwnershipControlsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketOwnershipControlsRuleArgs:
    def __init__(__self__, *,
                 object_ownership: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] object_ownership: Object ownership. Valid values: `BucketOwnerPreferred`, `ObjectWriter` or `BucketOwnerEnforced`
               * `BucketOwnerPreferred` - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the `bucket-owner-full-control` canned ACL.
               * `ObjectWriter` - Uploading account will own the object if the object is uploaded with the `bucket-owner-full-control` canned ACL.
               * `BucketOwnerEnforced` - Bucket owner automatically owns and has full control over every object in the bucket. ACLs no longer affect permissions to data in the S3 bucket.
        """
        pulumi.set(__self__, "object_ownership", object_ownership)

    @_builtins.property
    @pulumi.getter(name="objectOwnership")
    def object_ownership(self) -> pulumi.Input[_builtins.str]:
        """
        Object ownership. Valid values: `BucketOwnerPreferred`, `ObjectWriter` or `BucketOwnerEnforced`
        * `BucketOwnerPreferred` - Objects uploaded to the bucket change ownership to the bucket owner if the objects are uploaded with the `bucket-owner-full-control` canned ACL.
        * `ObjectWriter` - Uploading account will own the object if the object is uploaded with the `bucket-owner-full-control` canned ACL.
        * `BucketOwnerEnforced` - Bucket owner automatically owns and has full control over every object in the bucket. ACLs no longer affect permissions to data in the S3 bucket.
        """
        return pulumi.get(self, "object_ownership")

    @object_ownership.setter
    def object_ownership(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_ownership", value)


if not MYPY:
    class BucketReplicationConfigRuleArgsDict(TypedDict):
        destination: pulumi.Input['BucketReplicationConfigRuleDestinationArgsDict']
        """
        Specifies the destination for the rule. See below.
        """
        status: pulumi.Input[_builtins.str]
        """
        Status of the rule. Either `"Enabled"` or `"Disabled"`. The rule is ignored if status is not "Enabled".
        """
        delete_marker_replication: NotRequired[pulumi.Input['BucketReplicationConfigRuleDeleteMarkerReplicationArgsDict']]
        """
        Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when `filter` is used)documented below.
        """
        existing_object_replication: NotRequired[pulumi.Input['BucketReplicationConfigRuleExistingObjectReplicationArgsDict']]
        """
        Replicate existing objects in the source bucket according to the rule configurations. See below.
        """
        filter: NotRequired[pulumi.Input['BucketReplicationConfigRuleFilterArgsDict']]
        """
        Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the `rule` will default to using `prefix`.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string (`""`) if `filter` is not specified.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        source_selection_criteria: NotRequired[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaArgsDict']]
        """
        Specifies special object selection criteria. See below.
        """
elif False:
    BucketReplicationConfigRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BucketReplicationConfigRuleDestinationArgs'],
                 status: pulumi.Input[_builtins.str],
                 delete_marker_replication: Optional[pulumi.Input['BucketReplicationConfigRuleDeleteMarkerReplicationArgs']] = None,
                 existing_object_replication: Optional[pulumi.Input['BucketReplicationConfigRuleExistingObjectReplicationArgs']] = None,
                 filter: Optional[pulumi.Input['BucketReplicationConfigRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 source_selection_criteria: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationConfigRuleDestinationArgs'] destination: Specifies the destination for the rule. See below.
        :param pulumi.Input[_builtins.str] status: Status of the rule. Either `"Enabled"` or `"Disabled"`. The rule is ignored if status is not "Enabled".
        :param pulumi.Input['BucketReplicationConfigRuleDeleteMarkerReplicationArgs'] delete_marker_replication: Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when `filter` is used)documented below.
        :param pulumi.Input['BucketReplicationConfigRuleExistingObjectReplicationArgs'] existing_object_replication: Replicate existing objects in the source bucket according to the rule configurations. See below.
        :param pulumi.Input['BucketReplicationConfigRuleFilterArgs'] filter: Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the `rule` will default to using `prefix`.
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[_builtins.str] prefix: Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string (`""`) if `filter` is not specified.
        :param pulumi.Input[_builtins.int] priority: Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        :param pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaArgs'] source_selection_criteria: Specifies special object selection criteria. See below.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "status", status)
        if delete_marker_replication is not None:
            pulumi.set(__self__, "delete_marker_replication", delete_marker_replication)
        if existing_object_replication is not None:
            pulumi.set(__self__, "existing_object_replication", existing_object_replication)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            warnings.warn("""prefix is deprecated. Use filter instead.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: prefix is deprecated. Use filter instead.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if source_selection_criteria is not None:
            pulumi.set(__self__, "source_selection_criteria", source_selection_criteria)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BucketReplicationConfigRuleDestinationArgs']:
        """
        Specifies the destination for the rule. See below.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BucketReplicationConfigRuleDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the rule. Either `"Enabled"` or `"Disabled"`. The rule is ignored if status is not "Enabled".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDeleteMarkerReplicationArgs']]:
        """
        Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when `filter` is used)documented below.
        """
        return pulumi.get(self, "delete_marker_replication")

    @delete_marker_replication.setter
    def delete_marker_replication(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDeleteMarkerReplicationArgs']]):
        pulumi.set(self, "delete_marker_replication", value)

    @_builtins.property
    @pulumi.getter(name="existingObjectReplication")
    def existing_object_replication(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleExistingObjectReplicationArgs']]:
        """
        Replicate existing objects in the source bucket according to the rule configurations. See below.
        """
        return pulumi.get(self, "existing_object_replication")

    @existing_object_replication.setter
    def existing_object_replication(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleExistingObjectReplicationArgs']]):
        pulumi.set(self, "existing_object_replication", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleFilterArgs']]:
        """
        Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the `rule` will default to using `prefix`.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""prefix is deprecated. Use filter instead.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string (`""`) if `filter` is not specified.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="sourceSelectionCriteria")
    def source_selection_criteria(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaArgs']]:
        """
        Specifies special object selection criteria. See below.
        """
        return pulumi.get(self, "source_selection_criteria")

    @source_selection_criteria.setter
    def source_selection_criteria(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaArgs']]):
        pulumi.set(self, "source_selection_criteria", value)


if not MYPY:
    class BucketReplicationConfigRuleDeleteMarkerReplicationArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Whether delete markers should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
elif False:
    BucketReplicationConfigRuleDeleteMarkerReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDeleteMarkerReplicationArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: Whether delete markers should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether delete markers should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        ARN of the bucket where you want Amazon S3 to store the results.
        """
        access_control_translation: NotRequired[pulumi.Input['BucketReplicationConfigRuleDestinationAccessControlTranslationArgsDict']]
        """
        Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with `account` owner override configuration.
        """
        account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID to specify the replica ownership. Must be used in conjunction with `access_control_translation` override configuration.
        """
        encryption_configuration: NotRequired[pulumi.Input['BucketReplicationConfigRuleDestinationEncryptionConfigurationArgsDict']]
        """
        Configuration block that provides information about encryption. See below. If `source_selection_criteria` is specified, you must specify this element.
        """
        metrics: NotRequired[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsArgsDict']]
        """
        Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
        """
        replication_time: NotRequired[pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeArgsDict']]
        """
        Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with `metrics`.
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
elif False:
    BucketReplicationConfigRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 access_control_translation: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationAccessControlTranslationArgs']] = None,
                 account: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_configuration: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs']] = None,
                 metrics: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsArgs']] = None,
                 replication_time: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeArgs']] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: ARN of the bucket where you want Amazon S3 to store the results.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationAccessControlTranslationArgs'] access_control_translation: Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with `account` owner override configuration.
        :param pulumi.Input[_builtins.str] account: Account ID to specify the replica ownership. Must be used in conjunction with `access_control_translation` override configuration.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs'] encryption_configuration: Configuration block that provides information about encryption. See below. If `source_selection_criteria` is specified, you must specify this element.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationMetricsArgs'] metrics: Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeArgs'] replication_time: Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with `metrics`.
        :param pulumi.Input[_builtins.str] storage_class: The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        pulumi.set(__self__, "bucket", bucket)
        if access_control_translation is not None:
            pulumi.set(__self__, "access_control_translation", access_control_translation)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if replication_time is not None:
            pulumi.set(__self__, "replication_time", replication_time)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the bucket where you want Amazon S3 to store the results.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="accessControlTranslation")
    def access_control_translation(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDestinationAccessControlTranslationArgs']]:
        """
        Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with `account` owner override configuration.
        """
        return pulumi.get(self, "access_control_translation")

    @access_control_translation.setter
    def access_control_translation(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationAccessControlTranslationArgs']]):
        pulumi.set(self, "access_control_translation", value)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID to specify the replica ownership. Must be used in conjunction with `access_control_translation` override configuration.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs']]:
        """
        Configuration block that provides information about encryption. See below. If `source_selection_criteria` is specified, you must specify this element.
        """
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsArgs']]:
        """
        Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="replicationTime")
    def replication_time(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeArgs']]:
        """
        Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with `metrics`.
        """
        return pulumi.get(self, "replication_time")

    @replication_time.setter
    def replication_time(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeArgs']]):
        pulumi.set(self, "replication_time", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationAccessControlTranslationArgsDict(TypedDict):
        owner: pulumi.Input[_builtins.str]
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference. Valid values: `Destination`.
        """
elif False:
    BucketReplicationConfigRuleDestinationAccessControlTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationAccessControlTranslationArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] owner: Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference. Valid values: `Destination`.
        """
        pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the Amazon S3 API Reference. Valid values: `Destination`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationEncryptionConfigurationArgsDict(TypedDict):
        replica_kms_key_id: pulumi.Input[_builtins.str]
        """
        ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
        """
elif False:
    BucketReplicationConfigRuleDestinationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 replica_kms_key_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] replica_kms_key_id: ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
        """
        pulumi.set(__self__, "replica_kms_key_id", replica_kms_key_id)

    @_builtins.property
    @pulumi.getter(name="replicaKmsKeyId")
    def replica_kms_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
        """
        return pulumi.get(self, "replica_kms_key_id")

    @replica_kms_key_id.setter
    def replica_kms_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "replica_kms_key_id", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationMetricsArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Status of the Destination Metrics. Either `"Enabled"` or `"Disabled"`.
        """
        event_threshold: NotRequired[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsEventThresholdArgsDict']]
        """
        Configuration block that specifies the time threshold for emitting the `s3:Replication:OperationMissedThreshold` event. See below.
        """
elif False:
    BucketReplicationConfigRuleDestinationMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationMetricsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 event_threshold: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] status: Status of the Destination Metrics. Either `"Enabled"` or `"Disabled"`.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs'] event_threshold: Configuration block that specifies the time threshold for emitting the `s3:Replication:OperationMissedThreshold` event. See below.
        """
        pulumi.set(__self__, "status", status)
        if event_threshold is not None:
            pulumi.set(__self__, "event_threshold", event_threshold)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the Destination Metrics. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="eventThreshold")
    def event_threshold(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs']]:
        """
        Configuration block that specifies the time threshold for emitting the `s3:Replication:OperationMissedThreshold` event. See below.
        """
        return pulumi.get(self, "event_threshold")

    @event_threshold.setter
    def event_threshold(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs']]):
        pulumi.set(self, "event_threshold", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationMetricsEventThresholdArgsDict(TypedDict):
        minutes: pulumi.Input[_builtins.int]
        """
        Time in minutes. Valid values: `15`.
        """
elif False:
    BucketReplicationConfigRuleDestinationMetricsEventThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationMetricsEventThresholdArgs:
    def __init__(__self__, *,
                 minutes: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minutes: Time in minutes. Valid values: `15`.
        """
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[_builtins.int]:
        """
        Time in minutes. Valid values: `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationReplicationTimeArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Status of the Replication Time Control. Either `"Enabled"` or `"Disabled"`.
        """
        time: pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeTimeArgsDict']
        """
        Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
        """
elif False:
    BucketReplicationConfigRuleDestinationReplicationTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationReplicationTimeArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 time: pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs']):
        """
        :param pulumi.Input[_builtins.str] status: Status of the Replication Time Control. Either `"Enabled"` or `"Disabled"`.
        :param pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs'] time: Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the Replication Time Control. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs']:
        """
        Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input['BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs']):
        pulumi.set(self, "time", value)


if not MYPY:
    class BucketReplicationConfigRuleDestinationReplicationTimeTimeArgsDict(TypedDict):
        minutes: pulumi.Input[_builtins.int]
        """
        Time in minutes. Valid values: `15`.
        """
elif False:
    BucketReplicationConfigRuleDestinationReplicationTimeTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleDestinationReplicationTimeTimeArgs:
    def __init__(__self__, *,
                 minutes: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] minutes: Time in minutes. Valid values: `15`.
        """
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[_builtins.int]:
        """
        Time in minutes. Valid values: `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class BucketReplicationConfigRuleExistingObjectReplicationArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
elif False:
    BucketReplicationConfigRuleExistingObjectReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleExistingObjectReplicationArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigRuleFilterArgsDict(TypedDict):
        and_: NotRequired[pulumi.Input['BucketReplicationConfigRuleFilterAndArgsDict']]
        """
        Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        tag: NotRequired[pulumi.Input['BucketReplicationConfigRuleFilterTagArgsDict']]
        """
        Configuration block for specifying a tag key and value. See below.
        """
elif False:
    BucketReplicationConfigRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleFilterArgs:
    def __init__(__self__, *,
                 and_: Optional[pulumi.Input['BucketReplicationConfigRuleFilterAndArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input['BucketReplicationConfigRuleFilterTagArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationConfigRuleFilterAndArgs'] and_: Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
        :param pulumi.Input[_builtins.str] prefix: Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input['BucketReplicationConfigRuleFilterTagArgs'] tag: Configuration block for specifying a tag key and value. See below.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleFilterAndArgs']]:
        """
        Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
        """
        return pulumi.get(self, "and_")

    @and_.setter
    def and_(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleFilterAndArgs']]):
        pulumi.set(self, "and_", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleFilterTagArgs']]:
        """
        Configuration block for specifying a tag key and value. See below.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleFilterTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class BucketReplicationConfigRuleFilterAndArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
        """
elif False:
    BucketReplicationConfigRuleFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleFilterAndArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketReplicationConfigRuleFilterTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Name of the object key.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the tag.
        """
elif False:
    BucketReplicationConfigRuleFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Name of the object key.
        :param pulumi.Input[_builtins.str] value: Value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the object key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BucketReplicationConfigRuleSourceSelectionCriteriaArgsDict(TypedDict):
        replica_modifications: NotRequired[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgsDict']]
        """
        Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when `filter` is specified), you can specify this element and set the status to `Enabled` to replicate modifications on replicas.
        """
        sse_kms_encrypted_objects: NotRequired[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict']]
        """
        Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, `replica_kms_key_id` in `destination` `encryption_configuration` must be specified as well.
        """
elif False:
    BucketReplicationConfigRuleSourceSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleSourceSelectionCriteriaArgs:
    def __init__(__self__, *,
                 replica_modifications: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs']] = None,
                 sse_kms_encrypted_objects: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs'] replica_modifications: Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when `filter` is specified), you can specify this element and set the status to `Enabled` to replicate modifications on replicas.
        :param pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs'] sse_kms_encrypted_objects: Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, `replica_kms_key_id` in `destination` `encryption_configuration` must be specified as well.
        """
        if replica_modifications is not None:
            pulumi.set(__self__, "replica_modifications", replica_modifications)
        if sse_kms_encrypted_objects is not None:
            pulumi.set(__self__, "sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @_builtins.property
    @pulumi.getter(name="replicaModifications")
    def replica_modifications(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs']]:
        """
        Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when `filter` is specified), you can specify this element and set the status to `Enabled` to replicate modifications on replicas.
        """
        return pulumi.get(self, "replica_modifications")

    @replica_modifications.setter
    def replica_modifications(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs']]):
        pulumi.set(self, "replica_modifications", value)

    @_builtins.property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]:
        """
        Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, `replica_kms_key_id` in `destination` `encryption_configuration` must be specified as well.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")

    @sse_kms_encrypted_objects.setter
    def sse_kms_encrypted_objects(self, value: Optional[pulumi.Input['BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]):
        pulumi.set(self, "sse_kms_encrypted_objects", value)


if not MYPY:
    class BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
elif False:
    BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleSourceSelectionCriteriaReplicaModificationsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
elif False:
    BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] status: Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the existing objects should be replicated. Either `"Enabled"` or `"Disabled"`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigurationArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['BucketReplicationConfigurationRuleArgsDict']]]
        """
        Specifies the rules managing the replication (documented below).
        """
elif False:
    BucketReplicationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketReplicationConfigurationRuleArgs']]]):
        """
        :param pulumi.Input[_builtins.str] role: ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        :param pulumi.Input[Sequence[pulumi.Input['BucketReplicationConfigurationRuleArgs']]] rules: Specifies the rules managing the replication (documented below).
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketReplicationConfigurationRuleArgs']]]:
        """
        Specifies the rules managing the replication (documented below).
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketReplicationConfigurationRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BucketReplicationConfigurationRuleArgsDict(TypedDict):
        destination: pulumi.Input['BucketReplicationConfigurationRuleDestinationArgsDict']
        """
        Specifies the destination for the rule (documented below).
        """
        status: pulumi.Input[_builtins.str]
        """
        Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        """
        delete_marker_replication_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        """
        filter: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleFilterArgsDict']]
        """
        Filter that identifies subset of objects to which the replication rule applies (documented below).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        source_selection_criteria: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaArgsDict']]
        """
        Specifies special object selection criteria (documented below).
        """
elif False:
    BucketReplicationConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BucketReplicationConfigurationRuleDestinationArgs'],
                 status: pulumi.Input[_builtins.str],
                 delete_marker_replication_status: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input['BucketReplicationConfigurationRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 source_selection_criteria: Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationConfigurationRuleDestinationArgs'] destination: Specifies the destination for the rule (documented below).
        :param pulumi.Input[_builtins.str] status: Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        :param pulumi.Input[_builtins.str] delete_marker_replication_status: Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        :param pulumi.Input['BucketReplicationConfigurationRuleFilterArgs'] filter: Filter that identifies subset of objects to which the replication rule applies (documented below).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[_builtins.str] prefix: Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input[_builtins.int] priority: Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        :param pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs'] source_selection_criteria: Specifies special object selection criteria (documented below).
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "status", status)
        if delete_marker_replication_status is not None:
            pulumi.set(__self__, "delete_marker_replication_status", delete_marker_replication_status)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if source_selection_criteria is not None:
            pulumi.set(__self__, "source_selection_criteria", source_selection_criteria)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BucketReplicationConfigurationRuleDestinationArgs']:
        """
        Specifies the destination for the rule (documented below).
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BucketReplicationConfigurationRuleDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="deleteMarkerReplicationStatus")
    def delete_marker_replication_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        """
        return pulumi.get(self, "delete_marker_replication_status")

    @delete_marker_replication_status.setter
    def delete_marker_replication_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_marker_replication_status", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleFilterArgs']]:
        """
        Filter that identifies subset of objects to which the replication rule applies (documented below).
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="sourceSelectionCriteria")
    def source_selection_criteria(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs']]:
        """
        Specifies special object selection criteria (documented below).
        """
        return pulumi.get(self, "source_selection_criteria")

    @source_selection_criteria.setter
    def source_selection_criteria(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs']]):
        pulumi.set(self, "source_selection_criteria", value)


if not MYPY:
    class BucketReplicationConfigurationRuleDestinationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        """
        access_control_translation: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict']]
        """
        Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        """
        metrics: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleDestinationMetricsArgsDict']]
        """
        Enables replication metrics (required for S3 RTC) (documented below).
        """
        replica_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
        `sse_kms_encrypted_objects` source selection criteria.
        """
        replication_time: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleDestinationReplicationTimeArgsDict']]
        """
        Enables S3 Replication Time Control (S3 RTC) (documented below).
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
elif False:
    BucketReplicationConfigurationRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 access_control_translation: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs']] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 metrics: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationMetricsArgs']] = None,
                 replica_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 replication_time: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationReplicationTimeArgs']] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        :param pulumi.Input['BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs'] access_control_translation: Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        :param pulumi.Input[_builtins.str] account_id: Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        :param pulumi.Input['BucketReplicationConfigurationRuleDestinationMetricsArgs'] metrics: Enables replication metrics (required for S3 RTC) (documented below).
        :param pulumi.Input[_builtins.str] replica_kms_key_id: Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
               `sse_kms_encrypted_objects` source selection criteria.
        :param pulumi.Input['BucketReplicationConfigurationRuleDestinationReplicationTimeArgs'] replication_time: Enables S3 Replication Time Control (S3 RTC) (documented below).
        :param pulumi.Input[_builtins.str] storage_class: The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        pulumi.set(__self__, "bucket", bucket)
        if access_control_translation is not None:
            pulumi.set(__self__, "access_control_translation", access_control_translation)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if replica_kms_key_id is not None:
            pulumi.set(__self__, "replica_kms_key_id", replica_kms_key_id)
        if replication_time is not None:
            pulumi.set(__self__, "replication_time", replication_time)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="accessControlTranslation")
    def access_control_translation(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]:
        """
        Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        """
        return pulumi.get(self, "access_control_translation")

    @access_control_translation.setter
    def access_control_translation(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]):
        pulumi.set(self, "access_control_translation", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationMetricsArgs']]:
        """
        Enables replication metrics (required for S3 RTC) (documented below).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="replicaKmsKeyId")
    def replica_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
        `sse_kms_encrypted_objects` source selection criteria.
        """
        return pulumi.get(self, "replica_kms_key_id")

    @replica_kms_key_id.setter
    def replica_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replica_kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="replicationTime")
    def replication_time(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationReplicationTimeArgs']]:
        """
        Enables S3 Replication Time Control (S3 RTC) (documented below).
        """
        return pulumi.get(self, "replication_time")

    @replication_time.setter
    def replication_time(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleDestinationReplicationTimeArgs']]):
        pulumi.set(self, "replication_time", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict(TypedDict):
        owner: pulumi.Input[_builtins.str]
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
elif False:
    BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleDestinationAccessControlTranslationArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] owner: Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
        pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner", value)


if not MYPY:
    class BucketReplicationConfigurationRuleDestinationMetricsArgsDict(TypedDict):
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of replication metrics. Either `Enabled` or `Disabled`.
        """
elif False:
    BucketReplicationConfigurationRuleDestinationMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleDestinationMetricsArgs:
    def __init__(__self__, *,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] minutes: Threshold within which objects are to be replicated. The only valid value is `15`.
        :param pulumi.Input[_builtins.str] status: Status of replication metrics. Either `Enabled` or `Disabled`.
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of replication metrics. Either `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigurationRuleDestinationReplicationTimeArgsDict(TypedDict):
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of RTC. Either `Enabled` or `Disabled`.
        """
elif False:
    BucketReplicationConfigurationRuleDestinationReplicationTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleDestinationReplicationTimeArgs:
    def __init__(__self__, *,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] minutes: Threshold within which objects are to be replicated. The only valid value is `15`.
        :param pulumi.Input[_builtins.str] status: Status of RTC. Either `Enabled` or `Disabled`.
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of RTC. Either `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketReplicationConfigurationRuleFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of tags that identifies subset of objects to which the rule applies.
        The rule applies only to objects having all the tags in its tagset.
        """
elif False:
    BucketReplicationConfigurationRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: A map of tags that identifies subset of objects to which the rule applies.
               The rule applies only to objects having all the tags in its tagset.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of tags that identifies subset of objects to which the rule applies.
        The rule applies only to objects having all the tags in its tagset.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketReplicationConfigurationRuleSourceSelectionCriteriaArgsDict(TypedDict):
        sse_kms_encrypted_objects: NotRequired[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict']]
        """
        Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
        in `destination` must be specified as well.
        """
elif False:
    BucketReplicationConfigurationRuleSourceSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleSourceSelectionCriteriaArgs:
    def __init__(__self__, *,
                 sse_kms_encrypted_objects: Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']] = None):
        """
        :param pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs'] sse_kms_encrypted_objects: Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
               in `destination` must be specified as well.
        """
        if sse_kms_encrypted_objects is not None:
            pulumi.set(__self__, "sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @_builtins.property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]:
        """
        Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
        in `destination` must be specified as well.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")

    @sse_kms_encrypted_objects.setter
    def sse_kms_encrypted_objects(self, value: Optional[pulumi.Input['BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs']]):
        pulumi.set(self, "sse_kms_encrypted_objects", value)


if not MYPY:
    class BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean which indicates if this criteria is enabled.
        """
elif False:
    BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean which indicates if this criteria is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean which indicates if this criteria is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BucketServerSideEncryptionConfigurationArgsDict(TypedDict):
        rule: pulumi.Input['BucketServerSideEncryptionConfigurationRuleArgsDict']
        """
        Single object for server-side encryption by default configuration. (documented below)
        """
elif False:
    BucketServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 rule: pulumi.Input['BucketServerSideEncryptionConfigurationRuleArgs']):
        """
        :param pulumi.Input['BucketServerSideEncryptionConfigurationRuleArgs'] rule: Single object for server-side encryption by default configuration. (documented below)
        """
        pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input['BucketServerSideEncryptionConfigurationRuleArgs']:
        """
        Single object for server-side encryption by default configuration. (documented below)
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input['BucketServerSideEncryptionConfigurationRuleArgs']):
        pulumi.set(self, "rule", value)


if not MYPY:
    class BucketServerSideEncryptionConfigurationRuleArgsDict(TypedDict):
        apply_server_side_encryption_by_default: NotRequired[pulumi.Input['BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict']]
        """
        Single object for setting server-side encryption by default. See below.
        """
        bucket_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
elif False:
    BucketServerSideEncryptionConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionConfigurationRuleArgs:
    def __init__(__self__, *,
                 apply_server_side_encryption_by_default: Optional[pulumi.Input['BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']] = None,
                 bucket_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs'] apply_server_side_encryption_by_default: Single object for setting server-side encryption by default. See below.
        :param pulumi.Input[_builtins.bool] bucket_key_enabled: Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        if apply_server_side_encryption_by_default is not None:
            pulumi.set(__self__, "apply_server_side_encryption_by_default", apply_server_side_encryption_by_default)
        if bucket_key_enabled is not None:
            pulumi.set(__self__, "bucket_key_enabled", bucket_key_enabled)

    @_builtins.property
    @pulumi.getter(name="applyServerSideEncryptionByDefault")
    def apply_server_side_encryption_by_default(self) -> Optional[pulumi.Input['BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]:
        """
        Single object for setting server-side encryption by default. See below.
        """
        return pulumi.get(self, "apply_server_side_encryption_by_default")

    @apply_server_side_encryption_by_default.setter
    def apply_server_side_encryption_by_default(self, value: Optional[pulumi.Input['BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]):
        pulumi.set(self, "apply_server_side_encryption_by_default", value)

    @_builtins.property
    @pulumi.getter(name="bucketKeyEnabled")
    def bucket_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        return pulumi.get(self, "bucket_key_enabled")

    @bucket_key_enabled.setter
    def bucket_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bucket_key_enabled", value)


if not MYPY:
    class BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[_builtins.str]
        """
        Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        """
        kms_master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
elif False:
    BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[_builtins.str],
                 kms_master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        :param pulumi.Input[_builtins.str] kms_master_key_id: AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_master_key_id", value)


if not MYPY:
    class BucketServerSideEncryptionConfigurationV2RuleArgsDict(TypedDict):
        apply_server_side_encryption_by_default: NotRequired[pulumi.Input['BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgsDict']]
        """
        Single object for setting server-side encryption by default. See below.
        """
        bucket_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
elif False:
    BucketServerSideEncryptionConfigurationV2RuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionConfigurationV2RuleArgs:
    def __init__(__self__, *,
                 apply_server_side_encryption_by_default: Optional[pulumi.Input['BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs']] = None,
                 bucket_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs'] apply_server_side_encryption_by_default: Single object for setting server-side encryption by default. See below.
        :param pulumi.Input[_builtins.bool] bucket_key_enabled: Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        if apply_server_side_encryption_by_default is not None:
            pulumi.set(__self__, "apply_server_side_encryption_by_default", apply_server_side_encryption_by_default)
        if bucket_key_enabled is not None:
            pulumi.set(__self__, "bucket_key_enabled", bucket_key_enabled)

    @_builtins.property
    @pulumi.getter(name="applyServerSideEncryptionByDefault")
    def apply_server_side_encryption_by_default(self) -> Optional[pulumi.Input['BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs']]:
        """
        Single object for setting server-side encryption by default. See below.
        """
        return pulumi.get(self, "apply_server_side_encryption_by_default")

    @apply_server_side_encryption_by_default.setter
    def apply_server_side_encryption_by_default(self, value: Optional[pulumi.Input['BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs']]):
        pulumi.set(self, "apply_server_side_encryption_by_default", value)

    @_builtins.property
    @pulumi.getter(name="bucketKeyEnabled")
    def bucket_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        return pulumi.get(self, "bucket_key_enabled")

    @bucket_key_enabled.setter
    def bucket_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bucket_key_enabled", value)


if not MYPY:
    class BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[_builtins.str]
        """
        Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        """
        kms_master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
elif False:
    BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketServerSideEncryptionConfigurationV2RuleApplyServerSideEncryptionByDefaultArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[_builtins.str],
                 kms_master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        :param pulumi.Input[_builtins.str] kms_master_key_id: AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        Server-side encryption algorithm to use. Valid values are `AES256`, `aws:kms`, and `aws:kms:dsse`
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_master_key_id", value)


if not MYPY:
    class BucketV2CorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of headers allowed.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    BucketV2CorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2CorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: One or more origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: List of headers allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        :param pulumi.Input[_builtins.int] max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        One or more HTTP methods that you allow the origin to execute. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of headers allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript `XMLHttpRequest` object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class BucketV2GrantArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uri address to grant for. Used only when `type` is `Group`.
        """
elif False:
    BucketV2GrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2GrantArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        :param pulumi.Input[_builtins.str] type: Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        :param pulumi.Input[_builtins.str] id: Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        :param pulumi.Input[_builtins.str] uri: Uri address to grant for. Used only when `type` is `Group`.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`. `AmazonCustomerByEmail` is not supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user id to grant for. Used only when `type` is `CanonicalUser`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uri address to grant for. Used only when `type` is `Group`.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class BucketV2LifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies lifecycle rule status.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleExpirationArgsDict']]]]
        """
        Specifies a period in the object's expire. See Expiration below for details.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        noncurrent_version_expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionExpirationArgsDict']]]]
        """
        Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        """
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionTransitionArgsDict']]]]
        """
        Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies object tags key and value.
        """
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleTransitionArgsDict']]]]
        """
        Specifies a period in the object's transitions. See Transition below for details.
        """
elif False:
    BucketV2LifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expirations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleExpirationArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 noncurrent_version_expirations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionExpirationArgs']]]] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[_builtins.int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleExpirationArgs']]] expirations: Specifies a period in the object's expire. See Expiration below for details.
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionExpirationArgs']]] noncurrent_version_expirations: Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionTransitionArgs']]] noncurrent_version_transitions: Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        :param pulumi.Input[_builtins.str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Specifies object tags key and value.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleTransitionArgs']]] transitions: Specifies a period in the object's transitions. See Transition below for details.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expirations is not None:
            pulumi.set(__self__, "expirations", expirations)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expirations is not None:
            pulumi.set(__self__, "noncurrent_version_expirations", noncurrent_version_expirations)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @_builtins.property
    @pulumi.getter
    def expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleExpirationArgs']]]]:
        """
        Specifies a period in the object's expire. See Expiration below for details.
        """
        return pulumi.get(self, "expirations")

    @expirations.setter
    def expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleExpirationArgs']]]]):
        pulumi.set(self, "expirations", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpirations")
    def noncurrent_version_expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionExpirationArgs']]]]:
        """
        Specifies when noncurrent object versions expire. See Noncurrent Version Expiration below for details.
        """
        return pulumi.get(self, "noncurrent_version_expirations")

    @noncurrent_version_expirations.setter
    def noncurrent_version_expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionExpirationArgs']]]]):
        pulumi.set(self, "noncurrent_version_expirations", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionTransitionArgs']]]]:
        """
        Specifies when noncurrent object versions transitions. See Noncurrent Version Transition below for details.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleTransitionArgs']]]]:
        """
        Specifies a period in the object's transitions. See Transition below for details.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2LifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class BucketV2LifecycleRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
elif False:
    BucketV2LifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        :param pulumi.Input[_builtins.bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Amazon S3 to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class BucketV2LifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days noncurrent object versions expire.
        """
elif False:
    BucketV2LifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: Specifies the number of days noncurrent object versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days noncurrent object versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketV2LifecycleRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days noncurrent object versions transition.
        """
elif False:
    BucketV2LifecycleRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LifecycleRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketV2LifecycleRuleTransitionArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
elif False:
    BucketV2LifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        :param pulumi.Input[_builtins.str] date: Specifies the date after which you want the corresponding action to take effect.
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Amazon S3 [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Transition.html#AmazonS3-Type-Transition-StorageClass) to which you want the object to transition.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class BucketV2LoggingArgsDict(TypedDict):
        target_bucket: pulumi.Input[_builtins.str]
        """
        Name of the bucket that will receive the log objects.
        """
        target_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        To specify a key prefix for log objects.
        """
elif False:
    BucketV2LoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2LoggingArgs:
    def __init__(__self__, *,
                 target_bucket: pulumi.Input[_builtins.str],
                 target_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target_bucket: Name of the bucket that will receive the log objects.
        :param pulumi.Input[_builtins.str] target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @_builtins.property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @target_bucket.setter
    def target_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_bucket", value)

    @_builtins.property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")

    @target_prefix.setter
    def target_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_prefix", value)


if not MYPY:
    class BucketV2ObjectLockConfigurationArgsDict(TypedDict):
        object_lock_enabled: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleArgsDict']]]]
        """
        Object Lock rule in place for this bucket (documented below).
        """
elif False:
    BucketV2ObjectLockConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ObjectLockConfigurationArgs:
    def __init__(__self__, *,
                 object_lock_enabled: Optional[pulumi.Input[_builtins.str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] object_lock_enabled: Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleArgs']]] rules: Object Lock rule in place for this bucket (documented below).
        """
        if object_lock_enabled is not None:
            warnings.warn("""object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""", DeprecationWarning)
            pulumi.log.warn("""object_lock_enabled is deprecated: object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""")
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if rules is not None:
            warnings.warn("""rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""", DeprecationWarning)
            pulumi.log.warn("""rules is deprecated: rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""")
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="objectLockEnabled")
    @_utilities.deprecated("""object_lock_enabled is deprecated. Use the top-level parameter object_lock_enabled instead.""")
    def object_lock_enabled(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Valid values are `true` or `false`. This argument is not supported in all regions or partitions.
        """
        return pulumi.get(self, "object_lock_enabled")

    @object_lock_enabled.setter
    def object_lock_enabled(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_lock_enabled", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""rule is deprecated. Use the s3.BucketObjectLockConfiguration resource instead.""")
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleArgs']]]]:
        """
        Object Lock rule in place for this bucket (documented below).
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BucketV2ObjectLockConfigurationRuleArgsDict(TypedDict):
        default_retentions: pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleDefaultRetentionArgsDict']]]
        """
        Default retention period that you want to apply to new objects placed in this bucket (documented below).
        """
elif False:
    BucketV2ObjectLockConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ObjectLockConfigurationRuleArgs:
    def __init__(__self__, *,
                 default_retentions: pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs']]] default_retentions: Default retention period that you want to apply to new objects placed in this bucket (documented below).
        """
        pulumi.set(__self__, "default_retentions", default_retentions)

    @_builtins.property
    @pulumi.getter(name="defaultRetentions")
    def default_retentions(self) -> pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs']]]:
        """
        Default retention period that you want to apply to new objects placed in this bucket (documented below).
        """
        return pulumi.get(self, "default_retentions")

    @default_retentions.setter
    def default_retentions(self, value: pulumi.Input[Sequence[pulumi.Input['BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs']]]):
        pulumi.set(self, "default_retentions", value)


if not MYPY:
    class BucketV2ObjectLockConfigurationRuleDefaultRetentionArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days that you want to specify for the default retention period.
        """
        years: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of years that you want to specify for the default retention period.
        """
elif False:
    BucketV2ObjectLockConfigurationRuleDefaultRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ObjectLockConfigurationRuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 years: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
        :param pulumi.Input[_builtins.int] days: Number of days that you want to specify for the default retention period.
        :param pulumi.Input[_builtins.int] years: Number of years that you want to specify for the default retention period.
        """
        pulumi.set(__self__, "mode", mode)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Default Object Lock retention mode you want to apply to new objects placed in this bucket. Valid values are `GOVERNANCE` and `COMPLIANCE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days that you want to specify for the default retention period.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of years that you want to specify for the default retention period.
        """
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "years", value)


if not MYPY:
    class BucketV2ReplicationConfigurationArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleArgsDict']]]
        """
        Specifies the rules managing the replication (documented below).
        """
elif False:
    BucketV2ReplicationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleArgs']]]):
        """
        :param pulumi.Input[_builtins.str] role: ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleArgs']]] rules: Specifies the rules managing the replication (documented below).
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the IAM role for Amazon S3 to assume when replicating the objects.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleArgs']]]:
        """
        Specifies the rules managing the replication (documented below).
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleArgsDict(TypedDict):
        destinations: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationArgsDict']]]
        """
        Specifies the destination for the rule (documented below).
        """
        status: pulumi.Input[_builtins.str]
        """
        Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        """
        delete_marker_replication_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleFilterArgsDict']]]]
        """
        Filter that identifies subset of objects to which the replication rule applies (documented below).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        source_selection_criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgsDict']]]]
        """
        Specifies special object selection criteria (documented below).
        """
elif False:
    BucketV2ReplicationConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleArgs:
    def __init__(__self__, *,
                 destinations: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationArgs']]],
                 status: pulumi.Input[_builtins.str],
                 delete_marker_replication_status: Optional[pulumi.Input[_builtins.str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleFilterArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 source_selection_criterias: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationArgs']]] destinations: Specifies the destination for the rule (documented below).
        :param pulumi.Input[_builtins.str] status: Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        :param pulumi.Input[_builtins.str] delete_marker_replication_status: Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleFilterArgs']]] filters: Filter that identifies subset of objects to which the replication rule applies (documented below).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[_builtins.str] prefix: Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input[_builtins.int] priority: Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs']]] source_selection_criterias: Specifies special object selection criteria (documented below).
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "status", status)
        if delete_marker_replication_status is not None:
            pulumi.set(__self__, "delete_marker_replication_status", delete_marker_replication_status)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if source_selection_criterias is not None:
            pulumi.set(__self__, "source_selection_criterias", source_selection_criterias)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationArgs']]]:
        """
        Specifies the destination for the rule (documented below).
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationArgs']]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Status of the rule. Either `Enabled` or `Disabled`. The rule is ignored if status is not Enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="deleteMarkerReplicationStatus")
    def delete_marker_replication_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether delete markers are replicated. The only valid value is `Enabled`. To disable, omit this argument. This argument is only valid with V2 replication configurations (i.e., when `filter` is used).
        """
        return pulumi.get(self, "delete_marker_replication_status")

    @delete_marker_replication_status.setter
    def delete_marker_replication_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_marker_replication_status", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleFilterArgs']]]]:
        """
        Filter that identifies subset of objects to which the replication rule applies (documented below).
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object keyname prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority associated with the rule. Priority should only be set if `filter` is configured. If not provided, defaults to `0`. Priority must be unique between multiple rules.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="sourceSelectionCriterias")
    def source_selection_criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs']]]]:
        """
        Specifies special object selection criteria (documented below).
        """
        return pulumi.get(self, "source_selection_criterias")

    @source_selection_criterias.setter
    def source_selection_criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs']]]]):
        pulumi.set(self, "source_selection_criterias", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleDestinationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        """
        access_control_translations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict']]]]
        """
        Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationMetricArgsDict']]]]
        """
        Enables replication metrics (required for S3 RTC) (documented below).
        """
        replica_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
        `sse_kms_encrypted_objects` source selection criteria.
        """
        replication_times: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgsDict']]]]
        """
        Enables S3 Replication Time Control (S3 RTC) (documented below).
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
elif False:
    BucketV2ReplicationConfigurationRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 access_control_translations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]]] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationMetricArgs']]]] = None,
                 replica_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 replication_times: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs']]]] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]] access_control_translations: Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        :param pulumi.Input[_builtins.str] account_id: Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationMetricArgs']]] metrics: Enables replication metrics (required for S3 RTC) (documented below).
        :param pulumi.Input[_builtins.str] replica_kms_key_id: Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
               `sse_kms_encrypted_objects` source selection criteria.
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs']]] replication_times: Enables S3 Replication Time Control (S3 RTC) (documented below).
        :param pulumi.Input[_builtins.str] storage_class: The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        pulumi.set(__self__, "bucket", bucket)
        if access_control_translations is not None:
            pulumi.set(__self__, "access_control_translations", access_control_translations)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if replica_kms_key_id is not None:
            pulumi.set(__self__, "replica_kms_key_id", replica_kms_key_id)
        if replication_times is not None:
            pulumi.set(__self__, "replication_times", replication_times)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the S3 bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="accessControlTranslations")
    def access_control_translations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]]]:
        """
        Specifies the overrides to use for object owners on replication (documented below). Must be used in conjunction with `account_id` owner override configuration.
        """
        return pulumi.get(self, "access_control_translations")

    @access_control_translations.setter
    def access_control_translations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs']]]]):
        pulumi.set(self, "access_control_translations", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID to use for overriding the object owner on replication. Must be used in conjunction with `access_control_translation` override configuration.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationMetricArgs']]]]:
        """
        Enables replication metrics (required for S3 RTC) (documented below).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationMetricArgs']]]]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="replicaKmsKeyId")
    def replica_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination KMS encryption key ARN for SSE-KMS replication. Must be used in conjunction with
        `sse_kms_encrypted_objects` source selection criteria.
        """
        return pulumi.get(self, "replica_kms_key_id")

    @replica_kms_key_id.setter
    def replica_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replica_kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="replicationTimes")
    def replication_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs']]]]:
        """
        Enables S3 Replication Time Control (S3 RTC) (documented below).
        """
        return pulumi.get(self, "replication_times")

    @replication_times.setter
    def replication_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs']]]]):
        pulumi.set(self, "replication_times", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_Destination.html#AmazonS3-Type-Destination-StorageClass) used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict(TypedDict):
        owner: pulumi.Input[_builtins.str]
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
elif False:
    BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleDestinationAccessControlTranslationArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] owner: Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
        pulumi.set(__self__, "owner", owner)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketReplication.html) in the Amazon S3 API Reference. The only valid value is `Destination`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleDestinationMetricArgsDict(TypedDict):
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of replication metrics. Either `Enabled` or `Disabled`.
        """
elif False:
    BucketV2ReplicationConfigurationRuleDestinationMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleDestinationMetricArgs:
    def __init__(__self__, *,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] minutes: Threshold within which objects are to be replicated. The only valid value is `15`.
        :param pulumi.Input[_builtins.str] status: Status of replication metrics. Either `Enabled` or `Disabled`.
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of replication metrics. Either `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgsDict(TypedDict):
        minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of RTC. Either `Enabled` or `Disabled`.
        """
elif False:
    BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleDestinationReplicationTimeArgs:
    def __init__(__self__, *,
                 minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] minutes: Threshold within which objects are to be replicated. The only valid value is `15`.
        :param pulumi.Input[_builtins.str] status: Status of RTC. Either `Enabled` or `Disabled`.
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Threshold within which objects are to be replicated. The only valid value is `15`.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of RTC. Either `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of tags that identifies subset of objects to which the rule applies.
        The rule applies only to objects having all the tags in its tagset.
        """
elif False:
    BucketV2ReplicationConfigurationRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: A map of tags that identifies subset of objects to which the rule applies.
               The rule applies only to objects having all the tags in its tagset.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object keyname prefix that identifies subset of objects to which the rule applies. Must be less than or equal to 1024 characters in length.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of tags that identifies subset of objects to which the rule applies.
        The rule applies only to objects having all the tags in its tagset.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgsDict(TypedDict):
        sse_kms_encrypted_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgsDict']]]]
        """
        Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
        in `destination` must be specified as well.
        """
elif False:
    BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaArgs:
    def __init__(__self__, *,
                 sse_kms_encrypted_objects: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs']]] sse_kms_encrypted_objects: Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
               in `destination` must be specified as well.
        """
        if sse_kms_encrypted_objects is not None:
            pulumi.set(__self__, "sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @_builtins.property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs']]]]:
        """
        Match SSE-KMS encrypted objects (documented below). If specified, `replica_kms_key_id`
        in `destination` must be specified as well.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")

    @sse_kms_encrypted_objects.setter
    def sse_kms_encrypted_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs']]]]):
        pulumi.set(self, "sse_kms_encrypted_objects", value)


if not MYPY:
    class BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean which indicates if this criteria is enabled.
        """
elif False:
    BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ReplicationConfigurationRuleSourceSelectionCriteriaSseKmsEncryptedObjectArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean which indicates if this criteria is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean which indicates if this criteria is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BucketV2ServerSideEncryptionConfigurationArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleArgsDict']]]
        """
        Single object for server-side encryption by default configuration. (documented below)
        """
elif False:
    BucketV2ServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleArgs']]] rules: Single object for server-side encryption by default configuration. (documented below)
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleArgs']]]:
        """
        Single object for server-side encryption by default configuration. (documented below)
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BucketV2ServerSideEncryptionConfigurationRuleArgsDict(TypedDict):
        apply_server_side_encryption_by_defaults: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict']]]
        """
        Single object for setting server-side encryption by default. (documented below)
        """
        bucket_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
elif False:
    BucketV2ServerSideEncryptionConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ServerSideEncryptionConfigurationRuleArgs:
    def __init__(__self__, *,
                 apply_server_side_encryption_by_defaults: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]],
                 bucket_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]] apply_server_side_encryption_by_defaults: Single object for setting server-side encryption by default. (documented below)
        :param pulumi.Input[_builtins.bool] bucket_key_enabled: Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        pulumi.set(__self__, "apply_server_side_encryption_by_defaults", apply_server_side_encryption_by_defaults)
        if bucket_key_enabled is not None:
            pulumi.set(__self__, "bucket_key_enabled", bucket_key_enabled)

    @_builtins.property
    @pulumi.getter(name="applyServerSideEncryptionByDefaults")
    def apply_server_side_encryption_by_defaults(self) -> pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]]:
        """
        Single object for setting server-side encryption by default. (documented below)
        """
        return pulumi.get(self, "apply_server_side_encryption_by_defaults")

    @apply_server_side_encryption_by_defaults.setter
    def apply_server_side_encryption_by_defaults(self, value: pulumi.Input[Sequence[pulumi.Input['BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs']]]):
        pulumi.set(self, "apply_server_side_encryption_by_defaults", value)

    @_builtins.property
    @pulumi.getter(name="bucketKeyEnabled")
    def bucket_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) for SSE-KMS.
        """
        return pulumi.get(self, "bucket_key_enabled")

    @bucket_key_enabled.setter
    def bucket_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bucket_key_enabled", value)


if not MYPY:
    class BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict(TypedDict):
        sse_algorithm: pulumi.Input[_builtins.str]
        """
        Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
        """
        kms_master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
elif False:
    BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2ServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input[_builtins.str],
                 kms_master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sse_algorithm: Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
        :param pulumi.Input[_builtins.str] kms_master_key_id: AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input[_builtins.str]:
        """
        Server-side encryption algorithm to use. Valid values are `AES256` and `aws:kms`
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of `sse_algorithm` as `aws:kms`. The default `aws/s3` AWS KMS master key is used if this element is absent while the `sse_algorithm` is `aws:kms`.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_master_key_id", value)


if not MYPY:
    class BucketV2VersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        mfa_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
elif False:
    BucketV2VersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2VersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 mfa_delete: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        :param pulumi.Input[_builtins.bool] mfa_delete: Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mfa_delete is not None:
            pulumi.set(__self__, "mfa_delete", mfa_delete)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="mfaDelete")
    def mfa_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
        return pulumi.get(self, "mfa_delete")

    @mfa_delete.setter
    def mfa_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mfa_delete", value)


if not MYPY:
    class BucketV2WebsiteArgsDict(TypedDict):
        error_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Absolute path to the document to return in case of a 4XX error.
        """
        index_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        """
        redirect_all_requests_to: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        routing_rules: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
        describing redirect behavior and when redirects are applied.
        """
elif False:
    BucketV2WebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketV2WebsiteArgs:
    def __init__(__self__, *,
                 error_document: Optional[pulumi.Input[_builtins.str]] = None,
                 index_document: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_all_requests_to: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_rules: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_document: Absolute path to the document to return in case of a 4XX error.
        :param pulumi.Input[_builtins.str] index_document: Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        :param pulumi.Input[_builtins.str] redirect_all_requests_to: Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        :param pulumi.Input[_builtins.str] routing_rules: JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
               describing redirect behavior and when redirects are applied.
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_document", value)

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_document", value)

    @_builtins.property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @redirect_all_requests_to.setter
    def redirect_all_requests_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_all_requests_to", value)

    @_builtins.property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
        describing redirect behavior and when redirects are applied.
        """
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_rules", value)


if not MYPY:
    class BucketVersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        mfa_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
elif False:
    BucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 mfa_delete: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        :param pulumi.Input[_builtins.bool] mfa_delete: Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mfa_delete is not None:
            pulumi.set(__self__, "mfa_delete", mfa_delete)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="mfaDelete")
    def mfa_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable MFA delete for either `Change the versioning state of your bucket` or `Permanently delete an object version`. Default is `false`. This cannot be used to toggle this setting but is available to allow managed buckets to reflect the state in AWS
        """
        return pulumi.get(self, "mfa_delete")

    @mfa_delete.setter
    def mfa_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mfa_delete", value)


if not MYPY:
    class BucketVersioningV2VersioningConfigurationArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        """
        mfa_delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
elif False:
    BucketVersioningV2VersioningConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketVersioningV2VersioningConfigurationArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 mfa_delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        :param pulumi.Input[_builtins.str] mfa_delete: Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
        pulumi.set(__self__, "status", status)
        if mfa_delete is not None:
            pulumi.set(__self__, "mfa_delete", mfa_delete)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="mfaDelete")
    def mfa_delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "mfa_delete")

    @mfa_delete.setter
    def mfa_delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mfa_delete", value)


if not MYPY:
    class BucketVersioningVersioningConfigurationArgsDict(TypedDict):
        status: pulumi.Input[_builtins.str]
        """
        Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        """
        mfa_delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
elif False:
    BucketVersioningVersioningConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketVersioningVersioningConfigurationArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[_builtins.str],
                 mfa_delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        :param pulumi.Input[_builtins.str] mfa_delete: Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
        pulumi.set(__self__, "status", status)
        if mfa_delete is not None:
            pulumi.set(__self__, "mfa_delete", mfa_delete)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Versioning state of the bucket. Valid values: `Enabled`, `Suspended`, or `Disabled`. `Disabled` should only be used when creating or importing resources that correspond to unversioned S3 buckets.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="mfaDelete")
    def mfa_delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: `Enabled` or `Disabled`.
        """
        return pulumi.get(self, "mfa_delete")

    @mfa_delete.setter
    def mfa_delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mfa_delete", value)


if not MYPY:
    class BucketWebsiteArgsDict(TypedDict):
        error_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Absolute path to the document to return in case of a 4XX error.
        """
        index_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        """
        redirect_all_requests_to: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        routing_rules: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
        describing redirect behavior and when redirects are applied.
        """
elif False:
    BucketWebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteArgs:
    def __init__(__self__, *,
                 error_document: Optional[pulumi.Input[_builtins.str]] = None,
                 index_document: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_all_requests_to: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_rules: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_document: Absolute path to the document to return in case of a 4XX error.
        :param pulumi.Input[_builtins.str] index_document: Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        :param pulumi.Input[_builtins.str] redirect_all_requests_to: Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        :param pulumi.Input[_builtins.str] routing_rules: JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
               describing redirect behavior and when redirects are applied.
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_document", value)

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Amazon S3 returns this index document when requests are made to the root domain or any of the subfolders.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_document", value)

    @_builtins.property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @redirect_all_requests_to.setter
    def redirect_all_requests_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_all_requests_to", value)

    @_builtins.property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON array containing [routing rules](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-websiteconfiguration-routingrules.html)
        describing redirect behavior and when redirects are applied.
        """
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_rules", value)


if not MYPY:
    class BucketWebsiteConfigurationErrorDocumentArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Object key name to use when a 4XX class error occurs.
        """
elif False:
    BucketWebsiteConfigurationErrorDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationErrorDocumentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Object key name to use when a 4XX class error occurs.
        """
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Object key name to use when a 4XX class error occurs.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class BucketWebsiteConfigurationIndexDocumentArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        Suffix that is appended to a request that is for a directory on the website endpoint.
        For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
        The suffix must not be empty and must not include a slash character.
        """
elif False:
    BucketWebsiteConfigurationIndexDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationIndexDocumentArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] suffix: Suffix that is appended to a request that is for a directory on the website endpoint.
               For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
               The suffix must not be empty and must not include a slash character.
        """
        pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        Suffix that is appended to a request that is for a directory on the website endpoint.
        For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
        The suffix must not be empty and must not include a slash character.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class BucketWebsiteConfigurationRedirectAllRequestsToArgsDict(TypedDict):
        host_name: pulumi.Input[_builtins.str]
        """
        Name of the host where requests are redirected.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
elif False:
    BucketWebsiteConfigurationRedirectAllRequestsToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationRedirectAllRequestsToArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[_builtins.str],
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_name: Name of the host where requests are redirected.
        :param pulumi.Input[_builtins.str] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        pulumi.set(__self__, "host_name", host_name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the host where requests are redirected.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class BucketWebsiteConfigurationRoutingRuleArgsDict(TypedDict):
        redirect: pulumi.Input['BucketWebsiteConfigurationRoutingRuleRedirectArgsDict']
        """
        Configuration block for redirect information. See below.
        """
        condition: NotRequired[pulumi.Input['BucketWebsiteConfigurationRoutingRuleConditionArgsDict']]
        """
        Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
elif False:
    BucketWebsiteConfigurationRoutingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationRoutingRuleArgs:
    def __init__(__self__, *,
                 redirect: pulumi.Input['BucketWebsiteConfigurationRoutingRuleRedirectArgs'],
                 condition: Optional[pulumi.Input['BucketWebsiteConfigurationRoutingRuleConditionArgs']] = None):
        """
        :param pulumi.Input['BucketWebsiteConfigurationRoutingRuleRedirectArgs'] redirect: Configuration block for redirect information. See below.
        :param pulumi.Input['BucketWebsiteConfigurationRoutingRuleConditionArgs'] condition: Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
        pulumi.set(__self__, "redirect", redirect)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> pulumi.Input['BucketWebsiteConfigurationRoutingRuleRedirectArgs']:
        """
        Configuration block for redirect information. See below.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: pulumi.Input['BucketWebsiteConfigurationRoutingRuleRedirectArgs']):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['BucketWebsiteConfigurationRoutingRuleConditionArgs']]:
        """
        Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['BucketWebsiteConfigurationRoutingRuleConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class BucketWebsiteConfigurationRoutingRuleConditionArgsDict(TypedDict):
        http_error_code_returned_equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        """
        key_prefix_equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
elif False:
    BucketWebsiteConfigurationRoutingRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationRoutingRuleConditionArgs:
    def __init__(__self__, *,
                 http_error_code_returned_equals: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix_equals: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] http_error_code_returned_equals: HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        :param pulumi.Input[_builtins.str] key_prefix_equals: Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
        if http_error_code_returned_equals is not None:
            pulumi.set(__self__, "http_error_code_returned_equals", http_error_code_returned_equals)
        if key_prefix_equals is not None:
            pulumi.set(__self__, "key_prefix_equals", key_prefix_equals)

    @_builtins.property
    @pulumi.getter(name="httpErrorCodeReturnedEquals")
    def http_error_code_returned_equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "http_error_code_returned_equals")

    @http_error_code_returned_equals.setter
    def http_error_code_returned_equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_error_code_returned_equals", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefixEquals")
    def key_prefix_equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "key_prefix_equals")

    @key_prefix_equals.setter
    def key_prefix_equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix_equals", value)


if not MYPY:
    class BucketWebsiteConfigurationRoutingRuleRedirectArgsDict(TypedDict):
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name to use in the redirect request.
        """
        http_redirect_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP redirect code to use on the response.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        replace_key_prefix_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        """
        replace_key_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
elif False:
    BucketWebsiteConfigurationRoutingRuleRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationRoutingRuleRedirectArgs:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 http_redirect_code: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_key_prefix_with: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_key_with: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_name: Host name to use in the redirect request.
        :param pulumi.Input[_builtins.str] http_redirect_code: HTTP redirect code to use on the response.
        :param pulumi.Input[_builtins.str] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        :param pulumi.Input[_builtins.str] replace_key_prefix_with: Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        :param pulumi.Input[_builtins.str] replace_key_with: Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_redirect_code is not None:
            pulumi.set(__self__, "http_redirect_code", http_redirect_code)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if replace_key_prefix_with is not None:
            pulumi.set(__self__, "replace_key_prefix_with", replace_key_prefix_with)
        if replace_key_with is not None:
            pulumi.set(__self__, "replace_key_with", replace_key_with)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name to use in the redirect request.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter(name="httpRedirectCode")
    def http_redirect_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP redirect code to use on the response.
        """
        return pulumi.get(self, "http_redirect_code")

    @http_redirect_code.setter
    def http_redirect_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_redirect_code", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="replaceKeyPrefixWith")
    def replace_key_prefix_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        """
        return pulumi.get(self, "replace_key_prefix_with")

    @replace_key_prefix_with.setter
    def replace_key_prefix_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_key_prefix_with", value)

    @_builtins.property
    @pulumi.getter(name="replaceKeyWith")
    def replace_key_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
        return pulumi.get(self, "replace_key_with")

    @replace_key_with.setter
    def replace_key_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_key_with", value)


if not MYPY:
    class BucketWebsiteConfigurationV2ErrorDocumentArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Object key name to use when a 4XX class error occurs.
        """
elif False:
    BucketWebsiteConfigurationV2ErrorDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2ErrorDocumentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Object key name to use when a 4XX class error occurs.
        """
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Object key name to use when a 4XX class error occurs.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class BucketWebsiteConfigurationV2IndexDocumentArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        Suffix that is appended to a request that is for a directory on the website endpoint.
        For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
        The suffix must not be empty and must not include a slash character.
        """
elif False:
    BucketWebsiteConfigurationV2IndexDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2IndexDocumentArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] suffix: Suffix that is appended to a request that is for a directory on the website endpoint.
               For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
               The suffix must not be empty and must not include a slash character.
        """
        pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        Suffix that is appended to a request that is for a directory on the website endpoint.
        For example, if the suffix is `index.html` and you make a request to `samplebucket/images/`, the data that is returned will be for the object with the key name `images/index.html`.
        The suffix must not be empty and must not include a slash character.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class BucketWebsiteConfigurationV2RedirectAllRequestsToArgsDict(TypedDict):
        host_name: pulumi.Input[_builtins.str]
        """
        Name of the host where requests are redirected.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
elif False:
    BucketWebsiteConfigurationV2RedirectAllRequestsToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2RedirectAllRequestsToArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[_builtins.str],
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_name: Name of the host where requests are redirected.
        :param pulumi.Input[_builtins.str] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        pulumi.set(__self__, "host_name", host_name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the host where requests are redirected.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class BucketWebsiteConfigurationV2RoutingRuleArgsDict(TypedDict):
        redirect: pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleRedirectArgsDict']
        """
        Configuration block for redirect information. See below.
        """
        condition: NotRequired[pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleConditionArgsDict']]
        """
        Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
elif False:
    BucketWebsiteConfigurationV2RoutingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2RoutingRuleArgs:
    def __init__(__self__, *,
                 redirect: pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleRedirectArgs'],
                 condition: Optional[pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleConditionArgs']] = None):
        """
        :param pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleRedirectArgs'] redirect: Configuration block for redirect information. See below.
        :param pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleConditionArgs'] condition: Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
        pulumi.set(__self__, "redirect", redirect)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleRedirectArgs']:
        """
        Configuration block for redirect information. See below.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleRedirectArgs']):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleConditionArgs']]:
        """
        Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['BucketWebsiteConfigurationV2RoutingRuleConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class BucketWebsiteConfigurationV2RoutingRuleConditionArgsDict(TypedDict):
        http_error_code_returned_equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        """
        key_prefix_equals: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
elif False:
    BucketWebsiteConfigurationV2RoutingRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2RoutingRuleConditionArgs:
    def __init__(__self__, *,
                 http_error_code_returned_equals: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix_equals: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] http_error_code_returned_equals: HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        :param pulumi.Input[_builtins.str] key_prefix_equals: Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
        if http_error_code_returned_equals is not None:
            pulumi.set(__self__, "http_error_code_returned_equals", http_error_code_returned_equals)
        if key_prefix_equals is not None:
            pulumi.set(__self__, "key_prefix_equals", key_prefix_equals)

    @_builtins.property
    @pulumi.getter(name="httpErrorCodeReturnedEquals")
    def http_error_code_returned_equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP error code when the redirect is applied. If specified with `key_prefix_equals`, then both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "http_error_code_returned_equals")

    @http_error_code_returned_equals.setter
    def http_error_code_returned_equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_error_code_returned_equals", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefixEquals")
    def key_prefix_equals(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key name prefix when the redirect is applied. If specified with `http_error_code_returned_equals`, then both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "key_prefix_equals")

    @key_prefix_equals.setter
    def key_prefix_equals(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix_equals", value)


if not MYPY:
    class BucketWebsiteConfigurationV2RoutingRuleRedirectArgsDict(TypedDict):
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host name to use in the redirect request.
        """
        http_redirect_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP redirect code to use on the response.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        replace_key_prefix_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        """
        replace_key_with: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
elif False:
    BucketWebsiteConfigurationV2RoutingRuleRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteConfigurationV2RoutingRuleRedirectArgs:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 http_redirect_code: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_key_prefix_with: Optional[pulumi.Input[_builtins.str]] = None,
                 replace_key_with: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_name: Host name to use in the redirect request.
        :param pulumi.Input[_builtins.str] http_redirect_code: HTTP redirect code to use on the response.
        :param pulumi.Input[_builtins.str] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        :param pulumi.Input[_builtins.str] replace_key_prefix_with: Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        :param pulumi.Input[_builtins.str] replace_key_with: Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_redirect_code is not None:
            pulumi.set(__self__, "http_redirect_code", http_redirect_code)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if replace_key_prefix_with is not None:
            pulumi.set(__self__, "replace_key_prefix_with", replace_key_prefix_with)
        if replace_key_with is not None:
            pulumi.set(__self__, "replace_key_with", replace_key_with)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host name to use in the redirect request.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter(name="httpRedirectCode")
    def http_redirect_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP redirect code to use on the response.
        """
        return pulumi.get(self, "http_redirect_code")

    @http_redirect_code.setter
    def http_redirect_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_redirect_code", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: `http`, `https`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="replaceKeyPrefixWith")
    def replace_key_prefix_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a `condition` block with `key_prefix_equals` set to `docs/` and in the `redirect` set `replace_key_prefix_with` to `/documents`.
        """
        return pulumi.get(self, "replace_key_prefix_with")

    @replace_key_prefix_with.setter
    def replace_key_prefix_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_key_prefix_with", value)

    @_builtins.property
    @pulumi.getter(name="replaceKeyWith")
    def replace_key_with(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specific object key to use in the redirect request. For example, redirect request to `error.html`.
        """
        return pulumi.get(self, "replace_key_with")

    @replace_key_with.setter
    def replace_key_with(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replace_key_with", value)


if not MYPY:
    class DirectoryBucketLocationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        [Availability Zone ID](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#az-ids) or Local Zone ID.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location type. Valid values: `AvailabilityZone`, `LocalZone`.
        """
elif False:
    DirectoryBucketLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryBucketLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: [Availability Zone ID](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#az-ids) or Local Zone ID.
        :param pulumi.Input[_builtins.str] type: Location type. Valid values: `AvailabilityZone`, `LocalZone`.
        """
        pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        [Availability Zone ID](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#az-ids) or Local Zone ID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location type. Valid values: `AvailabilityZone`, `LocalZone`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InventoryDestinationArgsDict(TypedDict):
        bucket: pulumi.Input['InventoryDestinationBucketArgsDict']
        """
        S3 bucket configuration where inventory results are published (documented below).
        """
elif False:
    InventoryDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input['InventoryDestinationBucketArgs']):
        """
        :param pulumi.Input['InventoryDestinationBucketArgs'] bucket: S3 bucket configuration where inventory results are published (documented below).
        """
        pulumi.set(__self__, "bucket", bucket)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input['InventoryDestinationBucketArgs']:
        """
        S3 bucket configuration where inventory results are published (documented below).
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input['InventoryDestinationBucketArgs']):
        pulumi.set(self, "bucket", value)


if not MYPY:
    class InventoryDestinationBucketArgsDict(TypedDict):
        bucket_arn: pulumi.Input[_builtins.str]
        """
        Amazon S3 bucket ARN of the destination.
        """
        format: pulumi.Input[_builtins.str]
        """
        Specifies the output format of the inventory results. Can be `CSV`, [`ORC`](https://orc.apache.org/) or [`Parquet`](https://parquet.apache.org/).
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
        """
        encryption: NotRequired[pulumi.Input['InventoryDestinationBucketEncryptionArgsDict']]
        """
        Contains the type of server-side encryption to use to encrypt the inventory (documented below).
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix that is prepended to all inventory results.
        """
elif False:
    InventoryDestinationBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryDestinationBucketArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 format: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption: Optional[pulumi.Input['InventoryDestinationBucketEncryptionArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_arn: Amazon S3 bucket ARN of the destination.
        :param pulumi.Input[_builtins.str] format: Specifies the output format of the inventory results. Can be `CSV`, [`ORC`](https://orc.apache.org/) or [`Parquet`](https://parquet.apache.org/).
        :param pulumi.Input[_builtins.str] account_id: ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
        :param pulumi.Input['InventoryDestinationBucketEncryptionArgs'] encryption: Contains the type of server-side encryption to use to encrypt the inventory (documented below).
        :param pulumi.Input[_builtins.str] prefix: Prefix that is prepended to all inventory results.
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        pulumi.set(__self__, "format", format)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Amazon S3 bucket ARN of the destination.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the output format of the inventory results. Can be `CSV`, [`ORC`](https://orc.apache.org/) or [`Parquet`](https://parquet.apache.org/).
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['InventoryDestinationBucketEncryptionArgs']]:
        """
        Contains the type of server-side encryption to use to encrypt the inventory (documented below).
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['InventoryDestinationBucketEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix that is prepended to all inventory results.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class InventoryDestinationBucketEncryptionArgsDict(TypedDict):
        sse_kms: NotRequired[pulumi.Input['InventoryDestinationBucketEncryptionSseKmsArgsDict']]
        """
        Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
        """
        sse_s3: NotRequired[pulumi.Input['InventoryDestinationBucketEncryptionSseS3ArgsDict']]
        """
        Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
        """
elif False:
    InventoryDestinationBucketEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryDestinationBucketEncryptionArgs:
    def __init__(__self__, *,
                 sse_kms: Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseKmsArgs']] = None,
                 sse_s3: Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseS3Args']] = None):
        """
        :param pulumi.Input['InventoryDestinationBucketEncryptionSseKmsArgs'] sse_kms: Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
        :param pulumi.Input['InventoryDestinationBucketEncryptionSseS3Args'] sse_s3: Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
        """
        if sse_kms is not None:
            pulumi.set(__self__, "sse_kms", sse_kms)
        if sse_s3 is not None:
            pulumi.set(__self__, "sse_s3", sse_s3)

    @_builtins.property
    @pulumi.getter(name="sseKms")
    def sse_kms(self) -> Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseKmsArgs']]:
        """
        Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
        """
        return pulumi.get(self, "sse_kms")

    @sse_kms.setter
    def sse_kms(self, value: Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseKmsArgs']]):
        pulumi.set(self, "sse_kms", value)

    @_builtins.property
    @pulumi.getter(name="sseS3")
    def sse_s3(self) -> Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseS3Args']]:
        """
        Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
        """
        return pulumi.get(self, "sse_s3")

    @sse_s3.setter
    def sse_s3(self, value: Optional[pulumi.Input['InventoryDestinationBucketEncryptionSseS3Args']]):
        pulumi.set(self, "sse_s3", value)


if not MYPY:
    class InventoryDestinationBucketEncryptionSseKmsArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
        """
elif False:
    InventoryDestinationBucketEncryptionSseKmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryDestinationBucketEncryptionSseKmsArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
        """
        pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class InventoryDestinationBucketEncryptionSseS3ArgsDict(TypedDict):
        pass
elif False:
    InventoryDestinationBucketEncryptionSseS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryDestinationBucketEncryptionSseS3Args:
    def __init__(__self__):
        pass


if not MYPY:
    class InventoryFilterArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix that an object must have to be included in the inventory results.
        """
elif False:
    InventoryFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryFilterArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Prefix that an object must have to be included in the inventory results.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix that an object must have to be included in the inventory results.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class InventoryScheduleArgsDict(TypedDict):
        frequency: pulumi.Input[_builtins.str]
        """
        Specifies how frequently inventory results are produced. Valid values: `Daily`, `Weekly`.
        """
elif False:
    InventoryScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryScheduleArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] frequency: Specifies how frequently inventory results are produced. Valid values: `Daily`, `Weekly`.
        """
        pulumi.set(__self__, "frequency", frequency)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies how frequently inventory results are produced. Valid values: `Daily`, `Weekly`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class ObjectCopyGrantArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of permissions to grant to grantee. Valid values are `READ`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of grantee. Valid values are `CanonicalUser`, `Group`, and `AmazonCustomerByEmail`.

        This configuration block has the following optional arguments (one of the three is required):
        """
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address of the grantee. Used only when `type` is `AmazonCustomerByEmail`.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical user ID of the grantee. Used only when `type` is `CanonicalUser`.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        URI of the grantee group. Used only when `type` is `Group`.
        """
elif False:
    ObjectCopyGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectCopyGrantArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str],
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: List of permissions to grant to grantee. Valid values are `READ`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        :param pulumi.Input[_builtins.str] type: Type of grantee. Valid values are `CanonicalUser`, `Group`, and `AmazonCustomerByEmail`.
               
               This configuration block has the following optional arguments (one of the three is required):
        :param pulumi.Input[_builtins.str] email: Email address of the grantee. Used only when `type` is `AmazonCustomerByEmail`.
        :param pulumi.Input[_builtins.str] id: Canonical user ID of the grantee. Used only when `type` is `CanonicalUser`.
        :param pulumi.Input[_builtins.str] uri: URI of the grantee group. Used only when `type` is `Group`.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of permissions to grant to grantee. Valid values are `READ`, `READ_ACP`, `WRITE_ACP`, `FULL_CONTROL`.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of grantee. Valid values are `CanonicalUser`, `Group`, and `AmazonCustomerByEmail`.

        This configuration block has the following optional arguments (one of the three is required):
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address of the grantee. Used only when `type` is `AmazonCustomerByEmail`.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical user ID of the grantee. Used only when `type` is `CanonicalUser`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URI of the grantee group. Used only when `type` is `Group`.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class ObjectCopyOverrideProviderArgsDict(TypedDict):
        default_tags: NotRequired[pulumi.Input['ObjectCopyOverrideProviderDefaultTagsArgsDict']]
        """
        Override the provider `default_tags` configuration block.
        """
elif False:
    ObjectCopyOverrideProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectCopyOverrideProviderArgs:
    def __init__(__self__, *,
                 default_tags: Optional[pulumi.Input['ObjectCopyOverrideProviderDefaultTagsArgs']] = None):
        """
        :param pulumi.Input['ObjectCopyOverrideProviderDefaultTagsArgs'] default_tags: Override the provider `default_tags` configuration block.
        """
        if default_tags is not None:
            pulumi.set(__self__, "default_tags", default_tags)

    @_builtins.property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Optional[pulumi.Input['ObjectCopyOverrideProviderDefaultTagsArgs']]:
        """
        Override the provider `default_tags` configuration block.
        """
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Optional[pulumi.Input['ObjectCopyOverrideProviderDefaultTagsArgs']]):
        pulumi.set(self, "default_tags", value)


if not MYPY:
    class ObjectCopyOverrideProviderDefaultTagsArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    ObjectCopyOverrideProviderDefaultTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectCopyOverrideProviderDefaultTagsArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of tags to assign to the object. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PolicyDocumentArgsDict(TypedDict):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgsDict']]]
        version: pulumi.Input['iam.PolicyDocumentVersion']
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PolicyDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDocumentArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]],
                 version: pulumi.Input['iam.PolicyDocumentVersion'],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="Statement")
    def statement(self) -> pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter(name="Version")
    def version(self) -> pulumi.Input['iam.PolicyDocumentVersion']:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input['iam.PolicyDocumentVersion']):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


