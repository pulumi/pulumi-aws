# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AnomalySubscriptionSubscriberArgs',
    'AnomalySubscriptionSubscriberArgsDict',
    'AnomalySubscriptionThresholdExpressionArgs',
    'AnomalySubscriptionThresholdExpressionArgsDict',
    'AnomalySubscriptionThresholdExpressionAndArgs',
    'AnomalySubscriptionThresholdExpressionAndArgsDict',
    'AnomalySubscriptionThresholdExpressionAndCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionAndDimensionArgs',
    'AnomalySubscriptionThresholdExpressionAndDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionAndTagsArgs',
    'AnomalySubscriptionThresholdExpressionAndTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionDimensionArgs',
    'AnomalySubscriptionThresholdExpressionDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionNotArgs',
    'AnomalySubscriptionThresholdExpressionNotArgsDict',
    'AnomalySubscriptionThresholdExpressionNotCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionNotDimensionArgs',
    'AnomalySubscriptionThresholdExpressionNotDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionNotTagsArgs',
    'AnomalySubscriptionThresholdExpressionNotTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionOrArgs',
    'AnomalySubscriptionThresholdExpressionOrArgsDict',
    'AnomalySubscriptionThresholdExpressionOrCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionOrDimensionArgs',
    'AnomalySubscriptionThresholdExpressionOrDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionOrTagsArgs',
    'AnomalySubscriptionThresholdExpressionOrTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionTagsArgs',
    'AnomalySubscriptionThresholdExpressionTagsArgsDict',
    'CostCategoryRuleArgs',
    'CostCategoryRuleArgsDict',
    'CostCategoryRuleInheritedValueArgs',
    'CostCategoryRuleInheritedValueArgsDict',
    'CostCategoryRuleRuleArgs',
    'CostCategoryRuleRuleArgsDict',
    'CostCategoryRuleRuleAndArgs',
    'CostCategoryRuleRuleAndArgsDict',
    'CostCategoryRuleRuleAndAndArgs',
    'CostCategoryRuleRuleAndAndArgsDict',
    'CostCategoryRuleRuleAndAndCostCategoryArgs',
    'CostCategoryRuleRuleAndAndCostCategoryArgsDict',
    'CostCategoryRuleRuleAndAndDimensionArgs',
    'CostCategoryRuleRuleAndAndDimensionArgsDict',
    'CostCategoryRuleRuleAndAndTagsArgs',
    'CostCategoryRuleRuleAndAndTagsArgsDict',
    'CostCategoryRuleRuleAndCostCategoryArgs',
    'CostCategoryRuleRuleAndCostCategoryArgsDict',
    'CostCategoryRuleRuleAndDimensionArgs',
    'CostCategoryRuleRuleAndDimensionArgsDict',
    'CostCategoryRuleRuleAndNotArgs',
    'CostCategoryRuleRuleAndNotArgsDict',
    'CostCategoryRuleRuleAndNotCostCategoryArgs',
    'CostCategoryRuleRuleAndNotCostCategoryArgsDict',
    'CostCategoryRuleRuleAndNotDimensionArgs',
    'CostCategoryRuleRuleAndNotDimensionArgsDict',
    'CostCategoryRuleRuleAndNotTagsArgs',
    'CostCategoryRuleRuleAndNotTagsArgsDict',
    'CostCategoryRuleRuleAndOrArgs',
    'CostCategoryRuleRuleAndOrArgsDict',
    'CostCategoryRuleRuleAndOrCostCategoryArgs',
    'CostCategoryRuleRuleAndOrCostCategoryArgsDict',
    'CostCategoryRuleRuleAndOrDimensionArgs',
    'CostCategoryRuleRuleAndOrDimensionArgsDict',
    'CostCategoryRuleRuleAndOrTagsArgs',
    'CostCategoryRuleRuleAndOrTagsArgsDict',
    'CostCategoryRuleRuleAndTagsArgs',
    'CostCategoryRuleRuleAndTagsArgsDict',
    'CostCategoryRuleRuleCostCategoryArgs',
    'CostCategoryRuleRuleCostCategoryArgsDict',
    'CostCategoryRuleRuleDimensionArgs',
    'CostCategoryRuleRuleDimensionArgsDict',
    'CostCategoryRuleRuleNotArgs',
    'CostCategoryRuleRuleNotArgsDict',
    'CostCategoryRuleRuleNotAndArgs',
    'CostCategoryRuleRuleNotAndArgsDict',
    'CostCategoryRuleRuleNotAndCostCategoryArgs',
    'CostCategoryRuleRuleNotAndCostCategoryArgsDict',
    'CostCategoryRuleRuleNotAndDimensionArgs',
    'CostCategoryRuleRuleNotAndDimensionArgsDict',
    'CostCategoryRuleRuleNotAndTagsArgs',
    'CostCategoryRuleRuleNotAndTagsArgsDict',
    'CostCategoryRuleRuleNotCostCategoryArgs',
    'CostCategoryRuleRuleNotCostCategoryArgsDict',
    'CostCategoryRuleRuleNotDimensionArgs',
    'CostCategoryRuleRuleNotDimensionArgsDict',
    'CostCategoryRuleRuleNotNotArgs',
    'CostCategoryRuleRuleNotNotArgsDict',
    'CostCategoryRuleRuleNotNotCostCategoryArgs',
    'CostCategoryRuleRuleNotNotCostCategoryArgsDict',
    'CostCategoryRuleRuleNotNotDimensionArgs',
    'CostCategoryRuleRuleNotNotDimensionArgsDict',
    'CostCategoryRuleRuleNotNotTagsArgs',
    'CostCategoryRuleRuleNotNotTagsArgsDict',
    'CostCategoryRuleRuleNotOrArgs',
    'CostCategoryRuleRuleNotOrArgsDict',
    'CostCategoryRuleRuleNotOrCostCategoryArgs',
    'CostCategoryRuleRuleNotOrCostCategoryArgsDict',
    'CostCategoryRuleRuleNotOrDimensionArgs',
    'CostCategoryRuleRuleNotOrDimensionArgsDict',
    'CostCategoryRuleRuleNotOrTagsArgs',
    'CostCategoryRuleRuleNotOrTagsArgsDict',
    'CostCategoryRuleRuleNotTagsArgs',
    'CostCategoryRuleRuleNotTagsArgsDict',
    'CostCategoryRuleRuleOrArgs',
    'CostCategoryRuleRuleOrArgsDict',
    'CostCategoryRuleRuleOrAndArgs',
    'CostCategoryRuleRuleOrAndArgsDict',
    'CostCategoryRuleRuleOrAndCostCategoryArgs',
    'CostCategoryRuleRuleOrAndCostCategoryArgsDict',
    'CostCategoryRuleRuleOrAndDimensionArgs',
    'CostCategoryRuleRuleOrAndDimensionArgsDict',
    'CostCategoryRuleRuleOrAndTagsArgs',
    'CostCategoryRuleRuleOrAndTagsArgsDict',
    'CostCategoryRuleRuleOrCostCategoryArgs',
    'CostCategoryRuleRuleOrCostCategoryArgsDict',
    'CostCategoryRuleRuleOrDimensionArgs',
    'CostCategoryRuleRuleOrDimensionArgsDict',
    'CostCategoryRuleRuleOrNotArgs',
    'CostCategoryRuleRuleOrNotArgsDict',
    'CostCategoryRuleRuleOrNotCostCategoryArgs',
    'CostCategoryRuleRuleOrNotCostCategoryArgsDict',
    'CostCategoryRuleRuleOrNotDimensionArgs',
    'CostCategoryRuleRuleOrNotDimensionArgsDict',
    'CostCategoryRuleRuleOrNotTagsArgs',
    'CostCategoryRuleRuleOrNotTagsArgsDict',
    'CostCategoryRuleRuleOrOrArgs',
    'CostCategoryRuleRuleOrOrArgsDict',
    'CostCategoryRuleRuleOrOrCostCategoryArgs',
    'CostCategoryRuleRuleOrOrCostCategoryArgsDict',
    'CostCategoryRuleRuleOrOrDimensionArgs',
    'CostCategoryRuleRuleOrOrDimensionArgsDict',
    'CostCategoryRuleRuleOrOrTagsArgs',
    'CostCategoryRuleRuleOrOrTagsArgsDict',
    'CostCategoryRuleRuleOrTagsArgs',
    'CostCategoryRuleRuleOrTagsArgsDict',
    'CostCategoryRuleRuleTagsArgs',
    'CostCategoryRuleRuleTagsArgsDict',
    'CostCategorySplitChargeRuleArgs',
    'CostCategorySplitChargeRuleArgsDict',
    'CostCategorySplitChargeRuleParameterArgs',
    'CostCategorySplitChargeRuleParameterArgsDict',
    'GetTagsFilterArgs',
    'GetTagsFilterArgsDict',
    'GetTagsFilterAndArgs',
    'GetTagsFilterAndArgsDict',
    'GetTagsFilterAndCostCategoryArgs',
    'GetTagsFilterAndCostCategoryArgsDict',
    'GetTagsFilterAndDimensionArgs',
    'GetTagsFilterAndDimensionArgsDict',
    'GetTagsFilterAndTagsArgs',
    'GetTagsFilterAndTagsArgsDict',
    'GetTagsFilterCostCategoryArgs',
    'GetTagsFilterCostCategoryArgsDict',
    'GetTagsFilterDimensionArgs',
    'GetTagsFilterDimensionArgsDict',
    'GetTagsFilterNotArgs',
    'GetTagsFilterNotArgsDict',
    'GetTagsFilterNotCostCategoryArgs',
    'GetTagsFilterNotCostCategoryArgsDict',
    'GetTagsFilterNotDimensionArgs',
    'GetTagsFilterNotDimensionArgsDict',
    'GetTagsFilterNotTagsArgs',
    'GetTagsFilterNotTagsArgsDict',
    'GetTagsFilterOrArgs',
    'GetTagsFilterOrArgsDict',
    'GetTagsFilterOrCostCategoryArgs',
    'GetTagsFilterOrCostCategoryArgsDict',
    'GetTagsFilterOrDimensionArgs',
    'GetTagsFilterOrDimensionArgsDict',
    'GetTagsFilterOrTagsArgs',
    'GetTagsFilterOrTagsArgsDict',
    'GetTagsFilterTagsArgs',
    'GetTagsFilterTagsArgsDict',
    'GetTagsSortByArgs',
    'GetTagsSortByArgsDict',
    'GetTagsTimePeriodArgs',
    'GetTagsTimePeriodArgsDict',
]

MYPY = False

if not MYPY:
    class AnomalySubscriptionSubscriberArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        """
        type: pulumi.Input[str]
        """
        The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
elif False:
    AnomalySubscriptionSubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionSubscriberArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        :param pulumi.Input[str] type: The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgsDict']]]]
        """
        Return results that match both Dimension objects.
        """
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgsDict']]
        """
        Configuration block for the specific Dimension to use for.
        """
        not_: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgsDict']]
        """
        Return results that do not match the Dimension object.
        """
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgsDict']]]]
        """
        Return results that match either Dimension object.
        """
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgsDict']]
        """
        Configuration block for the specific Tag to use for. See Tags below.
        """
elif False:
    AnomalySubscriptionThresholdExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]] ands: Return results that match both Dimension objects.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs'] cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs'] dimension: Configuration block for the specific Dimension to use for.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs'] not_: Return results that do not match the Dimension object.
        :param pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]] ors: Return results that match either Dimension object.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs'] tags: Configuration block for the specific Tag to use for. See Tags below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]]:
        """
        Return results that match both Dimension objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']]:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']]:
        """
        Return results that do not match the Dimension object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]]:
        """
        Return results that match either Dimension object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']]:
        """
        Configuration block for the specific Tag to use for. See Tags below.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgsDict']]
        """
        Configuration block for the specific Dimension to use for.
        """
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgsDict']]
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    AnomalySubscriptionThresholdExpressionAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']] = None):
        """
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs'] dimension: Configuration block for the specific Dimension to use for.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs'] tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']]:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']]:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgsDict']]
        """
        Configuration block for the specific Dimension to use for.
        """
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgsDict']]
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    AnomalySubscriptionThresholdExpressionNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']] = None):
        """
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs'] dimension: Configuration block for the specific Dimension to use for.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs'] tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']]:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']]:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgsDict']]
        """
        Configuration block for the specific Dimension to use for.
        """
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgsDict']]
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    AnomalySubscriptionThresholdExpressionOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']] = None):
        """
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs'] dimension: Configuration block for the specific Dimension to use for.
        :param pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs'] tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']]:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']]:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    AnomalySubscriptionThresholdExpressionTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleArgsDict(TypedDict):
        inherited_value: NotRequired[pulumi.Input['CostCategoryRuleInheritedValueArgsDict']]
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        rule: NotRequired[pulumi.Input['CostCategoryRuleRuleArgsDict']]
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Default value for the cost category.
        """
elif False:
    CostCategoryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleArgs:
    def __init__(__self__, *,
                 inherited_value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']] = None,
                 rule: Optional[pulumi.Input['CostCategoryRuleRuleArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CostCategoryRuleInheritedValueArgs'] inherited_value: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param pulumi.Input['CostCategoryRuleRuleArgs'] rule: Configuration block for the `Expression` object used to categorize costs. See below.
        :param pulumi.Input[str] type: You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        :param pulumi.Input[str] value: Default value for the cost category.
        """
        if inherited_value is not None:
            pulumi.set(__self__, "inherited_value", inherited_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValue")
    def inherited_value(self) -> Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_value")

    @inherited_value.setter
    def inherited_value(self, value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]):
        pulumi.set(self, "inherited_value", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input['CostCategoryRuleRuleArgs']]:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['CostCategoryRuleRuleArgs']]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CostCategoryRuleInheritedValueArgsDict(TypedDict):
        dimension_key: NotRequired[pulumi.Input[str]]
        """
        Key to extract cost category values.
        """
        dimension_name: NotRequired[pulumi.Input[str]]
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
elif False:
    CostCategoryRuleInheritedValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleInheritedValueArgs:
    def __init__(__self__, *,
                 dimension_key: Optional[pulumi.Input[str]] = None,
                 dimension_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dimension_key: Key to extract cost category values.
        :param pulumi.Input[str] dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[pulumi.Input[str]]:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @dimension_key.setter
    def dimension_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dimension_key", value)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dimension_name", value)


if not MYPY:
    class CostCategoryRuleRuleArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgsDict']]]]
        """
        Return results that match both `Dimension` objects.
        """
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleNotArgsDict']]
        """
        Return results that match both `Dimension` object.
        """
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgsDict']]]]
        """
        Return results that match both `Dimension` object.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleTagsArgsDict']]
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
elif False:
    CostCategoryRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]] ands: Return results that match both `Dimension` objects.
        :param pulumi.Input['CostCategoryRuleRuleCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotArgs'] not_: Return results that match both `Dimension` object.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]] ors: Return results that match both `Dimension` object.
        :param pulumi.Input['CostCategoryRuleRuleTagsArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgsDict']]]]
        """
        Return results that match both `Dimension` objects.
        """
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotArgsDict']]
        """
        Return results that match both `Dimension` object.
        """
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgsDict']]]]
        """
        Return results that match both `Dimension` object.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]] ands: Return results that match both `Dimension` objects.
        :param pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndNotArgs'] not_: Return results that match both `Dimension` object.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]] ors: Return results that match both `Dimension` object.
        :param pulumi.Input['CostCategoryRuleRuleAndTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleAndAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleAndNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleAndOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgsDict']]]]
        """
        Return results that match both `Dimension` objects.
        """
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotArgsDict']]
        """
        Return results that match both `Dimension` object.
        """
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgsDict']]]]
        """
        Return results that match both `Dimension` object.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]] ands: Return results that match both `Dimension` objects.
        :param pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotNotArgs'] not_: Return results that match both `Dimension` object.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]] ors: Return results that match both `Dimension` object.
        :param pulumi.Input['CostCategoryRuleRuleNotTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleNotAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleNotNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleNotOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgsDict']]]]
        """
        Return results that match both `Dimension` objects.
        """
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotArgsDict']]
        """
        Return results that match both `Dimension` object.
        """
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgsDict']]]]
        """
        Return results that match both `Dimension` object.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]] ands: Return results that match both `Dimension` objects.
        :param pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrNotArgs'] not_: Return results that match both `Dimension` object.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]] ors: Return results that match both `Dimension` object.
        :param pulumi.Input['CostCategoryRuleRuleOrTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']]):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleOrAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleOrNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgsDict']]
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgsDict']]
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgsDict']]
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
elif False:
    CostCategoryRuleRuleOrOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']] = None):
        """
        :param pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs'] cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs'] dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs'] tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']]:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']]:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']]:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Unique name of the Cost Category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Key for the tag.
        """
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specific value of the Cost Category.
        """
elif False:
    CostCategoryRuleRuleTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Key for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategorySplitChargeRuleArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        source: pulumi.Input[str]
        """
        Cost Category value that you want to split.
        """
        targets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgsDict']]]]
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
elif False:
    CostCategorySplitChargeRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategorySplitChargeRuleArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 source: pulumi.Input[str],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param pulumi.Input[str] source: Cost Category value that you want to split.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        :param pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class CostCategorySplitChargeRuleParameterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Parameter type.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameter values.
        """
elif False:
    CostCategorySplitChargeRuleParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategorySplitChargeRuleParameterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Parameter type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Parameter values.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterArgsDict(TypedDict):
        ands: NotRequired[Sequence['GetTagsFilterAndArgsDict']]
        """
        Return results that match both `Dimension` objects.
        """
        cost_category: NotRequired['GetTagsFilterCostCategoryArgsDict']
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        dimension: NotRequired['GetTagsFilterDimensionArgsDict']
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        not_: NotRequired['GetTagsFilterNotArgsDict']
        """
        Return results that match both `Dimension` object.
        """
        ors: NotRequired[Sequence['GetTagsFilterOrArgsDict']]
        """
        Return results that match both `Dimension` object.
        """
        tags: NotRequired['GetTagsFilterTagsArgsDict']
        """
        Tags that match your request.
        """
elif False:
    GetTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 ands: Optional[Sequence['GetTagsFilterAndArgs']] = None,
                 cost_category: Optional['GetTagsFilterCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterDimensionArgs'] = None,
                 not_: Optional['GetTagsFilterNotArgs'] = None,
                 ors: Optional[Sequence['GetTagsFilterOrArgs']] = None,
                 tags: Optional['GetTagsFilterTagsArgs'] = None):
        """
        :param Sequence['GetTagsFilterAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'GetTagsFilterCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['GetTagsFilterOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'GetTagsFilterTagsArgs' tags: Tags that match your request.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['GetTagsFilterAndArgs']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[Sequence['GetTagsFilterAndArgs']]):
        pulumi.set(self, "ands", value)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['GetTagsFilterNotArgs']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional['GetTagsFilterNotArgs']):
        pulumi.set(self, "not_", value)

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['GetTagsFilterOrArgs']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[Sequence['GetTagsFilterOrArgs']]):
        pulumi.set(self, "ors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterAndArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterAndCostCategoryArgsDict']
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        dimension: NotRequired['GetTagsFilterAndDimensionArgsDict']
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        tags: NotRequired['GetTagsFilterAndTagsArgsDict']
        """
        Tags that match your request.
        """
elif False:
    GetTagsFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterAndCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterAndDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterAndTagsArgs'] = None):
        """
        :param 'GetTagsFilterAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterAndTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterAndCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterAndCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterAndDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterAndDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterAndTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterAndTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterAndDimensionArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterAndTagsArgsDict(TypedDict):
        key: NotRequired[str]
        match_options: NotRequired[Sequence[str]]
        values: NotRequired[Sequence[str]]
elif False:
    GetTagsFilterAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterCostCategoryArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterDimensionArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterNotCostCategoryArgsDict']
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        dimension: NotRequired['GetTagsFilterNotDimensionArgsDict']
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        tags: NotRequired['GetTagsFilterNotTagsArgsDict']
        """
        Tags that match your request.
        """
elif False:
    GetTagsFilterNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterNotCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterNotDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterNotTagsArgs'] = None):
        """
        :param 'GetTagsFilterNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterNotTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterNotCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterNotCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterNotDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterNotDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterNotTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterNotTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotDimensionArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotTagsArgsDict(TypedDict):
        key: NotRequired[str]
        match_options: NotRequired[Sequence[str]]
        values: NotRequired[Sequence[str]]
elif False:
    GetTagsFilterNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterOrCostCategoryArgsDict']
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        dimension: NotRequired['GetTagsFilterOrDimensionArgsDict']
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        tags: NotRequired['GetTagsFilterOrTagsArgsDict']
        """
        Tags that match your request.
        """
elif False:
    GetTagsFilterOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterOrCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterOrDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterOrTagsArgs'] = None):
        """
        :param 'GetTagsFilterOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterOrTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterOrCostCategoryArgs']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterOrCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterOrDimensionArgs']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterOrDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterOrTagsArgs']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterOrTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrDimensionArgsDict(TypedDict):
        key: NotRequired[str]
        """
        Unique name of the Cost Category.
        """
        match_options: NotRequired[Sequence[str]]
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        values: NotRequired[Sequence[str]]
        """
        Specific value of the Cost Category.
        """
elif False:
    GetTagsFilterOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrTagsArgsDict(TypedDict):
        key: NotRequired[str]
        match_options: NotRequired[Sequence[str]]
        values: NotRequired[Sequence[str]]
elif False:
    GetTagsFilterOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterTagsArgsDict(TypedDict):
        key: NotRequired[str]
        match_options: NotRequired[Sequence[str]]
        values: NotRequired[Sequence[str]]
elif False:
    GetTagsFilterTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterTagsArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "match_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsSortByArgsDict(TypedDict):
        key: NotRequired[str]
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        sort_order: NotRequired[str]
        """
        order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
elif False:
    GetTagsSortByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsSortByArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 sort_order: Optional[str] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param str sort_order: order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[str]:
        """
        order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: Optional[str]):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetTagsTimePeriodArgsDict(TypedDict):
        end: str
        """
        Beginning of the time period.
        """
        start: str
        """
        End of the time period.
        """
elif False:
    GetTagsTimePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsTimePeriodArgs:
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: Beginning of the time period.
        :param str start: End of the time period.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        Beginning of the time period.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: str):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        End of the time period.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: str):
        pulumi.set(self, "start", value)


