# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AnomalySubscriptionSubscriberArgs',
    'AnomalySubscriptionSubscriberArgsDict',
    'AnomalySubscriptionThresholdExpressionArgs',
    'AnomalySubscriptionThresholdExpressionArgsDict',
    'AnomalySubscriptionThresholdExpressionAndArgs',
    'AnomalySubscriptionThresholdExpressionAndArgsDict',
    'AnomalySubscriptionThresholdExpressionAndCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionAndDimensionArgs',
    'AnomalySubscriptionThresholdExpressionAndDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionAndTagsArgs',
    'AnomalySubscriptionThresholdExpressionAndTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionDimensionArgs',
    'AnomalySubscriptionThresholdExpressionDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionNotArgs',
    'AnomalySubscriptionThresholdExpressionNotArgsDict',
    'AnomalySubscriptionThresholdExpressionNotCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionNotDimensionArgs',
    'AnomalySubscriptionThresholdExpressionNotDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionNotTagsArgs',
    'AnomalySubscriptionThresholdExpressionNotTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionOrArgs',
    'AnomalySubscriptionThresholdExpressionOrArgsDict',
    'AnomalySubscriptionThresholdExpressionOrCostCategoryArgs',
    'AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict',
    'AnomalySubscriptionThresholdExpressionOrDimensionArgs',
    'AnomalySubscriptionThresholdExpressionOrDimensionArgsDict',
    'AnomalySubscriptionThresholdExpressionOrTagsArgs',
    'AnomalySubscriptionThresholdExpressionOrTagsArgsDict',
    'AnomalySubscriptionThresholdExpressionTagsArgs',
    'AnomalySubscriptionThresholdExpressionTagsArgsDict',
    'CostCategoryRuleArgs',
    'CostCategoryRuleArgsDict',
    'CostCategoryRuleInheritedValueArgs',
    'CostCategoryRuleInheritedValueArgsDict',
    'CostCategoryRuleRuleArgs',
    'CostCategoryRuleRuleArgsDict',
    'CostCategoryRuleRuleAndArgs',
    'CostCategoryRuleRuleAndArgsDict',
    'CostCategoryRuleRuleAndAndArgs',
    'CostCategoryRuleRuleAndAndArgsDict',
    'CostCategoryRuleRuleAndAndCostCategoryArgs',
    'CostCategoryRuleRuleAndAndCostCategoryArgsDict',
    'CostCategoryRuleRuleAndAndDimensionArgs',
    'CostCategoryRuleRuleAndAndDimensionArgsDict',
    'CostCategoryRuleRuleAndAndTagsArgs',
    'CostCategoryRuleRuleAndAndTagsArgsDict',
    'CostCategoryRuleRuleAndCostCategoryArgs',
    'CostCategoryRuleRuleAndCostCategoryArgsDict',
    'CostCategoryRuleRuleAndDimensionArgs',
    'CostCategoryRuleRuleAndDimensionArgsDict',
    'CostCategoryRuleRuleAndNotArgs',
    'CostCategoryRuleRuleAndNotArgsDict',
    'CostCategoryRuleRuleAndNotCostCategoryArgs',
    'CostCategoryRuleRuleAndNotCostCategoryArgsDict',
    'CostCategoryRuleRuleAndNotDimensionArgs',
    'CostCategoryRuleRuleAndNotDimensionArgsDict',
    'CostCategoryRuleRuleAndNotTagsArgs',
    'CostCategoryRuleRuleAndNotTagsArgsDict',
    'CostCategoryRuleRuleAndOrArgs',
    'CostCategoryRuleRuleAndOrArgsDict',
    'CostCategoryRuleRuleAndOrCostCategoryArgs',
    'CostCategoryRuleRuleAndOrCostCategoryArgsDict',
    'CostCategoryRuleRuleAndOrDimensionArgs',
    'CostCategoryRuleRuleAndOrDimensionArgsDict',
    'CostCategoryRuleRuleAndOrTagsArgs',
    'CostCategoryRuleRuleAndOrTagsArgsDict',
    'CostCategoryRuleRuleAndTagsArgs',
    'CostCategoryRuleRuleAndTagsArgsDict',
    'CostCategoryRuleRuleCostCategoryArgs',
    'CostCategoryRuleRuleCostCategoryArgsDict',
    'CostCategoryRuleRuleDimensionArgs',
    'CostCategoryRuleRuleDimensionArgsDict',
    'CostCategoryRuleRuleNotArgs',
    'CostCategoryRuleRuleNotArgsDict',
    'CostCategoryRuleRuleNotAndArgs',
    'CostCategoryRuleRuleNotAndArgsDict',
    'CostCategoryRuleRuleNotAndCostCategoryArgs',
    'CostCategoryRuleRuleNotAndCostCategoryArgsDict',
    'CostCategoryRuleRuleNotAndDimensionArgs',
    'CostCategoryRuleRuleNotAndDimensionArgsDict',
    'CostCategoryRuleRuleNotAndTagsArgs',
    'CostCategoryRuleRuleNotAndTagsArgsDict',
    'CostCategoryRuleRuleNotCostCategoryArgs',
    'CostCategoryRuleRuleNotCostCategoryArgsDict',
    'CostCategoryRuleRuleNotDimensionArgs',
    'CostCategoryRuleRuleNotDimensionArgsDict',
    'CostCategoryRuleRuleNotNotArgs',
    'CostCategoryRuleRuleNotNotArgsDict',
    'CostCategoryRuleRuleNotNotCostCategoryArgs',
    'CostCategoryRuleRuleNotNotCostCategoryArgsDict',
    'CostCategoryRuleRuleNotNotDimensionArgs',
    'CostCategoryRuleRuleNotNotDimensionArgsDict',
    'CostCategoryRuleRuleNotNotTagsArgs',
    'CostCategoryRuleRuleNotNotTagsArgsDict',
    'CostCategoryRuleRuleNotOrArgs',
    'CostCategoryRuleRuleNotOrArgsDict',
    'CostCategoryRuleRuleNotOrCostCategoryArgs',
    'CostCategoryRuleRuleNotOrCostCategoryArgsDict',
    'CostCategoryRuleRuleNotOrDimensionArgs',
    'CostCategoryRuleRuleNotOrDimensionArgsDict',
    'CostCategoryRuleRuleNotOrTagsArgs',
    'CostCategoryRuleRuleNotOrTagsArgsDict',
    'CostCategoryRuleRuleNotTagsArgs',
    'CostCategoryRuleRuleNotTagsArgsDict',
    'CostCategoryRuleRuleOrArgs',
    'CostCategoryRuleRuleOrArgsDict',
    'CostCategoryRuleRuleOrAndArgs',
    'CostCategoryRuleRuleOrAndArgsDict',
    'CostCategoryRuleRuleOrAndCostCategoryArgs',
    'CostCategoryRuleRuleOrAndCostCategoryArgsDict',
    'CostCategoryRuleRuleOrAndDimensionArgs',
    'CostCategoryRuleRuleOrAndDimensionArgsDict',
    'CostCategoryRuleRuleOrAndTagsArgs',
    'CostCategoryRuleRuleOrAndTagsArgsDict',
    'CostCategoryRuleRuleOrCostCategoryArgs',
    'CostCategoryRuleRuleOrCostCategoryArgsDict',
    'CostCategoryRuleRuleOrDimensionArgs',
    'CostCategoryRuleRuleOrDimensionArgsDict',
    'CostCategoryRuleRuleOrNotArgs',
    'CostCategoryRuleRuleOrNotArgsDict',
    'CostCategoryRuleRuleOrNotCostCategoryArgs',
    'CostCategoryRuleRuleOrNotCostCategoryArgsDict',
    'CostCategoryRuleRuleOrNotDimensionArgs',
    'CostCategoryRuleRuleOrNotDimensionArgsDict',
    'CostCategoryRuleRuleOrNotTagsArgs',
    'CostCategoryRuleRuleOrNotTagsArgsDict',
    'CostCategoryRuleRuleOrOrArgs',
    'CostCategoryRuleRuleOrOrArgsDict',
    'CostCategoryRuleRuleOrOrCostCategoryArgs',
    'CostCategoryRuleRuleOrOrCostCategoryArgsDict',
    'CostCategoryRuleRuleOrOrDimensionArgs',
    'CostCategoryRuleRuleOrOrDimensionArgsDict',
    'CostCategoryRuleRuleOrOrTagsArgs',
    'CostCategoryRuleRuleOrOrTagsArgsDict',
    'CostCategoryRuleRuleOrTagsArgs',
    'CostCategoryRuleRuleOrTagsArgsDict',
    'CostCategoryRuleRuleTagsArgs',
    'CostCategoryRuleRuleTagsArgsDict',
    'CostCategorySplitChargeRuleArgs',
    'CostCategorySplitChargeRuleArgsDict',
    'CostCategorySplitChargeRuleParameterArgs',
    'CostCategorySplitChargeRuleParameterArgsDict',
    'GetTagsFilterArgs',
    'GetTagsFilterArgsDict',
    'GetTagsFilterAndArgs',
    'GetTagsFilterAndArgsDict',
    'GetTagsFilterAndCostCategoryArgs',
    'GetTagsFilterAndCostCategoryArgsDict',
    'GetTagsFilterAndDimensionArgs',
    'GetTagsFilterAndDimensionArgsDict',
    'GetTagsFilterAndTagsArgs',
    'GetTagsFilterAndTagsArgsDict',
    'GetTagsFilterCostCategoryArgs',
    'GetTagsFilterCostCategoryArgsDict',
    'GetTagsFilterDimensionArgs',
    'GetTagsFilterDimensionArgsDict',
    'GetTagsFilterNotArgs',
    'GetTagsFilterNotArgsDict',
    'GetTagsFilterNotCostCategoryArgs',
    'GetTagsFilterNotCostCategoryArgsDict',
    'GetTagsFilterNotDimensionArgs',
    'GetTagsFilterNotDimensionArgsDict',
    'GetTagsFilterNotTagsArgs',
    'GetTagsFilterNotTagsArgsDict',
    'GetTagsFilterOrArgs',
    'GetTagsFilterOrArgsDict',
    'GetTagsFilterOrCostCategoryArgs',
    'GetTagsFilterOrCostCategoryArgsDict',
    'GetTagsFilterOrDimensionArgs',
    'GetTagsFilterOrDimensionArgsDict',
    'GetTagsFilterOrTagsArgs',
    'GetTagsFilterOrTagsArgsDict',
    'GetTagsFilterTagsArgs',
    'GetTagsFilterTagsArgsDict',
    'GetTagsSortByArgs',
    'GetTagsSortByArgsDict',
    'GetTagsTimePeriodArgs',
    'GetTagsTimePeriodArgsDict',
]

MYPY = False

if not MYPY:
    class AnomalySubscriptionSubscriberArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    AnomalySubscriptionSubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionSubscriberArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgsDict']]]]
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgsDict']]
        not_: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgsDict']]
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgsDict']]]]
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgsDict']]
elif False:
    AnomalySubscriptionThresholdExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotArgs']]):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnomalySubscriptionThresholdExpressionOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgsDict']]
elif False:
    AnomalySubscriptionThresholdExpressionAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgsDict']]
elif False:
    AnomalySubscriptionThresholdExpressionNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgsDict']]
elif False:
    AnomalySubscriptionThresholdExpressionOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['AnomalySubscriptionThresholdExpressionOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnomalySubscriptionThresholdExpressionTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AnomalySubscriptionThresholdExpressionTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalySubscriptionThresholdExpressionTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleArgsDict(TypedDict):
        inherited_value: NotRequired[pulumi.Input['CostCategoryRuleInheritedValueArgsDict']]
        rule: NotRequired[pulumi.Input['CostCategoryRuleRuleArgsDict']]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CostCategoryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleArgs:
    def __init__(__self__, *,
                 inherited_value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']] = None,
                 rule: Optional[pulumi.Input['CostCategoryRuleRuleArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if inherited_value is not None:
            pulumi.set(__self__, "inherited_value", inherited_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="inheritedValue")
    def inherited_value(self) -> Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]:
        return pulumi.get(self, "inherited_value")

    @inherited_value.setter
    def inherited_value(self, value: Optional[pulumi.Input['CostCategoryRuleInheritedValueArgs']]):
        pulumi.set(self, "inherited_value", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input['CostCategoryRuleRuleArgs']]:
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['CostCategoryRuleRuleArgs']]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CostCategoryRuleInheritedValueArgsDict(TypedDict):
        dimension_key: NotRequired[pulumi.Input[_builtins.str]]
        dimension_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CostCategoryRuleInheritedValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleInheritedValueArgs:
    def __init__(__self__, *,
                 dimension_key: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension_name: Optional[pulumi.Input[_builtins.str]] = None):
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)

    @_builtins.property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dimension_key")

    @dimension_key.setter
    def dimension_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension_key", value)

    @_builtins.property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension_name", value)


if not MYPY:
    class CostCategoryRuleRuleArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgsDict']]]]
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleDimensionArgsDict']]
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleNotArgsDict']]
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgsDict']]]]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleTagsArgsDict']]
elif False:
    CostCategoryRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotArgs']]):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgsDict']]]]
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndDimensionArgsDict']]
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotArgsDict']]
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgsDict']]]]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndTagsArgsDict']]
elif False:
    CostCategoryRuleRuleAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotArgs']]):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleAndOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgsDict']]
elif False:
    CostCategoryRuleRuleAndAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgsDict']]
elif False:
    CostCategoryRuleRuleAndNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgsDict']]
elif False:
    CostCategoryRuleRuleAndOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleAndOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgsDict']]]]
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotDimensionArgsDict']]
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotArgsDict']]
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgsDict']]]]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotTagsArgsDict']]
elif False:
    CostCategoryRuleRuleNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotArgs']]):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleNotOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgsDict']]
elif False:
    CostCategoryRuleRuleNotAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgsDict']]
elif False:
    CostCategoryRuleRuleNotNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgsDict']]
elif False:
    CostCategoryRuleRuleNotOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleNotOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrArgsDict(TypedDict):
        ands: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgsDict']]]]
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrDimensionArgsDict']]
        not_: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotArgsDict']]
        ors: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgsDict']]]]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrTagsArgsDict']]
elif False:
    CostCategoryRuleRuleOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrArgs:
    def __init__(__self__, *,
                 ands: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]] = None,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']] = None,
                 not_: Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']] = None,
                 ors: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrAndArgs']]]]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']]:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotArgs']]):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategoryRuleRuleOrOrArgs']]]]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgsDict']]
elif False:
    CostCategoryRuleRuleOrAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrAndTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrAndTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgsDict']]
elif False:
    CostCategoryRuleRuleOrNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrNotTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrNotTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrArgsDict(TypedDict):
        cost_category: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgsDict']]
        dimension: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgsDict']]
        tags: NotRequired[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgsDict']]
elif False:
    CostCategoryRuleRuleOrOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']] = None,
                 dimension: Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']] = None,
                 tags: Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']]:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrCostCategoryArgs']]):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['CostCategoryRuleRuleOrOrTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrDimensionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleOrTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategoryRuleRuleTagsArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategoryRuleRuleTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategoryRuleRuleTagsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class CostCategorySplitChargeRuleArgsDict(TypedDict):
        method: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        targets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgsDict']]]]
elif False:
    CostCategorySplitChargeRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategorySplitChargeRuleArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 targets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]] = None):
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "targets", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CostCategorySplitChargeRuleParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class CostCategorySplitChargeRuleParameterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CostCategorySplitChargeRuleParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CostCategorySplitChargeRuleParameterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterArgsDict(TypedDict):
        ands: NotRequired[Sequence['GetTagsFilterAndArgsDict']]
        cost_category: NotRequired['GetTagsFilterCostCategoryArgsDict']
        dimension: NotRequired['GetTagsFilterDimensionArgsDict']
        not_: NotRequired['GetTagsFilterNotArgsDict']
        ors: NotRequired[Sequence['GetTagsFilterOrArgsDict']]
        tags: NotRequired['GetTagsFilterTagsArgsDict']
elif False:
    GetTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 ands: Optional[Sequence['GetTagsFilterAndArgs']] = None,
                 cost_category: Optional['GetTagsFilterCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterDimensionArgs'] = None,
                 not_: Optional['GetTagsFilterNotArgs'] = None,
                 ors: Optional[Sequence['GetTagsFilterOrArgs']] = None,
                 tags: Optional['GetTagsFilterTagsArgs'] = None):
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['GetTagsFilterAndArgs']]:
        return pulumi.get(self, "ands")

    @ands.setter
    def ands(self, value: Optional[Sequence['GetTagsFilterAndArgs']]):
        pulumi.set(self, "ands", value)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterCostCategoryArgs']:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterDimensionArgs']:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['GetTagsFilterNotArgs']:
        return pulumi.get(self, "not_")

    @not_.setter
    def not_(self, value: Optional['GetTagsFilterNotArgs']):
        pulumi.set(self, "not_", value)

    @_builtins.property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['GetTagsFilterOrArgs']]:
        return pulumi.get(self, "ors")

    @ors.setter
    def ors(self, value: Optional[Sequence['GetTagsFilterOrArgs']]):
        pulumi.set(self, "ors", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterTagsArgs']:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterAndArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterAndCostCategoryArgsDict']
        dimension: NotRequired['GetTagsFilterAndDimensionArgsDict']
        tags: NotRequired['GetTagsFilterAndTagsArgsDict']
elif False:
    GetTagsFilterAndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterAndCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterAndDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterAndTagsArgs'] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterAndCostCategoryArgs']:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterAndCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterAndDimensionArgs']:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterAndDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterAndTagsArgs']:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterAndTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterAndCostCategoryArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterAndCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterAndDimensionArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterAndDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterAndTagsArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterAndTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterAndTagsArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterCostCategoryArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterDimensionArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterNotCostCategoryArgsDict']
        dimension: NotRequired['GetTagsFilterNotDimensionArgsDict']
        tags: NotRequired['GetTagsFilterNotTagsArgsDict']
elif False:
    GetTagsFilterNotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterNotCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterNotDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterNotTagsArgs'] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterNotCostCategoryArgs']:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterNotCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterNotDimensionArgs']:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterNotDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterNotTagsArgs']:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterNotTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterNotCostCategoryArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterNotCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotDimensionArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterNotDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterNotTagsArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterNotTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterNotTagsArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrArgsDict(TypedDict):
        cost_category: NotRequired['GetTagsFilterOrCostCategoryArgsDict']
        dimension: NotRequired['GetTagsFilterOrDimensionArgsDict']
        tags: NotRequired['GetTagsFilterOrTagsArgsDict']
elif False:
    GetTagsFilterOrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrArgs:
    def __init__(__self__, *,
                 cost_category: Optional['GetTagsFilterOrCostCategoryArgs'] = None,
                 dimension: Optional['GetTagsFilterOrDimensionArgs'] = None,
                 tags: Optional['GetTagsFilterOrTagsArgs'] = None):
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['GetTagsFilterOrCostCategoryArgs']:
        return pulumi.get(self, "cost_category")

    @cost_category.setter
    def cost_category(self, value: Optional['GetTagsFilterOrCostCategoryArgs']):
        pulumi.set(self, "cost_category", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional['GetTagsFilterOrDimensionArgs']:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional['GetTagsFilterOrDimensionArgs']):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['GetTagsFilterOrTagsArgs']:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional['GetTagsFilterOrTagsArgs']):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GetTagsFilterOrCostCategoryArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterOrCostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrCostCategoryArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrDimensionArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterOrDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrDimensionArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterOrTagsArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterOrTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterOrTagsArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsFilterTagsArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        match_options: NotRequired[Sequence[_builtins.str]]
        values: NotRequired[Sequence[_builtins.str]]
elif False:
    GetTagsFilterTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterTagsArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 match_options: Optional[Sequence[_builtins.str]] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "match_options")

    @match_options.setter
    def match_options(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "match_options", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTagsSortByArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        sort_order: NotRequired[_builtins.str]
elif False:
    GetTagsSortByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsSortByArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 sort_order: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetTagsTimePeriodArgsDict(TypedDict):
        end: _builtins.str
        start: _builtins.str
elif False:
    GetTagsTimePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsTimePeriodArgs:
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: _builtins.str):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: _builtins.str):
        pulumi.set(self, "start", value)


