# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AnomalySubscriptionSubscriber',
    'AnomalySubscriptionThresholdExpression',
    'AnomalySubscriptionThresholdExpressionAnd',
    'AnomalySubscriptionThresholdExpressionAndCostCategory',
    'AnomalySubscriptionThresholdExpressionAndDimension',
    'AnomalySubscriptionThresholdExpressionAndTags',
    'AnomalySubscriptionThresholdExpressionCostCategory',
    'AnomalySubscriptionThresholdExpressionDimension',
    'AnomalySubscriptionThresholdExpressionNot',
    'AnomalySubscriptionThresholdExpressionNotCostCategory',
    'AnomalySubscriptionThresholdExpressionNotDimension',
    'AnomalySubscriptionThresholdExpressionNotTags',
    'AnomalySubscriptionThresholdExpressionOr',
    'AnomalySubscriptionThresholdExpressionOrCostCategory',
    'AnomalySubscriptionThresholdExpressionOrDimension',
    'AnomalySubscriptionThresholdExpressionOrTags',
    'AnomalySubscriptionThresholdExpressionTags',
    'CostCategoryRule',
    'CostCategoryRuleInheritedValue',
    'CostCategoryRuleRule',
    'CostCategoryRuleRuleAnd',
    'CostCategoryRuleRuleAndCostCategory',
    'CostCategoryRuleRuleAndDimension',
    'CostCategoryRuleRuleAndTags',
    'CostCategoryRuleRuleCostCategory',
    'CostCategoryRuleRuleDimension',
    'CostCategoryRuleRuleNot',
    'CostCategoryRuleRuleNotCostCategory',
    'CostCategoryRuleRuleNotDimension',
    'CostCategoryRuleRuleNotTags',
    'CostCategoryRuleRuleOr',
    'CostCategoryRuleRuleOrCostCategory',
    'CostCategoryRuleRuleOrDimension',
    'CostCategoryRuleRuleOrTags',
    'CostCategoryRuleRuleTags',
    'CostCategorySplitChargeRule',
    'CostCategorySplitChargeRuleParameter',
    'GetCostCategoryRuleResult',
    'GetCostCategoryRuleInheritedValueResult',
    'GetCostCategoryRuleRuleResult',
    'GetCostCategoryRuleRuleAndResult',
    'GetCostCategoryRuleRuleAndCostCategoryResult',
    'GetCostCategoryRuleRuleAndDimensionResult',
    'GetCostCategoryRuleRuleAndTagResult',
    'GetCostCategoryRuleRuleCostCategoryResult',
    'GetCostCategoryRuleRuleDimensionResult',
    'GetCostCategoryRuleRuleNotResult',
    'GetCostCategoryRuleRuleNotCostCategoryResult',
    'GetCostCategoryRuleRuleNotDimensionResult',
    'GetCostCategoryRuleRuleNotTagResult',
    'GetCostCategoryRuleRuleOrResult',
    'GetCostCategoryRuleRuleOrCostCategoryResult',
    'GetCostCategoryRuleRuleOrDimensionResult',
    'GetCostCategoryRuleRuleOrTagResult',
    'GetCostCategoryRuleRuleTagResult',
    'GetCostCategorySplitChargeRuleResult',
    'GetCostCategorySplitChargeRuleParameterResult',
    'GetTagsFilterResult',
    'GetTagsFilterAndResult',
    'GetTagsFilterAndCostCategoryResult',
    'GetTagsFilterAndDimensionResult',
    'GetTagsFilterAndTagsResult',
    'GetTagsFilterCostCategoryResult',
    'GetTagsFilterDimensionResult',
    'GetTagsFilterNotResult',
    'GetTagsFilterNotCostCategoryResult',
    'GetTagsFilterNotDimensionResult',
    'GetTagsFilterNotTagsResult',
    'GetTagsFilterOrResult',
    'GetTagsFilterOrCostCategoryResult',
    'GetTagsFilterOrDimensionResult',
    'GetTagsFilterOrTagsResult',
    'GetTagsFilterTagsResult',
    'GetTagsSortByResult',
    'GetTagsTimePeriodResult',
]

@pulumi.output_type
class AnomalySubscriptionSubscriber(dict):
    def __init__(__self__, *,
                 address: str,
                 type: str):
        """
        :param str address: The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        :param str type: The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AnomalySubscriptionThresholdExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionAnd']] = None,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionDimension'] = None,
                 not_: Optional['outputs.AnomalySubscriptionThresholdExpressionNot'] = None,
                 ors: Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionOr']] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionTags'] = None):
        """
        :param Sequence['AnomalySubscriptionThresholdExpressionAndArgs'] ands: Return results that match both Dimension objects.
        :param 'AnomalySubscriptionThresholdExpressionCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionNotArgs' not_: Return results that match both Dimension object.
        :param Sequence['AnomalySubscriptionThresholdExpressionOrArgs'] ors: Return results that match both Dimension object.
        :param 'AnomalySubscriptionThresholdExpressionTagsArgs' tags: Configuration block for the specific Tag to use for. See Tags below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionAnd']]:
        """
        Return results that match both Dimension objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNot']:
        """
        Return results that match both Dimension object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionOr']]:
        """
        Return results that match both Dimension object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionTags']:
        """
        Configuration block for the specific Tag to use for. See Tags below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionAndCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionAndDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionAndTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionAndDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionAndTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionNotCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionNotDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionNotTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionNotDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionNotTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionOrCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionOrDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionOrTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionOrDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionOrTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inheritedValue":
            suggest = "inherited_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inherited_value: Optional['outputs.CostCategoryRuleInheritedValue'] = None,
                 rule: Optional['outputs.CostCategoryRuleRule'] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param 'CostCategoryRuleInheritedValueArgs' inherited_value: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param 'CostCategoryRuleRuleArgs' rule: Configuration block for the `Expression` object used to categorize costs. See below.
        :param str type: You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        :param str value: Default value for the cost category.
        """
        if inherited_value is not None:
            pulumi.set(__self__, "inherited_value", inherited_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValue")
    def inherited_value(self) -> Optional['outputs.CostCategoryRuleInheritedValue']:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_value")

    @property
    @pulumi.getter
    def rule(self) -> Optional['outputs.CostCategoryRuleRule']:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CostCategoryRuleInheritedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"
        elif key == "dimensionName":
            suggest = "dimension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleInheritedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleInheritedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleInheritedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_key: Optional[str] = None,
                 dimension_name: Optional[str] = None):
        """
        :param str dimension_key: Key to extract cost category values.
        :param str dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[str]:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[str]:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")


@pulumi.output_type
class CostCategoryRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.CostCategoryRuleRuleAnd']] = None,
                 cost_category: Optional['outputs.CostCategoryRuleRuleCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleDimension'] = None,
                 not_: Optional['outputs.CostCategoryRuleRuleNot'] = None,
                 ors: Optional[Sequence['outputs.CostCategoryRuleRuleOr']] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleTags'] = None):
        """
        :param Sequence['CostCategoryRuleRuleAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'CostCategoryRuleRuleCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['CostCategoryRuleRuleOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'CostCategoryRuleRuleTagsArgs' tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleAnd']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.CostCategoryRuleRuleNot']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleOr']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleTags']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleAndCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleAndDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleAndTags'] = None):
        """
        :param 'CostCategoryRuleRuleAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleAndTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleAndCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleAndDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleAndTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleNotCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleNotDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleNotTags'] = None):
        """
        :param 'CostCategoryRuleRuleNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleNotCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleNotDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleNotTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleOrCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleOrDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleOrTags'] = None):
        """
        :param 'CostCategoryRuleRuleOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleOrTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleOrCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleOrDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleOrTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategorySplitChargeRule(dict):
    def __init__(__self__, *,
                 method: str,
                 source: str,
                 targets: Sequence[str],
                 parameters: Optional[Sequence['outputs.CostCategorySplitChargeRuleParameter']] = None):
        """
        :param str method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param str source: Cost Category value that you want to split.
        :param Sequence[str] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        :param Sequence['CostCategorySplitChargeRuleParameterArgs'] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def targets(self) -> Sequence[str]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.CostCategorySplitChargeRuleParameter']]:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CostCategorySplitChargeRuleParameter(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: Parameter type.
        :param Sequence[str] values: Parameter values.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleResult(dict):
    def __init__(__self__, *,
                 inherited_values: Sequence['outputs.GetCostCategoryRuleInheritedValueResult'],
                 rules: Sequence['outputs.GetCostCategoryRuleRuleResult'],
                 type: str,
                 value: str):
        """
        :param Sequence['GetCostCategoryRuleInheritedValueArgs'] inherited_values: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param Sequence['GetCostCategoryRuleRuleArgs'] rules: Configuration block for the `Expression` object used to categorize costs. See below.
        :param str type: Parameter type.
        :param str value: Default value for the cost category.
        """
        pulumi.set(__self__, "inherited_values", inherited_values)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValues")
    def inherited_values(self) -> Sequence['outputs.GetCostCategoryRuleInheritedValueResult']:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_values")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetCostCategoryRuleRuleResult']:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCostCategoryRuleInheritedValueResult(dict):
    def __init__(__self__, *,
                 dimension_key: str,
                 dimension_name: str):
        """
        :param str dimension_key: Key to extract cost category values.
        :param str dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        pulumi.set(__self__, "dimension_key", dimension_key)
        pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> str:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> str:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")


@pulumi.output_type
class GetCostCategoryRuleRuleResult(dict):
    def __init__(__self__, *,
                 ands: Sequence['outputs.GetCostCategoryRuleRuleAndResult'],
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleDimensionResult'],
                 nots: Sequence['outputs.GetCostCategoryRuleRuleNotResult'],
                 ors: Sequence['outputs.GetCostCategoryRuleRuleOrResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndArgs'] ands: Return results that match both `Dimension` objects.
        :param Sequence['GetCostCategoryRuleRuleCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotArgs'] nots: Return results that do not match the `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleOrArgs'] ors: Return results that match either `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "ands", ands)
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "nots", nots)
        pulumi.set(__self__, "ors", ors)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndResult']:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def nots(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotResult']:
        """
        Return results that do not match the `Dimension` object.
        """
        return pulumi.get(self, "nots")

    @property
    @pulumi.getter
    def ors(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrResult']:
        """
        Return results that match either `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleAndCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleAndDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleAndTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleAndDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleAndTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleNotCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleNotDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleNotTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleNotCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleNotDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleOrCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleOrDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleOrTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleOrCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleOrDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleOrTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategorySplitChargeRuleResult(dict):
    def __init__(__self__, *,
                 method: str,
                 parameters: Sequence['outputs.GetCostCategorySplitChargeRuleParameterResult'],
                 source: str,
                 targets: Sequence[str]):
        """
        :param str method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param Sequence['GetCostCategorySplitChargeRuleParameterArgs'] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        :param str source: Cost Category value that you want to split.
        :param Sequence[str] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetCostCategorySplitChargeRuleParameterResult']:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def targets(self) -> Sequence[str]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetCostCategorySplitChargeRuleParameterResult(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Parameter type.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterResult(dict):
    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.GetTagsFilterAndResult']] = None,
                 cost_category: Optional['outputs.GetTagsFilterCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterDimensionResult'] = None,
                 not_: Optional['outputs.GetTagsFilterNotResult'] = None,
                 ors: Optional[Sequence['outputs.GetTagsFilterOrResult']] = None,
                 tags: Optional['outputs.GetTagsFilterTagsResult'] = None):
        """
        :param Sequence['GetTagsFilterAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'GetTagsFilterCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'GetTagsFilterDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'GetTagsFilterNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['GetTagsFilterOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'GetTagsFilterTagsArgs' tags: Tags that match your request.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.GetTagsFilterAndResult']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.GetTagsFilterNotResult']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.GetTagsFilterOrResult']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterAndResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterAndCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterAndDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterAndTagsResult'] = None):
        """
        :param 'GetTagsFilterAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'GetTagsFilterAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'GetTagsFilterAndTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterAndTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterAndTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterNotCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterNotDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterNotTagsResult'] = None):
        """
        :param 'GetTagsFilterNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'GetTagsFilterNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'GetTagsFilterNotTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterNotTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterOrCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterOrDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterOrTagsResult'] = None):
        """
        :param 'GetTagsFilterOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'GetTagsFilterOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'GetTagsFilterOrTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterOrTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsSortByResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 sort_order: Optional[str] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param str sort_order: order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[str]:
        """
        order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class GetTagsTimePeriodResult(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: Beginning of the time period.
        :param str start: End of the time period.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        Beginning of the time period.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        End of the time period.
        """
        return pulumi.get(self, "start")


