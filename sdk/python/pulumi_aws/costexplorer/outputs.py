# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AnomalySubscriptionSubscriber',
    'AnomalySubscriptionThresholdExpression',
    'AnomalySubscriptionThresholdExpressionAnd',
    'AnomalySubscriptionThresholdExpressionAndCostCategory',
    'AnomalySubscriptionThresholdExpressionAndDimension',
    'AnomalySubscriptionThresholdExpressionAndTags',
    'AnomalySubscriptionThresholdExpressionCostCategory',
    'AnomalySubscriptionThresholdExpressionDimension',
    'AnomalySubscriptionThresholdExpressionNot',
    'AnomalySubscriptionThresholdExpressionNotCostCategory',
    'AnomalySubscriptionThresholdExpressionNotDimension',
    'AnomalySubscriptionThresholdExpressionNotTags',
    'AnomalySubscriptionThresholdExpressionOr',
    'AnomalySubscriptionThresholdExpressionOrCostCategory',
    'AnomalySubscriptionThresholdExpressionOrDimension',
    'AnomalySubscriptionThresholdExpressionOrTags',
    'AnomalySubscriptionThresholdExpressionTags',
    'CostCategoryRule',
    'CostCategoryRuleInheritedValue',
    'CostCategoryRuleRule',
    'CostCategoryRuleRuleAnd',
    'CostCategoryRuleRuleAndAnd',
    'CostCategoryRuleRuleAndAndCostCategory',
    'CostCategoryRuleRuleAndAndDimension',
    'CostCategoryRuleRuleAndAndTags',
    'CostCategoryRuleRuleAndCostCategory',
    'CostCategoryRuleRuleAndDimension',
    'CostCategoryRuleRuleAndNot',
    'CostCategoryRuleRuleAndNotCostCategory',
    'CostCategoryRuleRuleAndNotDimension',
    'CostCategoryRuleRuleAndNotTags',
    'CostCategoryRuleRuleAndOr',
    'CostCategoryRuleRuleAndOrCostCategory',
    'CostCategoryRuleRuleAndOrDimension',
    'CostCategoryRuleRuleAndOrTags',
    'CostCategoryRuleRuleAndTags',
    'CostCategoryRuleRuleCostCategory',
    'CostCategoryRuleRuleDimension',
    'CostCategoryRuleRuleNot',
    'CostCategoryRuleRuleNotAnd',
    'CostCategoryRuleRuleNotAndCostCategory',
    'CostCategoryRuleRuleNotAndDimension',
    'CostCategoryRuleRuleNotAndTags',
    'CostCategoryRuleRuleNotCostCategory',
    'CostCategoryRuleRuleNotDimension',
    'CostCategoryRuleRuleNotNot',
    'CostCategoryRuleRuleNotNotCostCategory',
    'CostCategoryRuleRuleNotNotDimension',
    'CostCategoryRuleRuleNotNotTags',
    'CostCategoryRuleRuleNotOr',
    'CostCategoryRuleRuleNotOrCostCategory',
    'CostCategoryRuleRuleNotOrDimension',
    'CostCategoryRuleRuleNotOrTags',
    'CostCategoryRuleRuleNotTags',
    'CostCategoryRuleRuleOr',
    'CostCategoryRuleRuleOrAnd',
    'CostCategoryRuleRuleOrAndCostCategory',
    'CostCategoryRuleRuleOrAndDimension',
    'CostCategoryRuleRuleOrAndTags',
    'CostCategoryRuleRuleOrCostCategory',
    'CostCategoryRuleRuleOrDimension',
    'CostCategoryRuleRuleOrNot',
    'CostCategoryRuleRuleOrNotCostCategory',
    'CostCategoryRuleRuleOrNotDimension',
    'CostCategoryRuleRuleOrNotTags',
    'CostCategoryRuleRuleOrOr',
    'CostCategoryRuleRuleOrOrCostCategory',
    'CostCategoryRuleRuleOrOrDimension',
    'CostCategoryRuleRuleOrOrTags',
    'CostCategoryRuleRuleOrTags',
    'CostCategoryRuleRuleTags',
    'CostCategorySplitChargeRule',
    'CostCategorySplitChargeRuleParameter',
    'GetCostCategoryRuleResult',
    'GetCostCategoryRuleInheritedValueResult',
    'GetCostCategoryRuleRuleResult',
    'GetCostCategoryRuleRuleAndResult',
    'GetCostCategoryRuleRuleAndAndResult',
    'GetCostCategoryRuleRuleAndAndCostCategoryResult',
    'GetCostCategoryRuleRuleAndAndDimensionResult',
    'GetCostCategoryRuleRuleAndAndTagResult',
    'GetCostCategoryRuleRuleAndCostCategoryResult',
    'GetCostCategoryRuleRuleAndDimensionResult',
    'GetCostCategoryRuleRuleAndNotResult',
    'GetCostCategoryRuleRuleAndNotCostCategoryResult',
    'GetCostCategoryRuleRuleAndNotDimensionResult',
    'GetCostCategoryRuleRuleAndNotTagResult',
    'GetCostCategoryRuleRuleAndOrResult',
    'GetCostCategoryRuleRuleAndOrCostCategoryResult',
    'GetCostCategoryRuleRuleAndOrDimensionResult',
    'GetCostCategoryRuleRuleAndOrTagResult',
    'GetCostCategoryRuleRuleAndTagResult',
    'GetCostCategoryRuleRuleCostCategoryResult',
    'GetCostCategoryRuleRuleDimensionResult',
    'GetCostCategoryRuleRuleNotResult',
    'GetCostCategoryRuleRuleNotAndResult',
    'GetCostCategoryRuleRuleNotAndCostCategoryResult',
    'GetCostCategoryRuleRuleNotAndDimensionResult',
    'GetCostCategoryRuleRuleNotAndTagResult',
    'GetCostCategoryRuleRuleNotCostCategoryResult',
    'GetCostCategoryRuleRuleNotDimensionResult',
    'GetCostCategoryRuleRuleNotNotResult',
    'GetCostCategoryRuleRuleNotNotCostCategoryResult',
    'GetCostCategoryRuleRuleNotNotDimensionResult',
    'GetCostCategoryRuleRuleNotNotTagResult',
    'GetCostCategoryRuleRuleNotOrResult',
    'GetCostCategoryRuleRuleNotOrCostCategoryResult',
    'GetCostCategoryRuleRuleNotOrDimensionResult',
    'GetCostCategoryRuleRuleNotOrTagResult',
    'GetCostCategoryRuleRuleNotTagResult',
    'GetCostCategoryRuleRuleOrResult',
    'GetCostCategoryRuleRuleOrAndResult',
    'GetCostCategoryRuleRuleOrAndCostCategoryResult',
    'GetCostCategoryRuleRuleOrAndDimensionResult',
    'GetCostCategoryRuleRuleOrAndTagResult',
    'GetCostCategoryRuleRuleOrCostCategoryResult',
    'GetCostCategoryRuleRuleOrDimensionResult',
    'GetCostCategoryRuleRuleOrNotResult',
    'GetCostCategoryRuleRuleOrNotCostCategoryResult',
    'GetCostCategoryRuleRuleOrNotDimensionResult',
    'GetCostCategoryRuleRuleOrNotTagResult',
    'GetCostCategoryRuleRuleOrOrResult',
    'GetCostCategoryRuleRuleOrOrCostCategoryResult',
    'GetCostCategoryRuleRuleOrOrDimensionResult',
    'GetCostCategoryRuleRuleOrOrTagResult',
    'GetCostCategoryRuleRuleOrTagResult',
    'GetCostCategoryRuleRuleTagResult',
    'GetCostCategorySplitChargeRuleResult',
    'GetCostCategorySplitChargeRuleParameterResult',
    'GetTagsFilterResult',
    'GetTagsFilterAndResult',
    'GetTagsFilterAndCostCategoryResult',
    'GetTagsFilterAndDimensionResult',
    'GetTagsFilterAndTagsResult',
    'GetTagsFilterCostCategoryResult',
    'GetTagsFilterDimensionResult',
    'GetTagsFilterNotResult',
    'GetTagsFilterNotCostCategoryResult',
    'GetTagsFilterNotDimensionResult',
    'GetTagsFilterNotTagsResult',
    'GetTagsFilterOrResult',
    'GetTagsFilterOrCostCategoryResult',
    'GetTagsFilterOrDimensionResult',
    'GetTagsFilterOrTagsResult',
    'GetTagsFilterTagsResult',
    'GetTagsSortByResult',
    'GetTagsTimePeriodResult',
]

@pulumi.output_type
class AnomalySubscriptionSubscriber(dict):
    def __init__(__self__, *,
                 address: str,
                 type: str):
        """
        :param str address: The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        :param str type: The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the subscriber. If type is `SNS`, this will be the arn of the sns topic. If type is `EMAIL`, this will be the destination email address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of subscription. Valid Values: `SNS` | `EMAIL`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AnomalySubscriptionThresholdExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionAnd']] = None,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionDimension'] = None,
                 not_: Optional['outputs.AnomalySubscriptionThresholdExpressionNot'] = None,
                 ors: Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionOr']] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionTags'] = None):
        """
        :param Sequence['AnomalySubscriptionThresholdExpressionAndArgs'] ands: Return results that match both Dimension objects.
        :param 'AnomalySubscriptionThresholdExpressionCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionNotArgs' not_: Return results that match both Dimension object.
        :param Sequence['AnomalySubscriptionThresholdExpressionOrArgs'] ors: Return results that match both Dimension object.
        :param 'AnomalySubscriptionThresholdExpressionTagsArgs' tags: Configuration block for the specific Tag to use for. See Tags below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionAnd']]:
        """
        Return results that match both Dimension objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNot']:
        """
        Return results that match both Dimension object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.AnomalySubscriptionThresholdExpressionOr']]:
        """
        Return results that match both Dimension object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionTags']:
        """
        Configuration block for the specific Tag to use for. See Tags below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionAndCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionAndDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionAndTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionAndDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionAndTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionAndTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionNotCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionNotDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionNotTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionNotDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionNotTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionNotTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.AnomalySubscriptionThresholdExpressionOrCostCategory'] = None,
                 dimension: Optional['outputs.AnomalySubscriptionThresholdExpressionOrDimension'] = None,
                 tags: Optional['outputs.AnomalySubscriptionThresholdExpressionOrTags'] = None):
        """
        :param 'AnomalySubscriptionThresholdExpressionOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on  values. See Cost Category below.
        :param 'AnomalySubscriptionThresholdExpressionOrDimensionArgs' dimension: Configuration block for the specific Dimension to use for.
        :param 'AnomalySubscriptionThresholdExpressionOrTagsArgs' tags: A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrCostCategory']:
        """
        Configuration block for the filter that's based on  values. See Cost Category below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrDimension']:
        """
        Configuration block for the specific Dimension to use for.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.AnomalySubscriptionThresholdExpressionOrTags']:
        """
        A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AnomalySubscriptionThresholdExpressionTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalySubscriptionThresholdExpressionTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalySubscriptionThresholdExpressionTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalySubscriptionThresholdExpressionTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inheritedValue":
            suggest = "inherited_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inherited_value: Optional['outputs.CostCategoryRuleInheritedValue'] = None,
                 rule: Optional['outputs.CostCategoryRuleRule'] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param 'CostCategoryRuleInheritedValueArgs' inherited_value: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param 'CostCategoryRuleRuleArgs' rule: Configuration block for the `Expression` object used to categorize costs. See below.
        :param str type: You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        :param str value: Default value for the cost category.
        """
        if inherited_value is not None:
            pulumi.set(__self__, "inherited_value", inherited_value)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValue")
    def inherited_value(self) -> Optional['outputs.CostCategoryRuleInheritedValue']:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_value")

    @property
    @pulumi.getter
    def rule(self) -> Optional['outputs.CostCategoryRuleRule']:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        You can define the CostCategoryRule rule type as either `REGULAR` or `INHERITED_VALUE`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CostCategoryRuleInheritedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionKey":
            suggest = "dimension_key"
        elif key == "dimensionName":
            suggest = "dimension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleInheritedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleInheritedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleInheritedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_key: Optional[str] = None,
                 dimension_name: Optional[str] = None):
        """
        :param str dimension_key: Key to extract cost category values.
        :param str dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        if dimension_key is not None:
            pulumi.set(__self__, "dimension_key", dimension_key)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> Optional[str]:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[str]:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")


@pulumi.output_type
class CostCategoryRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.CostCategoryRuleRuleAnd']] = None,
                 cost_category: Optional['outputs.CostCategoryRuleRuleCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleDimension'] = None,
                 not_: Optional['outputs.CostCategoryRuleRuleNot'] = None,
                 ors: Optional[Sequence['outputs.CostCategoryRuleRuleOr']] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleTags'] = None):
        """
        :param Sequence['CostCategoryRuleRuleAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'CostCategoryRuleRuleCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['CostCategoryRuleRuleOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'CostCategoryRuleRuleTagsArgs' tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleAnd']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.CostCategoryRuleRuleNot']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleOr']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleTags']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.CostCategoryRuleRuleAndAnd']] = None,
                 cost_category: Optional['outputs.CostCategoryRuleRuleAndCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleAndDimension'] = None,
                 not_: Optional['outputs.CostCategoryRuleRuleAndNot'] = None,
                 ors: Optional[Sequence['outputs.CostCategoryRuleRuleAndOr']] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleAndTags'] = None):
        """
        :param Sequence['CostCategoryRuleRuleAndAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'CostCategoryRuleRuleAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleAndNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['CostCategoryRuleRuleAndOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'CostCategoryRuleRuleAndTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleAndAnd']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleAndCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleAndDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.CostCategoryRuleRuleAndNot']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleAndOr']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleAndTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAndAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleAndAndCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleAndAndDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleAndAndTags'] = None):
        """
        :param 'CostCategoryRuleRuleAndAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleAndAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleAndAndTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleAndAndCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleAndAndDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleAndAndTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAndAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleAndNotCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleAndNotDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleAndNotTags'] = None):
        """
        :param 'CostCategoryRuleRuleAndNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleAndNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleAndNotTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleAndNotCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleAndNotDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleAndNotTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAndNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleAndOrCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleAndOrDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleAndOrTags'] = None):
        """
        :param 'CostCategoryRuleRuleAndOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleAndOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleAndOrTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleAndOrCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleAndOrDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleAndOrTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleAndOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.CostCategoryRuleRuleNotAnd']] = None,
                 cost_category: Optional['outputs.CostCategoryRuleRuleNotCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleNotDimension'] = None,
                 not_: Optional['outputs.CostCategoryRuleRuleNotNot'] = None,
                 ors: Optional[Sequence['outputs.CostCategoryRuleRuleNotOr']] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleNotTags'] = None):
        """
        :param Sequence['CostCategoryRuleRuleNotAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'CostCategoryRuleRuleNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['CostCategoryRuleRuleNotOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'CostCategoryRuleRuleNotTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleNotAnd']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleNotCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleNotDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.CostCategoryRuleRuleNotNot']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleNotOr']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleNotTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleNotAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleNotAndCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleNotAndDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleNotAndTags'] = None):
        """
        :param 'CostCategoryRuleRuleNotAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleNotAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotAndTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleNotAndCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleNotAndDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleNotAndTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleNotAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleNotNotCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleNotNotDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleNotNotTags'] = None):
        """
        :param 'CostCategoryRuleRuleNotNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleNotNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotNotTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleNotNotCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleNotNotDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleNotNotTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleNotNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleNotOrCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleNotOrDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleNotOrTags'] = None):
        """
        :param 'CostCategoryRuleRuleNotOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleNotOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleNotOrTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleNotOrCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleNotOrDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleNotOrTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleNotOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"
        elif key == "not":
            suggest = "not_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.CostCategoryRuleRuleOrAnd']] = None,
                 cost_category: Optional['outputs.CostCategoryRuleRuleOrCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleOrDimension'] = None,
                 not_: Optional['outputs.CostCategoryRuleRuleOrNot'] = None,
                 ors: Optional[Sequence['outputs.CostCategoryRuleRuleOrOr']] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleOrTags'] = None):
        """
        :param Sequence['CostCategoryRuleRuleOrAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'CostCategoryRuleRuleOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleOrNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['CostCategoryRuleRuleOrOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'CostCategoryRuleRuleOrTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleOrAnd']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleOrCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleOrDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.CostCategoryRuleRuleOrNot']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.CostCategoryRuleRuleOrOr']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleOrTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleOrAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleOrAndCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleOrAndDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleOrAndTags'] = None):
        """
        :param 'CostCategoryRuleRuleOrAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleOrAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleOrAndTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleOrAndCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleOrAndDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleOrAndTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleOrAndCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrAndCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrAndCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrAndCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrAndDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrAndDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrAndDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrAndDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrAndTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrAndTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrAndTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrAndTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrNot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrNot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrNot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrNot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleOrNotCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleOrNotDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleOrNotTags'] = None):
        """
        :param 'CostCategoryRuleRuleOrNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleOrNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleOrNotTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleOrNotCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleOrNotDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleOrNotTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleOrNotCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrNotCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrNotCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrNotCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrNotDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrNotDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrNotDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrNotDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrNotTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrNotTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrNotTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrNotTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrOr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costCategory":
            suggest = "cost_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrOr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrOr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrOr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_category: Optional['outputs.CostCategoryRuleRuleOrOrCostCategory'] = None,
                 dimension: Optional['outputs.CostCategoryRuleRuleOrOrDimension'] = None,
                 tags: Optional['outputs.CostCategoryRuleRuleOrOrTags'] = None):
        """
        :param 'CostCategoryRuleRuleOrOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param 'CostCategoryRuleRuleOrOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param 'CostCategoryRuleRuleOrOrTagsArgs' tags: Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.CostCategoryRuleRuleOrOrCostCategory']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.CostCategoryRuleRuleOrOrDimension']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.CostCategoryRuleRuleOrOrTags']:
        """
        Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CostCategoryRuleRuleOrOrCostCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrOrCostCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrOrCostCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrOrCostCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrOrDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrOrDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrOrDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrOrDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleOrTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleOrTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleOrTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleOrTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategoryRuleRuleTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOptions":
            suggest = "match_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CostCategoryRuleRuleTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CostCategoryRuleRuleTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CostCategoryRuleRuleTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CostCategorySplitChargeRule(dict):
    def __init__(__self__, *,
                 method: str,
                 source: str,
                 targets: Sequence[str],
                 parameters: Optional[Sequence['outputs.CostCategorySplitChargeRuleParameter']] = None):
        """
        :param str method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param str source: Cost Category value that you want to split.
        :param Sequence[str] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        :param Sequence['CostCategorySplitChargeRuleParameterArgs'] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def targets(self) -> Sequence[str]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.CostCategorySplitChargeRuleParameter']]:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CostCategorySplitChargeRuleParameter(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str type: Parameter type.
        :param Sequence[str] values: Parameter values.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleResult(dict):
    def __init__(__self__, *,
                 inherited_values: Sequence['outputs.GetCostCategoryRuleInheritedValueResult'],
                 rules: Sequence['outputs.GetCostCategoryRuleRuleResult'],
                 type: str,
                 value: str):
        """
        :param Sequence['GetCostCategoryRuleInheritedValueArgs'] inherited_values: Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        :param Sequence['GetCostCategoryRuleRuleArgs'] rules: Configuration block for the `Expression` object used to categorize costs. See below.
        :param str type: Parameter type.
        :param str value: Default value for the cost category.
        """
        pulumi.set(__self__, "inherited_values", inherited_values)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="inheritedValues")
    def inherited_values(self) -> Sequence['outputs.GetCostCategoryRuleInheritedValueResult']:
        """
        Configuration block for the value the line item is categorized as if the line item contains the matched dimension. See below.
        """
        return pulumi.get(self, "inherited_values")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetCostCategoryRuleRuleResult']:
        """
        Configuration block for the `Expression` object used to categorize costs. See below.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Default value for the cost category.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCostCategoryRuleInheritedValueResult(dict):
    def __init__(__self__, *,
                 dimension_key: str,
                 dimension_name: str):
        """
        :param str dimension_key: Key to extract cost category values.
        :param str dimension_name: Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        pulumi.set(__self__, "dimension_key", dimension_key)
        pulumi.set(__self__, "dimension_name", dimension_name)

    @property
    @pulumi.getter(name="dimensionKey")
    def dimension_key(self) -> str:
        """
        Key to extract cost category values.
        """
        return pulumi.get(self, "dimension_key")

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> str:
        """
        Name of the dimension that's used to group costs. If you specify `LINKED_ACCOUNT_NAME`, the cost category value is based on account name. If you specify `TAG`, the cost category value will be based on the value of the specified tag key. Valid values are `LINKED_ACCOUNT_NAME`, `TAG`
        """
        return pulumi.get(self, "dimension_name")


@pulumi.output_type
class GetCostCategoryRuleRuleResult(dict):
    def __init__(__self__, *,
                 ands: Sequence['outputs.GetCostCategoryRuleRuleAndResult'],
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleDimensionResult'],
                 nots: Sequence['outputs.GetCostCategoryRuleRuleNotResult'],
                 ors: Sequence['outputs.GetCostCategoryRuleRuleOrResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndArgs'] ands: Return results that match both `Dimension` objects.
        :param Sequence['GetCostCategoryRuleRuleCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotArgs'] nots: Return results that do not match the `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleOrArgs'] ors: Return results that match either `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "ands", ands)
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "nots", nots)
        pulumi.set(__self__, "ors", ors)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndResult']:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def nots(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotResult']:
        """
        Return results that do not match the `Dimension` object.
        """
        return pulumi.get(self, "nots")

    @property
    @pulumi.getter
    def ors(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrResult']:
        """
        Return results that match either `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndResult(dict):
    def __init__(__self__, *,
                 ands: Sequence['outputs.GetCostCategoryRuleRuleAndAndResult'],
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleAndCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleAndDimensionResult'],
                 nots: Sequence['outputs.GetCostCategoryRuleRuleAndNotResult'],
                 ors: Sequence['outputs.GetCostCategoryRuleRuleAndOrResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleAndTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndAndArgs'] ands: Return results that match both `Dimension` objects.
        :param Sequence['GetCostCategoryRuleRuleAndCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleAndDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleAndNotArgs'] nots: Return results that do not match the `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleAndOrArgs'] ors: Return results that match either `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleAndTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "ands", ands)
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "nots", nots)
        pulumi.set(__self__, "ors", ors)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndAndResult']:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def nots(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndNotResult']:
        """
        Return results that do not match the `Dimension` object.
        """
        return pulumi.get(self, "nots")

    @property
    @pulumi.getter
    def ors(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndOrResult']:
        """
        Return results that match either `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndAndResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleAndAndCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleAndAndDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleAndAndTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndAndCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleAndAndDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleAndAndTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndAndTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndAndTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndNotResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleAndNotCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleAndNotDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleAndNotTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndNotCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleAndNotDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleAndNotTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndNotTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndNotTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndOrResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleAndOrCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleAndOrDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleAndOrTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleAndOrCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleAndOrDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleAndOrTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleAndOrTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleAndOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndOrTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleAndTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotResult(dict):
    def __init__(__self__, *,
                 ands: Sequence['outputs.GetCostCategoryRuleRuleNotAndResult'],
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleNotCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleNotDimensionResult'],
                 nots: Sequence['outputs.GetCostCategoryRuleRuleNotNotResult'],
                 ors: Sequence['outputs.GetCostCategoryRuleRuleNotOrResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleNotTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleNotAndArgs'] ands: Return results that match both `Dimension` objects.
        :param Sequence['GetCostCategoryRuleRuleNotCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleNotDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotNotArgs'] nots: Return results that do not match the `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleNotOrArgs'] ors: Return results that match either `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleNotTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "ands", ands)
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "nots", nots)
        pulumi.set(__self__, "ors", ors)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotAndResult']:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def nots(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotNotResult']:
        """
        Return results that do not match the `Dimension` object.
        """
        return pulumi.get(self, "nots")

    @property
    @pulumi.getter
    def ors(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotOrResult']:
        """
        Return results that match either `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleNotAndResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleNotAndCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleNotAndDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleNotAndTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleNotAndCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleNotAndDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotAndTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotAndTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleNotAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotAndTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotNotResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleNotNotCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleNotNotDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleNotNotTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleNotNotCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleNotNotDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotNotTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotNotTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleNotNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotNotTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotOrResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleNotOrCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleNotOrDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleNotOrTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleNotOrCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleNotOrDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleNotOrTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleNotOrTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleNotOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotOrTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleNotTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrResult(dict):
    def __init__(__self__, *,
                 ands: Sequence['outputs.GetCostCategoryRuleRuleOrAndResult'],
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleOrCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleOrDimensionResult'],
                 nots: Sequence['outputs.GetCostCategoryRuleRuleOrNotResult'],
                 ors: Sequence['outputs.GetCostCategoryRuleRuleOrOrResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleOrTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleOrAndArgs'] ands: Return results that match both `Dimension` objects.
        :param Sequence['GetCostCategoryRuleRuleOrCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleOrDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleOrNotArgs'] nots: Return results that do not match the `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleOrOrArgs'] ors: Return results that match either `Dimension` object.
        :param Sequence['GetCostCategoryRuleRuleOrTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "ands", ands)
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "nots", nots)
        pulumi.set(__self__, "ors", ors)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrAndResult']:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def nots(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrNotResult']:
        """
        Return results that do not match the `Dimension` object.
        """
        return pulumi.get(self, "nots")

    @property
    @pulumi.getter
    def ors(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrOrResult']:
        """
        Return results that match either `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleOrAndResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleOrAndCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleOrAndDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleOrAndTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleOrAndCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleOrAndDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleOrAndTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrAndTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleOrAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrAndTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrNotResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleOrNotCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleOrNotDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleOrNotTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleOrNotCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleOrNotDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleOrNotTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrNotTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleOrNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrNotTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrOrResult(dict):
    def __init__(__self__, *,
                 cost_categories: Sequence['outputs.GetCostCategoryRuleRuleOrOrCostCategoryResult'],
                 dimensions: Sequence['outputs.GetCostCategoryRuleRuleOrOrDimensionResult'],
                 tags: Sequence['outputs.GetCostCategoryRuleRuleOrOrTagResult']):
        """
        :param Sequence['GetCostCategoryRuleRuleOrOrCostCategoryArgs'] cost_categories: Configuration block for the filter that's based on `CostCategory` values. See below.
        :param Sequence['GetCostCategoryRuleRuleOrOrDimensionArgs'] dimensions: Configuration block for the specific `Dimension` to use for `Expression`. See below.
        :param Sequence['GetCostCategoryRuleRuleOrOrTagArgs'] tags: Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        pulumi.set(__self__, "cost_categories", cost_categories)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategories")
    def cost_categories(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See below.
        """
        return pulumi.get(self, "cost_categories")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See below.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetCostCategoryRuleRuleOrOrTagResult']:
        """
        Configuration block for the specific `Tag` to use for `Expression`. See below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCostCategoryRuleRuleOrOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrOrTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleOrTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategoryRuleRuleTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 match_options: Sequence[str],
                 values: Sequence[str]):
        """
        :param str key: Key for the tag.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match_options", match_options)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Sequence[str]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCostCategorySplitChargeRuleResult(dict):
    def __init__(__self__, *,
                 method: str,
                 parameters: Sequence['outputs.GetCostCategorySplitChargeRuleParameterResult'],
                 source: str,
                 targets: Sequence[str]):
        """
        :param str method: Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        :param Sequence['GetCostCategorySplitChargeRuleParameterArgs'] parameters: Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        :param str source: Cost Category value that you want to split.
        :param Sequence[str] targets: Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Method that's used to define how to split your source costs across your targets. Valid values are `FIXED`, `PROPORTIONAL`, `EVEN`
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetCostCategorySplitChargeRuleParameterResult']:
        """
        Configuration block for the parameters for a split charge method. This is only required for the `FIXED` method. See below.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Cost Category value that you want to split.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def targets(self) -> Sequence[str]:
        """
        Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetCostCategorySplitChargeRuleParameterResult(dict):
    def __init__(__self__, *,
                 type: str,
                 values: Sequence[str]):
        """
        :param str type: Parameter type.
        :param Sequence[str] values: Parameter values.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterResult(dict):
    def __init__(__self__, *,
                 ands: Optional[Sequence['outputs.GetTagsFilterAndResult']] = None,
                 cost_category: Optional['outputs.GetTagsFilterCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterDimensionResult'] = None,
                 not_: Optional['outputs.GetTagsFilterNotResult'] = None,
                 ors: Optional[Sequence['outputs.GetTagsFilterOrResult']] = None,
                 tags: Optional['outputs.GetTagsFilterTagsResult'] = None):
        """
        :param Sequence['GetTagsFilterAndArgs'] ands: Return results that match both `Dimension` objects.
        :param 'GetTagsFilterCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterNotArgs' not_: Return results that match both `Dimension` object.
        :param Sequence['GetTagsFilterOrArgs'] ors: Return results that match both `Dimension` object.
        :param 'GetTagsFilterTagsArgs' tags: Tags that match your request.
        """
        if ands is not None:
            pulumi.set(__self__, "ands", ands)
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if ors is not None:
            pulumi.set(__self__, "ors", ors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def ands(self) -> Optional[Sequence['outputs.GetTagsFilterAndResult']]:
        """
        Return results that match both `Dimension` objects.
        """
        return pulumi.get(self, "ands")

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.GetTagsFilterNotResult']:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def ors(self) -> Optional[Sequence['outputs.GetTagsFilterOrResult']]:
        """
        Return results that match both `Dimension` object.
        """
        return pulumi.get(self, "ors")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterAndResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterAndCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterAndDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterAndTagsResult'] = None):
        """
        :param 'GetTagsFilterAndCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterAndDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterAndTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterAndCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterAndDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterAndTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterAndCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterAndDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterAndTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterNotCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterNotDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterNotTagsResult'] = None):
        """
        :param 'GetTagsFilterNotCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterNotDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterNotTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterNotCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterNotDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterNotTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterNotCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterNotTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrResult(dict):
    def __init__(__self__, *,
                 cost_category: Optional['outputs.GetTagsFilterOrCostCategoryResult'] = None,
                 dimension: Optional['outputs.GetTagsFilterOrDimensionResult'] = None,
                 tags: Optional['outputs.GetTagsFilterOrTagsResult'] = None):
        """
        :param 'GetTagsFilterOrCostCategoryArgs' cost_category: Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        :param 'GetTagsFilterOrDimensionArgs' dimension: Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        :param 'GetTagsFilterOrTagsArgs' tags: Tags that match your request.
        """
        if cost_category is not None:
            pulumi.set(__self__, "cost_category", cost_category)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="costCategory")
    def cost_category(self) -> Optional['outputs.GetTagsFilterOrCostCategoryResult']:
        """
        Configuration block for the filter that's based on `CostCategory` values. See `cost_category` block below for details.
        """
        return pulumi.get(self, "cost_category")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.GetTagsFilterOrDimensionResult']:
        """
        Configuration block for the specific `Dimension` to use for `Expression`. See `dimension` block below for details.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def tags(self) -> Optional['outputs.GetTagsFilterOrTagsResult']:
        """
        Tags that match your request.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTagsFilterOrCostCategoryResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrDimensionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: Unique name of the Cost Category.
        :param Sequence[str] match_options: Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        :param Sequence[str] values: Specific value of the Cost Category.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique name of the Cost Category.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        """
        Match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is `EQUALS` and `CASE_SENSITIVE`. Valid values are: `EQUALS`,  `ABSENT`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CASE_SENSITIVE`, `CASE_INSENSITIVE`.
        """
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Specific value of the Cost Category.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterOrTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsFilterTagsResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 match_options: Optional[Sequence[str]] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_options is not None:
            pulumi.set(__self__, "match_options", match_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchOptions")
    def match_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_options")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagsSortByResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 sort_order: Optional[str] = None):
        """
        :param str key: key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        :param str sort_order: order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        key that's used to sort the data. Valid values are: `BlendedCost`,  `UnblendedCost`, `AmortizedCost`, `NetAmortizedCost`, `NetUnblendedCost`, `UsageQuantity`, `NormalizedUsageAmount`.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[str]:
        """
        order that's used to sort the data. Valid values are: `ASCENDING`,  `DESCENDING`.
        """
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class GetTagsTimePeriodResult(dict):
    def __init__(__self__, *,
                 end: str,
                 start: str):
        """
        :param str end: Beginning of the time period.
        :param str start: End of the time period.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        Beginning of the time period.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        End of the time period.
        """
        return pulumi.get(self, "start")


