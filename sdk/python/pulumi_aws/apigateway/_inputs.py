# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccountThrottleSettingArgs',
    'AccountThrottleSettingArgsDict',
    'DocumentationPartLocationArgs',
    'DocumentationPartLocationArgsDict',
    'DomainNameEndpointConfigurationArgs',
    'DomainNameEndpointConfigurationArgsDict',
    'DomainNameMutualTlsAuthenticationArgs',
    'DomainNameMutualTlsAuthenticationArgsDict',
    'IntegrationTlsConfigArgs',
    'IntegrationTlsConfigArgsDict',
    'MethodSettingsSettingsArgs',
    'MethodSettingsSettingsArgsDict',
    'RestApiEndpointConfigurationArgs',
    'RestApiEndpointConfigurationArgsDict',
    'RestApiPutTimeoutsArgs',
    'RestApiPutTimeoutsArgsDict',
    'StageAccessLogSettingsArgs',
    'StageAccessLogSettingsArgsDict',
    'StageCanarySettingsArgs',
    'StageCanarySettingsArgsDict',
    'UsagePlanApiStageArgs',
    'UsagePlanApiStageArgsDict',
    'UsagePlanApiStageThrottleArgs',
    'UsagePlanApiStageThrottleArgsDict',
    'UsagePlanQuotaSettingsArgs',
    'UsagePlanQuotaSettingsArgsDict',
    'UsagePlanThrottleSettingsArgs',
    'UsagePlanThrottleSettingsArgsDict',
]

MYPY = False

if not MYPY:
    class AccountThrottleSettingArgsDict(TypedDict):
        burst_limit: pulumi.Input[_builtins.int]
        rate_limit: pulumi.Input[_builtins.float]
elif False:
    AccountThrottleSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountThrottleSettingArgs:
    def __init__(__self__, *,
                 burst_limit: pulumi.Input[_builtins.int],
                 rate_limit: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "burst_limit", burst_limit)
        pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "burst_limit")

    @burst_limit.setter
    def burst_limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "burst_limit", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class DocumentationPartLocationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        method: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        status_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DocumentationPartLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentationPartLocationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class DomainNameEndpointConfigurationArgsDict(TypedDict):
        types: pulumi.Input[_builtins.str]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainNameEndpointConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainNameEndpointConfigurationArgs:
    def __init__(__self__, *,
                 types: pulumi.Input[_builtins.str],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "types", types)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @_builtins.property
    @pulumi.getter
    def types(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "types", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)


if not MYPY:
    class DomainNameMutualTlsAuthenticationArgsDict(TypedDict):
        truststore_uri: pulumi.Input[_builtins.str]
        truststore_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainNameMutualTlsAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainNameMutualTlsAuthenticationArgs:
    def __init__(__self__, *,
                 truststore_uri: pulumi.Input[_builtins.str],
                 truststore_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "truststore_uri", truststore_uri)
        if truststore_version is not None:
            pulumi.set(__self__, "truststore_version", truststore_version)

    @_builtins.property
    @pulumi.getter(name="truststoreUri")
    def truststore_uri(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "truststore_uri")

    @truststore_uri.setter
    def truststore_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "truststore_uri", value)

    @_builtins.property
    @pulumi.getter(name="truststoreVersion")
    def truststore_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "truststore_version")

    @truststore_version.setter
    def truststore_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "truststore_version", value)


if not MYPY:
    class IntegrationTlsConfigArgsDict(TypedDict):
        insecure_skip_verification: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    IntegrationTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTlsConfigArgs:
    def __init__(__self__, *,
                 insecure_skip_verification: Optional[pulumi.Input[_builtins.bool]] = None):
        if insecure_skip_verification is not None:
            pulumi.set(__self__, "insecure_skip_verification", insecure_skip_verification)

    @_builtins.property
    @pulumi.getter(name="insecureSkipVerification")
    def insecure_skip_verification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "insecure_skip_verification")

    @insecure_skip_verification.setter
    def insecure_skip_verification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_skip_verification", value)


if not MYPY:
    class MethodSettingsSettingsArgsDict(TypedDict):
        cache_data_encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        cache_ttl_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        caching_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        data_trace_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        logging_level: NotRequired[pulumi.Input[_builtins.str]]
        metrics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        require_authorization_for_cache_control: NotRequired[pulumi.Input[_builtins.bool]]
        throttling_burst_limit: NotRequired[pulumi.Input[_builtins.int]]
        throttling_rate_limit: NotRequired[pulumi.Input[_builtins.float]]
        unauthorized_cache_control_header_strategy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MethodSettingsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MethodSettingsSettingsArgs:
    def __init__(__self__, *,
                 cache_data_encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 cache_ttl_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 caching_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 data_trace_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 logging_level: Optional[pulumi.Input[_builtins.str]] = None,
                 metrics_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 require_authorization_for_cache_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 throttling_burst_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 throttling_rate_limit: Optional[pulumi.Input[_builtins.float]] = None,
                 unauthorized_cache_control_header_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        if cache_data_encrypted is not None:
            pulumi.set(__self__, "cache_data_encrypted", cache_data_encrypted)
        if cache_ttl_in_seconds is not None:
            pulumi.set(__self__, "cache_ttl_in_seconds", cache_ttl_in_seconds)
        if caching_enabled is not None:
            pulumi.set(__self__, "caching_enabled", caching_enabled)
        if data_trace_enabled is not None:
            pulumi.set(__self__, "data_trace_enabled", data_trace_enabled)
        if logging_level is not None:
            pulumi.set(__self__, "logging_level", logging_level)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if require_authorization_for_cache_control is not None:
            pulumi.set(__self__, "require_authorization_for_cache_control", require_authorization_for_cache_control)
        if throttling_burst_limit is not None:
            pulumi.set(__self__, "throttling_burst_limit", throttling_burst_limit)
        if throttling_rate_limit is not None:
            pulumi.set(__self__, "throttling_rate_limit", throttling_rate_limit)
        if unauthorized_cache_control_header_strategy is not None:
            pulumi.set(__self__, "unauthorized_cache_control_header_strategy", unauthorized_cache_control_header_strategy)

    @_builtins.property
    @pulumi.getter(name="cacheDataEncrypted")
    def cache_data_encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cache_data_encrypted")

    @cache_data_encrypted.setter
    def cache_data_encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cache_data_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="cacheTtlInSeconds")
    def cache_ttl_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "cache_ttl_in_seconds")

    @cache_ttl_in_seconds.setter
    def cache_ttl_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cache_ttl_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="cachingEnabled")
    def caching_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "caching_enabled")

    @caching_enabled.setter
    def caching_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "caching_enabled", value)

    @_builtins.property
    @pulumi.getter(name="dataTraceEnabled")
    def data_trace_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "data_trace_enabled")

    @data_trace_enabled.setter
    def data_trace_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "data_trace_enabled", value)

    @_builtins.property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "logging_level")

    @logging_level.setter
    def logging_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logging_level", value)

    @_builtins.property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "metrics_enabled")

    @metrics_enabled.setter
    def metrics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="requireAuthorizationForCacheControl")
    def require_authorization_for_cache_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "require_authorization_for_cache_control")

    @require_authorization_for_cache_control.setter
    def require_authorization_for_cache_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_authorization_for_cache_control", value)

    @_builtins.property
    @pulumi.getter(name="throttlingBurstLimit")
    def throttling_burst_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throttling_burst_limit")

    @throttling_burst_limit.setter
    def throttling_burst_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throttling_burst_limit", value)

    @_builtins.property
    @pulumi.getter(name="throttlingRateLimit")
    def throttling_rate_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "throttling_rate_limit")

    @throttling_rate_limit.setter
    def throttling_rate_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "throttling_rate_limit", value)

    @_builtins.property
    @pulumi.getter(name="unauthorizedCacheControlHeaderStrategy")
    def unauthorized_cache_control_header_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unauthorized_cache_control_header_strategy")

    @unauthorized_cache_control_header_strategy.setter
    def unauthorized_cache_control_header_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unauthorized_cache_control_header_strategy", value)


if not MYPY:
    class RestApiEndpointConfigurationArgsDict(TypedDict):
        types: pulumi.Input[_builtins.str]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
        vpc_endpoint_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RestApiEndpointConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestApiEndpointConfigurationArgs:
    def __init__(__self__, *,
                 types: pulumi.Input[_builtins.str],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_endpoint_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "types", types)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if vpc_endpoint_ids is not None:
            pulumi.set(__self__, "vpc_endpoint_ids", vpc_endpoint_ids)

    @_builtins.property
    @pulumi.getter
    def types(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "types", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)

    @_builtins.property
    @pulumi.getter(name="vpcEndpointIds")
    def vpc_endpoint_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "vpc_endpoint_ids")

    @vpc_endpoint_ids.setter
    def vpc_endpoint_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "vpc_endpoint_ids", value)


if not MYPY:
    class RestApiPutTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    RestApiPutTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestApiPutTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class StageAccessLogSettingsArgsDict(TypedDict):
        destination_arn: pulumi.Input[_builtins.str]
        format: pulumi.Input[_builtins.str]
elif False:
    StageAccessLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageAccessLogSettingsArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[_builtins.str],
                 format: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)


if not MYPY:
    class StageCanarySettingsArgsDict(TypedDict):
        deployment_id: pulumi.Input[_builtins.str]
        percent_traffic: NotRequired[pulumi.Input[_builtins.float]]
        stage_variable_overrides: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        use_stage_cache: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    StageCanarySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageCanarySettingsArgs:
    def __init__(__self__, *,
                 deployment_id: pulumi.Input[_builtins.str],
                 percent_traffic: Optional[pulumi.Input[_builtins.float]] = None,
                 stage_variable_overrides: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 use_stage_cache: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "deployment_id", deployment_id)
        if percent_traffic is not None:
            pulumi.set(__self__, "percent_traffic", percent_traffic)
        if stage_variable_overrides is not None:
            pulumi.set(__self__, "stage_variable_overrides", stage_variable_overrides)
        if use_stage_cache is not None:
            pulumi.set(__self__, "use_stage_cache", use_stage_cache)

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @deployment_id.setter
    def deployment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_id", value)

    @_builtins.property
    @pulumi.getter(name="percentTraffic")
    def percent_traffic(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "percent_traffic")

    @percent_traffic.setter
    def percent_traffic(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "percent_traffic", value)

    @_builtins.property
    @pulumi.getter(name="stageVariableOverrides")
    def stage_variable_overrides(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "stage_variable_overrides")

    @stage_variable_overrides.setter
    def stage_variable_overrides(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stage_variable_overrides", value)

    @_builtins.property
    @pulumi.getter(name="useStageCache")
    def use_stage_cache(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_stage_cache")

    @use_stage_cache.setter
    def use_stage_cache(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_stage_cache", value)


if not MYPY:
    class UsagePlanApiStageArgsDict(TypedDict):
        api_id: pulumi.Input[_builtins.str]
        stage: pulumi.Input[_builtins.str]
        throttles: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsagePlanApiStageThrottleArgsDict']]]]
elif False:
    UsagePlanApiStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanApiStageArgs:
    def __init__(__self__, *,
                 api_id: pulumi.Input[_builtins.str],
                 stage: pulumi.Input[_builtins.str],
                 throttles: Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanApiStageThrottleArgs']]]] = None):
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "stage", stage)
        if throttles is not None:
            pulumi.set(__self__, "throttles", throttles)

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "api_id")

    @api_id.setter
    def api_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_id", value)

    @_builtins.property
    @pulumi.getter
    def stage(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stage")

    @stage.setter
    def stage(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stage", value)

    @_builtins.property
    @pulumi.getter
    def throttles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanApiStageThrottleArgs']]]]:
        return pulumi.get(self, "throttles")

    @throttles.setter
    def throttles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanApiStageThrottleArgs']]]]):
        pulumi.set(self, "throttles", value)


if not MYPY:
    class UsagePlanApiStageThrottleArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        burst_limit: NotRequired[pulumi.Input[_builtins.int]]
        rate_limit: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    UsagePlanApiStageThrottleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanApiStageThrottleArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 burst_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[_builtins.float]] = None):
        pulumi.set(__self__, "path", path)
        if burst_limit is not None:
            pulumi.set(__self__, "burst_limit", burst_limit)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "burst_limit")

    @burst_limit.setter
    def burst_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "burst_limit", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class UsagePlanQuotaSettingsArgsDict(TypedDict):
        limit: pulumi.Input[_builtins.int]
        period: pulumi.Input[_builtins.str]
        offset: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    UsagePlanQuotaSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanQuotaSettingsArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[_builtins.int],
                 period: pulumi.Input[_builtins.str],
                 offset: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "period", period)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class UsagePlanThrottleSettingsArgsDict(TypedDict):
        burst_limit: NotRequired[pulumi.Input[_builtins.int]]
        rate_limit: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    UsagePlanThrottleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanThrottleSettingsArgs:
    def __init__(__self__, *,
                 burst_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[_builtins.float]] = None):
        if burst_limit is not None:
            pulumi.set(__self__, "burst_limit", burst_limit)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "burst_limit")

    @burst_limit.setter
    def burst_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "burst_limit", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "rate_limit", value)


