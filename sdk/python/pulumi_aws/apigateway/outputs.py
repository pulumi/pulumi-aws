# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AccountThrottleSetting',
    'DocumentationPartLocation',
    'DomainNameEndpointConfiguration',
    'DomainNameMutualTlsAuthentication',
    'IntegrationTlsConfig',
    'MethodSettingsSettings',
    'RestApiEndpointConfiguration',
    'RestApiPutTimeouts',
    'StageAccessLogSettings',
    'StageCanarySettings',
    'UsagePlanApiStage',
    'UsagePlanApiStageThrottle',
    'UsagePlanQuotaSettings',
    'UsagePlanThrottleSettings',
    'GetApiKeysItemResult',
    'GetDomainNameEndpointConfigurationResult',
    'GetRestApiEndpointConfigurationResult',
]

@pulumi.output_type
class AccountThrottleSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burstLimit":
            suggest = "burst_limit"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountThrottleSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountThrottleSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountThrottleSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burst_limit: _builtins.int,
                 rate_limit: _builtins.float):
        pulumi.set(__self__, "burst_limit", burst_limit)
        pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> _builtins.int:
        return pulumi.get(self, "burst_limit")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> _builtins.float:
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class DocumentationPartLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DocumentationPartLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DocumentationPartLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DocumentationPartLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 method: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class DomainNameEndpointConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNameEndpointConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNameEndpointConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNameEndpointConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 types: _builtins.str,
                 ip_address_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "types", types)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @_builtins.property
    @pulumi.getter
    def types(self) -> _builtins.str:
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address_type")


@pulumi.output_type
class DomainNameMutualTlsAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "truststoreUri":
            suggest = "truststore_uri"
        elif key == "truststoreVersion":
            suggest = "truststore_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNameMutualTlsAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNameMutualTlsAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNameMutualTlsAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 truststore_uri: _builtins.str,
                 truststore_version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "truststore_uri", truststore_uri)
        if truststore_version is not None:
            pulumi.set(__self__, "truststore_version", truststore_version)

    @_builtins.property
    @pulumi.getter(name="truststoreUri")
    def truststore_uri(self) -> _builtins.str:
        return pulumi.get(self, "truststore_uri")

    @_builtins.property
    @pulumi.getter(name="truststoreVersion")
    def truststore_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "truststore_version")


@pulumi.output_type
class IntegrationTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insecureSkipVerification":
            suggest = "insecure_skip_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insecure_skip_verification: Optional[_builtins.bool] = None):
        if insecure_skip_verification is not None:
            pulumi.set(__self__, "insecure_skip_verification", insecure_skip_verification)

    @_builtins.property
    @pulumi.getter(name="insecureSkipVerification")
    def insecure_skip_verification(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "insecure_skip_verification")


@pulumi.output_type
class MethodSettingsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheDataEncrypted":
            suggest = "cache_data_encrypted"
        elif key == "cacheTtlInSeconds":
            suggest = "cache_ttl_in_seconds"
        elif key == "cachingEnabled":
            suggest = "caching_enabled"
        elif key == "dataTraceEnabled":
            suggest = "data_trace_enabled"
        elif key == "loggingLevel":
            suggest = "logging_level"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"
        elif key == "requireAuthorizationForCacheControl":
            suggest = "require_authorization_for_cache_control"
        elif key == "throttlingBurstLimit":
            suggest = "throttling_burst_limit"
        elif key == "throttlingRateLimit":
            suggest = "throttling_rate_limit"
        elif key == "unauthorizedCacheControlHeaderStrategy":
            suggest = "unauthorized_cache_control_header_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MethodSettingsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MethodSettingsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MethodSettingsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_data_encrypted: Optional[_builtins.bool] = None,
                 cache_ttl_in_seconds: Optional[_builtins.int] = None,
                 caching_enabled: Optional[_builtins.bool] = None,
                 data_trace_enabled: Optional[_builtins.bool] = None,
                 logging_level: Optional[_builtins.str] = None,
                 metrics_enabled: Optional[_builtins.bool] = None,
                 require_authorization_for_cache_control: Optional[_builtins.bool] = None,
                 throttling_burst_limit: Optional[_builtins.int] = None,
                 throttling_rate_limit: Optional[_builtins.float] = None,
                 unauthorized_cache_control_header_strategy: Optional[_builtins.str] = None):
        if cache_data_encrypted is not None:
            pulumi.set(__self__, "cache_data_encrypted", cache_data_encrypted)
        if cache_ttl_in_seconds is not None:
            pulumi.set(__self__, "cache_ttl_in_seconds", cache_ttl_in_seconds)
        if caching_enabled is not None:
            pulumi.set(__self__, "caching_enabled", caching_enabled)
        if data_trace_enabled is not None:
            pulumi.set(__self__, "data_trace_enabled", data_trace_enabled)
        if logging_level is not None:
            pulumi.set(__self__, "logging_level", logging_level)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if require_authorization_for_cache_control is not None:
            pulumi.set(__self__, "require_authorization_for_cache_control", require_authorization_for_cache_control)
        if throttling_burst_limit is not None:
            pulumi.set(__self__, "throttling_burst_limit", throttling_burst_limit)
        if throttling_rate_limit is not None:
            pulumi.set(__self__, "throttling_rate_limit", throttling_rate_limit)
        if unauthorized_cache_control_header_strategy is not None:
            pulumi.set(__self__, "unauthorized_cache_control_header_strategy", unauthorized_cache_control_header_strategy)

    @_builtins.property
    @pulumi.getter(name="cacheDataEncrypted")
    def cache_data_encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cache_data_encrypted")

    @_builtins.property
    @pulumi.getter(name="cacheTtlInSeconds")
    def cache_ttl_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cache_ttl_in_seconds")

    @_builtins.property
    @pulumi.getter(name="cachingEnabled")
    def caching_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "caching_enabled")

    @_builtins.property
    @pulumi.getter(name="dataTraceEnabled")
    def data_trace_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "data_trace_enabled")

    @_builtins.property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "logging_level")

    @_builtins.property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "metrics_enabled")

    @_builtins.property
    @pulumi.getter(name="requireAuthorizationForCacheControl")
    def require_authorization_for_cache_control(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_authorization_for_cache_control")

    @_builtins.property
    @pulumi.getter(name="throttlingBurstLimit")
    def throttling_burst_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throttling_burst_limit")

    @_builtins.property
    @pulumi.getter(name="throttlingRateLimit")
    def throttling_rate_limit(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "throttling_rate_limit")

    @_builtins.property
    @pulumi.getter(name="unauthorizedCacheControlHeaderStrategy")
    def unauthorized_cache_control_header_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unauthorized_cache_control_header_strategy")


@pulumi.output_type
class RestApiEndpointConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "vpcEndpointIds":
            suggest = "vpc_endpoint_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RestApiEndpointConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RestApiEndpointConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RestApiEndpointConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 types: _builtins.str,
                 ip_address_type: Optional[_builtins.str] = None,
                 vpc_endpoint_ids: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "types", types)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if vpc_endpoint_ids is not None:
            pulumi.set(__self__, "vpc_endpoint_ids", vpc_endpoint_ids)

    @_builtins.property
    @pulumi.getter
    def types(self) -> _builtins.str:
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointIds")
    def vpc_endpoint_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "vpc_endpoint_ids")


@pulumi.output_type
class RestApiPutTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class StageAccessLogSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAccessLogSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAccessLogSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAccessLogSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_arn: _builtins.str,
                 format: _builtins.str):
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> _builtins.str:
        return pulumi.get(self, "destination_arn")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        return pulumi.get(self, "format")


@pulumi.output_type
class StageCanarySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"
        elif key == "percentTraffic":
            suggest = "percent_traffic"
        elif key == "stageVariableOverrides":
            suggest = "stage_variable_overrides"
        elif key == "useStageCache":
            suggest = "use_stage_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageCanarySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageCanarySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageCanarySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: _builtins.str,
                 percent_traffic: Optional[_builtins.float] = None,
                 stage_variable_overrides: Optional[Mapping[str, _builtins.str]] = None,
                 use_stage_cache: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "deployment_id", deployment_id)
        if percent_traffic is not None:
            pulumi.set(__self__, "percent_traffic", percent_traffic)
        if stage_variable_overrides is not None:
            pulumi.set(__self__, "stage_variable_overrides", stage_variable_overrides)
        if use_stage_cache is not None:
            pulumi.set(__self__, "use_stage_cache", use_stage_cache)

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> _builtins.str:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter(name="percentTraffic")
    def percent_traffic(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "percent_traffic")

    @_builtins.property
    @pulumi.getter(name="stageVariableOverrides")
    def stage_variable_overrides(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "stage_variable_overrides")

    @_builtins.property
    @pulumi.getter(name="useStageCache")
    def use_stage_cache(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_stage_cache")


@pulumi.output_type
class UsagePlanApiStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiId":
            suggest = "api_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsagePlanApiStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsagePlanApiStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsagePlanApiStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_id: _builtins.str,
                 stage: _builtins.str,
                 throttles: Optional[Sequence['outputs.UsagePlanApiStageThrottle']] = None):
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "stage", stage)
        if throttles is not None:
            pulumi.set(__self__, "throttles", throttles)

    @_builtins.property
    @pulumi.getter(name="apiId")
    def api_id(self) -> _builtins.str:
        return pulumi.get(self, "api_id")

    @_builtins.property
    @pulumi.getter
    def stage(self) -> _builtins.str:
        return pulumi.get(self, "stage")

    @_builtins.property
    @pulumi.getter
    def throttles(self) -> Optional[Sequence['outputs.UsagePlanApiStageThrottle']]:
        return pulumi.get(self, "throttles")


@pulumi.output_type
class UsagePlanApiStageThrottle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burstLimit":
            suggest = "burst_limit"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsagePlanApiStageThrottle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsagePlanApiStageThrottle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsagePlanApiStageThrottle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 burst_limit: Optional[_builtins.int] = None,
                 rate_limit: Optional[_builtins.float] = None):
        pulumi.set(__self__, "path", path)
        if burst_limit is not None:
            pulumi.set(__self__, "burst_limit", burst_limit)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "burst_limit")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class UsagePlanQuotaSettings(dict):
    def __init__(__self__, *,
                 limit: _builtins.int,
                 period: _builtins.str,
                 offset: Optional[_builtins.int] = None):
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "period", period)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.str:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "offset")


@pulumi.output_type
class UsagePlanThrottleSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burstLimit":
            suggest = "burst_limit"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsagePlanThrottleSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsagePlanThrottleSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsagePlanThrottleSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burst_limit: Optional[_builtins.int] = None,
                 rate_limit: Optional[_builtins.float] = None):
        if burst_limit is not None:
            pulumi.set(__self__, "burst_limit", burst_limit)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="burstLimit")
    def burst_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "burst_limit")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class GetApiKeysItemResult(dict):
    def __init__(__self__, *,
                 created_date: _builtins.str,
                 customer_id: _builtins.str,
                 description: _builtins.str,
                 enabled: _builtins.bool,
                 id: _builtins.str,
                 last_updated_date: _builtins.str,
                 name: _builtins.str,
                 stage_keys: Sequence[_builtins.str],
                 tags: Mapping[str, _builtins.str],
                 value: _builtins.str):
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stage_keys", stage_keys)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> _builtins.str:
        return pulumi.get(self, "customer_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> _builtins.str:
        return pulumi.get(self, "last_updated_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stageKeys")
    def stage_keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "stage_keys")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDomainNameEndpointConfigurationResult(dict):
    def __init__(__self__, *,
                 ip_address_type: _builtins.str,
                 types: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_address_type", ip_address_type)
        pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> _builtins.str:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "types")


@pulumi.output_type
class GetRestApiEndpointConfigurationResult(dict):
    def __init__(__self__, *,
                 ip_address_type: _builtins.str,
                 types: Sequence[_builtins.str],
                 vpc_endpoint_ids: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_address_type", ip_address_type)
        pulumi.set(__self__, "types", types)
        pulumi.set(__self__, "vpc_endpoint_ids", vpc_endpoint_ids)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> _builtins.str:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointIds")
    def vpc_endpoint_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_ids")


