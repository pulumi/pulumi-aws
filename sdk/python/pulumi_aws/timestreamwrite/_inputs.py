# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'TableMagneticStoreWritePropertiesArgs',
    'TableMagneticStoreWritePropertiesArgsDict',
    'TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs',
    'TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgsDict',
    'TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs',
    'TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgsDict',
    'TableRetentionPropertiesArgs',
    'TableRetentionPropertiesArgsDict',
    'TableSchemaArgs',
    'TableSchemaArgsDict',
    'TableSchemaCompositePartitionKeyArgs',
    'TableSchemaCompositePartitionKeyArgsDict',
]

MYPY = False

if not MYPY:
    class TableMagneticStoreWritePropertiesArgsDict(TypedDict):
        enable_magnetic_store_writes: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable magnetic store writes.
        """
        magnetic_store_rejected_data_location: NotRequired[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgsDict']]
        """
        The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
        """
elif False:
    TableMagneticStoreWritePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableMagneticStoreWritePropertiesArgs:
    def __init__(__self__, *,
                 enable_magnetic_store_writes: Optional[pulumi.Input[bool]] = None,
                 magnetic_store_rejected_data_location: Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs']] = None):
        """
        :param pulumi.Input[bool] enable_magnetic_store_writes: A flag to enable magnetic store writes.
        :param pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs'] magnetic_store_rejected_data_location: The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
        """
        if enable_magnetic_store_writes is not None:
            pulumi.set(__self__, "enable_magnetic_store_writes", enable_magnetic_store_writes)
        if magnetic_store_rejected_data_location is not None:
            pulumi.set(__self__, "magnetic_store_rejected_data_location", magnetic_store_rejected_data_location)

    @property
    @pulumi.getter(name="enableMagneticStoreWrites")
    def enable_magnetic_store_writes(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable magnetic store writes.
        """
        return pulumi.get(self, "enable_magnetic_store_writes")

    @enable_magnetic_store_writes.setter
    def enable_magnetic_store_writes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_magnetic_store_writes", value)

    @property
    @pulumi.getter(name="magneticStoreRejectedDataLocation")
    def magnetic_store_rejected_data_location(self) -> Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs']]:
        """
        The location to write error reports for records rejected asynchronously during magnetic store writes. See Magnetic Store Rejected Data Location below for more details.
        """
        return pulumi.get(self, "magnetic_store_rejected_data_location")

    @magnetic_store_rejected_data_location.setter
    def magnetic_store_rejected_data_location(self, value: Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs']]):
        pulumi.set(self, "magnetic_store_rejected_data_location", value)


if not MYPY:
    class TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgsDict(TypedDict):
        s3_configuration: NotRequired[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgsDict']]
        """
        Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
        """
elif False:
    TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs:
    def __init__(__self__, *,
                 s3_configuration: Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs']] = None):
        """
        :param pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs'] s3_configuration: Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
        """
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs']]:
        """
        Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes. See S3 Configuration below for more details.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)


if not MYPY:
    class TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        Bucket name of the customer S3 bucket.
        """
        encryption_option: NotRequired[pulumi.Input[str]]
        """
        Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        KMS key arn for the customer s3 location when encrypting with a KMS managed key.
        """
        object_key_prefix: NotRequired[pulumi.Input[str]]
        """
        Object key prefix for the customer S3 location.
        """
elif False:
    TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 encryption_option: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 object_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Bucket name of the customer S3 bucket.
        :param pulumi.Input[str] encryption_option: Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
        :param pulumi.Input[str] kms_key_id: KMS key arn for the customer s3 location when encrypting with a KMS managed key.
        :param pulumi.Input[str] object_key_prefix: Object key prefix for the customer S3 location.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Bucket name of the customer S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[pulumi.Input[str]]:
        """
        Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
        """
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_option", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        KMS key arn for the customer s3 location when encrypting with a KMS managed key.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix for the customer S3 location.
        """
        return pulumi.get(self, "object_key_prefix")

    @object_key_prefix.setter
    def object_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key_prefix", value)


if not MYPY:
    class TableRetentionPropertiesArgsDict(TypedDict):
        magnetic_store_retention_period_in_days: pulumi.Input[int]
        """
        The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
        """
        memory_store_retention_period_in_hours: pulumi.Input[int]
        """
        The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
        """
elif False:
    TableRetentionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableRetentionPropertiesArgs:
    def __init__(__self__, *,
                 magnetic_store_retention_period_in_days: pulumi.Input[int],
                 memory_store_retention_period_in_hours: pulumi.Input[int]):
        """
        :param pulumi.Input[int] magnetic_store_retention_period_in_days: The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
        :param pulumi.Input[int] memory_store_retention_period_in_hours: The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
        """
        pulumi.set(__self__, "magnetic_store_retention_period_in_days", magnetic_store_retention_period_in_days)
        pulumi.set(__self__, "memory_store_retention_period_in_hours", memory_store_retention_period_in_hours)

    @property
    @pulumi.getter(name="magneticStoreRetentionPeriodInDays")
    def magnetic_store_retention_period_in_days(self) -> pulumi.Input[int]:
        """
        The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
        """
        return pulumi.get(self, "magnetic_store_retention_period_in_days")

    @magnetic_store_retention_period_in_days.setter
    def magnetic_store_retention_period_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "magnetic_store_retention_period_in_days", value)

    @property
    @pulumi.getter(name="memoryStoreRetentionPeriodInHours")
    def memory_store_retention_period_in_hours(self) -> pulumi.Input[int]:
        """
        The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
        """
        return pulumi.get(self, "memory_store_retention_period_in_hours")

    @memory_store_retention_period_in_hours.setter
    def memory_store_retention_period_in_hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory_store_retention_period_in_hours", value)


if not MYPY:
    class TableSchemaArgsDict(TypedDict):
        composite_partition_key: NotRequired[pulumi.Input['TableSchemaCompositePartitionKeyArgsDict']]
        """
        A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed. See Composite Partition Key below for more details.
        """
elif False:
    TableSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableSchemaArgs:
    def __init__(__self__, *,
                 composite_partition_key: Optional[pulumi.Input['TableSchemaCompositePartitionKeyArgs']] = None):
        """
        :param pulumi.Input['TableSchemaCompositePartitionKeyArgs'] composite_partition_key: A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed. See Composite Partition Key below for more details.
        """
        if composite_partition_key is not None:
            pulumi.set(__self__, "composite_partition_key", composite_partition_key)

    @property
    @pulumi.getter(name="compositePartitionKey")
    def composite_partition_key(self) -> Optional[pulumi.Input['TableSchemaCompositePartitionKeyArgs']]:
        """
        A non-empty list of partition keys defining the attributes used to partition the table data. The order of the list determines the partition hierarchy. The name and type of each partition key as well as the partition key order cannot be changed after the table is created. However, the enforcement level of each partition key can be changed. See Composite Partition Key below for more details.
        """
        return pulumi.get(self, "composite_partition_key")

    @composite_partition_key.setter
    def composite_partition_key(self, value: Optional[pulumi.Input['TableSchemaCompositePartitionKeyArgs']]):
        pulumi.set(self, "composite_partition_key", value)


if not MYPY:
    class TableSchemaCompositePartitionKeyArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of the partition key. Valid values: `DIMENSION`, `MEASURE`.
        """
        enforcement_in_record: NotRequired[pulumi.Input[str]]
        """
        The level of enforcement for the specification of a dimension key in ingested records. Valid values: `REQUIRED`, `OPTIONAL`.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute used for a dimension key.
        """
elif False:
    TableSchemaCompositePartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableSchemaCompositePartitionKeyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 enforcement_in_record: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of the partition key. Valid values: `DIMENSION`, `MEASURE`.
        :param pulumi.Input[str] enforcement_in_record: The level of enforcement for the specification of a dimension key in ingested records. Valid values: `REQUIRED`, `OPTIONAL`.
        :param pulumi.Input[str] name: The name of the attribute used for a dimension key.
        """
        pulumi.set(__self__, "type", type)
        if enforcement_in_record is not None:
            pulumi.set(__self__, "enforcement_in_record", enforcement_in_record)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the partition key. Valid values: `DIMENSION`, `MEASURE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="enforcementInRecord")
    def enforcement_in_record(self) -> Optional[pulumi.Input[str]]:
        """
        The level of enforcement for the specification of a dimension key in ingested records. Valid values: `REQUIRED`, `OPTIONAL`.
        """
        return pulumi.get(self, "enforcement_in_record")

    @enforcement_in_record.setter
    def enforcement_in_record(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enforcement_in_record", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute used for a dimension key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


