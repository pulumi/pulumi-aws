# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CachePolicyParametersInCacheKeyAndForwardedToOriginArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgsDict',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgs',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgsDict',
    'ConnectionFunctionConnectionFunctionConfigArgs',
    'ConnectionFunctionConnectionFunctionConfigArgsDict',
    'ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgs',
    'ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgsDict',
    'ConnectionGroupTimeoutsArgs',
    'ConnectionGroupTimeoutsArgsDict',
    'ContinuousDeploymentPolicyStagingDistributionDnsNamesArgs',
    'ContinuousDeploymentPolicyStagingDistributionDnsNamesArgsDict',
    'ContinuousDeploymentPolicyTrafficConfigArgs',
    'ContinuousDeploymentPolicyTrafficConfigArgsDict',
    'ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgs',
    'ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgsDict',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgs',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgsDict',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgs',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgsDict',
    'DistributionConnectionFunctionAssociationArgs',
    'DistributionConnectionFunctionAssociationArgsDict',
    'DistributionCustomErrorResponseArgs',
    'DistributionCustomErrorResponseArgsDict',
    'DistributionDefaultCacheBehaviorArgs',
    'DistributionDefaultCacheBehaviorArgsDict',
    'DistributionDefaultCacheBehaviorForwardedValuesArgs',
    'DistributionDefaultCacheBehaviorForwardedValuesArgsDict',
    'DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs',
    'DistributionDefaultCacheBehaviorForwardedValuesCookiesArgsDict',
    'DistributionDefaultCacheBehaviorFunctionAssociationArgs',
    'DistributionDefaultCacheBehaviorFunctionAssociationArgsDict',
    'DistributionDefaultCacheBehaviorGrpcConfigArgs',
    'DistributionDefaultCacheBehaviorGrpcConfigArgsDict',
    'DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs',
    'DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict',
    'DistributionLoggingConfigArgs',
    'DistributionLoggingConfigArgsDict',
    'DistributionOrderedCacheBehaviorArgs',
    'DistributionOrderedCacheBehaviorArgsDict',
    'DistributionOrderedCacheBehaviorForwardedValuesArgs',
    'DistributionOrderedCacheBehaviorForwardedValuesArgsDict',
    'DistributionOrderedCacheBehaviorForwardedValuesCookiesArgs',
    'DistributionOrderedCacheBehaviorForwardedValuesCookiesArgsDict',
    'DistributionOrderedCacheBehaviorFunctionAssociationArgs',
    'DistributionOrderedCacheBehaviorFunctionAssociationArgsDict',
    'DistributionOrderedCacheBehaviorGrpcConfigArgs',
    'DistributionOrderedCacheBehaviorGrpcConfigArgsDict',
    'DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgs',
    'DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgsDict',
    'DistributionOriginArgs',
    'DistributionOriginArgsDict',
    'DistributionOriginCustomHeaderArgs',
    'DistributionOriginCustomHeaderArgsDict',
    'DistributionOriginCustomOriginConfigArgs',
    'DistributionOriginCustomOriginConfigArgsDict',
    'DistributionOriginGroupArgs',
    'DistributionOriginGroupArgsDict',
    'DistributionOriginGroupFailoverCriteriaArgs',
    'DistributionOriginGroupFailoverCriteriaArgsDict',
    'DistributionOriginGroupMemberArgs',
    'DistributionOriginGroupMemberArgsDict',
    'DistributionOriginOriginShieldArgs',
    'DistributionOriginOriginShieldArgsDict',
    'DistributionOriginS3OriginConfigArgs',
    'DistributionOriginS3OriginConfigArgsDict',
    'DistributionOriginVpcOriginConfigArgs',
    'DistributionOriginVpcOriginConfigArgsDict',
    'DistributionRestrictionsArgs',
    'DistributionRestrictionsArgsDict',
    'DistributionRestrictionsGeoRestrictionArgs',
    'DistributionRestrictionsGeoRestrictionArgsDict',
    'DistributionTenantCustomizationsArgs',
    'DistributionTenantCustomizationsArgsDict',
    'DistributionTenantCustomizationsCertificateArgs',
    'DistributionTenantCustomizationsCertificateArgsDict',
    'DistributionTenantCustomizationsGeoRestrictionArgs',
    'DistributionTenantCustomizationsGeoRestrictionArgsDict',
    'DistributionTenantCustomizationsWebAclArgs',
    'DistributionTenantCustomizationsWebAclArgsDict',
    'DistributionTenantDomainArgs',
    'DistributionTenantDomainArgsDict',
    'DistributionTenantManagedCertificateRequestArgs',
    'DistributionTenantManagedCertificateRequestArgsDict',
    'DistributionTenantParameterArgs',
    'DistributionTenantParameterArgsDict',
    'DistributionTenantTimeoutsArgs',
    'DistributionTenantTimeoutsArgsDict',
    'DistributionTrustedKeyGroupArgs',
    'DistributionTrustedKeyGroupArgsDict',
    'DistributionTrustedKeyGroupItemArgs',
    'DistributionTrustedKeyGroupItemArgsDict',
    'DistributionTrustedSignerArgs',
    'DistributionTrustedSignerArgsDict',
    'DistributionTrustedSignerItemArgs',
    'DistributionTrustedSignerItemArgsDict',
    'DistributionViewerCertificateArgs',
    'DistributionViewerCertificateArgsDict',
    'DistributionViewerMtlsConfigArgs',
    'DistributionViewerMtlsConfigArgsDict',
    'DistributionViewerMtlsConfigTrustStoreConfigArgs',
    'DistributionViewerMtlsConfigTrustStoreConfigArgsDict',
    'FieldLevelEncryptionConfigContentTypeProfileConfigArgs',
    'FieldLevelEncryptionConfigContentTypeProfileConfigArgsDict',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgs',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgsDict',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgs',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgsDict',
    'FieldLevelEncryptionConfigQueryArgProfileConfigArgs',
    'FieldLevelEncryptionConfigQueryArgProfileConfigArgsDict',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgs',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgsDict',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgs',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgsDict',
    'FieldLevelEncryptionProfileEncryptionEntitiesArgs',
    'FieldLevelEncryptionProfileEncryptionEntitiesArgsDict',
    'FieldLevelEncryptionProfileEncryptionEntitiesItemArgs',
    'FieldLevelEncryptionProfileEncryptionEntitiesItemArgsDict',
    'FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgs',
    'FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgsDict',
    'KeyValueStoreTimeoutsArgs',
    'KeyValueStoreTimeoutsArgsDict',
    'KeyvaluestoreKeysExclusiveResourceKeyValuePairArgs',
    'KeyvaluestoreKeysExclusiveResourceKeyValuePairArgsDict',
    'MonitoringSubscriptionMonitoringSubscriptionArgs',
    'MonitoringSubscriptionMonitoringSubscriptionArgsDict',
    'MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs',
    'MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgsDict',
    'MultitenantDistributionActiveTrustedKeyGroupArgs',
    'MultitenantDistributionActiveTrustedKeyGroupArgsDict',
    'MultitenantDistributionActiveTrustedKeyGroupItemArgs',
    'MultitenantDistributionActiveTrustedKeyGroupItemArgsDict',
    'MultitenantDistributionCacheBehaviorArgs',
    'MultitenantDistributionCacheBehaviorArgsDict',
    'MultitenantDistributionCacheBehaviorAllowedMethodsArgs',
    'MultitenantDistributionCacheBehaviorAllowedMethodsArgsDict',
    'MultitenantDistributionCacheBehaviorFunctionAssociationArgs',
    'MultitenantDistributionCacheBehaviorFunctionAssociationArgsDict',
    'MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgs',
    'MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgsDict',
    'MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgs',
    'MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgsDict',
    'MultitenantDistributionCustomErrorResponseArgs',
    'MultitenantDistributionCustomErrorResponseArgsDict',
    'MultitenantDistributionDefaultCacheBehaviorArgs',
    'MultitenantDistributionDefaultCacheBehaviorArgsDict',
    'MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgs',
    'MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgsDict',
    'MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgs',
    'MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgsDict',
    'MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs',
    'MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict',
    'MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgs',
    'MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgsDict',
    'MultitenantDistributionOriginArgs',
    'MultitenantDistributionOriginArgsDict',
    'MultitenantDistributionOriginCustomHeaderArgs',
    'MultitenantDistributionOriginCustomHeaderArgsDict',
    'MultitenantDistributionOriginCustomOriginConfigArgs',
    'MultitenantDistributionOriginCustomOriginConfigArgsDict',
    'MultitenantDistributionOriginGroupArgs',
    'MultitenantDistributionOriginGroupArgsDict',
    'MultitenantDistributionOriginGroupFailoverCriteriaArgs',
    'MultitenantDistributionOriginGroupFailoverCriteriaArgsDict',
    'MultitenantDistributionOriginGroupMemberArgs',
    'MultitenantDistributionOriginGroupMemberArgsDict',
    'MultitenantDistributionOriginOriginShieldArgs',
    'MultitenantDistributionOriginOriginShieldArgsDict',
    'MultitenantDistributionOriginVpcOriginConfigArgs',
    'MultitenantDistributionOriginVpcOriginConfigArgsDict',
    'MultitenantDistributionRestrictionsArgs',
    'MultitenantDistributionRestrictionsArgsDict',
    'MultitenantDistributionRestrictionsGeoRestrictionArgs',
    'MultitenantDistributionRestrictionsGeoRestrictionArgsDict',
    'MultitenantDistributionTenantConfigArgs',
    'MultitenantDistributionTenantConfigArgsDict',
    'MultitenantDistributionTenantConfigParameterDefinitionArgs',
    'MultitenantDistributionTenantConfigParameterDefinitionArgsDict',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgs',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgsDict',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgs',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgsDict',
    'MultitenantDistributionTimeoutsArgs',
    'MultitenantDistributionTimeoutsArgsDict',
    'MultitenantDistributionViewerCertificateArgs',
    'MultitenantDistributionViewerCertificateArgsDict',
    'OriginRequestPolicyCookiesConfigArgs',
    'OriginRequestPolicyCookiesConfigArgsDict',
    'OriginRequestPolicyCookiesConfigCookiesArgs',
    'OriginRequestPolicyCookiesConfigCookiesArgsDict',
    'OriginRequestPolicyHeadersConfigArgs',
    'OriginRequestPolicyHeadersConfigArgsDict',
    'OriginRequestPolicyHeadersConfigHeadersArgs',
    'OriginRequestPolicyHeadersConfigHeadersArgsDict',
    'OriginRequestPolicyQueryStringsConfigArgs',
    'OriginRequestPolicyQueryStringsConfigArgsDict',
    'OriginRequestPolicyQueryStringsConfigQueryStringsArgs',
    'OriginRequestPolicyQueryStringsConfigQueryStringsArgsDict',
    'RealtimeLogConfigEndpointArgs',
    'RealtimeLogConfigEndpointArgsDict',
    'RealtimeLogConfigEndpointKinesisStreamConfigArgs',
    'RealtimeLogConfigEndpointKinesisStreamConfigArgsDict',
    'ResponseHeadersPolicyCorsConfigArgs',
    'ResponseHeadersPolicyCorsConfigArgsDict',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgs',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgsDict',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgs',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgsDict',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgs',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgsDict',
    'ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgs',
    'ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgsDict',
    'ResponseHeadersPolicyCustomHeadersConfigArgs',
    'ResponseHeadersPolicyCustomHeadersConfigArgsDict',
    'ResponseHeadersPolicyCustomHeadersConfigItemArgs',
    'ResponseHeadersPolicyCustomHeadersConfigItemArgsDict',
    'ResponseHeadersPolicyRemoveHeadersConfigArgs',
    'ResponseHeadersPolicyRemoveHeadersConfigArgsDict',
    'ResponseHeadersPolicyRemoveHeadersConfigItemArgs',
    'ResponseHeadersPolicyRemoveHeadersConfigItemArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigArgs',
    'ResponseHeadersPolicySecurityHeadersConfigArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgs',
    'ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgs',
    'ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgs',
    'ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgs',
    'ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgs',
    'ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgsDict',
    'ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgs',
    'ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgsDict',
    'ResponseHeadersPolicyServerTimingHeadersConfigArgs',
    'ResponseHeadersPolicyServerTimingHeadersConfigArgsDict',
    'TrustStoreCaCertificatesBundleSourceArgs',
    'TrustStoreCaCertificatesBundleSourceArgsDict',
    'TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgs',
    'TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgsDict',
    'TrustStoreTimeoutsArgs',
    'TrustStoreTimeoutsArgsDict',
    'VpcOriginTimeoutsArgs',
    'VpcOriginTimeoutsArgsDict',
    'VpcOriginVpcOriginEndpointConfigArgs',
    'VpcOriginVpcOriginEndpointConfigArgsDict',
    'VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgs',
    'VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgsDict',
]

MYPY = False

if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginArgsDict(TypedDict):
        cookies_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgsDict']
        headers_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgsDict']
        query_strings_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgsDict']
        enable_accept_encoding_brotli: NotRequired[pulumi.Input[_builtins.bool]]
        enable_accept_encoding_gzip: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginArgs:
    def __init__(__self__, *,
                 cookies_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgs'],
                 headers_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgs'],
                 query_strings_config: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgs'],
                 enable_accept_encoding_brotli: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_accept_encoding_gzip: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "cookies_config", cookies_config)
        pulumi.set(__self__, "headers_config", headers_config)
        pulumi.set(__self__, "query_strings_config", query_strings_config)
        if enable_accept_encoding_brotli is not None:
            pulumi.set(__self__, "enable_accept_encoding_brotli", enable_accept_encoding_brotli)
        if enable_accept_encoding_gzip is not None:
            pulumi.set(__self__, "enable_accept_encoding_gzip", enable_accept_encoding_gzip)

    @_builtins.property
    @pulumi.getter(name="cookiesConfig")
    def cookies_config(self) -> pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgs']:
        return pulumi.get(self, "cookies_config")

    @cookies_config.setter
    def cookies_config(self, value: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgs']):
        pulumi.set(self, "cookies_config", value)

    @_builtins.property
    @pulumi.getter(name="headersConfig")
    def headers_config(self) -> pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgs']:
        return pulumi.get(self, "headers_config")

    @headers_config.setter
    def headers_config(self, value: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgs']):
        pulumi.set(self, "headers_config", value)

    @_builtins.property
    @pulumi.getter(name="queryStringsConfig")
    def query_strings_config(self) -> pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgs']:
        return pulumi.get(self, "query_strings_config")

    @query_strings_config.setter
    def query_strings_config(self, value: pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgs']):
        pulumi.set(self, "query_strings_config", value)

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingBrotli")
    def enable_accept_encoding_brotli(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_accept_encoding_brotli")

    @enable_accept_encoding_brotli.setter
    def enable_accept_encoding_brotli(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_accept_encoding_brotli", value)

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingGzip")
    def enable_accept_encoding_gzip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_accept_encoding_gzip")

    @enable_accept_encoding_gzip.setter
    def enable_accept_encoding_gzip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_accept_encoding_gzip", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgsDict(TypedDict):
        cookie_behavior: pulumi.Input[_builtins.str]
        cookies: NotRequired[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgsDict']]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigArgs:
    def __init__(__self__, *,
                 cookie_behavior: pulumi.Input[_builtins.str],
                 cookies: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgs']] = None):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cookie_behavior")

    @cookie_behavior.setter
    def cookie_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cookie_behavior", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgs']]):
        pulumi.set(self, "cookies", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgsDict(TypedDict):
        header_behavior: NotRequired[pulumi.Input[_builtins.str]]
        headers: NotRequired[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgsDict']]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigArgs:
    def __init__(__self__, *,
                 header_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgs']] = None):
        if header_behavior is not None:
            pulumi.set(__self__, "header_behavior", header_behavior)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "header_behavior")

    @header_behavior.setter
    def header_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_behavior", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgs']]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgsDict(TypedDict):
        query_string_behavior: pulumi.Input[_builtins.str]
        query_strings: NotRequired[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgsDict']]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigArgs:
    def __init__(__self__, *,
                 query_string_behavior: pulumi.Input[_builtins.str],
                 query_strings: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgs']] = None):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "query_string_behavior")

    @query_string_behavior.setter
    def query_string_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query_string_behavior", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgs']]:
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input['CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgs']]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ConnectionFunctionConnectionFunctionConfigArgsDict(TypedDict):
        comment: pulumi.Input[_builtins.str]
        runtime: pulumi.Input[_builtins.str]
        key_value_store_association: NotRequired[pulumi.Input['ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgsDict']]
elif False:
    ConnectionFunctionConnectionFunctionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionFunctionConnectionFunctionConfigArgs:
    def __init__(__self__, *,
                 comment: pulumi.Input[_builtins.str],
                 runtime: pulumi.Input[_builtins.str],
                 key_value_store_association: Optional[pulumi.Input['ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgs']] = None):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "runtime", runtime)
        if key_value_store_association is not None:
            pulumi.set(__self__, "key_value_store_association", key_value_store_association)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runtime", value)

    @_builtins.property
    @pulumi.getter(name="keyValueStoreAssociation")
    def key_value_store_association(self) -> Optional[pulumi.Input['ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgs']]:
        return pulumi.get(self, "key_value_store_association")

    @key_value_store_association.setter
    def key_value_store_association(self, value: Optional[pulumi.Input['ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgs']]):
        pulumi.set(self, "key_value_store_association", value)


if not MYPY:
    class ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgsDict(TypedDict):
        key_value_store_arn: pulumi.Input[_builtins.str]
elif False:
    ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociationArgs:
    def __init__(__self__, *,
                 key_value_store_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key_value_store_arn", key_value_store_arn)

    @_builtins.property
    @pulumi.getter(name="keyValueStoreArn")
    def key_value_store_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_value_store_arn")

    @key_value_store_arn.setter
    def key_value_store_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_value_store_arn", value)


if not MYPY:
    class ConnectionGroupTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
elif False:
    ConnectionGroupTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionGroupTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ContinuousDeploymentPolicyStagingDistributionDnsNamesArgsDict(TypedDict):
        quantity: pulumi.Input[_builtins.int]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ContinuousDeploymentPolicyStagingDistributionDnsNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousDeploymentPolicyStagingDistributionDnsNamesArgs:
    def __init__(__self__, *,
                 quantity: pulumi.Input[_builtins.int],
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "quantity", quantity)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "quantity", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ContinuousDeploymentPolicyTrafficConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        single_header_config: NotRequired[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgsDict']]
        single_weight_config: NotRequired[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgsDict']]
elif False:
    ContinuousDeploymentPolicyTrafficConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousDeploymentPolicyTrafficConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 single_header_config: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgs']] = None,
                 single_weight_config: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgs']] = None):
        pulumi.set(__self__, "type", type)
        if single_header_config is not None:
            pulumi.set(__self__, "single_header_config", single_header_config)
        if single_weight_config is not None:
            pulumi.set(__self__, "single_weight_config", single_weight_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="singleHeaderConfig")
    def single_header_config(self) -> Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgs']]:
        return pulumi.get(self, "single_header_config")

    @single_header_config.setter
    def single_header_config(self, value: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgs']]):
        pulumi.set(self, "single_header_config", value)

    @_builtins.property
    @pulumi.getter(name="singleWeightConfig")
    def single_weight_config(self) -> Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgs']]:
        return pulumi.get(self, "single_weight_config")

    @single_weight_config.setter
    def single_weight_config(self, value: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgs']]):
        pulumi.set(self, "single_weight_config", value)


if not MYPY:
    class ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgsDict(TypedDict):
        header: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfigArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgsDict(TypedDict):
        weight: pulumi.Input[_builtins.float]
        session_stickiness_config: NotRequired[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgsDict']]
elif False:
    ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigArgs:
    def __init__(__self__, *,
                 weight: pulumi.Input[_builtins.float],
                 session_stickiness_config: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgs']] = None):
        pulumi.set(__self__, "weight", weight)
        if session_stickiness_config is not None:
            pulumi.set(__self__, "session_stickiness_config", session_stickiness_config)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "weight", value)

    @_builtins.property
    @pulumi.getter(name="sessionStickinessConfig")
    def session_stickiness_config(self) -> Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgs']]:
        return pulumi.get(self, "session_stickiness_config")

    @session_stickiness_config.setter
    def session_stickiness_config(self, value: Optional[pulumi.Input['ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgs']]):
        pulumi.set(self, "session_stickiness_config", value)


if not MYPY:
    class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgsDict(TypedDict):
        idle_ttl: pulumi.Input[_builtins.int]
        maximum_ttl: pulumi.Input[_builtins.int]
elif False:
    ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfigArgs:
    def __init__(__self__, *,
                 idle_ttl: pulumi.Input[_builtins.int],
                 maximum_ttl: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "idle_ttl", idle_ttl)
        pulumi.set(__self__, "maximum_ttl", maximum_ttl)

    @_builtins.property
    @pulumi.getter(name="idleTtl")
    def idle_ttl(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "idle_ttl")

    @idle_ttl.setter
    def idle_ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "idle_ttl", value)

    @_builtins.property
    @pulumi.getter(name="maximumTtl")
    def maximum_ttl(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_ttl")

    @maximum_ttl.setter
    def maximum_ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_ttl", value)


if not MYPY:
    class DistributionConnectionFunctionAssociationArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
elif False:
    DistributionConnectionFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionConnectionFunctionAssociationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DistributionCustomErrorResponseArgsDict(TypedDict):
        error_code: pulumi.Input[_builtins.int]
        error_caching_min_ttl: NotRequired[pulumi.Input[_builtins.int]]
        response_code: NotRequired[pulumi.Input[_builtins.int]]
        response_page_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionCustomErrorResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionCustomErrorResponseArgs:
    def __init__(__self__, *,
                 error_code: pulumi.Input[_builtins.int],
                 error_caching_min_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 response_code: Optional[pulumi.Input[_builtins.int]] = None,
                 response_page_path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "error_code", error_code)
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorCachingMinTtl")
    def error_caching_min_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "error_caching_min_ttl")

    @error_caching_min_ttl.setter
    def error_caching_min_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "error_caching_min_ttl", value)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_page_path")

    @response_page_path.setter
    def response_page_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_page_path", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        target_origin_id: pulumi.Input[_builtins.str]
        viewer_protocol_policy: pulumi.Input[_builtins.str]
        cache_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        compress: NotRequired[pulumi.Input[_builtins.bool]]
        default_ttl: NotRequired[pulumi.Input[_builtins.int]]
        field_level_encryption_id: NotRequired[pulumi.Input[_builtins.str]]
        forwarded_values: NotRequired[pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesArgsDict']]
        function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorFunctionAssociationArgsDict']]]]
        grpc_config: NotRequired[pulumi.Input['DistributionDefaultCacheBehaviorGrpcConfigArgsDict']]
        lambda_function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict']]]]
        max_ttl: NotRequired[pulumi.Input[_builtins.int]]
        min_ttl: NotRequired[pulumi.Input[_builtins.int]]
        origin_request_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        realtime_log_config_arn: NotRequired[pulumi.Input[_builtins.str]]
        response_headers_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        smooth_streaming: NotRequired[pulumi.Input[_builtins.bool]]
        trusted_key_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        trusted_signers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionDefaultCacheBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 target_origin_id: pulumi.Input[_builtins.str],
                 viewer_protocol_policy: pulumi.Input[_builtins.str],
                 cache_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compress: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 field_level_encryption_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forwarded_values: Optional[pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesArgs']] = None,
                 function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorFunctionAssociationArgs']]]] = None,
                 grpc_config: Optional[pulumi.Input['DistributionDefaultCacheBehaviorGrpcConfigArgs']] = None,
                 lambda_function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 min_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_request_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 realtime_log_config_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 smooth_streaming: Optional[pulumi.Input[_builtins.bool]] = None,
                 trusted_key_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 trusted_signers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if grpc_config is not None:
            pulumi.set(__self__, "grpc_config", grpc_config)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "cached_methods")

    @cached_methods.setter
    def cached_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "cached_methods", value)

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_origin_id")

    @target_origin_id.setter
    def target_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "viewer_protocol_policy")

    @viewer_protocol_policy.setter
    def viewer_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "viewer_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_policy_id")

    @cache_policy_id.setter
    def cache_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_policy_id", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_level_encryption_id")

    @field_level_encryption_id.setter
    def field_level_encryption_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_level_encryption_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional[pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesArgs']]:
        return pulumi.get(self, "forwarded_values")

    @forwarded_values.setter
    def forwarded_values(self, value: Optional[pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesArgs']]):
        pulumi.set(self, "forwarded_values", value)

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorFunctionAssociationArgs']]]]:
        return pulumi.get(self, "function_associations")

    @function_associations.setter
    def function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorFunctionAssociationArgs']]]]):
        pulumi.set(self, "function_associations", value)

    @_builtins.property
    @pulumi.getter(name="grpcConfig")
    def grpc_config(self) -> Optional[pulumi.Input['DistributionDefaultCacheBehaviorGrpcConfigArgs']]:
        return pulumi.get(self, "grpc_config")

    @grpc_config.setter
    def grpc_config(self, value: Optional[pulumi.Input['DistributionDefaultCacheBehaviorGrpcConfigArgs']]):
        pulumi.set(self, "grpc_config", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]]:
        return pulumi.get(self, "lambda_function_associations")

    @lambda_function_associations.setter
    def lambda_function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]]):
        pulumi.set(self, "lambda_function_associations", value)

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_ttl")

    @max_ttl.setter
    def max_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ttl", value)

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_ttl")

    @min_ttl.setter
    def min_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_ttl", value)

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_request_policy_id")

    @origin_request_policy_id.setter
    def origin_request_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_request_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "realtime_log_config_arn")

    @realtime_log_config_arn.setter
    def realtime_log_config_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realtime_log_config_arn", value)

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_headers_policy_id")

    @response_headers_policy_id.setter
    def response_headers_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_headers_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "smooth_streaming")

    @smooth_streaming.setter
    def smooth_streaming(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "smooth_streaming", value)

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "trusted_key_groups")

    @trusted_key_groups.setter
    def trusted_key_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trusted_key_groups", value)

    @_builtins.property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "trusted_signers")

    @trusted_signers.setter
    def trusted_signers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trusted_signers", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorForwardedValuesArgsDict(TypedDict):
        cookies: pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesCookiesArgsDict']
        query_string: pulumi.Input[_builtins.bool]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        query_string_cache_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionDefaultCacheBehaviorForwardedValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorForwardedValuesArgs:
    def __init__(__self__, *,
                 cookies: pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs'],
                 query_string: pulumi.Input[_builtins.bool],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 query_string_cache_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs']:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: pulumi.Input['DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs']):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "query_string_cache_keys")

    @query_string_cache_keys.setter
    def query_string_cache_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_string_cache_keys", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorForwardedValuesCookiesArgsDict(TypedDict):
        forward: pulumi.Input[_builtins.str]
        whitelisted_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionDefaultCacheBehaviorForwardedValuesCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorForwardedValuesCookiesArgs:
    def __init__(__self__, *,
                 forward: pulumi.Input[_builtins.str],
                 whitelisted_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "whitelisted_names")

    @whitelisted_names.setter
    def whitelisted_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "whitelisted_names", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        function_arn: pulumi.Input[_builtins.str]
elif False:
    DistributionDefaultCacheBehaviorFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorGrpcConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DistributionDefaultCacheBehaviorGrpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorGrpcConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        lambda_arn: pulumi.Input[_builtins.str]
        include_body: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 lambda_arn: pulumi.Input[_builtins.str],
                 include_body: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_body")

    @include_body.setter
    def include_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_body", value)


if not MYPY:
    class DistributionLoggingConfigArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        include_cookies: NotRequired[pulumi.Input[_builtins.bool]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionLoggingConfigArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 include_cookies: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if include_cookies is not None:
            pulumi.set(__self__, "include_cookies", include_cookies)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="includeCookies")
    def include_cookies(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_cookies")

    @include_cookies.setter
    def include_cookies(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_cookies", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        path_pattern: pulumi.Input[_builtins.str]
        target_origin_id: pulumi.Input[_builtins.str]
        viewer_protocol_policy: pulumi.Input[_builtins.str]
        cache_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        compress: NotRequired[pulumi.Input[_builtins.bool]]
        default_ttl: NotRequired[pulumi.Input[_builtins.int]]
        field_level_encryption_id: NotRequired[pulumi.Input[_builtins.str]]
        forwarded_values: NotRequired[pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesArgsDict']]
        function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorFunctionAssociationArgsDict']]]]
        grpc_config: NotRequired[pulumi.Input['DistributionOrderedCacheBehaviorGrpcConfigArgsDict']]
        lambda_function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgsDict']]]]
        max_ttl: NotRequired[pulumi.Input[_builtins.int]]
        min_ttl: NotRequired[pulumi.Input[_builtins.int]]
        origin_request_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        realtime_log_config_arn: NotRequired[pulumi.Input[_builtins.str]]
        response_headers_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        smooth_streaming: NotRequired[pulumi.Input[_builtins.bool]]
        trusted_key_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        trusted_signers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionOrderedCacheBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 path_pattern: pulumi.Input[_builtins.str],
                 target_origin_id: pulumi.Input[_builtins.str],
                 viewer_protocol_policy: pulumi.Input[_builtins.str],
                 cache_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compress: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 field_level_encryption_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forwarded_values: Optional[pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesArgs']] = None,
                 function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorFunctionAssociationArgs']]]] = None,
                 grpc_config: Optional[pulumi.Input['DistributionOrderedCacheBehaviorGrpcConfigArgs']] = None,
                 lambda_function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgs']]]] = None,
                 max_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 min_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_request_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 realtime_log_config_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 smooth_streaming: Optional[pulumi.Input[_builtins.bool]] = None,
                 trusted_key_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 trusted_signers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "path_pattern", path_pattern)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if grpc_config is not None:
            pulumi.set(__self__, "grpc_config", grpc_config)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "cached_methods")

    @cached_methods.setter
    def cached_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "cached_methods", value)

    @_builtins.property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path_pattern")

    @path_pattern.setter
    def path_pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_pattern", value)

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_origin_id")

    @target_origin_id.setter
    def target_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "viewer_protocol_policy")

    @viewer_protocol_policy.setter
    def viewer_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "viewer_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_policy_id")

    @cache_policy_id.setter
    def cache_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_policy_id", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_level_encryption_id")

    @field_level_encryption_id.setter
    def field_level_encryption_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_level_encryption_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional[pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesArgs']]:
        return pulumi.get(self, "forwarded_values")

    @forwarded_values.setter
    def forwarded_values(self, value: Optional[pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesArgs']]):
        pulumi.set(self, "forwarded_values", value)

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorFunctionAssociationArgs']]]]:
        return pulumi.get(self, "function_associations")

    @function_associations.setter
    def function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorFunctionAssociationArgs']]]]):
        pulumi.set(self, "function_associations", value)

    @_builtins.property
    @pulumi.getter(name="grpcConfig")
    def grpc_config(self) -> Optional[pulumi.Input['DistributionOrderedCacheBehaviorGrpcConfigArgs']]:
        return pulumi.get(self, "grpc_config")

    @grpc_config.setter
    def grpc_config(self, value: Optional[pulumi.Input['DistributionOrderedCacheBehaviorGrpcConfigArgs']]):
        pulumi.set(self, "grpc_config", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgs']]]]:
        return pulumi.get(self, "lambda_function_associations")

    @lambda_function_associations.setter
    def lambda_function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgs']]]]):
        pulumi.set(self, "lambda_function_associations", value)

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_ttl")

    @max_ttl.setter
    def max_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_ttl", value)

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_ttl")

    @min_ttl.setter
    def min_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_ttl", value)

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_request_policy_id")

    @origin_request_policy_id.setter
    def origin_request_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_request_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "realtime_log_config_arn")

    @realtime_log_config_arn.setter
    def realtime_log_config_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realtime_log_config_arn", value)

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_headers_policy_id")

    @response_headers_policy_id.setter
    def response_headers_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_headers_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "smooth_streaming")

    @smooth_streaming.setter
    def smooth_streaming(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "smooth_streaming", value)

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "trusted_key_groups")

    @trusted_key_groups.setter
    def trusted_key_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trusted_key_groups", value)

    @_builtins.property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "trusted_signers")

    @trusted_signers.setter
    def trusted_signers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trusted_signers", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorForwardedValuesArgsDict(TypedDict):
        cookies: pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesCookiesArgsDict']
        query_string: pulumi.Input[_builtins.bool]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        query_string_cache_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionOrderedCacheBehaviorForwardedValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorForwardedValuesArgs:
    def __init__(__self__, *,
                 cookies: pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesCookiesArgs'],
                 query_string: pulumi.Input[_builtins.bool],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 query_string_cache_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesCookiesArgs']:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: pulumi.Input['DistributionOrderedCacheBehaviorForwardedValuesCookiesArgs']):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "query_string_cache_keys")

    @query_string_cache_keys.setter
    def query_string_cache_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_string_cache_keys", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorForwardedValuesCookiesArgsDict(TypedDict):
        forward: pulumi.Input[_builtins.str]
        whitelisted_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionOrderedCacheBehaviorForwardedValuesCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorForwardedValuesCookiesArgs:
    def __init__(__self__, *,
                 forward: pulumi.Input[_builtins.str],
                 whitelisted_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "forward", value)

    @_builtins.property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "whitelisted_names")

    @whitelisted_names.setter
    def whitelisted_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "whitelisted_names", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        function_arn: pulumi.Input[_builtins.str]
elif False:
    DistributionOrderedCacheBehaviorFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorGrpcConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DistributionOrderedCacheBehaviorGrpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorGrpcConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        lambda_arn: pulumi.Input[_builtins.str]
        include_body: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOrderedCacheBehaviorLambdaFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 lambda_arn: pulumi.Input[_builtins.str],
                 include_body: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_body")

    @include_body.setter
    def include_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_body", value)


if not MYPY:
    class DistributionOriginArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        origin_id: pulumi.Input[_builtins.str]
        connection_attempts: NotRequired[pulumi.Input[_builtins.int]]
        connection_timeout: NotRequired[pulumi.Input[_builtins.int]]
        custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionOriginCustomHeaderArgsDict']]]]
        custom_origin_config: NotRequired[pulumi.Input['DistributionOriginCustomOriginConfigArgsDict']]
        origin_access_control_id: NotRequired[pulumi.Input[_builtins.str]]
        origin_path: NotRequired[pulumi.Input[_builtins.str]]
        origin_shield: NotRequired[pulumi.Input['DistributionOriginOriginShieldArgsDict']]
        response_completion_timeout: NotRequired[pulumi.Input[_builtins.int]]
        s3_origin_config: NotRequired[pulumi.Input['DistributionOriginS3OriginConfigArgsDict']]
        vpc_origin_config: NotRequired[pulumi.Input['DistributionOriginVpcOriginConfigArgsDict']]
elif False:
    DistributionOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 origin_id: pulumi.Input[_builtins.str],
                 connection_attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 connection_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOriginCustomHeaderArgs']]]] = None,
                 custom_origin_config: Optional[pulumi.Input['DistributionOriginCustomOriginConfigArgs']] = None,
                 origin_access_control_id: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_path: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_shield: Optional[pulumi.Input['DistributionOriginOriginShieldArgs']] = None,
                 response_completion_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 s3_origin_config: Optional[pulumi.Input['DistributionOriginS3OriginConfigArgs']] = None,
                 vpc_origin_config: Optional[pulumi.Input['DistributionOriginVpcOriginConfigArgs']] = None):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "origin_id", origin_id)
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_origin_config is not None:
            pulumi.set(__self__, "custom_origin_config", custom_origin_config)
        if origin_access_control_id is not None:
            pulumi.set(__self__, "origin_access_control_id", origin_access_control_id)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shield is not None:
            pulumi.set(__self__, "origin_shield", origin_shield)
        if response_completion_timeout is not None:
            pulumi.set(__self__, "response_completion_timeout", response_completion_timeout)
        if s3_origin_config is not None:
            pulumi.set(__self__, "s3_origin_config", s3_origin_config)
        if vpc_origin_config is not None:
            pulumi.set(__self__, "vpc_origin_config", vpc_origin_config)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "connection_attempts")

    @connection_attempts.setter
    def connection_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_attempts", value)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_timeout", value)

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOriginCustomHeaderArgs']]]]:
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionOriginCustomHeaderArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @_builtins.property
    @pulumi.getter(name="customOriginConfig")
    def custom_origin_config(self) -> Optional[pulumi.Input['DistributionOriginCustomOriginConfigArgs']]:
        return pulumi.get(self, "custom_origin_config")

    @custom_origin_config.setter
    def custom_origin_config(self, value: Optional[pulumi.Input['DistributionOriginCustomOriginConfigArgs']]):
        pulumi.set(self, "custom_origin_config", value)

    @_builtins.property
    @pulumi.getter(name="originAccessControlId")
    def origin_access_control_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_access_control_id")

    @origin_access_control_id.setter
    def origin_access_control_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_access_control_id", value)

    @_builtins.property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_path")

    @origin_path.setter
    def origin_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_path", value)

    @_builtins.property
    @pulumi.getter(name="originShield")
    def origin_shield(self) -> Optional[pulumi.Input['DistributionOriginOriginShieldArgs']]:
        return pulumi.get(self, "origin_shield")

    @origin_shield.setter
    def origin_shield(self, value: Optional[pulumi.Input['DistributionOriginOriginShieldArgs']]):
        pulumi.set(self, "origin_shield", value)

    @_builtins.property
    @pulumi.getter(name="responseCompletionTimeout")
    def response_completion_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "response_completion_timeout")

    @response_completion_timeout.setter
    def response_completion_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_completion_timeout", value)

    @_builtins.property
    @pulumi.getter(name="s3OriginConfig")
    def s3_origin_config(self) -> Optional[pulumi.Input['DistributionOriginS3OriginConfigArgs']]:
        return pulumi.get(self, "s3_origin_config")

    @s3_origin_config.setter
    def s3_origin_config(self, value: Optional[pulumi.Input['DistributionOriginS3OriginConfigArgs']]):
        pulumi.set(self, "s3_origin_config", value)

    @_builtins.property
    @pulumi.getter(name="vpcOriginConfig")
    def vpc_origin_config(self) -> Optional[pulumi.Input['DistributionOriginVpcOriginConfigArgs']]:
        return pulumi.get(self, "vpc_origin_config")

    @vpc_origin_config.setter
    def vpc_origin_config(self, value: Optional[pulumi.Input['DistributionOriginVpcOriginConfigArgs']]):
        pulumi.set(self, "vpc_origin_config", value)


if not MYPY:
    class DistributionOriginCustomHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    DistributionOriginCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginCustomHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DistributionOriginCustomOriginConfigArgsDict(TypedDict):
        http_port: pulumi.Input[_builtins.int]
        https_port: pulumi.Input[_builtins.int]
        origin_protocol_policy: pulumi.Input[_builtins.str]
        origin_ssl_protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
        origin_keepalive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        origin_read_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DistributionOriginCustomOriginConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginCustomOriginConfigArgs:
    def __init__(__self__, *,
                 http_port: pulumi.Input[_builtins.int],
                 https_port: pulumi.Input[_builtins.int],
                 origin_protocol_policy: pulumi.Input[_builtins.str],
                 origin_ssl_protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_keepalive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_read_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_protocol_policy")

    @origin_protocol_policy.setter
    def origin_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "origin_ssl_protocols")

    @origin_ssl_protocols.setter
    def origin_ssl_protocols(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "origin_ssl_protocols", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @origin_keepalive_timeout.setter
    def origin_keepalive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_keepalive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_read_timeout")

    @origin_read_timeout.setter
    def origin_read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_read_timeout", value)


if not MYPY:
    class DistributionOriginGroupArgsDict(TypedDict):
        failover_criteria: pulumi.Input['DistributionOriginGroupFailoverCriteriaArgsDict']
        members: pulumi.Input[Sequence[pulumi.Input['DistributionOriginGroupMemberArgsDict']]]
        origin_id: pulumi.Input[_builtins.str]
elif False:
    DistributionOriginGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginGroupArgs:
    def __init__(__self__, *,
                 failover_criteria: pulumi.Input['DistributionOriginGroupFailoverCriteriaArgs'],
                 members: pulumi.Input[Sequence[pulumi.Input['DistributionOriginGroupMemberArgs']]],
                 origin_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "failover_criteria", failover_criteria)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> pulumi.Input['DistributionOriginGroupFailoverCriteriaArgs']:
        return pulumi.get(self, "failover_criteria")

    @failover_criteria.setter
    def failover_criteria(self, value: pulumi.Input['DistributionOriginGroupFailoverCriteriaArgs']):
        pulumi.set(self, "failover_criteria", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> pulumi.Input[Sequence[pulumi.Input['DistributionOriginGroupMemberArgs']]]:
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: pulumi.Input[Sequence[pulumi.Input['DistributionOriginGroupMemberArgs']]]):
        pulumi.set(self, "members", value)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)


if not MYPY:
    class DistributionOriginGroupFailoverCriteriaArgsDict(TypedDict):
        status_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    DistributionOriginGroupFailoverCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginGroupFailoverCriteriaArgs:
    def __init__(__self__, *,
                 status_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "status_codes", status_codes)

    @_builtins.property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class DistributionOriginGroupMemberArgsDict(TypedDict):
        origin_id: pulumi.Input[_builtins.str]
elif False:
    DistributionOriginGroupMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginGroupMemberArgs:
    def __init__(__self__, *,
                 origin_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)


if not MYPY:
    class DistributionOriginOriginShieldArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        origin_shield_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionOriginOriginShieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginOriginShieldArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 origin_shield_region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if origin_shield_region is not None:
            pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_shield_region")

    @origin_shield_region.setter
    def origin_shield_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_shield_region", value)


if not MYPY:
    class DistributionOriginS3OriginConfigArgsDict(TypedDict):
        origin_access_identity: pulumi.Input[_builtins.str]
elif False:
    DistributionOriginS3OriginConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginS3OriginConfigArgs:
    def __init__(__self__, *,
                 origin_access_identity: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "origin_access_identity", origin_access_identity)

    @_builtins.property
    @pulumi.getter(name="originAccessIdentity")
    def origin_access_identity(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_access_identity")

    @origin_access_identity.setter
    def origin_access_identity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_access_identity", value)


if not MYPY:
    class DistributionOriginVpcOriginConfigArgsDict(TypedDict):
        vpc_origin_id: pulumi.Input[_builtins.str]
        origin_keepalive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        origin_read_timeout: NotRequired[pulumi.Input[_builtins.int]]
        owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionOriginVpcOriginConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionOriginVpcOriginConfigArgs:
    def __init__(__self__, *,
                 vpc_origin_id: pulumi.Input[_builtins.str],
                 origin_keepalive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_read_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 owner_account_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "vpc_origin_id", vpc_origin_id)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)
        if owner_account_id is not None:
            pulumi.set(__self__, "owner_account_id", owner_account_id)

    @_builtins.property
    @pulumi.getter(name="vpcOriginId")
    def vpc_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_origin_id")

    @vpc_origin_id.setter
    def vpc_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @origin_keepalive_timeout.setter
    def origin_keepalive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_keepalive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_read_timeout")

    @origin_read_timeout.setter
    def origin_read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_read_timeout", value)

    @_builtins.property
    @pulumi.getter(name="ownerAccountId")
    def owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner_account_id")

    @owner_account_id.setter
    def owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner_account_id", value)


if not MYPY:
    class DistributionRestrictionsArgsDict(TypedDict):
        geo_restriction: pulumi.Input['DistributionRestrictionsGeoRestrictionArgsDict']
elif False:
    DistributionRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionRestrictionsArgs:
    def __init__(__self__, *,
                 geo_restriction: pulumi.Input['DistributionRestrictionsGeoRestrictionArgs']):
        pulumi.set(__self__, "geo_restriction", geo_restriction)

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> pulumi.Input['DistributionRestrictionsGeoRestrictionArgs']:
        return pulumi.get(self, "geo_restriction")

    @geo_restriction.setter
    def geo_restriction(self, value: pulumi.Input['DistributionRestrictionsGeoRestrictionArgs']):
        pulumi.set(self, "geo_restriction", value)


if not MYPY:
    class DistributionRestrictionsGeoRestrictionArgsDict(TypedDict):
        restriction_type: pulumi.Input[_builtins.str]
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionRestrictionsGeoRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionRestrictionsGeoRestrictionArgs:
    def __init__(__self__, *,
                 restriction_type: pulumi.Input[_builtins.str],
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "restriction_type", restriction_type)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "restriction_type")

    @restriction_type.setter
    def restriction_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "restriction_type", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class DistributionTenantCustomizationsArgsDict(TypedDict):
        certificate: NotRequired[pulumi.Input['DistributionTenantCustomizationsCertificateArgsDict']]
        geo_restriction: NotRequired[pulumi.Input['DistributionTenantCustomizationsGeoRestrictionArgsDict']]
        web_acl: NotRequired[pulumi.Input['DistributionTenantCustomizationsWebAclArgsDict']]
elif False:
    DistributionTenantCustomizationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantCustomizationsArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input['DistributionTenantCustomizationsCertificateArgs']] = None,
                 geo_restriction: Optional[pulumi.Input['DistributionTenantCustomizationsGeoRestrictionArgs']] = None,
                 web_acl: Optional[pulumi.Input['DistributionTenantCustomizationsWebAclArgs']] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restriction is not None:
            pulumi.set(__self__, "geo_restriction", geo_restriction)
        if web_acl is not None:
            pulumi.set(__self__, "web_acl", web_acl)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['DistributionTenantCustomizationsCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['DistributionTenantCustomizationsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> Optional[pulumi.Input['DistributionTenantCustomizationsGeoRestrictionArgs']]:
        return pulumi.get(self, "geo_restriction")

    @geo_restriction.setter
    def geo_restriction(self, value: Optional[pulumi.Input['DistributionTenantCustomizationsGeoRestrictionArgs']]):
        pulumi.set(self, "geo_restriction", value)

    @_builtins.property
    @pulumi.getter(name="webAcl")
    def web_acl(self) -> Optional[pulumi.Input['DistributionTenantCustomizationsWebAclArgs']]:
        return pulumi.get(self, "web_acl")

    @web_acl.setter
    def web_acl(self, value: Optional[pulumi.Input['DistributionTenantCustomizationsWebAclArgs']]):
        pulumi.set(self, "web_acl", value)


if not MYPY:
    class DistributionTenantCustomizationsCertificateArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionTenantCustomizationsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantCustomizationsCertificateArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class DistributionTenantCustomizationsGeoRestrictionArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        restriction_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionTenantCustomizationsGeoRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantCustomizationsGeoRestrictionArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 restriction_type: Optional[pulumi.Input[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if restriction_type is not None:
            pulumi.set(__self__, "restriction_type", restriction_type)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "restriction_type")

    @restriction_type.setter
    def restriction_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restriction_type", value)


if not MYPY:
    class DistributionTenantCustomizationsWebAclArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionTenantCustomizationsWebAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantCustomizationsWebAclArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class DistributionTenantDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionTenantDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "domain", domain)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DistributionTenantManagedCertificateRequestArgsDict(TypedDict):
        certificate_transparency_logging_preference: NotRequired[pulumi.Input[_builtins.str]]
        primary_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        validation_token_host: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionTenantManagedCertificateRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantManagedCertificateRequestArgs:
    def __init__(__self__, *,
                 certificate_transparency_logging_preference: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_token_host: Optional[pulumi.Input[_builtins.str]] = None):
        if certificate_transparency_logging_preference is not None:
            pulumi.set(__self__, "certificate_transparency_logging_preference", certificate_transparency_logging_preference)
        if primary_domain_name is not None:
            pulumi.set(__self__, "primary_domain_name", primary_domain_name)
        if validation_token_host is not None:
            pulumi.set(__self__, "validation_token_host", validation_token_host)

    @_builtins.property
    @pulumi.getter(name="certificateTransparencyLoggingPreference")
    def certificate_transparency_logging_preference(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_transparency_logging_preference")

    @certificate_transparency_logging_preference.setter
    def certificate_transparency_logging_preference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_transparency_logging_preference", value)

    @_builtins.property
    @pulumi.getter(name="primaryDomainName")
    def primary_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_domain_name")

    @primary_domain_name.setter
    def primary_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="validationTokenHost")
    def validation_token_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "validation_token_host")

    @validation_token_host.setter
    def validation_token_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_token_host", value)


if not MYPY:
    class DistributionTenantParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    DistributionTenantParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DistributionTenantTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DistributionTenantTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTenantTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class DistributionTrustedKeyGroupArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedKeyGroupItemArgsDict']]]]
elif False:
    DistributionTrustedKeyGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTrustedKeyGroupArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedKeyGroupItemArgs']]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedKeyGroupItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedKeyGroupItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DistributionTrustedKeyGroupItemArgsDict(TypedDict):
        key_group_id: NotRequired[pulumi.Input[_builtins.str]]
        key_pair_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionTrustedKeyGroupItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTrustedKeyGroupItemArgs:
    def __init__(__self__, *,
                 key_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_pair_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key_group_id is not None:
            pulumi.set(__self__, "key_group_id", key_group_id)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="keyGroupId")
    def key_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_group_id")

    @key_group_id.setter
    def key_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_group_id", value)

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "key_pair_ids")

    @key_pair_ids.setter
    def key_pair_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_pair_ids", value)


if not MYPY:
    class DistributionTrustedSignerArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedSignerItemArgsDict']]]]
elif False:
    DistributionTrustedSignerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTrustedSignerArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedSignerItemArgs']]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedSignerItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DistributionTrustedSignerItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DistributionTrustedSignerItemArgsDict(TypedDict):
        aws_account_number: NotRequired[pulumi.Input[_builtins.str]]
        key_pair_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DistributionTrustedSignerItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionTrustedSignerItemArgs:
    def __init__(__self__, *,
                 aws_account_number: Optional[pulumi.Input[_builtins.str]] = None,
                 key_pair_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if aws_account_number is not None:
            pulumi.set(__self__, "aws_account_number", aws_account_number)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="awsAccountNumber")
    def aws_account_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aws_account_number")

    @aws_account_number.setter
    def aws_account_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aws_account_number", value)

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "key_pair_ids")

    @key_pair_ids.setter
    def key_pair_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_pair_ids", value)


if not MYPY:
    class DistributionViewerCertificateArgsDict(TypedDict):
        acm_certificate_arn: NotRequired[pulumi.Input[_builtins.str]]
        cloudfront_default_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        iam_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        minimum_protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        ssl_support_method: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DistributionViewerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionViewerCertificateArgs:
    def __init__(__self__, *,
                 acm_certificate_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 cloudfront_default_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 iam_certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 minimum_protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_support_method: Optional[pulumi.Input[_builtins.str]] = None):
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloudfront_default_certificate is not None:
            pulumi.set(__self__, "cloudfront_default_certificate", cloudfront_default_certificate)
        if iam_certificate_id is not None:
            pulumi.set(__self__, "iam_certificate_id", iam_certificate_id)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @_builtins.property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "acm_certificate_arn")

    @acm_certificate_arn.setter
    def acm_certificate_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acm_certificate_arn", value)

    @_builtins.property
    @pulumi.getter(name="cloudfrontDefaultCertificate")
    def cloudfront_default_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cloudfront_default_certificate")

    @cloudfront_default_certificate.setter
    def cloudfront_default_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloudfront_default_certificate", value)

    @_builtins.property
    @pulumi.getter(name="iamCertificateId")
    def iam_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "iam_certificate_id")

    @iam_certificate_id.setter
    def iam_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "minimum_protocol_version")

    @minimum_protocol_version.setter
    def minimum_protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "minimum_protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ssl_support_method")

    @ssl_support_method.setter
    def ssl_support_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_support_method", value)


if not MYPY:
    class DistributionViewerMtlsConfigArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        trust_store_config: NotRequired[pulumi.Input['DistributionViewerMtlsConfigTrustStoreConfigArgsDict']]
elif False:
    DistributionViewerMtlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionViewerMtlsConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_store_config: Optional[pulumi.Input['DistributionViewerMtlsConfigTrustStoreConfigArgs']] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trust_store_config is not None:
            pulumi.set(__self__, "trust_store_config", trust_store_config)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="trustStoreConfig")
    def trust_store_config(self) -> Optional[pulumi.Input['DistributionViewerMtlsConfigTrustStoreConfigArgs']]:
        return pulumi.get(self, "trust_store_config")

    @trust_store_config.setter
    def trust_store_config(self, value: Optional[pulumi.Input['DistributionViewerMtlsConfigTrustStoreConfigArgs']]):
        pulumi.set(self, "trust_store_config", value)


if not MYPY:
    class DistributionViewerMtlsConfigTrustStoreConfigArgsDict(TypedDict):
        trust_store_id: pulumi.Input[_builtins.str]
        advertise_trust_store_ca_names: NotRequired[pulumi.Input[_builtins.bool]]
        ignore_certificate_expiry: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DistributionViewerMtlsConfigTrustStoreConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionViewerMtlsConfigTrustStoreConfigArgs:
    def __init__(__self__, *,
                 trust_store_id: pulumi.Input[_builtins.str],
                 advertise_trust_store_ca_names: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_certificate_expiry: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "trust_store_id", trust_store_id)
        if advertise_trust_store_ca_names is not None:
            pulumi.set(__self__, "advertise_trust_store_ca_names", advertise_trust_store_ca_names)
        if ignore_certificate_expiry is not None:
            pulumi.set(__self__, "ignore_certificate_expiry", ignore_certificate_expiry)

    @_builtins.property
    @pulumi.getter(name="trustStoreId")
    def trust_store_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "trust_store_id")

    @trust_store_id.setter
    def trust_store_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trust_store_id", value)

    @_builtins.property
    @pulumi.getter(name="advertiseTrustStoreCaNames")
    def advertise_trust_store_ca_names(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "advertise_trust_store_ca_names")

    @advertise_trust_store_ca_names.setter
    def advertise_trust_store_ca_names(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "advertise_trust_store_ca_names", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateExpiry")
    def ignore_certificate_expiry(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ignore_certificate_expiry")

    @ignore_certificate_expiry.setter
    def ignore_certificate_expiry(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_certificate_expiry", value)


if not MYPY:
    class FieldLevelEncryptionConfigContentTypeProfileConfigArgsDict(TypedDict):
        content_type_profiles: pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgsDict']
        forward_when_content_type_is_unknown: pulumi.Input[_builtins.bool]
elif False:
    FieldLevelEncryptionConfigContentTypeProfileConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigContentTypeProfileConfigArgs:
    def __init__(__self__, *,
                 content_type_profiles: pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgs'],
                 forward_when_content_type_is_unknown: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "content_type_profiles", content_type_profiles)
        pulumi.set(__self__, "forward_when_content_type_is_unknown", forward_when_content_type_is_unknown)

    @_builtins.property
    @pulumi.getter(name="contentTypeProfiles")
    def content_type_profiles(self) -> pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgs']:
        return pulumi.get(self, "content_type_profiles")

    @content_type_profiles.setter
    def content_type_profiles(self, value: pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgs']):
        pulumi.set(self, "content_type_profiles", value)

    @_builtins.property
    @pulumi.getter(name="forwardWhenContentTypeIsUnknown")
    def forward_when_content_type_is_unknown(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "forward_when_content_type_is_unknown")

    @forward_when_content_type_is_unknown.setter
    def forward_when_content_type_is_unknown(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "forward_when_content_type_is_unknown", value)


if not MYPY:
    class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgsDict']]]
elif False:
    FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgs']]]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgs']]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgsDict(TypedDict):
        content_type: pulumi.Input[_builtins.str]
        format: pulumi.Input[_builtins.str]
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItemArgs:
    def __init__(__self__, *,
                 content_type: pulumi.Input[_builtins.str],
                 format: pulumi.Input[_builtins.str],
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "format", format)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)


if not MYPY:
    class FieldLevelEncryptionConfigQueryArgProfileConfigArgsDict(TypedDict):
        forward_when_query_arg_profile_is_unknown: pulumi.Input[_builtins.bool]
        query_arg_profiles: NotRequired[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgsDict']]
elif False:
    FieldLevelEncryptionConfigQueryArgProfileConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigQueryArgProfileConfigArgs:
    def __init__(__self__, *,
                 forward_when_query_arg_profile_is_unknown: pulumi.Input[_builtins.bool],
                 query_arg_profiles: Optional[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgs']] = None):
        pulumi.set(__self__, "forward_when_query_arg_profile_is_unknown", forward_when_query_arg_profile_is_unknown)
        if query_arg_profiles is not None:
            pulumi.set(__self__, "query_arg_profiles", query_arg_profiles)

    @_builtins.property
    @pulumi.getter(name="forwardWhenQueryArgProfileIsUnknown")
    def forward_when_query_arg_profile_is_unknown(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "forward_when_query_arg_profile_is_unknown")

    @forward_when_query_arg_profile_is_unknown.setter
    def forward_when_query_arg_profile_is_unknown(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "forward_when_query_arg_profile_is_unknown", value)

    @_builtins.property
    @pulumi.getter(name="queryArgProfiles")
    def query_arg_profiles(self) -> Optional[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgs']]:
        return pulumi.get(self, "query_arg_profiles")

    @query_arg_profiles.setter
    def query_arg_profiles(self, value: Optional[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgs']]):
        pulumi.set(self, "query_arg_profiles", value)


if not MYPY:
    class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgsDict']]]]
elif False:
    FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgs']]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgsDict(TypedDict):
        profile_id: pulumi.Input[_builtins.str]
        query_arg: pulumi.Input[_builtins.str]
elif False:
    FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItemArgs:
    def __init__(__self__, *,
                 profile_id: pulumi.Input[_builtins.str],
                 query_arg: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "query_arg", query_arg)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="queryArg")
    def query_arg(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "query_arg")

    @query_arg.setter
    def query_arg(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query_arg", value)


if not MYPY:
    class FieldLevelEncryptionProfileEncryptionEntitiesArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemArgsDict']]]]
elif False:
    FieldLevelEncryptionProfileEncryptionEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionProfileEncryptionEntitiesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemArgs']]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class FieldLevelEncryptionProfileEncryptionEntitiesItemArgsDict(TypedDict):
        field_patterns: pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgsDict']
        provider_id: pulumi.Input[_builtins.str]
        public_key_id: pulumi.Input[_builtins.str]
elif False:
    FieldLevelEncryptionProfileEncryptionEntitiesItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionProfileEncryptionEntitiesItemArgs:
    def __init__(__self__, *,
                 field_patterns: pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgs'],
                 provider_id: pulumi.Input[_builtins.str],
                 public_key_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "field_patterns", field_patterns)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "public_key_id", public_key_id)

    @_builtins.property
    @pulumi.getter(name="fieldPatterns")
    def field_patterns(self) -> pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgs']:
        return pulumi.get(self, "field_patterns")

    @field_patterns.setter
    def field_patterns(self, value: pulumi.Input['FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgs']):
        pulumi.set(self, "field_patterns", value)

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_id", value)

    @_builtins.property
    @pulumi.getter(name="publicKeyId")
    def public_key_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "public_key_id")

    @public_key_id.setter
    def public_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_key_id", value)


if not MYPY:
    class FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatternsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class KeyValueStoreTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    KeyValueStoreTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyValueStoreTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class KeyvaluestoreKeysExclusiveResourceKeyValuePairArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key to put.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to put.
        """
elif False:
    KeyvaluestoreKeysExclusiveResourceKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyvaluestoreKeysExclusiveResourceKeyValuePairArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The key to put.
        :param pulumi.Input[_builtins.str] value: The value to put.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key to put.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to put.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoringSubscriptionMonitoringSubscriptionArgsDict(TypedDict):
        realtime_metrics_subscription_config: pulumi.Input['MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgsDict']
elif False:
    MonitoringSubscriptionMonitoringSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringSubscriptionMonitoringSubscriptionArgs:
    def __init__(__self__, *,
                 realtime_metrics_subscription_config: pulumi.Input['MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs']):
        pulumi.set(__self__, "realtime_metrics_subscription_config", realtime_metrics_subscription_config)

    @_builtins.property
    @pulumi.getter(name="realtimeMetricsSubscriptionConfig")
    def realtime_metrics_subscription_config(self) -> pulumi.Input['MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs']:
        return pulumi.get(self, "realtime_metrics_subscription_config")

    @realtime_metrics_subscription_config.setter
    def realtime_metrics_subscription_config(self, value: pulumi.Input['MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs']):
        pulumi.set(self, "realtime_metrics_subscription_config", value)


if not MYPY:
    class MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgsDict(TypedDict):
        realtime_metrics_subscription_status: pulumi.Input[_builtins.str]
elif False:
    MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs:
    def __init__(__self__, *,
                 realtime_metrics_subscription_status: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "realtime_metrics_subscription_status", realtime_metrics_subscription_status)

    @_builtins.property
    @pulumi.getter(name="realtimeMetricsSubscriptionStatus")
    def realtime_metrics_subscription_status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "realtime_metrics_subscription_status")

    @realtime_metrics_subscription_status.setter
    def realtime_metrics_subscription_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "realtime_metrics_subscription_status", value)


if not MYPY:
    class MultitenantDistributionActiveTrustedKeyGroupArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionActiveTrustedKeyGroupItemArgsDict']]]]
elif False:
    MultitenantDistributionActiveTrustedKeyGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionActiveTrustedKeyGroupArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionActiveTrustedKeyGroupItemArgs']]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionActiveTrustedKeyGroupItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionActiveTrustedKeyGroupItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionActiveTrustedKeyGroupItemArgsDict(TypedDict):
        key_group_id: NotRequired[pulumi.Input[_builtins.str]]
        key_pair_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MultitenantDistributionActiveTrustedKeyGroupItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionActiveTrustedKeyGroupItemArgs:
    def __init__(__self__, *,
                 key_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_pair_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key_group_id is not None:
            pulumi.set(__self__, "key_group_id", key_group_id)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="keyGroupId")
    def key_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_group_id")

    @key_group_id.setter
    def key_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_group_id", value)

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "key_pair_ids")

    @key_pair_ids.setter
    def key_pair_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_pair_ids", value)


if not MYPY:
    class MultitenantDistributionCacheBehaviorArgsDict(TypedDict):
        path_pattern: pulumi.Input[_builtins.str]
        target_origin_id: pulumi.Input[_builtins.str]
        viewer_protocol_policy: pulumi.Input[_builtins.str]
        allowed_methods: NotRequired[pulumi.Input['MultitenantDistributionCacheBehaviorAllowedMethodsArgsDict']]
        cache_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        compress: NotRequired[pulumi.Input[_builtins.bool]]
        field_level_encryption_id: NotRequired[pulumi.Input[_builtins.str]]
        function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorFunctionAssociationArgsDict']]]]
        lambda_function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgsDict']]]]
        origin_request_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        realtime_log_config_arn: NotRequired[pulumi.Input[_builtins.str]]
        response_headers_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        trusted_key_groups: NotRequired[pulumi.Input['MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgsDict']]
elif False:
    MultitenantDistributionCacheBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCacheBehaviorArgs:
    def __init__(__self__, *,
                 path_pattern: pulumi.Input[_builtins.str],
                 target_origin_id: pulumi.Input[_builtins.str],
                 viewer_protocol_policy: pulumi.Input[_builtins.str],
                 allowed_methods: Optional[pulumi.Input['MultitenantDistributionCacheBehaviorAllowedMethodsArgs']] = None,
                 cache_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compress: Optional[pulumi.Input[_builtins.bool]] = None,
                 field_level_encryption_id: Optional[pulumi.Input[_builtins.str]] = None,
                 function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorFunctionAssociationArgs']]]] = None,
                 lambda_function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgs']]]] = None,
                 origin_request_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 realtime_log_config_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 trusted_key_groups: Optional[pulumi.Input['MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgs']] = None):
        pulumi.set(__self__, "path_pattern", path_pattern)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)

    @_builtins.property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path_pattern")

    @path_pattern.setter
    def path_pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_pattern", value)

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_origin_id")

    @target_origin_id.setter
    def target_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "viewer_protocol_policy")

    @viewer_protocol_policy.setter
    def viewer_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "viewer_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input['MultitenantDistributionCacheBehaviorAllowedMethodsArgs']]:
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input['MultitenantDistributionCacheBehaviorAllowedMethodsArgs']]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_policy_id")

    @cache_policy_id.setter
    def cache_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_policy_id", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_level_encryption_id")

    @field_level_encryption_id.setter
    def field_level_encryption_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_level_encryption_id", value)

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorFunctionAssociationArgs']]]]:
        return pulumi.get(self, "function_associations")

    @function_associations.setter
    def function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorFunctionAssociationArgs']]]]):
        pulumi.set(self, "function_associations", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgs']]]]:
        return pulumi.get(self, "lambda_function_associations")

    @lambda_function_associations.setter
    def lambda_function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgs']]]]):
        pulumi.set(self, "lambda_function_associations", value)

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_request_policy_id")

    @origin_request_policy_id.setter
    def origin_request_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_request_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "realtime_log_config_arn")

    @realtime_log_config_arn.setter
    def realtime_log_config_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realtime_log_config_arn", value)

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_headers_policy_id")

    @response_headers_policy_id.setter
    def response_headers_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_headers_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[pulumi.Input['MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgs']]:
        return pulumi.get(self, "trusted_key_groups")

    @trusted_key_groups.setter
    def trusted_key_groups(self, value: Optional[pulumi.Input['MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgs']]):
        pulumi.set(self, "trusted_key_groups", value)


if not MYPY:
    class MultitenantDistributionCacheBehaviorAllowedMethodsArgsDict(TypedDict):
        cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MultitenantDistributionCacheBehaviorAllowedMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCacheBehaviorAllowedMethodsArgs:
    def __init__(__self__, *,
                 cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "cached_methods")

    @cached_methods.setter
    def cached_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "cached_methods", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionCacheBehaviorFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        function_arn: pulumi.Input[_builtins.str]
elif False:
    MultitenantDistributionCacheBehaviorFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCacheBehaviorFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        lambda_function_arn: pulumi.Input[_builtins.str]
        include_body: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCacheBehaviorLambdaFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 lambda_function_arn: pulumi.Input[_builtins.str],
                 include_body: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lambda_function_arn")

    @lambda_function_arn.setter
    def lambda_function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_function_arn", value)

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_body")

    @include_body.setter
    def include_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_body", value)


if not MYPY:
    class MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCacheBehaviorTrustedKeyGroupsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionCustomErrorResponseArgsDict(TypedDict):
        error_code: pulumi.Input[_builtins.int]
        error_caching_min_ttl: NotRequired[pulumi.Input[_builtins.int]]
        response_code: NotRequired[pulumi.Input[_builtins.str]]
        response_page_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MultitenantDistributionCustomErrorResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionCustomErrorResponseArgs:
    def __init__(__self__, *,
                 error_code: pulumi.Input[_builtins.int],
                 error_caching_min_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 response_code: Optional[pulumi.Input[_builtins.str]] = None,
                 response_page_path: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "error_code", error_code)
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorCachingMinTtl")
    def error_caching_min_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "error_caching_min_ttl")

    @error_caching_min_ttl.setter
    def error_caching_min_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "error_caching_min_ttl", value)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_page_path")

    @response_page_path.setter
    def response_page_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_page_path", value)


if not MYPY:
    class MultitenantDistributionDefaultCacheBehaviorArgsDict(TypedDict):
        target_origin_id: pulumi.Input[_builtins.str]
        viewer_protocol_policy: pulumi.Input[_builtins.str]
        allowed_methods: NotRequired[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgsDict']]
        cache_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        compress: NotRequired[pulumi.Input[_builtins.bool]]
        field_level_encryption_id: NotRequired[pulumi.Input[_builtins.str]]
        function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgsDict']]]]
        lambda_function_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict']]]]
        origin_request_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        realtime_log_config_arn: NotRequired[pulumi.Input[_builtins.str]]
        response_headers_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        trusted_key_groups: NotRequired[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgsDict']]
elif False:
    MultitenantDistributionDefaultCacheBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionDefaultCacheBehaviorArgs:
    def __init__(__self__, *,
                 target_origin_id: pulumi.Input[_builtins.str],
                 viewer_protocol_policy: pulumi.Input[_builtins.str],
                 allowed_methods: Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgs']] = None,
                 cache_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 compress: Optional[pulumi.Input[_builtins.bool]] = None,
                 field_level_encryption_id: Optional[pulumi.Input[_builtins.str]] = None,
                 function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgs']]]] = None,
                 lambda_function_associations: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]] = None,
                 origin_request_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 realtime_log_config_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 trusted_key_groups: Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgs']] = None):
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_origin_id")

    @target_origin_id.setter
    def target_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "viewer_protocol_policy")

    @viewer_protocol_policy.setter
    def viewer_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "viewer_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgs']]:
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgs']]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_policy_id")

    @cache_policy_id.setter
    def cache_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_policy_id", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_level_encryption_id")

    @field_level_encryption_id.setter
    def field_level_encryption_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_level_encryption_id", value)

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgs']]]]:
        return pulumi.get(self, "function_associations")

    @function_associations.setter
    def function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgs']]]]):
        pulumi.set(self, "function_associations", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]]:
        return pulumi.get(self, "lambda_function_associations")

    @lambda_function_associations.setter
    def lambda_function_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs']]]]):
        pulumi.set(self, "lambda_function_associations", value)

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_request_policy_id")

    @origin_request_policy_id.setter
    def origin_request_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_request_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "realtime_log_config_arn")

    @realtime_log_config_arn.setter
    def realtime_log_config_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "realtime_log_config_arn", value)

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_headers_policy_id")

    @response_headers_policy_id.setter
    def response_headers_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_headers_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgs']]:
        return pulumi.get(self, "trusted_key_groups")

    @trusted_key_groups.setter
    def trusted_key_groups(self, value: Optional[pulumi.Input['MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgs']]):
        pulumi.set(self, "trusted_key_groups", value)


if not MYPY:
    class MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgsDict(TypedDict):
        cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionDefaultCacheBehaviorAllowedMethodsArgs:
    def __init__(__self__, *,
                 cached_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "cached_methods")

    @cached_methods.setter
    def cached_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "cached_methods", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        function_arn: pulumi.Input[_builtins.str]
elif False:
    MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionDefaultCacheBehaviorFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        lambda_function_arn: pulumi.Input[_builtins.str]
        include_body: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociationArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 lambda_function_arn: pulumi.Input[_builtins.str],
                 include_body: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "lambda_function_arn")

    @lambda_function_arn.setter
    def lambda_function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_function_arn", value)

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_body")

    @include_body.setter
    def include_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_body", value)


if not MYPY:
    class MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroupsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionOriginArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        id: pulumi.Input[_builtins.str]
        connection_attempts: NotRequired[pulumi.Input[_builtins.int]]
        connection_timeout: NotRequired[pulumi.Input[_builtins.int]]
        custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomHeaderArgsDict']]]]
        custom_origin_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomOriginConfigArgsDict']]]]
        origin_access_control_id: NotRequired[pulumi.Input[_builtins.str]]
        origin_path: NotRequired[pulumi.Input[_builtins.str]]
        origin_shields: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginOriginShieldArgsDict']]]]
        response_completion_timeout: NotRequired[pulumi.Input[_builtins.int]]
        vpc_origin_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginVpcOriginConfigArgsDict']]]]
elif False:
    MultitenantDistributionOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 connection_attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 connection_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomHeaderArgs']]]] = None,
                 custom_origin_configs: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomOriginConfigArgs']]]] = None,
                 origin_access_control_id: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_path: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_shields: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginOriginShieldArgs']]]] = None,
                 response_completion_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 vpc_origin_configs: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginVpcOriginConfigArgs']]]] = None):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "id", id)
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_origin_configs is not None:
            pulumi.set(__self__, "custom_origin_configs", custom_origin_configs)
        if origin_access_control_id is not None:
            pulumi.set(__self__, "origin_access_control_id", origin_access_control_id)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shields is not None:
            pulumi.set(__self__, "origin_shields", origin_shields)
        if response_completion_timeout is not None:
            pulumi.set(__self__, "response_completion_timeout", response_completion_timeout)
        if vpc_origin_configs is not None:
            pulumi.set(__self__, "vpc_origin_configs", vpc_origin_configs)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "connection_attempts")

    @connection_attempts.setter
    def connection_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_attempts", value)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "connection_timeout")

    @connection_timeout.setter
    def connection_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_timeout", value)

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomHeaderArgs']]]]:
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomHeaderArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @_builtins.property
    @pulumi.getter(name="customOriginConfigs")
    def custom_origin_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomOriginConfigArgs']]]]:
        return pulumi.get(self, "custom_origin_configs")

    @custom_origin_configs.setter
    def custom_origin_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginCustomOriginConfigArgs']]]]):
        pulumi.set(self, "custom_origin_configs", value)

    @_builtins.property
    @pulumi.getter(name="originAccessControlId")
    def origin_access_control_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_access_control_id")

    @origin_access_control_id.setter
    def origin_access_control_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_access_control_id", value)

    @_builtins.property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_path")

    @origin_path.setter
    def origin_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_path", value)

    @_builtins.property
    @pulumi.getter(name="originShields")
    def origin_shields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginOriginShieldArgs']]]]:
        return pulumi.get(self, "origin_shields")

    @origin_shields.setter
    def origin_shields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginOriginShieldArgs']]]]):
        pulumi.set(self, "origin_shields", value)

    @_builtins.property
    @pulumi.getter(name="responseCompletionTimeout")
    def response_completion_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "response_completion_timeout")

    @response_completion_timeout.setter
    def response_completion_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_completion_timeout", value)

    @_builtins.property
    @pulumi.getter(name="vpcOriginConfigs")
    def vpc_origin_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginVpcOriginConfigArgs']]]]:
        return pulumi.get(self, "vpc_origin_configs")

    @vpc_origin_configs.setter
    def vpc_origin_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginVpcOriginConfigArgs']]]]):
        pulumi.set(self, "vpc_origin_configs", value)


if not MYPY:
    class MultitenantDistributionOriginCustomHeaderArgsDict(TypedDict):
        header_name: pulumi.Input[_builtins.str]
        header_value: pulumi.Input[_builtins.str]
elif False:
    MultitenantDistributionOriginCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginCustomHeaderArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[_builtins.str],
                 header_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_value", value)


if not MYPY:
    class MultitenantDistributionOriginCustomOriginConfigArgsDict(TypedDict):
        http_port: pulumi.Input[_builtins.int]
        https_port: pulumi.Input[_builtins.int]
        origin_protocol_policy: pulumi.Input[_builtins.str]
        origin_ssl_protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
        origin_keepalive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        origin_read_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    MultitenantDistributionOriginCustomOriginConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginCustomOriginConfigArgs:
    def __init__(__self__, *,
                 http_port: pulumi.Input[_builtins.int],
                 https_port: pulumi.Input[_builtins.int],
                 origin_protocol_policy: pulumi.Input[_builtins.str],
                 origin_ssl_protocols: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_keepalive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_read_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_protocol_policy")

    @origin_protocol_policy.setter
    def origin_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "origin_ssl_protocols")

    @origin_ssl_protocols.setter
    def origin_ssl_protocols(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "origin_ssl_protocols", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @origin_keepalive_timeout.setter
    def origin_keepalive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_keepalive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_read_timeout")

    @origin_read_timeout.setter
    def origin_read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_read_timeout", value)


if not MYPY:
    class MultitenantDistributionOriginGroupArgsDict(TypedDict):
        origin_id: pulumi.Input[_builtins.str]
        failover_criteria: NotRequired[pulumi.Input['MultitenantDistributionOriginGroupFailoverCriteriaArgsDict']]
        members: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginGroupMemberArgsDict']]]]
elif False:
    MultitenantDistributionOriginGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginGroupArgs:
    def __init__(__self__, *,
                 origin_id: pulumi.Input[_builtins.str],
                 failover_criteria: Optional[pulumi.Input['MultitenantDistributionOriginGroupFailoverCriteriaArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginGroupMemberArgs']]]] = None):
        pulumi.set(__self__, "origin_id", origin_id)
        if failover_criteria is not None:
            pulumi.set(__self__, "failover_criteria", failover_criteria)
        if members is not None:
            pulumi.set(__self__, "members", members)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)

    @_builtins.property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> Optional[pulumi.Input['MultitenantDistributionOriginGroupFailoverCriteriaArgs']]:
        return pulumi.get(self, "failover_criteria")

    @failover_criteria.setter
    def failover_criteria(self, value: Optional[pulumi.Input['MultitenantDistributionOriginGroupFailoverCriteriaArgs']]):
        pulumi.set(self, "failover_criteria", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginGroupMemberArgs']]]]:
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionOriginGroupMemberArgs']]]]):
        pulumi.set(self, "members", value)


if not MYPY:
    class MultitenantDistributionOriginGroupFailoverCriteriaArgsDict(TypedDict):
        status_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    MultitenantDistributionOriginGroupFailoverCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginGroupFailoverCriteriaArgs:
    def __init__(__self__, *,
                 status_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "status_codes", status_codes)

    @_builtins.property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "status_codes", value)


if not MYPY:
    class MultitenantDistributionOriginGroupMemberArgsDict(TypedDict):
        origin_id: pulumi.Input[_builtins.str]
elif False:
    MultitenantDistributionOriginGroupMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginGroupMemberArgs:
    def __init__(__self__, *,
                 origin_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_id")

    @origin_id.setter
    def origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_id", value)


if not MYPY:
    class MultitenantDistributionOriginOriginShieldArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        origin_shield_region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MultitenantDistributionOriginOriginShieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginOriginShieldArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 origin_shield_region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if origin_shield_region is not None:
            pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_shield_region")

    @origin_shield_region.setter
    def origin_shield_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_shield_region", value)


if not MYPY:
    class MultitenantDistributionOriginVpcOriginConfigArgsDict(TypedDict):
        vpc_origin_id: pulumi.Input[_builtins.str]
        origin_keepalive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        origin_read_timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    MultitenantDistributionOriginVpcOriginConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionOriginVpcOriginConfigArgs:
    def __init__(__self__, *,
                 vpc_origin_id: pulumi.Input[_builtins.str],
                 origin_keepalive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_read_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "vpc_origin_id", vpc_origin_id)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="vpcOriginId")
    def vpc_origin_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_origin_id")

    @vpc_origin_id.setter
    def vpc_origin_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_origin_id", value)

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @origin_keepalive_timeout.setter
    def origin_keepalive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_keepalive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_read_timeout")

    @origin_read_timeout.setter
    def origin_read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_read_timeout", value)


if not MYPY:
    class MultitenantDistributionRestrictionsArgsDict(TypedDict):
        geo_restriction: NotRequired[pulumi.Input['MultitenantDistributionRestrictionsGeoRestrictionArgsDict']]
elif False:
    MultitenantDistributionRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionRestrictionsArgs:
    def __init__(__self__, *,
                 geo_restriction: Optional[pulumi.Input['MultitenantDistributionRestrictionsGeoRestrictionArgs']] = None):
        if geo_restriction is not None:
            pulumi.set(__self__, "geo_restriction", geo_restriction)

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> Optional[pulumi.Input['MultitenantDistributionRestrictionsGeoRestrictionArgs']]:
        return pulumi.get(self, "geo_restriction")

    @geo_restriction.setter
    def geo_restriction(self, value: Optional[pulumi.Input['MultitenantDistributionRestrictionsGeoRestrictionArgs']]):
        pulumi.set(self, "geo_restriction", value)


if not MYPY:
    class MultitenantDistributionRestrictionsGeoRestrictionArgsDict(TypedDict):
        restriction_type: pulumi.Input[_builtins.str]
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MultitenantDistributionRestrictionsGeoRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionRestrictionsGeoRestrictionArgs:
    def __init__(__self__, *,
                 restriction_type: pulumi.Input[_builtins.str],
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "restriction_type", restriction_type)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "restriction_type")

    @restriction_type.setter
    def restriction_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "restriction_type", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class MultitenantDistributionTenantConfigArgsDict(TypedDict):
        parameter_definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionArgsDict']]]]
elif False:
    MultitenantDistributionTenantConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionTenantConfigArgs:
    def __init__(__self__, *,
                 parameter_definitions: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionArgs']]]] = None):
        if parameter_definitions is not None:
            pulumi.set(__self__, "parameter_definitions", parameter_definitions)

    @_builtins.property
    @pulumi.getter(name="parameterDefinitions")
    def parameter_definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionArgs']]]]:
        return pulumi.get(self, "parameter_definitions")

    @parameter_definitions.setter
    def parameter_definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionArgs']]]]):
        pulumi.set(self, "parameter_definitions", value)


if not MYPY:
    class MultitenantDistributionTenantConfigParameterDefinitionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgsDict']]]]
elif False:
    MultitenantDistributionTenantConfigParameterDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionTenantConfigParameterDefinitionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 definitions: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgs']]]] = None):
        pulumi.set(__self__, "name", name)
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgs']]]]:
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgs']]]]):
        pulumi.set(self, "definitions", value)


if not MYPY:
    class MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgsDict(TypedDict):
        string_schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgsDict']]]]
elif False:
    MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionTenantConfigParameterDefinitionDefinitionArgs:
    def __init__(__self__, *,
                 string_schemas: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgs']]]] = None):
        if string_schemas is not None:
            pulumi.set(__self__, "string_schemas", string_schemas)

    @_builtins.property
    @pulumi.getter(name="stringSchemas")
    def string_schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgs']]]]:
        return pulumi.get(self, "string_schemas")

    @string_schemas.setter
    def string_schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgs']]]]):
        pulumi.set(self, "string_schemas", value)


if not MYPY:
    class MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgsDict(TypedDict):
        required: pulumi.Input[_builtins.bool]
        comment: NotRequired[pulumi.Input[_builtins.str]]
        default_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchemaArgs:
    def __init__(__self__, *,
                 required: pulumi.Input[_builtins.bool],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 default_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "required", required)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)


if not MYPY:
    class MultitenantDistributionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    MultitenantDistributionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class MultitenantDistributionViewerCertificateArgsDict(TypedDict):
        acm_certificate_arn: NotRequired[pulumi.Input[_builtins.str]]
        cloudfront_default_certificate: NotRequired[pulumi.Input[_builtins.bool]]
        minimum_protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        ssl_support_method: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MultitenantDistributionViewerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultitenantDistributionViewerCertificateArgs:
    def __init__(__self__, *,
                 acm_certificate_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 cloudfront_default_certificate: Optional[pulumi.Input[_builtins.bool]] = None,
                 minimum_protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_support_method: Optional[pulumi.Input[_builtins.str]] = None):
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloudfront_default_certificate is not None:
            pulumi.set(__self__, "cloudfront_default_certificate", cloudfront_default_certificate)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @_builtins.property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "acm_certificate_arn")

    @acm_certificate_arn.setter
    def acm_certificate_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acm_certificate_arn", value)

    @_builtins.property
    @pulumi.getter(name="cloudfrontDefaultCertificate")
    def cloudfront_default_certificate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cloudfront_default_certificate")

    @cloudfront_default_certificate.setter
    def cloudfront_default_certificate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloudfront_default_certificate", value)

    @_builtins.property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "minimum_protocol_version")

    @minimum_protocol_version.setter
    def minimum_protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "minimum_protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ssl_support_method")

    @ssl_support_method.setter
    def ssl_support_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_support_method", value)


if not MYPY:
    class OriginRequestPolicyCookiesConfigArgsDict(TypedDict):
        cookie_behavior: pulumi.Input[_builtins.str]
        cookies: NotRequired[pulumi.Input['OriginRequestPolicyCookiesConfigCookiesArgsDict']]
elif False:
    OriginRequestPolicyCookiesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyCookiesConfigArgs:
    def __init__(__self__, *,
                 cookie_behavior: pulumi.Input[_builtins.str],
                 cookies: Optional[pulumi.Input['OriginRequestPolicyCookiesConfigCookiesArgs']] = None):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cookie_behavior")

    @cookie_behavior.setter
    def cookie_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cookie_behavior", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['OriginRequestPolicyCookiesConfigCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['OriginRequestPolicyCookiesConfigCookiesArgs']]):
        pulumi.set(self, "cookies", value)


if not MYPY:
    class OriginRequestPolicyCookiesConfigCookiesArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OriginRequestPolicyCookiesConfigCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyCookiesConfigCookiesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class OriginRequestPolicyHeadersConfigArgsDict(TypedDict):
        header_behavior: NotRequired[pulumi.Input[_builtins.str]]
        headers: NotRequired[pulumi.Input['OriginRequestPolicyHeadersConfigHeadersArgsDict']]
elif False:
    OriginRequestPolicyHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyHeadersConfigArgs:
    def __init__(__self__, *,
                 header_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input['OriginRequestPolicyHeadersConfigHeadersArgs']] = None):
        if header_behavior is not None:
            pulumi.set(__self__, "header_behavior", header_behavior)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "header_behavior")

    @header_behavior.setter
    def header_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_behavior", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['OriginRequestPolicyHeadersConfigHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['OriginRequestPolicyHeadersConfigHeadersArgs']]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class OriginRequestPolicyHeadersConfigHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OriginRequestPolicyHeadersConfigHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyHeadersConfigHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class OriginRequestPolicyQueryStringsConfigArgsDict(TypedDict):
        query_string_behavior: pulumi.Input[_builtins.str]
        query_strings: NotRequired[pulumi.Input['OriginRequestPolicyQueryStringsConfigQueryStringsArgsDict']]
elif False:
    OriginRequestPolicyQueryStringsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyQueryStringsConfigArgs:
    def __init__(__self__, *,
                 query_string_behavior: pulumi.Input[_builtins.str],
                 query_strings: Optional[pulumi.Input['OriginRequestPolicyQueryStringsConfigQueryStringsArgs']] = None):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "query_string_behavior")

    @query_string_behavior.setter
    def query_string_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query_string_behavior", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input['OriginRequestPolicyQueryStringsConfigQueryStringsArgs']]:
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input['OriginRequestPolicyQueryStringsConfigQueryStringsArgs']]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class OriginRequestPolicyQueryStringsConfigQueryStringsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    OriginRequestPolicyQueryStringsConfigQueryStringsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OriginRequestPolicyQueryStringsConfigQueryStringsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class RealtimeLogConfigEndpointArgsDict(TypedDict):
        kinesis_stream_config: pulumi.Input['RealtimeLogConfigEndpointKinesisStreamConfigArgsDict']
        stream_type: pulumi.Input[_builtins.str]
elif False:
    RealtimeLogConfigEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RealtimeLogConfigEndpointArgs:
    def __init__(__self__, *,
                 kinesis_stream_config: pulumi.Input['RealtimeLogConfigEndpointKinesisStreamConfigArgs'],
                 stream_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "kinesis_stream_config", kinesis_stream_config)
        pulumi.set(__self__, "stream_type", stream_type)

    @_builtins.property
    @pulumi.getter(name="kinesisStreamConfig")
    def kinesis_stream_config(self) -> pulumi.Input['RealtimeLogConfigEndpointKinesisStreamConfigArgs']:
        return pulumi.get(self, "kinesis_stream_config")

    @kinesis_stream_config.setter
    def kinesis_stream_config(self, value: pulumi.Input['RealtimeLogConfigEndpointKinesisStreamConfigArgs']):
        pulumi.set(self, "kinesis_stream_config", value)

    @_builtins.property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stream_type")

    @stream_type.setter
    def stream_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_type", value)


if not MYPY:
    class RealtimeLogConfigEndpointKinesisStreamConfigArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        stream_arn: pulumi.Input[_builtins.str]
elif False:
    RealtimeLogConfigEndpointKinesisStreamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RealtimeLogConfigEndpointKinesisStreamConfigArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 stream_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_arn", stream_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_arn", value)


if not MYPY:
    class ResponseHeadersPolicyCorsConfigArgsDict(TypedDict):
        access_control_allow_credentials: pulumi.Input[_builtins.bool]
        access_control_allow_headers: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgsDict']
        access_control_allow_methods: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgsDict']
        access_control_allow_origins: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgsDict']
        origin_override: pulumi.Input[_builtins.bool]
        access_control_expose_headers: NotRequired[pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgsDict']]
        access_control_max_age_sec: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ResponseHeadersPolicyCorsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCorsConfigArgs:
    def __init__(__self__, *,
                 access_control_allow_credentials: pulumi.Input[_builtins.bool],
                 access_control_allow_headers: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgs'],
                 access_control_allow_methods: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgs'],
                 access_control_allow_origins: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgs'],
                 origin_override: pulumi.Input[_builtins.bool],
                 access_control_expose_headers: Optional[pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgs']] = None,
                 access_control_max_age_sec: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "access_control_allow_credentials", access_control_allow_credentials)
        pulumi.set(__self__, "access_control_allow_headers", access_control_allow_headers)
        pulumi.set(__self__, "access_control_allow_methods", access_control_allow_methods)
        pulumi.set(__self__, "access_control_allow_origins", access_control_allow_origins)
        pulumi.set(__self__, "origin_override", origin_override)
        if access_control_expose_headers is not None:
            pulumi.set(__self__, "access_control_expose_headers", access_control_expose_headers)
        if access_control_max_age_sec is not None:
            pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowCredentials")
    def access_control_allow_credentials(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "access_control_allow_credentials")

    @access_control_allow_credentials.setter
    def access_control_allow_credentials(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "access_control_allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowHeaders")
    def access_control_allow_headers(self) -> pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgs']:
        return pulumi.get(self, "access_control_allow_headers")

    @access_control_allow_headers.setter
    def access_control_allow_headers(self, value: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgs']):
        pulumi.set(self, "access_control_allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowMethods")
    def access_control_allow_methods(self) -> pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgs']:
        return pulumi.get(self, "access_control_allow_methods")

    @access_control_allow_methods.setter
    def access_control_allow_methods(self, value: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgs']):
        pulumi.set(self, "access_control_allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowOrigins")
    def access_control_allow_origins(self) -> pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgs']:
        return pulumi.get(self, "access_control_allow_origins")

    @access_control_allow_origins.setter
    def access_control_allow_origins(self, value: pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgs']):
        pulumi.set(self, "access_control_allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="originOverride")
    def origin_override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "origin_override")

    @origin_override.setter
    def origin_override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "origin_override", value)

    @_builtins.property
    @pulumi.getter(name="accessControlExposeHeaders")
    def access_control_expose_headers(self) -> Optional[pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgs']]:
        return pulumi.get(self, "access_control_expose_headers")

    @access_control_expose_headers.setter
    def access_control_expose_headers(self, value: Optional[pulumi.Input['ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgs']]):
        pulumi.set(self, "access_control_expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "access_control_max_age_sec")

    @access_control_max_age_sec.setter
    def access_control_max_age_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "access_control_max_age_sec", value)


if not MYPY:
    class ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowMethodsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowOriginsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCorsConfigAccessControlExposeHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyCustomHeadersConfigArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyCustomHeadersConfigItemArgsDict']]]]
elif False:
    ResponseHeadersPolicyCustomHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCustomHeadersConfigArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyCustomHeadersConfigItemArgs']]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyCustomHeadersConfigItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyCustomHeadersConfigItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyCustomHeadersConfigItemArgsDict(TypedDict):
        header: pulumi.Input[_builtins.str]
        override: pulumi.Input[_builtins.bool]
        value: pulumi.Input[_builtins.str]
elif False:
    ResponseHeadersPolicyCustomHeadersConfigItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyCustomHeadersConfigItemArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[_builtins.str],
                 override: pulumi.Input[_builtins.bool],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ResponseHeadersPolicyRemoveHeadersConfigArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyRemoveHeadersConfigItemArgsDict']]]]
elif False:
    ResponseHeadersPolicyRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyRemoveHeadersConfigItemArgs']]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyRemoveHeadersConfigItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponseHeadersPolicyRemoveHeadersConfigItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ResponseHeadersPolicyRemoveHeadersConfigItemArgsDict(TypedDict):
        header: pulumi.Input[_builtins.str]
elif False:
    ResponseHeadersPolicyRemoveHeadersConfigItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyRemoveHeadersConfigItemArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigArgsDict(TypedDict):
        content_security_policy: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgsDict']]
        content_type_options: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgsDict']]
        frame_options: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgsDict']]
        referrer_policy: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgsDict']]
        strict_transport_security: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgsDict']]
        xss_protection: NotRequired[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgsDict']]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigArgs:
    def __init__(__self__, *,
                 content_security_policy: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgs']] = None,
                 content_type_options: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgs']] = None,
                 frame_options: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgs']] = None,
                 referrer_policy: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgs']] = None,
                 strict_transport_security: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgs']] = None,
                 xss_protection: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgs']] = None):
        if content_security_policy is not None:
            pulumi.set(__self__, "content_security_policy", content_security_policy)
        if content_type_options is not None:
            pulumi.set(__self__, "content_type_options", content_type_options)
        if frame_options is not None:
            pulumi.set(__self__, "frame_options", frame_options)
        if referrer_policy is not None:
            pulumi.set(__self__, "referrer_policy", referrer_policy)
        if strict_transport_security is not None:
            pulumi.set(__self__, "strict_transport_security", strict_transport_security)
        if xss_protection is not None:
            pulumi.set(__self__, "xss_protection", xss_protection)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgs']]:
        return pulumi.get(self, "content_security_policy")

    @content_security_policy.setter
    def content_security_policy(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgs']]):
        pulumi.set(self, "content_security_policy", value)

    @_builtins.property
    @pulumi.getter(name="contentTypeOptions")
    def content_type_options(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgs']]:
        return pulumi.get(self, "content_type_options")

    @content_type_options.setter
    def content_type_options(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgs']]):
        pulumi.set(self, "content_type_options", value)

    @_builtins.property
    @pulumi.getter(name="frameOptions")
    def frame_options(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgs']]:
        return pulumi.get(self, "frame_options")

    @frame_options.setter
    def frame_options(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgs']]):
        pulumi.set(self, "frame_options", value)

    @_builtins.property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgs']]:
        return pulumi.get(self, "referrer_policy")

    @referrer_policy.setter
    def referrer_policy(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgs']]):
        pulumi.set(self, "referrer_policy", value)

    @_builtins.property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgs']]:
        return pulumi.get(self, "strict_transport_security")

    @strict_transport_security.setter
    def strict_transport_security(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgs']]):
        pulumi.set(self, "strict_transport_security", value)

    @_builtins.property
    @pulumi.getter(name="xssProtection")
    def xss_protection(self) -> Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgs']]:
        return pulumi.get(self, "xss_protection")

    @xss_protection.setter
    def xss_protection(self, value: Optional[pulumi.Input['ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgs']]):
        pulumi.set(self, "xss_protection", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgsDict(TypedDict):
        content_security_policy: pulumi.Input[_builtins.str]
        override: pulumi.Input[_builtins.bool]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyArgs:
    def __init__(__self__, *,
                 content_security_policy: pulumi.Input[_builtins.str],
                 override: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "content_security_policy", content_security_policy)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content_security_policy")

    @content_security_policy.setter
    def content_security_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_security_policy", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgsDict(TypedDict):
        override: pulumi.Input[_builtins.bool]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigContentTypeOptionsArgs:
    def __init__(__self__, *,
                 override: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgsDict(TypedDict):
        frame_option: pulumi.Input[_builtins.str]
        override: pulumi.Input[_builtins.bool]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigFrameOptionsArgs:
    def __init__(__self__, *,
                 frame_option: pulumi.Input[_builtins.str],
                 override: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "frame_option", frame_option)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="frameOption")
    def frame_option(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "frame_option")

    @frame_option.setter
    def frame_option(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "frame_option", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgsDict(TypedDict):
        override: pulumi.Input[_builtins.bool]
        referrer_policy: pulumi.Input[_builtins.str]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigReferrerPolicyArgs:
    def __init__(__self__, *,
                 override: pulumi.Input[_builtins.bool],
                 referrer_policy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "referrer_policy", referrer_policy)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "referrer_policy")

    @referrer_policy.setter
    def referrer_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "referrer_policy", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgsDict(TypedDict):
        access_control_max_age_sec: pulumi.Input[_builtins.int]
        override: pulumi.Input[_builtins.bool]
        include_subdomains: NotRequired[pulumi.Input[_builtins.bool]]
        preload: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityArgs:
    def __init__(__self__, *,
                 access_control_max_age_sec: pulumi.Input[_builtins.int],
                 override: pulumi.Input[_builtins.bool],
                 include_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 preload: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)
        pulumi.set(__self__, "override", override)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "access_control_max_age_sec")

    @access_control_max_age_sec.setter
    def access_control_max_age_sec(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "access_control_max_age_sec", value)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_subdomains", value)

    @_builtins.property
    @pulumi.getter
    def preload(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "preload")

    @preload.setter
    def preload(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preload", value)


if not MYPY:
    class ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgsDict(TypedDict):
        override: pulumi.Input[_builtins.bool]
        protection: pulumi.Input[_builtins.bool]
        mode_block: NotRequired[pulumi.Input[_builtins.bool]]
        report_uri: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicySecurityHeadersConfigXssProtectionArgs:
    def __init__(__self__, *,
                 override: pulumi.Input[_builtins.bool],
                 protection: pulumi.Input[_builtins.bool],
                 mode_block: Optional[pulumi.Input[_builtins.bool]] = None,
                 report_uri: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "protection", protection)
        if mode_block is not None:
            pulumi.set(__self__, "mode_block", mode_block)
        if report_uri is not None:
            pulumi.set(__self__, "report_uri", report_uri)

    @_builtins.property
    @pulumi.getter
    def override(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "override", value)

    @_builtins.property
    @pulumi.getter
    def protection(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "protection")

    @protection.setter
    def protection(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "protection", value)

    @_builtins.property
    @pulumi.getter(name="modeBlock")
    def mode_block(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "mode_block")

    @mode_block.setter
    def mode_block(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mode_block", value)

    @_builtins.property
    @pulumi.getter(name="reportUri")
    def report_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "report_uri")

    @report_uri.setter
    def report_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "report_uri", value)


if not MYPY:
    class ResponseHeadersPolicyServerTimingHeadersConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        sampling_rate: pulumi.Input[_builtins.float]
elif False:
    ResponseHeadersPolicyServerTimingHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponseHeadersPolicyServerTimingHeadersConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 sampling_rate: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "sampling_rate")

    @sampling_rate.setter
    def sampling_rate(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling_rate", value)


if not MYPY:
    class TrustStoreCaCertificatesBundleSourceArgsDict(TypedDict):
        ca_certificates_bundle_s3_location: NotRequired[pulumi.Input['TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgsDict']]
elif False:
    TrustStoreCaCertificatesBundleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustStoreCaCertificatesBundleSourceArgs:
    def __init__(__self__, *,
                 ca_certificates_bundle_s3_location: Optional[pulumi.Input['TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgs']] = None):
        if ca_certificates_bundle_s3_location is not None:
            pulumi.set(__self__, "ca_certificates_bundle_s3_location", ca_certificates_bundle_s3_location)

    @_builtins.property
    @pulumi.getter(name="caCertificatesBundleS3Location")
    def ca_certificates_bundle_s3_location(self) -> Optional[pulumi.Input['TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgs']]:
        return pulumi.get(self, "ca_certificates_bundle_s3_location")

    @ca_certificates_bundle_s3_location.setter
    def ca_certificates_bundle_s3_location(self, value: Optional[pulumi.Input['TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgs']]):
        pulumi.set(self, "ca_certificates_bundle_s3_location", value)


if not MYPY:
    class TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
        region: pulumi.Input[_builtins.str]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TrustStoreTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    TrustStoreTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustStoreTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class VpcOriginTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    VpcOriginTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcOriginTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class VpcOriginVpcOriginEndpointConfigArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        http_port: pulumi.Input[_builtins.int]
        https_port: pulumi.Input[_builtins.int]
        name: pulumi.Input[_builtins.str]
        origin_protocol_policy: pulumi.Input[_builtins.str]
        origin_ssl_protocols: NotRequired[pulumi.Input['VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgsDict']]
elif False:
    VpcOriginVpcOriginEndpointConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcOriginVpcOriginEndpointConfigArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 http_port: pulumi.Input[_builtins.int],
                 https_port: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 origin_protocol_policy: pulumi.Input[_builtins.str],
                 origin_ssl_protocols: Optional[pulumi.Input['VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        if origin_ssl_protocols is not None:
            pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_protocol_policy")

    @origin_protocol_policy.setter
    def origin_protocol_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_protocol_policy", value)

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> Optional[pulumi.Input['VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgs']]:
        return pulumi.get(self, "origin_ssl_protocols")

    @origin_ssl_protocols.setter
    def origin_ssl_protocols(self, value: Optional[pulumi.Input['VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgs']]):
        pulumi.set(self, "origin_ssl_protocols", value)


if not MYPY:
    class VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        quantity: pulumi.Input[_builtins.int]
elif False:
    VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcOriginVpcOriginEndpointConfigOriginSslProtocolsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 quantity: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "quantity", value)


