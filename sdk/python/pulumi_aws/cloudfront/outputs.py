# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CachePolicyParametersInCacheKeyAndForwardedToOrigin',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig',
    'CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings',
    'ConnectionFunctionConnectionFunctionConfig',
    'ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation',
    'ConnectionGroupTimeouts',
    'ContinuousDeploymentPolicyStagingDistributionDnsNames',
    'ContinuousDeploymentPolicyTrafficConfig',
    'ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig',
    'ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig',
    'DistributionConnectionFunctionAssociation',
    'DistributionCustomErrorResponse',
    'DistributionDefaultCacheBehavior',
    'DistributionDefaultCacheBehaviorForwardedValues',
    'DistributionDefaultCacheBehaviorForwardedValuesCookies',
    'DistributionDefaultCacheBehaviorFunctionAssociation',
    'DistributionDefaultCacheBehaviorGrpcConfig',
    'DistributionDefaultCacheBehaviorLambdaFunctionAssociation',
    'DistributionLoggingConfig',
    'DistributionOrderedCacheBehavior',
    'DistributionOrderedCacheBehaviorForwardedValues',
    'DistributionOrderedCacheBehaviorForwardedValuesCookies',
    'DistributionOrderedCacheBehaviorFunctionAssociation',
    'DistributionOrderedCacheBehaviorGrpcConfig',
    'DistributionOrderedCacheBehaviorLambdaFunctionAssociation',
    'DistributionOrigin',
    'DistributionOriginCustomHeader',
    'DistributionOriginCustomOriginConfig',
    'DistributionOriginGroup',
    'DistributionOriginGroupFailoverCriteria',
    'DistributionOriginGroupMember',
    'DistributionOriginOriginShield',
    'DistributionOriginS3OriginConfig',
    'DistributionOriginVpcOriginConfig',
    'DistributionRestrictions',
    'DistributionRestrictionsGeoRestriction',
    'DistributionTenantCustomizations',
    'DistributionTenantCustomizationsCertificate',
    'DistributionTenantCustomizationsGeoRestriction',
    'DistributionTenantCustomizationsWebAcl',
    'DistributionTenantDomain',
    'DistributionTenantManagedCertificateRequest',
    'DistributionTenantParameter',
    'DistributionTenantTimeouts',
    'DistributionTrustedKeyGroup',
    'DistributionTrustedKeyGroupItem',
    'DistributionTrustedSigner',
    'DistributionTrustedSignerItem',
    'DistributionViewerCertificate',
    'DistributionViewerMtlsConfig',
    'DistributionViewerMtlsConfigTrustStoreConfig',
    'FieldLevelEncryptionConfigContentTypeProfileConfig',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles',
    'FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem',
    'FieldLevelEncryptionConfigQueryArgProfileConfig',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles',
    'FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem',
    'FieldLevelEncryptionProfileEncryptionEntities',
    'FieldLevelEncryptionProfileEncryptionEntitiesItem',
    'FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns',
    'KeyValueStoreTimeouts',
    'KeyvaluestoreKeysExclusiveResourceKeyValuePair',
    'MonitoringSubscriptionMonitoringSubscription',
    'MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig',
    'MultitenantDistributionActiveTrustedKeyGroup',
    'MultitenantDistributionActiveTrustedKeyGroupItem',
    'MultitenantDistributionCacheBehavior',
    'MultitenantDistributionCacheBehaviorAllowedMethods',
    'MultitenantDistributionCacheBehaviorFunctionAssociation',
    'MultitenantDistributionCacheBehaviorLambdaFunctionAssociation',
    'MultitenantDistributionCacheBehaviorTrustedKeyGroups',
    'MultitenantDistributionCustomErrorResponse',
    'MultitenantDistributionDefaultCacheBehavior',
    'MultitenantDistributionDefaultCacheBehaviorAllowedMethods',
    'MultitenantDistributionDefaultCacheBehaviorFunctionAssociation',
    'MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation',
    'MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroups',
    'MultitenantDistributionOrigin',
    'MultitenantDistributionOriginCustomHeader',
    'MultitenantDistributionOriginCustomOriginConfig',
    'MultitenantDistributionOriginGroup',
    'MultitenantDistributionOriginGroupFailoverCriteria',
    'MultitenantDistributionOriginGroupMember',
    'MultitenantDistributionOriginOriginShield',
    'MultitenantDistributionOriginVpcOriginConfig',
    'MultitenantDistributionRestrictions',
    'MultitenantDistributionRestrictionsGeoRestriction',
    'MultitenantDistributionTenantConfig',
    'MultitenantDistributionTenantConfigParameterDefinition',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinition',
    'MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema',
    'MultitenantDistributionTimeouts',
    'MultitenantDistributionViewerCertificate',
    'OriginRequestPolicyCookiesConfig',
    'OriginRequestPolicyCookiesConfigCookies',
    'OriginRequestPolicyHeadersConfig',
    'OriginRequestPolicyHeadersConfigHeaders',
    'OriginRequestPolicyQueryStringsConfig',
    'OriginRequestPolicyQueryStringsConfigQueryStrings',
    'RealtimeLogConfigEndpoint',
    'RealtimeLogConfigEndpointKinesisStreamConfig',
    'ResponseHeadersPolicyCorsConfig',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowMethods',
    'ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins',
    'ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders',
    'ResponseHeadersPolicyCustomHeadersConfig',
    'ResponseHeadersPolicyCustomHeadersConfigItem',
    'ResponseHeadersPolicyRemoveHeadersConfig',
    'ResponseHeadersPolicyRemoveHeadersConfigItem',
    'ResponseHeadersPolicySecurityHeadersConfig',
    'ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy',
    'ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions',
    'ResponseHeadersPolicySecurityHeadersConfigFrameOptions',
    'ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy',
    'ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity',
    'ResponseHeadersPolicySecurityHeadersConfigXssProtection',
    'ResponseHeadersPolicyServerTimingHeadersConfig',
    'TrustStoreCaCertificatesBundleSource',
    'TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3Location',
    'TrustStoreTimeouts',
    'VpcOriginTimeouts',
    'VpcOriginVpcOriginEndpointConfig',
    'VpcOriginVpcOriginEndpointConfigOriginSslProtocols',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookieResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaderResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigResult',
    'GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringResult',
    'GetDistributionTenantCustomizationResult',
    'GetDistributionTenantCustomizationCertificateResult',
    'GetDistributionTenantCustomizationGeoRestrictionResult',
    'GetDistributionTenantCustomizationWebAclResult',
    'GetDistributionTenantDomainResult',
    'GetDistributionTenantManagedCertificateRequestResult',
    'GetDistributionTenantParameterResult',
    'GetOriginRequestPolicyCookiesConfigResult',
    'GetOriginRequestPolicyCookiesConfigCookieResult',
    'GetOriginRequestPolicyHeadersConfigResult',
    'GetOriginRequestPolicyHeadersConfigHeaderResult',
    'GetOriginRequestPolicyQueryStringsConfigResult',
    'GetOriginRequestPolicyQueryStringsConfigQueryStringResult',
    'GetRealtimeLogConfigEndpointResult',
    'GetRealtimeLogConfigEndpointKinesisStreamConfigResult',
    'GetResponseHeadersPolicyCorsConfigResult',
    'GetResponseHeadersPolicyCorsConfigAccessControlAllowHeaderResult',
    'GetResponseHeadersPolicyCorsConfigAccessControlAllowMethodResult',
    'GetResponseHeadersPolicyCorsConfigAccessControlAllowOriginResult',
    'GetResponseHeadersPolicyCorsConfigAccessControlExposeHeaderResult',
    'GetResponseHeadersPolicyCustomHeadersConfigResult',
    'GetResponseHeadersPolicyCustomHeadersConfigItemResult',
    'GetResponseHeadersPolicyRemoveHeadersConfigResult',
    'GetResponseHeadersPolicyRemoveHeadersConfigItemResult',
    'GetResponseHeadersPolicySecurityHeadersConfigResult',
    'GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyResult',
    'GetResponseHeadersPolicySecurityHeadersConfigContentTypeOptionResult',
    'GetResponseHeadersPolicySecurityHeadersConfigFrameOptionResult',
    'GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicyResult',
    'GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityResult',
    'GetResponseHeadersPolicySecurityHeadersConfigXssProtectionResult',
    'GetResponseHeadersPolicyServerTimingHeadersConfigResult',
]

@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookiesConfig":
            suggest = "cookies_config"
        elif key == "headersConfig":
            suggest = "headers_config"
        elif key == "queryStringsConfig":
            suggest = "query_strings_config"
        elif key == "enableAcceptEncodingBrotli":
            suggest = "enable_accept_encoding_brotli"
        elif key == "enableAcceptEncodingGzip":
            suggest = "enable_accept_encoding_gzip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CachePolicyParametersInCacheKeyAndForwardedToOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies_config: 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig',
                 headers_config: 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig',
                 query_strings_config: 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig',
                 enable_accept_encoding_brotli: Optional[_builtins.bool] = None,
                 enable_accept_encoding_gzip: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "cookies_config", cookies_config)
        pulumi.set(__self__, "headers_config", headers_config)
        pulumi.set(__self__, "query_strings_config", query_strings_config)
        if enable_accept_encoding_brotli is not None:
            pulumi.set(__self__, "enable_accept_encoding_brotli", enable_accept_encoding_brotli)
        if enable_accept_encoding_gzip is not None:
            pulumi.set(__self__, "enable_accept_encoding_gzip", enable_accept_encoding_gzip)

    @_builtins.property
    @pulumi.getter(name="cookiesConfig")
    def cookies_config(self) -> 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig':
        return pulumi.get(self, "cookies_config")

    @_builtins.property
    @pulumi.getter(name="headersConfig")
    def headers_config(self) -> 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig':
        return pulumi.get(self, "headers_config")

    @_builtins.property
    @pulumi.getter(name="queryStringsConfig")
    def query_strings_config(self) -> 'outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig':
        return pulumi.get(self, "query_strings_config")

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingBrotli")
    def enable_accept_encoding_brotli(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_accept_encoding_brotli")

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingGzip")
    def enable_accept_encoding_gzip(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_accept_encoding_gzip")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieBehavior":
            suggest = "cookie_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_behavior: _builtins.str,
                 cookies: Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies'] = None):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> _builtins.str:
        return pulumi.get(self, "cookie_behavior")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerBehavior":
            suggest = "header_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_behavior: Optional[_builtins.str] = None,
                 headers: Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders'] = None):
        if header_behavior is not None:
            pulumi.set(__self__, "header_behavior", header_behavior)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "header_behavior")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryStringBehavior":
            suggest = "query_string_behavior"
        elif key == "queryStrings":
            suggest = "query_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string_behavior: _builtins.str,
                 query_strings: Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings'] = None):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> _builtins.str:
        return pulumi.get(self, "query_string_behavior")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional['outputs.CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings']:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class CachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ConnectionFunctionConnectionFunctionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyValueStoreAssociation":
            suggest = "key_value_store_association"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionFunctionConnectionFunctionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionFunctionConnectionFunctionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionFunctionConnectionFunctionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: _builtins.str,
                 runtime: _builtins.str,
                 key_value_store_association: Optional['outputs.ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation'] = None):
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "runtime", runtime)
        if key_value_store_association is not None:
            pulumi.set(__self__, "key_value_store_association", key_value_store_association)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> _builtins.str:
        return pulumi.get(self, "runtime")

    @_builtins.property
    @pulumi.getter(name="keyValueStoreAssociation")
    def key_value_store_association(self) -> Optional['outputs.ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation']:
        return pulumi.get(self, "key_value_store_association")


@pulumi.output_type
class ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyValueStoreArn":
            suggest = "key_value_store_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionFunctionConnectionFunctionConfigKeyValueStoreAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_value_store_arn: _builtins.str):
        pulumi.set(__self__, "key_value_store_arn", key_value_store_arn)

    @_builtins.property
    @pulumi.getter(name="keyValueStoreArn")
    def key_value_store_arn(self) -> _builtins.str:
        return pulumi.get(self, "key_value_store_arn")


@pulumi.output_type
class ConnectionGroupTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Default is 90 minutes.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ContinuousDeploymentPolicyStagingDistributionDnsNames(dict):
    def __init__(__self__, *,
                 quantity: _builtins.int,
                 items: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "quantity", quantity)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        return pulumi.get(self, "quantity")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ContinuousDeploymentPolicyTrafficConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "singleHeaderConfig":
            suggest = "single_header_config"
        elif key == "singleWeightConfig":
            suggest = "single_weight_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousDeploymentPolicyTrafficConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousDeploymentPolicyTrafficConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousDeploymentPolicyTrafficConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 single_header_config: Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig'] = None,
                 single_weight_config: Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig'] = None):
        pulumi.set(__self__, "type", type)
        if single_header_config is not None:
            pulumi.set(__self__, "single_header_config", single_header_config)
        if single_weight_config is not None:
            pulumi.set(__self__, "single_weight_config", single_weight_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="singleHeaderConfig")
    def single_header_config(self) -> Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig']:
        return pulumi.get(self, "single_header_config")

    @_builtins.property
    @pulumi.getter(name="singleWeightConfig")
    def single_weight_config(self) -> Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig']:
        return pulumi.get(self, "single_weight_config")


@pulumi.output_type
class ContinuousDeploymentPolicyTrafficConfigSingleHeaderConfig(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionStickinessConfig":
            suggest = "session_stickiness_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousDeploymentPolicyTrafficConfigSingleWeightConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 weight: _builtins.float,
                 session_stickiness_config: Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig'] = None):
        pulumi.set(__self__, "weight", weight)
        if session_stickiness_config is not None:
            pulumi.set(__self__, "session_stickiness_config", session_stickiness_config)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="sessionStickinessConfig")
    def session_stickiness_config(self) -> Optional['outputs.ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig']:
        return pulumi.get(self, "session_stickiness_config")


@pulumi.output_type
class ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTtl":
            suggest = "idle_ttl"
        elif key == "maximumTtl":
            suggest = "maximum_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousDeploymentPolicyTrafficConfigSingleWeightConfigSessionStickinessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_ttl: _builtins.int,
                 maximum_ttl: _builtins.int):
        pulumi.set(__self__, "idle_ttl", idle_ttl)
        pulumi.set(__self__, "maximum_ttl", maximum_ttl)

    @_builtins.property
    @pulumi.getter(name="idleTtl")
    def idle_ttl(self) -> _builtins.int:
        return pulumi.get(self, "idle_ttl")

    @_builtins.property
    @pulumi.getter(name="maximumTtl")
    def maximum_ttl(self) -> _builtins.int:
        return pulumi.get(self, "maximum_ttl")


@pulumi.output_type
class DistributionConnectionFunctionAssociation(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class DistributionCustomErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorCachingMinTtl":
            suggest = "error_caching_min_ttl"
        elif key == "responseCode":
            suggest = "response_code"
        elif key == "responsePagePath":
            suggest = "response_page_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionCustomErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionCustomErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionCustomErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: _builtins.int,
                 error_caching_min_ttl: Optional[_builtins.int] = None,
                 response_code: Optional[_builtins.int] = None,
                 response_page_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "error_code", error_code)
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.int:
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorCachingMinTtl")
    def error_caching_min_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "error_caching_min_ttl")

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_page_path")


@pulumi.output_type
class DistributionDefaultCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "grpcConfig":
            suggest = "grpc_config"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "minTtl":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionDefaultCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionDefaultCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionDefaultCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[_builtins.str],
                 cached_methods: Sequence[_builtins.str],
                 target_origin_id: _builtins.str,
                 viewer_protocol_policy: _builtins.str,
                 cache_policy_id: Optional[_builtins.str] = None,
                 compress: Optional[_builtins.bool] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 field_level_encryption_id: Optional[_builtins.str] = None,
                 forwarded_values: Optional['outputs.DistributionDefaultCacheBehaviorForwardedValues'] = None,
                 function_associations: Optional[Sequence['outputs.DistributionDefaultCacheBehaviorFunctionAssociation']] = None,
                 grpc_config: Optional['outputs.DistributionDefaultCacheBehaviorGrpcConfig'] = None,
                 lambda_function_associations: Optional[Sequence['outputs.DistributionDefaultCacheBehaviorLambdaFunctionAssociation']] = None,
                 max_ttl: Optional[_builtins.int] = None,
                 min_ttl: Optional[_builtins.int] = None,
                 origin_request_policy_id: Optional[_builtins.str] = None,
                 realtime_log_config_arn: Optional[_builtins.str] = None,
                 response_headers_policy_id: Optional[_builtins.str] = None,
                 smooth_streaming: Optional[_builtins.bool] = None,
                 trusted_key_groups: Optional[Sequence[_builtins.str]] = None,
                 trusted_signers: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if grpc_config is not None:
            pulumi.set(__self__, "grpc_config", grpc_config)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cached_methods")

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "target_origin_id")

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "viewer_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cache_policy_id")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_level_encryption_id")

    @_builtins.property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.DistributionDefaultCacheBehaviorForwardedValues']:
        return pulumi.get(self, "forwarded_values")

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.DistributionDefaultCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @_builtins.property
    @pulumi.getter(name="grpcConfig")
    def grpc_config(self) -> Optional['outputs.DistributionDefaultCacheBehaviorGrpcConfig']:
        return pulumi.get(self, "grpc_config")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.DistributionDefaultCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_ttl")

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_request_policy_id")

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_headers_policy_id")

    @_builtins.property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "smooth_streaming")

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "trusted_key_groups")

    @_builtins.property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "trusted_signers")


@pulumi.output_type
class DistributionDefaultCacheBehaviorForwardedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "queryStringCacheKeys":
            suggest = "query_string_cache_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionDefaultCacheBehaviorForwardedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionDefaultCacheBehaviorForwardedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionDefaultCacheBehaviorForwardedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies: 'outputs.DistributionDefaultCacheBehaviorForwardedValuesCookies',
                 query_string: _builtins.bool,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 query_string_cache_keys: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> 'outputs.DistributionDefaultCacheBehaviorForwardedValuesCookies':
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> _builtins.bool:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "query_string_cache_keys")


@pulumi.output_type
class DistributionDefaultCacheBehaviorForwardedValuesCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistedNames":
            suggest = "whitelisted_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionDefaultCacheBehaviorForwardedValuesCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionDefaultCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionDefaultCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward: _builtins.str,
                 whitelisted_names: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> _builtins.str:
        return pulumi.get(self, "forward")

    @_builtins.property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "whitelisted_names")


@pulumi.output_type
class DistributionDefaultCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionDefaultCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class DistributionDefaultCacheBehaviorGrpcConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DistributionDefaultCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionDefaultCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 lambda_arn: _builtins.str,
                 include_body: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_body")


@pulumi.output_type
class DistributionLoggingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeCookies":
            suggest = "include_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: Optional[_builtins.str] = None,
                 include_cookies: Optional[_builtins.bool] = None,
                 prefix: Optional[_builtins.str] = None):
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if include_cookies is not None:
            pulumi.set(__self__, "include_cookies", include_cookies)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="includeCookies")
    def include_cookies(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_cookies")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DistributionOrderedCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "pathPattern":
            suggest = "path_pattern"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "grpcConfig":
            suggest = "grpc_config"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "minTtl":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrderedCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrderedCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrderedCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[_builtins.str],
                 cached_methods: Sequence[_builtins.str],
                 path_pattern: _builtins.str,
                 target_origin_id: _builtins.str,
                 viewer_protocol_policy: _builtins.str,
                 cache_policy_id: Optional[_builtins.str] = None,
                 compress: Optional[_builtins.bool] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 field_level_encryption_id: Optional[_builtins.str] = None,
                 forwarded_values: Optional['outputs.DistributionOrderedCacheBehaviorForwardedValues'] = None,
                 function_associations: Optional[Sequence['outputs.DistributionOrderedCacheBehaviorFunctionAssociation']] = None,
                 grpc_config: Optional['outputs.DistributionOrderedCacheBehaviorGrpcConfig'] = None,
                 lambda_function_associations: Optional[Sequence['outputs.DistributionOrderedCacheBehaviorLambdaFunctionAssociation']] = None,
                 max_ttl: Optional[_builtins.int] = None,
                 min_ttl: Optional[_builtins.int] = None,
                 origin_request_policy_id: Optional[_builtins.str] = None,
                 realtime_log_config_arn: Optional[_builtins.str] = None,
                 response_headers_policy_id: Optional[_builtins.str] = None,
                 smooth_streaming: Optional[_builtins.bool] = None,
                 trusted_key_groups: Optional[Sequence[_builtins.str]] = None,
                 trusted_signers: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "path_pattern", path_pattern)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if grpc_config is not None:
            pulumi.set(__self__, "grpc_config", grpc_config)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cached_methods")

    @_builtins.property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> _builtins.str:
        return pulumi.get(self, "path_pattern")

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "target_origin_id")

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "viewer_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cache_policy_id")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_level_encryption_id")

    @_builtins.property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.DistributionOrderedCacheBehaviorForwardedValues']:
        return pulumi.get(self, "forwarded_values")

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.DistributionOrderedCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @_builtins.property
    @pulumi.getter(name="grpcConfig")
    def grpc_config(self) -> Optional['outputs.DistributionOrderedCacheBehaviorGrpcConfig']:
        return pulumi.get(self, "grpc_config")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.DistributionOrderedCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @_builtins.property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_ttl")

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_ttl")

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_request_policy_id")

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_headers_policy_id")

    @_builtins.property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "smooth_streaming")

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "trusted_key_groups")

    @_builtins.property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "trusted_signers")


@pulumi.output_type
class DistributionOrderedCacheBehaviorForwardedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "queryStringCacheKeys":
            suggest = "query_string_cache_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrderedCacheBehaviorForwardedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrderedCacheBehaviorForwardedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrderedCacheBehaviorForwardedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies: 'outputs.DistributionOrderedCacheBehaviorForwardedValuesCookies',
                 query_string: _builtins.bool,
                 headers: Optional[Sequence[_builtins.str]] = None,
                 query_string_cache_keys: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> 'outputs.DistributionOrderedCacheBehaviorForwardedValuesCookies':
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> _builtins.bool:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "query_string_cache_keys")


@pulumi.output_type
class DistributionOrderedCacheBehaviorForwardedValuesCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistedNames":
            suggest = "whitelisted_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrderedCacheBehaviorForwardedValuesCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrderedCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrderedCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward: _builtins.str,
                 whitelisted_names: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> _builtins.str:
        return pulumi.get(self, "forward")

    @_builtins.property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "whitelisted_names")


@pulumi.output_type
class DistributionOrderedCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrderedCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrderedCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrderedCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class DistributionOrderedCacheBehaviorGrpcConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DistributionOrderedCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrderedCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrderedCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrderedCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 lambda_arn: _builtins.str,
                 include_body: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_body")


@pulumi.output_type
class DistributionOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "originId":
            suggest = "origin_id"
        elif key == "connectionAttempts":
            suggest = "connection_attempts"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customHeaders":
            suggest = "custom_headers"
        elif key == "customOriginConfig":
            suggest = "custom_origin_config"
        elif key == "originAccessControlId":
            suggest = "origin_access_control_id"
        elif key == "originPath":
            suggest = "origin_path"
        elif key == "originShield":
            suggest = "origin_shield"
        elif key == "responseCompletionTimeout":
            suggest = "response_completion_timeout"
        elif key == "s3OriginConfig":
            suggest = "s3_origin_config"
        elif key == "vpcOriginConfig":
            suggest = "vpc_origin_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 origin_id: _builtins.str,
                 connection_attempts: Optional[_builtins.int] = None,
                 connection_timeout: Optional[_builtins.int] = None,
                 custom_headers: Optional[Sequence['outputs.DistributionOriginCustomHeader']] = None,
                 custom_origin_config: Optional['outputs.DistributionOriginCustomOriginConfig'] = None,
                 origin_access_control_id: Optional[_builtins.str] = None,
                 origin_path: Optional[_builtins.str] = None,
                 origin_shield: Optional['outputs.DistributionOriginOriginShield'] = None,
                 response_completion_timeout: Optional[_builtins.int] = None,
                 s3_origin_config: Optional['outputs.DistributionOriginS3OriginConfig'] = None,
                 vpc_origin_config: Optional['outputs.DistributionOriginVpcOriginConfig'] = None):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "origin_id", origin_id)
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_origin_config is not None:
            pulumi.set(__self__, "custom_origin_config", custom_origin_config)
        if origin_access_control_id is not None:
            pulumi.set(__self__, "origin_access_control_id", origin_access_control_id)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shield is not None:
            pulumi.set(__self__, "origin_shield", origin_shield)
        if response_completion_timeout is not None:
            pulumi.set(__self__, "response_completion_timeout", response_completion_timeout)
        if s3_origin_config is not None:
            pulumi.set(__self__, "s3_origin_config", s3_origin_config)
        if vpc_origin_config is not None:
            pulumi.set(__self__, "vpc_origin_config", vpc_origin_config)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connection_attempts")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.DistributionOriginCustomHeader']]:
        return pulumi.get(self, "custom_headers")

    @_builtins.property
    @pulumi.getter(name="customOriginConfig")
    def custom_origin_config(self) -> Optional['outputs.DistributionOriginCustomOriginConfig']:
        return pulumi.get(self, "custom_origin_config")

    @_builtins.property
    @pulumi.getter(name="originAccessControlId")
    def origin_access_control_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_access_control_id")

    @_builtins.property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_path")

    @_builtins.property
    @pulumi.getter(name="originShield")
    def origin_shield(self) -> Optional['outputs.DistributionOriginOriginShield']:
        return pulumi.get(self, "origin_shield")

    @_builtins.property
    @pulumi.getter(name="responseCompletionTimeout")
    def response_completion_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "response_completion_timeout")

    @_builtins.property
    @pulumi.getter(name="s3OriginConfig")
    def s3_origin_config(self) -> Optional['outputs.DistributionOriginS3OriginConfig']:
        return pulumi.get(self, "s3_origin_config")

    @_builtins.property
    @pulumi.getter(name="vpcOriginConfig")
    def vpc_origin_config(self) -> Optional['outputs.DistributionOriginVpcOriginConfig']:
        return pulumi.get(self, "vpc_origin_config")


@pulumi.output_type
class DistributionOriginCustomHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DistributionOriginCustomOriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originSslProtocols":
            suggest = "origin_ssl_protocols"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginCustomOriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginCustomOriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginCustomOriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_port: _builtins.int,
                 https_port: _builtins.int,
                 origin_protocol_policy: _builtins.str,
                 origin_ssl_protocols: Sequence[_builtins.str],
                 ip_address_type: Optional[_builtins.str] = None,
                 origin_keepalive_timeout: Optional[_builtins.int] = None,
                 origin_read_timeout: Optional[_builtins.int] = None):
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> _builtins.int:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "origin_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "origin_ssl_protocols")

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_read_timeout")


@pulumi.output_type
class DistributionOriginGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverCriteria":
            suggest = "failover_criteria"
        elif key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_criteria: 'outputs.DistributionOriginGroupFailoverCriteria',
                 members: Sequence['outputs.DistributionOriginGroupMember'],
                 origin_id: _builtins.str):
        pulumi.set(__self__, "failover_criteria", failover_criteria)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> 'outputs.DistributionOriginGroupFailoverCriteria':
        return pulumi.get(self, "failover_criteria")

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.DistributionOriginGroupMember']:
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class DistributionOriginGroupFailoverCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginGroupFailoverCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: Sequence[_builtins.int]):
        pulumi.set(__self__, "status_codes", status_codes)

    @_builtins.property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class DistributionOriginGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_id: _builtins.str):
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class DistributionOriginOriginShield(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originShieldRegion":
            suggest = "origin_shield_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginOriginShield. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginOriginShield.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginOriginShield.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 origin_shield_region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if origin_shield_region is not None:
            pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_shield_region")


@pulumi.output_type
class DistributionOriginS3OriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originAccessIdentity":
            suggest = "origin_access_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginS3OriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginS3OriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginS3OriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_access_identity: _builtins.str):
        pulumi.set(__self__, "origin_access_identity", origin_access_identity)

    @_builtins.property
    @pulumi.getter(name="originAccessIdentity")
    def origin_access_identity(self) -> _builtins.str:
        return pulumi.get(self, "origin_access_identity")


@pulumi.output_type
class DistributionOriginVpcOriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcOriginId":
            suggest = "vpc_origin_id"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"
        elif key == "ownerAccountId":
            suggest = "owner_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionOriginVpcOriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionOriginVpcOriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionOriginVpcOriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_origin_id: _builtins.str,
                 origin_keepalive_timeout: Optional[_builtins.int] = None,
                 origin_read_timeout: Optional[_builtins.int] = None,
                 owner_account_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "vpc_origin_id", vpc_origin_id)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)
        if owner_account_id is not None:
            pulumi.set(__self__, "owner_account_id", owner_account_id)

    @_builtins.property
    @pulumi.getter(name="vpcOriginId")
    def vpc_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_origin_id")

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_read_timeout")

    @_builtins.property
    @pulumi.getter(name="ownerAccountId")
    def owner_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner_account_id")


@pulumi.output_type
class DistributionRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoRestriction":
            suggest = "geo_restriction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_restriction: 'outputs.DistributionRestrictionsGeoRestriction'):
        pulumi.set(__self__, "geo_restriction", geo_restriction)

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> 'outputs.DistributionRestrictionsGeoRestriction':
        return pulumi.get(self, "geo_restriction")


@pulumi.output_type
class DistributionRestrictionsGeoRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionType":
            suggest = "restriction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionRestrictionsGeoRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restriction_type: _builtins.str,
                 locations: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "restriction_type", restriction_type)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> _builtins.str:
        return pulumi.get(self, "restriction_type")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class DistributionTenantCustomizations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoRestriction":
            suggest = "geo_restriction"
        elif key == "webAcl":
            suggest = "web_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionTenantCustomizations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionTenantCustomizations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionTenantCustomizations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional['outputs.DistributionTenantCustomizationsCertificate'] = None,
                 geo_restriction: Optional['outputs.DistributionTenantCustomizationsGeoRestriction'] = None,
                 web_acl: Optional['outputs.DistributionTenantCustomizationsWebAcl'] = None):
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if geo_restriction is not None:
            pulumi.set(__self__, "geo_restriction", geo_restriction)
        if web_acl is not None:
            pulumi.set(__self__, "web_acl", web_acl)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.DistributionTenantCustomizationsCertificate']:
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> Optional['outputs.DistributionTenantCustomizationsGeoRestriction']:
        return pulumi.get(self, "geo_restriction")

    @_builtins.property
    @pulumi.getter(name="webAcl")
    def web_acl(self) -> Optional['outputs.DistributionTenantCustomizationsWebAcl']:
        return pulumi.get(self, "web_acl")


@pulumi.output_type
class DistributionTenantCustomizationsCertificate(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class DistributionTenantCustomizationsGeoRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionType":
            suggest = "restriction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionTenantCustomizationsGeoRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionTenantCustomizationsGeoRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionTenantCustomizationsGeoRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None,
                 restriction_type: Optional[_builtins.str] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if restriction_type is not None:
            pulumi.set(__self__, "restriction_type", restriction_type)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "restriction_type")


@pulumi.output_type
class DistributionTenantCustomizationsWebAcl(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 arn: Optional[_builtins.str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class DistributionTenantDomain(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "domain", domain)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DistributionTenantManagedCertificateRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateTransparencyLoggingPreference":
            suggest = "certificate_transparency_logging_preference"
        elif key == "primaryDomainName":
            suggest = "primary_domain_name"
        elif key == "validationTokenHost":
            suggest = "validation_token_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionTenantManagedCertificateRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionTenantManagedCertificateRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionTenantManagedCertificateRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_transparency_logging_preference: Optional[_builtins.str] = None,
                 primary_domain_name: Optional[_builtins.str] = None,
                 validation_token_host: Optional[_builtins.str] = None):
        if certificate_transparency_logging_preference is not None:
            pulumi.set(__self__, "certificate_transparency_logging_preference", certificate_transparency_logging_preference)
        if primary_domain_name is not None:
            pulumi.set(__self__, "primary_domain_name", primary_domain_name)
        if validation_token_host is not None:
            pulumi.set(__self__, "validation_token_host", validation_token_host)

    @_builtins.property
    @pulumi.getter(name="certificateTransparencyLoggingPreference")
    def certificate_transparency_logging_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_transparency_logging_preference")

    @_builtins.property
    @pulumi.getter(name="primaryDomainName")
    def primary_domain_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_domain_name")

    @_builtins.property
    @pulumi.getter(name="validationTokenHost")
    def validation_token_host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "validation_token_host")


@pulumi.output_type
class DistributionTenantParameter(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DistributionTenantTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class DistributionTrustedKeyGroup(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 items: Optional[Sequence['outputs.DistributionTrustedKeyGroupItem']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.DistributionTrustedKeyGroupItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class DistributionTrustedKeyGroupItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyGroupId":
            suggest = "key_group_id"
        elif key == "keyPairIds":
            suggest = "key_pair_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionTrustedKeyGroupItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionTrustedKeyGroupItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionTrustedKeyGroupItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_group_id: Optional[_builtins.str] = None,
                 key_pair_ids: Optional[Sequence[_builtins.str]] = None):
        if key_group_id is not None:
            pulumi.set(__self__, "key_group_id", key_group_id)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="keyGroupId")
    def key_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_group_id")

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "key_pair_ids")


@pulumi.output_type
class DistributionTrustedSigner(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 items: Optional[Sequence['outputs.DistributionTrustedSignerItem']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.DistributionTrustedSignerItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class DistributionTrustedSignerItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccountNumber":
            suggest = "aws_account_number"
        elif key == "keyPairIds":
            suggest = "key_pair_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionTrustedSignerItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionTrustedSignerItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionTrustedSignerItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_account_number: Optional[_builtins.str] = None,
                 key_pair_ids: Optional[Sequence[_builtins.str]] = None):
        if aws_account_number is not None:
            pulumi.set(__self__, "aws_account_number", aws_account_number)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="awsAccountNumber")
    def aws_account_number(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_account_number")

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "key_pair_ids")


@pulumi.output_type
class DistributionViewerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acmCertificateArn":
            suggest = "acm_certificate_arn"
        elif key == "cloudfrontDefaultCertificate":
            suggest = "cloudfront_default_certificate"
        elif key == "iamCertificateId":
            suggest = "iam_certificate_id"
        elif key == "minimumProtocolVersion":
            suggest = "minimum_protocol_version"
        elif key == "sslSupportMethod":
            suggest = "ssl_support_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionViewerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionViewerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionViewerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acm_certificate_arn: Optional[_builtins.str] = None,
                 cloudfront_default_certificate: Optional[_builtins.bool] = None,
                 iam_certificate_id: Optional[_builtins.str] = None,
                 minimum_protocol_version: Optional[_builtins.str] = None,
                 ssl_support_method: Optional[_builtins.str] = None):
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloudfront_default_certificate is not None:
            pulumi.set(__self__, "cloudfront_default_certificate", cloudfront_default_certificate)
        if iam_certificate_id is not None:
            pulumi.set(__self__, "iam_certificate_id", iam_certificate_id)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @_builtins.property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "acm_certificate_arn")

    @_builtins.property
    @pulumi.getter(name="cloudfrontDefaultCertificate")
    def cloudfront_default_certificate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cloudfront_default_certificate")

    @_builtins.property
    @pulumi.getter(name="iamCertificateId")
    def iam_certificate_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iam_certificate_id")

    @_builtins.property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "minimum_protocol_version")

    @_builtins.property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssl_support_method")


@pulumi.output_type
class DistributionViewerMtlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustStoreConfig":
            suggest = "trust_store_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionViewerMtlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionViewerMtlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionViewerMtlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 trust_store_config: Optional['outputs.DistributionViewerMtlsConfigTrustStoreConfig'] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trust_store_config is not None:
            pulumi.set(__self__, "trust_store_config", trust_store_config)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="trustStoreConfig")
    def trust_store_config(self) -> Optional['outputs.DistributionViewerMtlsConfigTrustStoreConfig']:
        return pulumi.get(self, "trust_store_config")


@pulumi.output_type
class DistributionViewerMtlsConfigTrustStoreConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustStoreId":
            suggest = "trust_store_id"
        elif key == "advertiseTrustStoreCaNames":
            suggest = "advertise_trust_store_ca_names"
        elif key == "ignoreCertificateExpiry":
            suggest = "ignore_certificate_expiry"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionViewerMtlsConfigTrustStoreConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionViewerMtlsConfigTrustStoreConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionViewerMtlsConfigTrustStoreConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_store_id: _builtins.str,
                 advertise_trust_store_ca_names: Optional[_builtins.bool] = None,
                 ignore_certificate_expiry: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "trust_store_id", trust_store_id)
        if advertise_trust_store_ca_names is not None:
            pulumi.set(__self__, "advertise_trust_store_ca_names", advertise_trust_store_ca_names)
        if ignore_certificate_expiry is not None:
            pulumi.set(__self__, "ignore_certificate_expiry", ignore_certificate_expiry)

    @_builtins.property
    @pulumi.getter(name="trustStoreId")
    def trust_store_id(self) -> _builtins.str:
        return pulumi.get(self, "trust_store_id")

    @_builtins.property
    @pulumi.getter(name="advertiseTrustStoreCaNames")
    def advertise_trust_store_ca_names(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "advertise_trust_store_ca_names")

    @_builtins.property
    @pulumi.getter(name="ignoreCertificateExpiry")
    def ignore_certificate_expiry(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ignore_certificate_expiry")


@pulumi.output_type
class FieldLevelEncryptionConfigContentTypeProfileConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTypeProfiles":
            suggest = "content_type_profiles"
        elif key == "forwardWhenContentTypeIsUnknown":
            suggest = "forward_when_content_type_is_unknown"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldLevelEncryptionConfigContentTypeProfileConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldLevelEncryptionConfigContentTypeProfileConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldLevelEncryptionConfigContentTypeProfileConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type_profiles: 'outputs.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles',
                 forward_when_content_type_is_unknown: _builtins.bool):
        pulumi.set(__self__, "content_type_profiles", content_type_profiles)
        pulumi.set(__self__, "forward_when_content_type_is_unknown", forward_when_content_type_is_unknown)

    @_builtins.property
    @pulumi.getter(name="contentTypeProfiles")
    def content_type_profiles(self) -> 'outputs.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles':
        return pulumi.get(self, "content_type_profiles")

    @_builtins.property
    @pulumi.getter(name="forwardWhenContentTypeIsUnknown")
    def forward_when_content_type_is_unknown(self) -> _builtins.bool:
        return pulumi.get(self, "forward_when_content_type_is_unknown")


@pulumi.output_type
class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfiles(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem']:
        return pulumi.get(self, "items")


@pulumi.output_type
class FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "profileId":
            suggest = "profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldLevelEncryptionConfigContentTypeProfileConfigContentTypeProfilesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: _builtins.str,
                 format: _builtins.str,
                 profile_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "format", format)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profile_id")


@pulumi.output_type
class FieldLevelEncryptionConfigQueryArgProfileConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardWhenQueryArgProfileIsUnknown":
            suggest = "forward_when_query_arg_profile_is_unknown"
        elif key == "queryArgProfiles":
            suggest = "query_arg_profiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldLevelEncryptionConfigQueryArgProfileConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldLevelEncryptionConfigQueryArgProfileConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldLevelEncryptionConfigQueryArgProfileConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_when_query_arg_profile_is_unknown: _builtins.bool,
                 query_arg_profiles: Optional['outputs.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles'] = None):
        pulumi.set(__self__, "forward_when_query_arg_profile_is_unknown", forward_when_query_arg_profile_is_unknown)
        if query_arg_profiles is not None:
            pulumi.set(__self__, "query_arg_profiles", query_arg_profiles)

    @_builtins.property
    @pulumi.getter(name="forwardWhenQueryArgProfileIsUnknown")
    def forward_when_query_arg_profile_is_unknown(self) -> _builtins.bool:
        return pulumi.get(self, "forward_when_query_arg_profile_is_unknown")

    @_builtins.property
    @pulumi.getter(name="queryArgProfiles")
    def query_arg_profiles(self) -> Optional['outputs.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles']:
        return pulumi.get(self, "query_arg_profiles")


@pulumi.output_type
class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfiles(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem']] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileId":
            suggest = "profile_id"
        elif key == "queryArg":
            suggest = "query_arg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldLevelEncryptionConfigQueryArgProfileConfigQueryArgProfilesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 profile_id: _builtins.str,
                 query_arg: _builtins.str):
        pulumi.set(__self__, "profile_id", profile_id)
        pulumi.set(__self__, "query_arg", query_arg)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> _builtins.str:
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="queryArg")
    def query_arg(self) -> _builtins.str:
        return pulumi.get(self, "query_arg")


@pulumi.output_type
class FieldLevelEncryptionProfileEncryptionEntities(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.FieldLevelEncryptionProfileEncryptionEntitiesItem']] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.FieldLevelEncryptionProfileEncryptionEntitiesItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class FieldLevelEncryptionProfileEncryptionEntitiesItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldPatterns":
            suggest = "field_patterns"
        elif key == "providerId":
            suggest = "provider_id"
        elif key == "publicKeyId":
            suggest = "public_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldLevelEncryptionProfileEncryptionEntitiesItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldLevelEncryptionProfileEncryptionEntitiesItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldLevelEncryptionProfileEncryptionEntitiesItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_patterns: 'outputs.FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns',
                 provider_id: _builtins.str,
                 public_key_id: _builtins.str):
        pulumi.set(__self__, "field_patterns", field_patterns)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "public_key_id", public_key_id)

    @_builtins.property
    @pulumi.getter(name="fieldPatterns")
    def field_patterns(self) -> 'outputs.FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns':
        return pulumi.get(self, "field_patterns")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        return pulumi.get(self, "provider_id")

    @_builtins.property
    @pulumi.getter(name="publicKeyId")
    def public_key_id(self) -> _builtins.str:
        return pulumi.get(self, "public_key_id")


@pulumi.output_type
class FieldLevelEncryptionProfileEncryptionEntitiesItemFieldPatterns(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class KeyValueStoreTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class KeyvaluestoreKeysExclusiveResourceKeyValuePair(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key to put.
        :param _builtins.str value: The value to put.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key to put.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to put.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MonitoringSubscriptionMonitoringSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "realtimeMetricsSubscriptionConfig":
            suggest = "realtime_metrics_subscription_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringSubscriptionMonitoringSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringSubscriptionMonitoringSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringSubscriptionMonitoringSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 realtime_metrics_subscription_config: 'outputs.MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig'):
        pulumi.set(__self__, "realtime_metrics_subscription_config", realtime_metrics_subscription_config)

    @_builtins.property
    @pulumi.getter(name="realtimeMetricsSubscriptionConfig")
    def realtime_metrics_subscription_config(self) -> 'outputs.MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig':
        return pulumi.get(self, "realtime_metrics_subscription_config")


@pulumi.output_type
class MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "realtimeMetricsSubscriptionStatus":
            suggest = "realtime_metrics_subscription_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringSubscriptionMonitoringSubscriptionRealtimeMetricsSubscriptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 realtime_metrics_subscription_status: _builtins.str):
        pulumi.set(__self__, "realtime_metrics_subscription_status", realtime_metrics_subscription_status)

    @_builtins.property
    @pulumi.getter(name="realtimeMetricsSubscriptionStatus")
    def realtime_metrics_subscription_status(self) -> _builtins.str:
        return pulumi.get(self, "realtime_metrics_subscription_status")


@pulumi.output_type
class MultitenantDistributionActiveTrustedKeyGroup(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 items: Optional[Sequence['outputs.MultitenantDistributionActiveTrustedKeyGroupItem']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.MultitenantDistributionActiveTrustedKeyGroupItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionActiveTrustedKeyGroupItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyGroupId":
            suggest = "key_group_id"
        elif key == "keyPairIds":
            suggest = "key_pair_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionActiveTrustedKeyGroupItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionActiveTrustedKeyGroupItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionActiveTrustedKeyGroupItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_group_id: Optional[_builtins.str] = None,
                 key_pair_ids: Optional[Sequence[_builtins.str]] = None):
        if key_group_id is not None:
            pulumi.set(__self__, "key_group_id", key_group_id)
        if key_pair_ids is not None:
            pulumi.set(__self__, "key_pair_ids", key_pair_ids)

    @_builtins.property
    @pulumi.getter(name="keyGroupId")
    def key_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_group_id")

    @_builtins.property
    @pulumi.getter(name="keyPairIds")
    def key_pair_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "key_pair_ids")


@pulumi.output_type
class MultitenantDistributionCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathPattern":
            suggest = "path_pattern"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path_pattern: _builtins.str,
                 target_origin_id: _builtins.str,
                 viewer_protocol_policy: _builtins.str,
                 allowed_methods: Optional['outputs.MultitenantDistributionCacheBehaviorAllowedMethods'] = None,
                 cache_policy_id: Optional[_builtins.str] = None,
                 compress: Optional[_builtins.bool] = None,
                 field_level_encryption_id: Optional[_builtins.str] = None,
                 function_associations: Optional[Sequence['outputs.MultitenantDistributionCacheBehaviorFunctionAssociation']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.MultitenantDistributionCacheBehaviorLambdaFunctionAssociation']] = None,
                 origin_request_policy_id: Optional[_builtins.str] = None,
                 realtime_log_config_arn: Optional[_builtins.str] = None,
                 response_headers_policy_id: Optional[_builtins.str] = None,
                 trusted_key_groups: Optional['outputs.MultitenantDistributionCacheBehaviorTrustedKeyGroups'] = None):
        pulumi.set(__self__, "path_pattern", path_pattern)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)

    @_builtins.property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> _builtins.str:
        return pulumi.get(self, "path_pattern")

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "target_origin_id")

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "viewer_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional['outputs.MultitenantDistributionCacheBehaviorAllowedMethods']:
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cache_policy_id")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_level_encryption_id")

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.MultitenantDistributionCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.MultitenantDistributionCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_request_policy_id")

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_headers_policy_id")

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional['outputs.MultitenantDistributionCacheBehaviorTrustedKeyGroups']:
        return pulumi.get(self, "trusted_key_groups")


@pulumi.output_type
class MultitenantDistributionCacheBehaviorAllowedMethods(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachedMethods":
            suggest = "cached_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionCacheBehaviorAllowedMethods. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionCacheBehaviorAllowedMethods.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionCacheBehaviorAllowedMethods.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cached_methods: Sequence[_builtins.str],
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cached_methods")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class MultitenantDistributionCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaFunctionArn":
            suggest = "lambda_function_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 lambda_function_arn: _builtins.str,
                 include_body: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_function_arn")

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_body")


@pulumi.output_type
class MultitenantDistributionCacheBehaviorTrustedKeyGroups(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 items: Optional[Sequence[_builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionCustomErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorCachingMinTtl":
            suggest = "error_caching_min_ttl"
        elif key == "responseCode":
            suggest = "response_code"
        elif key == "responsePagePath":
            suggest = "response_page_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionCustomErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionCustomErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionCustomErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: _builtins.int,
                 error_caching_min_ttl: Optional[_builtins.int] = None,
                 response_code: Optional[_builtins.str] = None,
                 response_page_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "error_code", error_code)
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.int:
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorCachingMinTtl")
    def error_caching_min_ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "error_caching_min_ttl")

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_page_path")


@pulumi.output_type
class MultitenantDistributionDefaultCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionDefaultCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionDefaultCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionDefaultCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_origin_id: _builtins.str,
                 viewer_protocol_policy: _builtins.str,
                 allowed_methods: Optional['outputs.MultitenantDistributionDefaultCacheBehaviorAllowedMethods'] = None,
                 cache_policy_id: Optional[_builtins.str] = None,
                 compress: Optional[_builtins.bool] = None,
                 field_level_encryption_id: Optional[_builtins.str] = None,
                 function_associations: Optional[Sequence['outputs.MultitenantDistributionDefaultCacheBehaviorFunctionAssociation']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation']] = None,
                 origin_request_policy_id: Optional[_builtins.str] = None,
                 realtime_log_config_arn: Optional[_builtins.str] = None,
                 response_headers_policy_id: Optional[_builtins.str] = None,
                 trusted_key_groups: Optional['outputs.MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroups'] = None):
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)

    @_builtins.property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "target_origin_id")

    @_builtins.property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "viewer_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional['outputs.MultitenantDistributionDefaultCacheBehaviorAllowedMethods']:
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cache_policy_id")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_level_encryption_id")

    @_builtins.property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.MultitenantDistributionDefaultCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @_builtins.property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_request_policy_id")

    @_builtins.property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @_builtins.property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "response_headers_policy_id")

    @_builtins.property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional['outputs.MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroups']:
        return pulumi.get(self, "trusted_key_groups")


@pulumi.output_type
class MultitenantDistributionDefaultCacheBehaviorAllowedMethods(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachedMethods":
            suggest = "cached_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionDefaultCacheBehaviorAllowedMethods. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionDefaultCacheBehaviorAllowedMethods.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionDefaultCacheBehaviorAllowedMethods.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cached_methods: Sequence[_builtins.str],
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cached_methods")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionDefaultCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionDefaultCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaFunctionArn":
            suggest = "lambda_function_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: _builtins.str,
                 lambda_function_arn: _builtins.str,
                 include_body: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_function_arn")

    @_builtins.property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_body")


@pulumi.output_type
class MultitenantDistributionDefaultCacheBehaviorTrustedKeyGroups(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 items: Optional[Sequence[_builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "connectionAttempts":
            suggest = "connection_attempts"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customHeaders":
            suggest = "custom_headers"
        elif key == "customOriginConfigs":
            suggest = "custom_origin_configs"
        elif key == "originAccessControlId":
            suggest = "origin_access_control_id"
        elif key == "originPath":
            suggest = "origin_path"
        elif key == "originShields":
            suggest = "origin_shields"
        elif key == "responseCompletionTimeout":
            suggest = "response_completion_timeout"
        elif key == "vpcOriginConfigs":
            suggest = "vpc_origin_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 id: _builtins.str,
                 connection_attempts: Optional[_builtins.int] = None,
                 connection_timeout: Optional[_builtins.int] = None,
                 custom_headers: Optional[Sequence['outputs.MultitenantDistributionOriginCustomHeader']] = None,
                 custom_origin_configs: Optional[Sequence['outputs.MultitenantDistributionOriginCustomOriginConfig']] = None,
                 origin_access_control_id: Optional[_builtins.str] = None,
                 origin_path: Optional[_builtins.str] = None,
                 origin_shields: Optional[Sequence['outputs.MultitenantDistributionOriginOriginShield']] = None,
                 response_completion_timeout: Optional[_builtins.int] = None,
                 vpc_origin_configs: Optional[Sequence['outputs.MultitenantDistributionOriginVpcOriginConfig']] = None):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "id", id)
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_origin_configs is not None:
            pulumi.set(__self__, "custom_origin_configs", custom_origin_configs)
        if origin_access_control_id is not None:
            pulumi.set(__self__, "origin_access_control_id", origin_access_control_id)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shields is not None:
            pulumi.set(__self__, "origin_shields", origin_shields)
        if response_completion_timeout is not None:
            pulumi.set(__self__, "response_completion_timeout", response_completion_timeout)
        if vpc_origin_configs is not None:
            pulumi.set(__self__, "vpc_origin_configs", vpc_origin_configs)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connection_attempts")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.MultitenantDistributionOriginCustomHeader']]:
        return pulumi.get(self, "custom_headers")

    @_builtins.property
    @pulumi.getter(name="customOriginConfigs")
    def custom_origin_configs(self) -> Optional[Sequence['outputs.MultitenantDistributionOriginCustomOriginConfig']]:
        return pulumi.get(self, "custom_origin_configs")

    @_builtins.property
    @pulumi.getter(name="originAccessControlId")
    def origin_access_control_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_access_control_id")

    @_builtins.property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_path")

    @_builtins.property
    @pulumi.getter(name="originShields")
    def origin_shields(self) -> Optional[Sequence['outputs.MultitenantDistributionOriginOriginShield']]:
        return pulumi.get(self, "origin_shields")

    @_builtins.property
    @pulumi.getter(name="responseCompletionTimeout")
    def response_completion_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "response_completion_timeout")

    @_builtins.property
    @pulumi.getter(name="vpcOriginConfigs")
    def vpc_origin_configs(self) -> Optional[Sequence['outputs.MultitenantDistributionOriginVpcOriginConfig']]:
        return pulumi.get(self, "vpc_origin_configs")


@pulumi.output_type
class MultitenantDistributionOriginCustomHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginCustomHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginCustomHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginCustomHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str,
                 header_value: _builtins.str):
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> _builtins.str:
        return pulumi.get(self, "header_value")


@pulumi.output_type
class MultitenantDistributionOriginCustomOriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originSslProtocols":
            suggest = "origin_ssl_protocols"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginCustomOriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginCustomOriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginCustomOriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_port: _builtins.int,
                 https_port: _builtins.int,
                 origin_protocol_policy: _builtins.str,
                 origin_ssl_protocols: Sequence[_builtins.str],
                 ip_address_type: Optional[_builtins.str] = None,
                 origin_keepalive_timeout: Optional[_builtins.int] = None,
                 origin_read_timeout: Optional[_builtins.int] = None):
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> _builtins.int:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "origin_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "origin_ssl_protocols")

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address_type")

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_read_timeout")


@pulumi.output_type
class MultitenantDistributionOriginGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"
        elif key == "failoverCriteria":
            suggest = "failover_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_id: _builtins.str,
                 failover_criteria: Optional['outputs.MultitenantDistributionOriginGroupFailoverCriteria'] = None,
                 members: Optional[Sequence['outputs.MultitenantDistributionOriginGroupMember']] = None):
        pulumi.set(__self__, "origin_id", origin_id)
        if failover_criteria is not None:
            pulumi.set(__self__, "failover_criteria", failover_criteria)
        if members is not None:
            pulumi.set(__self__, "members", members)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        return pulumi.get(self, "origin_id")

    @_builtins.property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> Optional['outputs.MultitenantDistributionOriginGroupFailoverCriteria']:
        return pulumi.get(self, "failover_criteria")

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[Sequence['outputs.MultitenantDistributionOriginGroupMember']]:
        return pulumi.get(self, "members")


@pulumi.output_type
class MultitenantDistributionOriginGroupFailoverCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginGroupFailoverCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: Sequence[_builtins.int]):
        pulumi.set(__self__, "status_codes", status_codes)

    @_builtins.property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class MultitenantDistributionOriginGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_id: _builtins.str):
        pulumi.set(__self__, "origin_id", origin_id)

    @_builtins.property
    @pulumi.getter(name="originId")
    def origin_id(self) -> _builtins.str:
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class MultitenantDistributionOriginOriginShield(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originShieldRegion":
            suggest = "origin_shield_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginOriginShield. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginOriginShield.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginOriginShield.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 origin_shield_region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if origin_shield_region is not None:
            pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_shield_region")


@pulumi.output_type
class MultitenantDistributionOriginVpcOriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcOriginId":
            suggest = "vpc_origin_id"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionOriginVpcOriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionOriginVpcOriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionOriginVpcOriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_origin_id: _builtins.str,
                 origin_keepalive_timeout: Optional[_builtins.int] = None,
                 origin_read_timeout: Optional[_builtins.int] = None):
        pulumi.set(__self__, "vpc_origin_id", vpc_origin_id)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @_builtins.property
    @pulumi.getter(name="vpcOriginId")
    def vpc_origin_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_origin_id")

    @_builtins.property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_keepalive_timeout")

    @_builtins.property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_read_timeout")


@pulumi.output_type
class MultitenantDistributionRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoRestriction":
            suggest = "geo_restriction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_restriction: Optional['outputs.MultitenantDistributionRestrictionsGeoRestriction'] = None):
        if geo_restriction is not None:
            pulumi.set(__self__, "geo_restriction", geo_restriction)

    @_builtins.property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> Optional['outputs.MultitenantDistributionRestrictionsGeoRestriction']:
        return pulumi.get(self, "geo_restriction")


@pulumi.output_type
class MultitenantDistributionRestrictionsGeoRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionType":
            suggest = "restriction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionRestrictionsGeoRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restriction_type: _builtins.str,
                 items: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "restriction_type", restriction_type)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> _builtins.str:
        return pulumi.get(self, "restriction_type")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class MultitenantDistributionTenantConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterDefinitions":
            suggest = "parameter_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionTenantConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionTenantConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionTenantConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_definitions: Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinition']] = None):
        if parameter_definitions is not None:
            pulumi.set(__self__, "parameter_definitions", parameter_definitions)

    @_builtins.property
    @pulumi.getter(name="parameterDefinitions")
    def parameter_definitions(self) -> Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinition']]:
        return pulumi.get(self, "parameter_definitions")


@pulumi.output_type
class MultitenantDistributionTenantConfigParameterDefinition(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 definitions: Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinitionDefinition']] = None):
        pulumi.set(__self__, "name", name)
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def definitions(self) -> Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinitionDefinition']]:
        return pulumi.get(self, "definitions")


@pulumi.output_type
class MultitenantDistributionTenantConfigParameterDefinitionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stringSchemas":
            suggest = "string_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionTenantConfigParameterDefinitionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionTenantConfigParameterDefinitionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionTenantConfigParameterDefinitionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 string_schemas: Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema']] = None):
        if string_schemas is not None:
            pulumi.set(__self__, "string_schemas", string_schemas)

    @_builtins.property
    @pulumi.getter(name="stringSchemas")
    def string_schemas(self) -> Optional[Sequence['outputs.MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema']]:
        return pulumi.get(self, "string_schemas")


@pulumi.output_type
class MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionTenantConfigParameterDefinitionDefinitionStringSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required: _builtins.bool,
                 comment: Optional[_builtins.str] = None,
                 default_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "required", required)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_value")


@pulumi.output_type
class MultitenantDistributionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class MultitenantDistributionViewerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acmCertificateArn":
            suggest = "acm_certificate_arn"
        elif key == "cloudfrontDefaultCertificate":
            suggest = "cloudfront_default_certificate"
        elif key == "minimumProtocolVersion":
            suggest = "minimum_protocol_version"
        elif key == "sslSupportMethod":
            suggest = "ssl_support_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultitenantDistributionViewerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultitenantDistributionViewerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultitenantDistributionViewerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acm_certificate_arn: Optional[_builtins.str] = None,
                 cloudfront_default_certificate: Optional[_builtins.bool] = None,
                 minimum_protocol_version: Optional[_builtins.str] = None,
                 ssl_support_method: Optional[_builtins.str] = None):
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloudfront_default_certificate is not None:
            pulumi.set(__self__, "cloudfront_default_certificate", cloudfront_default_certificate)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @_builtins.property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "acm_certificate_arn")

    @_builtins.property
    @pulumi.getter(name="cloudfrontDefaultCertificate")
    def cloudfront_default_certificate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cloudfront_default_certificate")

    @_builtins.property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "minimum_protocol_version")

    @_builtins.property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssl_support_method")


@pulumi.output_type
class OriginRequestPolicyCookiesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieBehavior":
            suggest = "cookie_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginRequestPolicyCookiesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginRequestPolicyCookiesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginRequestPolicyCookiesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_behavior: _builtins.str,
                 cookies: Optional['outputs.OriginRequestPolicyCookiesConfigCookies'] = None):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> _builtins.str:
        return pulumi.get(self, "cookie_behavior")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.OriginRequestPolicyCookiesConfigCookies']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class OriginRequestPolicyCookiesConfigCookies(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class OriginRequestPolicyHeadersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerBehavior":
            suggest = "header_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginRequestPolicyHeadersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginRequestPolicyHeadersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginRequestPolicyHeadersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_behavior: Optional[_builtins.str] = None,
                 headers: Optional['outputs.OriginRequestPolicyHeadersConfigHeaders'] = None):
        if header_behavior is not None:
            pulumi.set(__self__, "header_behavior", header_behavior)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "header_behavior")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional['outputs.OriginRequestPolicyHeadersConfigHeaders']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class OriginRequestPolicyHeadersConfigHeaders(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class OriginRequestPolicyQueryStringsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryStringBehavior":
            suggest = "query_string_behavior"
        elif key == "queryStrings":
            suggest = "query_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginRequestPolicyQueryStringsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginRequestPolicyQueryStringsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginRequestPolicyQueryStringsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string_behavior: _builtins.str,
                 query_strings: Optional['outputs.OriginRequestPolicyQueryStringsConfigQueryStrings'] = None):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> _builtins.str:
        return pulumi.get(self, "query_string_behavior")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional['outputs.OriginRequestPolicyQueryStringsConfigQueryStrings']:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class OriginRequestPolicyQueryStringsConfigQueryStrings(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class RealtimeLogConfigEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kinesisStreamConfig":
            suggest = "kinesis_stream_config"
        elif key == "streamType":
            suggest = "stream_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealtimeLogConfigEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealtimeLogConfigEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealtimeLogConfigEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kinesis_stream_config: 'outputs.RealtimeLogConfigEndpointKinesisStreamConfig',
                 stream_type: _builtins.str):
        pulumi.set(__self__, "kinesis_stream_config", kinesis_stream_config)
        pulumi.set(__self__, "stream_type", stream_type)

    @_builtins.property
    @pulumi.getter(name="kinesisStreamConfig")
    def kinesis_stream_config(self) -> 'outputs.RealtimeLogConfigEndpointKinesisStreamConfig':
        return pulumi.get(self, "kinesis_stream_config")

    @_builtins.property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> _builtins.str:
        return pulumi.get(self, "stream_type")


@pulumi.output_type
class RealtimeLogConfigEndpointKinesisStreamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "streamArn":
            suggest = "stream_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealtimeLogConfigEndpointKinesisStreamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealtimeLogConfigEndpointKinesisStreamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealtimeLogConfigEndpointKinesisStreamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 stream_arn: _builtins.str):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_arn", stream_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> _builtins.str:
        return pulumi.get(self, "stream_arn")


@pulumi.output_type
class ResponseHeadersPolicyCorsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessControlAllowCredentials":
            suggest = "access_control_allow_credentials"
        elif key == "accessControlAllowHeaders":
            suggest = "access_control_allow_headers"
        elif key == "accessControlAllowMethods":
            suggest = "access_control_allow_methods"
        elif key == "accessControlAllowOrigins":
            suggest = "access_control_allow_origins"
        elif key == "originOverride":
            suggest = "origin_override"
        elif key == "accessControlExposeHeaders":
            suggest = "access_control_expose_headers"
        elif key == "accessControlMaxAgeSec":
            suggest = "access_control_max_age_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicyCorsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicyCorsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicyCorsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_control_allow_credentials: _builtins.bool,
                 access_control_allow_headers: 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders',
                 access_control_allow_methods: 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowMethods',
                 access_control_allow_origins: 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins',
                 origin_override: _builtins.bool,
                 access_control_expose_headers: Optional['outputs.ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders'] = None,
                 access_control_max_age_sec: Optional[_builtins.int] = None):
        pulumi.set(__self__, "access_control_allow_credentials", access_control_allow_credentials)
        pulumi.set(__self__, "access_control_allow_headers", access_control_allow_headers)
        pulumi.set(__self__, "access_control_allow_methods", access_control_allow_methods)
        pulumi.set(__self__, "access_control_allow_origins", access_control_allow_origins)
        pulumi.set(__self__, "origin_override", origin_override)
        if access_control_expose_headers is not None:
            pulumi.set(__self__, "access_control_expose_headers", access_control_expose_headers)
        if access_control_max_age_sec is not None:
            pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowCredentials")
    def access_control_allow_credentials(self) -> _builtins.bool:
        return pulumi.get(self, "access_control_allow_credentials")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowHeaders")
    def access_control_allow_headers(self) -> 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders':
        return pulumi.get(self, "access_control_allow_headers")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowMethods")
    def access_control_allow_methods(self) -> 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowMethods':
        return pulumi.get(self, "access_control_allow_methods")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowOrigins")
    def access_control_allow_origins(self) -> 'outputs.ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins':
        return pulumi.get(self, "access_control_allow_origins")

    @_builtins.property
    @pulumi.getter(name="originOverride")
    def origin_override(self) -> _builtins.bool:
        return pulumi.get(self, "origin_override")

    @_builtins.property
    @pulumi.getter(name="accessControlExposeHeaders")
    def access_control_expose_headers(self) -> Optional['outputs.ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders']:
        return pulumi.get(self, "access_control_expose_headers")

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "access_control_max_age_sec")


@pulumi.output_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowHeaders(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowMethods(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyCorsConfigAccessControlAllowOrigins(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyCorsConfigAccessControlExposeHeaders(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence[_builtins.str]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyCustomHeadersConfig(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.ResponseHeadersPolicyCustomHeadersConfigItem']] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.ResponseHeadersPolicyCustomHeadersConfigItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyCustomHeadersConfigItem(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 override: _builtins.bool,
                 value: _builtins.str):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ResponseHeadersPolicyRemoveHeadersConfig(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.ResponseHeadersPolicyRemoveHeadersConfigItem']] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.ResponseHeadersPolicyRemoveHeadersConfigItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class ResponseHeadersPolicyRemoveHeadersConfigItem(dict):
    def __init__(__self__, *,
                 header: _builtins.str):
        pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentSecurityPolicy":
            suggest = "content_security_policy"
        elif key == "contentTypeOptions":
            suggest = "content_type_options"
        elif key == "frameOptions":
            suggest = "frame_options"
        elif key == "referrerPolicy":
            suggest = "referrer_policy"
        elif key == "strictTransportSecurity":
            suggest = "strict_transport_security"
        elif key == "xssProtection":
            suggest = "xss_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_security_policy: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy'] = None,
                 content_type_options: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions'] = None,
                 frame_options: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigFrameOptions'] = None,
                 referrer_policy: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy'] = None,
                 strict_transport_security: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity'] = None,
                 xss_protection: Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigXssProtection'] = None):
        if content_security_policy is not None:
            pulumi.set(__self__, "content_security_policy", content_security_policy)
        if content_type_options is not None:
            pulumi.set(__self__, "content_type_options", content_type_options)
        if frame_options is not None:
            pulumi.set(__self__, "frame_options", frame_options)
        if referrer_policy is not None:
            pulumi.set(__self__, "referrer_policy", referrer_policy)
        if strict_transport_security is not None:
            pulumi.set(__self__, "strict_transport_security", strict_transport_security)
        if xss_protection is not None:
            pulumi.set(__self__, "xss_protection", xss_protection)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy']:
        return pulumi.get(self, "content_security_policy")

    @_builtins.property
    @pulumi.getter(name="contentTypeOptions")
    def content_type_options(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions']:
        return pulumi.get(self, "content_type_options")

    @_builtins.property
    @pulumi.getter(name="frameOptions")
    def frame_options(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigFrameOptions']:
        return pulumi.get(self, "frame_options")

    @_builtins.property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy']:
        return pulumi.get(self, "referrer_policy")

    @_builtins.property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity']:
        return pulumi.get(self, "strict_transport_security")

    @_builtins.property
    @pulumi.getter(name="xssProtection")
    def xss_protection(self) -> Optional['outputs.ResponseHeadersPolicySecurityHeadersConfigXssProtection']:
        return pulumi.get(self, "xss_protection")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentSecurityPolicy":
            suggest = "content_security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_security_policy: _builtins.str,
                 override: _builtins.bool):
        pulumi.set(__self__, "content_security_policy", content_security_policy)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> _builtins.str:
        return pulumi.get(self, "content_security_policy")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigContentTypeOptions(dict):
    def __init__(__self__, *,
                 override: _builtins.bool):
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigFrameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameOption":
            suggest = "frame_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfigFrameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigFrameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigFrameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frame_option: _builtins.str,
                 override: _builtins.bool):
        pulumi.set(__self__, "frame_option", frame_option)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="frameOption")
    def frame_option(self) -> _builtins.str:
        return pulumi.get(self, "frame_option")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referrerPolicy":
            suggest = "referrer_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigReferrerPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override: _builtins.bool,
                 referrer_policy: _builtins.str):
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "referrer_policy", referrer_policy)

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> _builtins.str:
        return pulumi.get(self, "referrer_policy")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessControlMaxAgeSec":
            suggest = "access_control_max_age_sec"
        elif key == "includeSubdomains":
            suggest = "include_subdomains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_control_max_age_sec: _builtins.int,
                 override: _builtins.bool,
                 include_subdomains: Optional[_builtins.bool] = None,
                 preload: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)
        pulumi.set(__self__, "override", override)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preload is not None:
            pulumi.set(__self__, "preload", preload)

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> _builtins.int:
        return pulumi.get(self, "access_control_max_age_sec")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_subdomains")

    @_builtins.property
    @pulumi.getter
    def preload(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "preload")


@pulumi.output_type
class ResponseHeadersPolicySecurityHeadersConfigXssProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modeBlock":
            suggest = "mode_block"
        elif key == "reportUri":
            suggest = "report_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicySecurityHeadersConfigXssProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigXssProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicySecurityHeadersConfigXssProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override: _builtins.bool,
                 protection: _builtins.bool,
                 mode_block: Optional[_builtins.bool] = None,
                 report_uri: Optional[_builtins.str] = None):
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "protection", protection)
        if mode_block is not None:
            pulumi.set(__self__, "mode_block", mode_block)
        if report_uri is not None:
            pulumi.set(__self__, "report_uri", report_uri)

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter
    def protection(self) -> _builtins.bool:
        return pulumi.get(self, "protection")

    @_builtins.property
    @pulumi.getter(name="modeBlock")
    def mode_block(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "mode_block")

    @_builtins.property
    @pulumi.getter(name="reportUri")
    def report_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "report_uri")


@pulumi.output_type
class ResponseHeadersPolicyServerTimingHeadersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingRate":
            suggest = "sampling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseHeadersPolicyServerTimingHeadersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseHeadersPolicyServerTimingHeadersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseHeadersPolicyServerTimingHeadersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.float):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.float:
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class TrustStoreCaCertificatesBundleSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificatesBundleS3Location":
            suggest = "ca_certificates_bundle_s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrustStoreCaCertificatesBundleSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrustStoreCaCertificatesBundleSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrustStoreCaCertificatesBundleSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates_bundle_s3_location: Optional['outputs.TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3Location'] = None):
        if ca_certificates_bundle_s3_location is not None:
            pulumi.set(__self__, "ca_certificates_bundle_s3_location", ca_certificates_bundle_s3_location)

    @_builtins.property
    @pulumi.getter(name="caCertificatesBundleS3Location")
    def ca_certificates_bundle_s3_location(self) -> Optional['outputs.TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3Location']:
        return pulumi.get(self, "ca_certificates_bundle_s3_location")


@pulumi.output_type
class TrustStoreCaCertificatesBundleSourceCaCertificatesBundleS3Location(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 key: _builtins.str,
                 region: _builtins.str,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class TrustStoreTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcOriginTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VpcOriginVpcOriginEndpointConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originSslProtocols":
            suggest = "origin_ssl_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcOriginVpcOriginEndpointConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcOriginVpcOriginEndpointConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcOriginVpcOriginEndpointConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 http_port: _builtins.int,
                 https_port: _builtins.int,
                 name: _builtins.str,
                 origin_protocol_policy: _builtins.str,
                 origin_ssl_protocols: Optional['outputs.VpcOriginVpcOriginEndpointConfigOriginSslProtocols'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        if origin_ssl_protocols is not None:
            pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> _builtins.int:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> _builtins.str:
        return pulumi.get(self, "origin_protocol_policy")

    @_builtins.property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> Optional['outputs.VpcOriginVpcOriginEndpointConfigOriginSslProtocols']:
        return pulumi.get(self, "origin_ssl_protocols")


@pulumi.output_type
class VpcOriginVpcOriginEndpointConfigOriginSslProtocols(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str],
                 quantity: _builtins.int):
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginResult(dict):
    def __init__(__self__, *,
                 cookies_configs: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigResult'],
                 enable_accept_encoding_brotli: _builtins.bool,
                 enable_accept_encoding_gzip: _builtins.bool,
                 headers_configs: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigResult'],
                 query_strings_configs: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigResult']):
        pulumi.set(__self__, "cookies_configs", cookies_configs)
        pulumi.set(__self__, "enable_accept_encoding_brotli", enable_accept_encoding_brotli)
        pulumi.set(__self__, "enable_accept_encoding_gzip", enable_accept_encoding_gzip)
        pulumi.set(__self__, "headers_configs", headers_configs)
        pulumi.set(__self__, "query_strings_configs", query_strings_configs)

    @_builtins.property
    @pulumi.getter(name="cookiesConfigs")
    def cookies_configs(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigResult']:
        return pulumi.get(self, "cookies_configs")

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingBrotli")
    def enable_accept_encoding_brotli(self) -> _builtins.bool:
        return pulumi.get(self, "enable_accept_encoding_brotli")

    @_builtins.property
    @pulumi.getter(name="enableAcceptEncodingGzip")
    def enable_accept_encoding_gzip(self) -> _builtins.bool:
        return pulumi.get(self, "enable_accept_encoding_gzip")

    @_builtins.property
    @pulumi.getter(name="headersConfigs")
    def headers_configs(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigResult']:
        return pulumi.get(self, "headers_configs")

    @_builtins.property
    @pulumi.getter(name="queryStringsConfigs")
    def query_strings_configs(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigResult']:
        return pulumi.get(self, "query_strings_configs")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigResult(dict):
    def __init__(__self__, *,
                 cookie_behavior: _builtins.str,
                 cookies: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookieResult']):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> _builtins.str:
        return pulumi.get(self, "cookie_behavior")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookieResult']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginCookiesConfigCookieResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigResult(dict):
    def __init__(__self__, *,
                 header_behavior: _builtins.str,
                 headers: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaderResult']):
        pulumi.set(__self__, "header_behavior", header_behavior)
        pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> _builtins.str:
        return pulumi.get(self, "header_behavior")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaderResult']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaderResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigResult(dict):
    def __init__(__self__, *,
                 query_string_behavior: _builtins.str,
                 query_strings: Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringResult']):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> _builtins.str:
        return pulumi.get(self, "query_string_behavior")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Sequence['outputs.GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringResult']:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class GetCachePolicyParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDistributionTenantCustomizationResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetDistributionTenantCustomizationCertificateResult'],
                 geo_restrictions: Sequence['outputs.GetDistributionTenantCustomizationGeoRestrictionResult'],
                 web_acls: Sequence['outputs.GetDistributionTenantCustomizationWebAclResult']):
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "geo_restrictions", geo_restrictions)
        pulumi.set(__self__, "web_acls", web_acls)

    @_builtins.property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetDistributionTenantCustomizationCertificateResult']:
        return pulumi.get(self, "certificates")

    @_builtins.property
    @pulumi.getter(name="geoRestrictions")
    def geo_restrictions(self) -> Sequence['outputs.GetDistributionTenantCustomizationGeoRestrictionResult']:
        return pulumi.get(self, "geo_restrictions")

    @_builtins.property
    @pulumi.getter(name="webAcls")
    def web_acls(self) -> Sequence['outputs.GetDistributionTenantCustomizationWebAclResult']:
        return pulumi.get(self, "web_acls")


@pulumi.output_type
class GetDistributionTenantCustomizationCertificateResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str):
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")


@pulumi.output_type
class GetDistributionTenantCustomizationGeoRestrictionResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str],
                 restriction_type: _builtins.str):
        pulumi.set(__self__, "locations", locations)
        pulumi.set(__self__, "restriction_type", restriction_type)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> _builtins.str:
        return pulumi.get(self, "restriction_type")


@pulumi.output_type
class GetDistributionTenantCustomizationWebAclResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 arn: _builtins.str):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")


@pulumi.output_type
class GetDistributionTenantDomainResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDistributionTenantManagedCertificateRequestResult(dict):
    def __init__(__self__, *,
                 certificate_transparency_logging_preference: _builtins.str,
                 primary_domain_name: _builtins.str,
                 validation_token_host: _builtins.str):
        pulumi.set(__self__, "certificate_transparency_logging_preference", certificate_transparency_logging_preference)
        pulumi.set(__self__, "primary_domain_name", primary_domain_name)
        pulumi.set(__self__, "validation_token_host", validation_token_host)

    @_builtins.property
    @pulumi.getter(name="certificateTransparencyLoggingPreference")
    def certificate_transparency_logging_preference(self) -> _builtins.str:
        return pulumi.get(self, "certificate_transparency_logging_preference")

    @_builtins.property
    @pulumi.getter(name="primaryDomainName")
    def primary_domain_name(self) -> _builtins.str:
        return pulumi.get(self, "primary_domain_name")

    @_builtins.property
    @pulumi.getter(name="validationTokenHost")
    def validation_token_host(self) -> _builtins.str:
        return pulumi.get(self, "validation_token_host")


@pulumi.output_type
class GetDistributionTenantParameterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetOriginRequestPolicyCookiesConfigResult(dict):
    def __init__(__self__, *,
                 cookie_behavior: _builtins.str,
                 cookies: Sequence['outputs.GetOriginRequestPolicyCookiesConfigCookieResult']):
        pulumi.set(__self__, "cookie_behavior", cookie_behavior)
        pulumi.set(__self__, "cookies", cookies)

    @_builtins.property
    @pulumi.getter(name="cookieBehavior")
    def cookie_behavior(self) -> _builtins.str:
        return pulumi.get(self, "cookie_behavior")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.GetOriginRequestPolicyCookiesConfigCookieResult']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class GetOriginRequestPolicyCookiesConfigCookieResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOriginRequestPolicyHeadersConfigResult(dict):
    def __init__(__self__, *,
                 header_behavior: _builtins.str,
                 headers: Sequence['outputs.GetOriginRequestPolicyHeadersConfigHeaderResult']):
        pulumi.set(__self__, "header_behavior", header_behavior)
        pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter(name="headerBehavior")
    def header_behavior(self) -> _builtins.str:
        return pulumi.get(self, "header_behavior")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetOriginRequestPolicyHeadersConfigHeaderResult']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetOriginRequestPolicyHeadersConfigHeaderResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOriginRequestPolicyQueryStringsConfigResult(dict):
    def __init__(__self__, *,
                 query_string_behavior: _builtins.str,
                 query_strings: Sequence['outputs.GetOriginRequestPolicyQueryStringsConfigQueryStringResult']):
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> _builtins.str:
        return pulumi.get(self, "query_string_behavior")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Sequence['outputs.GetOriginRequestPolicyQueryStringsConfigQueryStringResult']:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class GetOriginRequestPolicyQueryStringsConfigQueryStringResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetRealtimeLogConfigEndpointResult(dict):
    def __init__(__self__, *,
                 kinesis_stream_configs: Sequence['outputs.GetRealtimeLogConfigEndpointKinesisStreamConfigResult'],
                 stream_type: _builtins.str):
        pulumi.set(__self__, "kinesis_stream_configs", kinesis_stream_configs)
        pulumi.set(__self__, "stream_type", stream_type)

    @_builtins.property
    @pulumi.getter(name="kinesisStreamConfigs")
    def kinesis_stream_configs(self) -> Sequence['outputs.GetRealtimeLogConfigEndpointKinesisStreamConfigResult']:
        return pulumi.get(self, "kinesis_stream_configs")

    @_builtins.property
    @pulumi.getter(name="streamType")
    def stream_type(self) -> _builtins.str:
        return pulumi.get(self, "stream_type")


@pulumi.output_type
class GetRealtimeLogConfigEndpointKinesisStreamConfigResult(dict):
    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 stream_arn: _builtins.str):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_arn", stream_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> _builtins.str:
        return pulumi.get(self, "stream_arn")


@pulumi.output_type
class GetResponseHeadersPolicyCorsConfigResult(dict):
    def __init__(__self__, *,
                 access_control_allow_credentials: _builtins.bool,
                 access_control_allow_headers: Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowHeaderResult'],
                 access_control_allow_methods: Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowMethodResult'],
                 access_control_allow_origins: Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowOriginResult'],
                 access_control_expose_headers: Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlExposeHeaderResult'],
                 access_control_max_age_sec: _builtins.int,
                 origin_override: _builtins.bool):
        pulumi.set(__self__, "access_control_allow_credentials", access_control_allow_credentials)
        pulumi.set(__self__, "access_control_allow_headers", access_control_allow_headers)
        pulumi.set(__self__, "access_control_allow_methods", access_control_allow_methods)
        pulumi.set(__self__, "access_control_allow_origins", access_control_allow_origins)
        pulumi.set(__self__, "access_control_expose_headers", access_control_expose_headers)
        pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)
        pulumi.set(__self__, "origin_override", origin_override)

    @_builtins.property
    @pulumi.getter(name="accessControlAllowCredentials")
    def access_control_allow_credentials(self) -> _builtins.bool:
        return pulumi.get(self, "access_control_allow_credentials")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowHeaders")
    def access_control_allow_headers(self) -> Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowHeaderResult']:
        return pulumi.get(self, "access_control_allow_headers")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowMethods")
    def access_control_allow_methods(self) -> Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowMethodResult']:
        return pulumi.get(self, "access_control_allow_methods")

    @_builtins.property
    @pulumi.getter(name="accessControlAllowOrigins")
    def access_control_allow_origins(self) -> Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlAllowOriginResult']:
        return pulumi.get(self, "access_control_allow_origins")

    @_builtins.property
    @pulumi.getter(name="accessControlExposeHeaders")
    def access_control_expose_headers(self) -> Sequence['outputs.GetResponseHeadersPolicyCorsConfigAccessControlExposeHeaderResult']:
        return pulumi.get(self, "access_control_expose_headers")

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> _builtins.int:
        return pulumi.get(self, "access_control_max_age_sec")

    @_builtins.property
    @pulumi.getter(name="originOverride")
    def origin_override(self) -> _builtins.bool:
        return pulumi.get(self, "origin_override")


@pulumi.output_type
class GetResponseHeadersPolicyCorsConfigAccessControlAllowHeaderResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyCorsConfigAccessControlAllowMethodResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyCorsConfigAccessControlAllowOriginResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyCorsConfigAccessControlExposeHeaderResult(dict):
    def __init__(__self__, *,
                 items: Sequence[_builtins.str]):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyCustomHeadersConfigResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetResponseHeadersPolicyCustomHeadersConfigItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetResponseHeadersPolicyCustomHeadersConfigItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyCustomHeadersConfigItemResult(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 override: _builtins.bool,
                 value: _builtins.str):
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResponseHeadersPolicyRemoveHeadersConfigResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetResponseHeadersPolicyRemoveHeadersConfigItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetResponseHeadersPolicyRemoveHeadersConfigItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponseHeadersPolicyRemoveHeadersConfigItemResult(dict):
    def __init__(__self__, *,
                 header: _builtins.str):
        pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        return pulumi.get(self, "header")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigResult(dict):
    def __init__(__self__, *,
                 content_security_policies: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyResult'],
                 content_type_options: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigContentTypeOptionResult'],
                 frame_options: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigFrameOptionResult'],
                 referrer_policies: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicyResult'],
                 strict_transport_securities: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityResult'],
                 xss_protections: Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigXssProtectionResult']):
        pulumi.set(__self__, "content_security_policies", content_security_policies)
        pulumi.set(__self__, "content_type_options", content_type_options)
        pulumi.set(__self__, "frame_options", frame_options)
        pulumi.set(__self__, "referrer_policies", referrer_policies)
        pulumi.set(__self__, "strict_transport_securities", strict_transport_securities)
        pulumi.set(__self__, "xss_protections", xss_protections)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicies")
    def content_security_policies(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyResult']:
        return pulumi.get(self, "content_security_policies")

    @_builtins.property
    @pulumi.getter(name="contentTypeOptions")
    def content_type_options(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigContentTypeOptionResult']:
        return pulumi.get(self, "content_type_options")

    @_builtins.property
    @pulumi.getter(name="frameOptions")
    def frame_options(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigFrameOptionResult']:
        return pulumi.get(self, "frame_options")

    @_builtins.property
    @pulumi.getter(name="referrerPolicies")
    def referrer_policies(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicyResult']:
        return pulumi.get(self, "referrer_policies")

    @_builtins.property
    @pulumi.getter(name="strictTransportSecurities")
    def strict_transport_securities(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityResult']:
        return pulumi.get(self, "strict_transport_securities")

    @_builtins.property
    @pulumi.getter(name="xssProtections")
    def xss_protections(self) -> Sequence['outputs.GetResponseHeadersPolicySecurityHeadersConfigXssProtectionResult']:
        return pulumi.get(self, "xss_protections")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigContentSecurityPolicyResult(dict):
    def __init__(__self__, *,
                 content_security_policy: _builtins.str,
                 override: _builtins.bool):
        pulumi.set(__self__, "content_security_policy", content_security_policy)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> _builtins.str:
        return pulumi.get(self, "content_security_policy")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigContentTypeOptionResult(dict):
    def __init__(__self__, *,
                 override: _builtins.bool):
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigFrameOptionResult(dict):
    def __init__(__self__, *,
                 frame_option: _builtins.str,
                 override: _builtins.bool):
        pulumi.set(__self__, "frame_option", frame_option)
        pulumi.set(__self__, "override", override)

    @_builtins.property
    @pulumi.getter(name="frameOption")
    def frame_option(self) -> _builtins.str:
        return pulumi.get(self, "frame_option")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigReferrerPolicyResult(dict):
    def __init__(__self__, *,
                 override: _builtins.bool,
                 referrer_policy: _builtins.str):
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "referrer_policy", referrer_policy)

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> _builtins.str:
        return pulumi.get(self, "referrer_policy")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigStrictTransportSecurityResult(dict):
    def __init__(__self__, *,
                 access_control_max_age_sec: _builtins.int,
                 include_subdomains: _builtins.bool,
                 override: _builtins.bool,
                 preload: _builtins.bool):
        pulumi.set(__self__, "access_control_max_age_sec", access_control_max_age_sec)
        pulumi.set(__self__, "include_subdomains", include_subdomains)
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "preload", preload)

    @_builtins.property
    @pulumi.getter(name="accessControlMaxAgeSec")
    def access_control_max_age_sec(self) -> _builtins.int:
        return pulumi.get(self, "access_control_max_age_sec")

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> _builtins.bool:
        return pulumi.get(self, "include_subdomains")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter
    def preload(self) -> _builtins.bool:
        return pulumi.get(self, "preload")


@pulumi.output_type
class GetResponseHeadersPolicySecurityHeadersConfigXssProtectionResult(dict):
    def __init__(__self__, *,
                 mode_block: _builtins.bool,
                 override: _builtins.bool,
                 protection: _builtins.bool,
                 report_uri: _builtins.str):
        pulumi.set(__self__, "mode_block", mode_block)
        pulumi.set(__self__, "override", override)
        pulumi.set(__self__, "protection", protection)
        pulumi.set(__self__, "report_uri", report_uri)

    @_builtins.property
    @pulumi.getter(name="modeBlock")
    def mode_block(self) -> _builtins.bool:
        return pulumi.get(self, "mode_block")

    @_builtins.property
    @pulumi.getter
    def override(self) -> _builtins.bool:
        return pulumi.get(self, "override")

    @_builtins.property
    @pulumi.getter
    def protection(self) -> _builtins.bool:
        return pulumi.get(self, "protection")

    @_builtins.property
    @pulumi.getter(name="reportUri")
    def report_uri(self) -> _builtins.str:
        return pulumi.get(self, "report_uri")


@pulumi.output_type
class GetResponseHeadersPolicyServerTimingHeadersConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 sampling_rate: _builtins.float):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sampling_rate", sampling_rate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> _builtins.float:
        return pulumi.get(self, "sampling_rate")


