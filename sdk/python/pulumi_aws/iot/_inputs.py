# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'IndexingConfigurationThingGroupIndexingConfigurationArgs',
    'IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs',
    'IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs',
    'IndexingConfigurationThingIndexingConfigurationArgs',
    'IndexingConfigurationThingIndexingConfigurationCustomFieldArgs',
    'IndexingConfigurationThingIndexingConfigurationManagedFieldArgs',
    'ProvisioningTemplatePreProvisioningHookArgs',
    'ThingGroupMetadataArgs',
    'ThingGroupMetadataRootToParentGroupArgs',
    'ThingGroupPropertiesArgs',
    'ThingGroupPropertiesAttributePayloadArgs',
    'ThingTypePropertiesArgs',
    'TopicRuleCloudwatchAlarmArgs',
    'TopicRuleCloudwatchLogArgs',
    'TopicRuleCloudwatchMetricArgs',
    'TopicRuleDestinationVpcConfigurationArgs',
    'TopicRuleDynamodbArgs',
    'TopicRuleDynamodbv2Args',
    'TopicRuleDynamodbv2PutItemArgs',
    'TopicRuleElasticsearchArgs',
    'TopicRuleErrorActionArgs',
    'TopicRuleErrorActionCloudwatchAlarmArgs',
    'TopicRuleErrorActionCloudwatchLogsArgs',
    'TopicRuleErrorActionCloudwatchMetricArgs',
    'TopicRuleErrorActionDynamodbArgs',
    'TopicRuleErrorActionDynamodbv2Args',
    'TopicRuleErrorActionDynamodbv2PutItemArgs',
    'TopicRuleErrorActionElasticsearchArgs',
    'TopicRuleErrorActionFirehoseArgs',
    'TopicRuleErrorActionHttpArgs',
    'TopicRuleErrorActionHttpHttpHeaderArgs',
    'TopicRuleErrorActionIotAnalyticsArgs',
    'TopicRuleErrorActionIotEventsArgs',
    'TopicRuleErrorActionKafkaArgs',
    'TopicRuleErrorActionKinesisArgs',
    'TopicRuleErrorActionLambdaArgs',
    'TopicRuleErrorActionRepublishArgs',
    'TopicRuleErrorActionS3Args',
    'TopicRuleErrorActionSnsArgs',
    'TopicRuleErrorActionSqsArgs',
    'TopicRuleErrorActionStepFunctionsArgs',
    'TopicRuleErrorActionTimestreamArgs',
    'TopicRuleErrorActionTimestreamDimensionArgs',
    'TopicRuleErrorActionTimestreamTimestampArgs',
    'TopicRuleFirehoseArgs',
    'TopicRuleHttpArgs',
    'TopicRuleHttpHttpHeaderArgs',
    'TopicRuleIotAnalyticArgs',
    'TopicRuleIotEventArgs',
    'TopicRuleKafkaArgs',
    'TopicRuleKinesisArgs',
    'TopicRuleLambdaArgs',
    'TopicRuleRepublishArgs',
    'TopicRuleS3Args',
    'TopicRuleSnsArgs',
    'TopicRuleSqsArgs',
    'TopicRuleStepFunctionArgs',
    'TopicRuleTimestreamArgs',
    'TopicRuleTimestreamDimensionArgs',
    'TopicRuleTimestreamTimestampArgs',
]

@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationArgs:
    def __init__(__self__, *,
                 thing_group_indexing_mode: pulumi.Input[str],
                 custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]] = None,
                 managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]] = None):
        """
        :param pulumi.Input[str] thing_group_indexing_mode: Thing group indexing mode. Valid values: `OFF`, `ON`.
        :param pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]] custom_fields: A list of thing group fields to index. This list cannot contain any managed fields. See below.
        :param pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]] managed_fields: Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
        """
        IndexingConfigurationThingGroupIndexingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            thing_group_indexing_mode=thing_group_indexing_mode,
            custom_fields=custom_fields,
            managed_fields=managed_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             thing_group_indexing_mode: Optional[pulumi.Input[str]] = None,
             custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]] = None,
             managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if thing_group_indexing_mode is None and 'thingGroupIndexingMode' in kwargs:
            thing_group_indexing_mode = kwargs['thingGroupIndexingMode']
        if thing_group_indexing_mode is None:
            raise TypeError("Missing 'thing_group_indexing_mode' argument")
        if custom_fields is None and 'customFields' in kwargs:
            custom_fields = kwargs['customFields']
        if managed_fields is None and 'managedFields' in kwargs:
            managed_fields = kwargs['managedFields']

        _setter("thing_group_indexing_mode", thing_group_indexing_mode)
        if custom_fields is not None:
            _setter("custom_fields", custom_fields)
        if managed_fields is not None:
            _setter("managed_fields", managed_fields)

    @property
    @pulumi.getter(name="thingGroupIndexingMode")
    def thing_group_indexing_mode(self) -> pulumi.Input[str]:
        """
        Thing group indexing mode. Valid values: `OFF`, `ON`.
        """
        return pulumi.get(self, "thing_group_indexing_mode")

    @thing_group_indexing_mode.setter
    def thing_group_indexing_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "thing_group_indexing_mode", value)

    @property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]]:
        """
        A list of thing group fields to index. This list cannot contain any managed fields. See below.
        """
        return pulumi.get(self, "custom_fields")

    @custom_fields.setter
    def custom_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]]):
        pulumi.set(self, "custom_fields", value)

    @property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]]:
        """
        Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
        """
        return pulumi.get(self, "managed_fields")

    @managed_fields.setter
    def managed_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]]):
        pulumi.set(self, "managed_fields", value)


@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the field.
        :param pulumi.Input[str] type: The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the field.
        :param pulumi.Input[str] type: The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationArgs:
    def __init__(__self__, *,
                 thing_indexing_mode: pulumi.Input[str],
                 custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]] = None,
                 device_defender_indexing_mode: Optional[pulumi.Input[str]] = None,
                 managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]] = None,
                 named_shadow_indexing_mode: Optional[pulumi.Input[str]] = None,
                 thing_connectivity_indexing_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] thing_indexing_mode: Thing indexing mode. Valid values: `REGISTRY`, `REGISTRY_AND_SHADOW`, `OFF`.
        :param pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]] custom_fields: Contains custom field names and their data type. See below.
        :param pulumi.Input[str] device_defender_indexing_mode: Device Defender indexing mode. Valid values: `VIOLATIONS`, `OFF`. Default: `OFF`.
        :param pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]] managed_fields: Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
        :param pulumi.Input[str] named_shadow_indexing_mode: [Named shadow](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html) indexing mode. Valid values: `ON`, `OFF`. Default: `OFF`.
        :param pulumi.Input[str] thing_connectivity_indexing_mode: Thing connectivity indexing mode. Valid values: `STATUS`, `OFF`. Default: `OFF`.
        """
        IndexingConfigurationThingIndexingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            thing_indexing_mode=thing_indexing_mode,
            custom_fields=custom_fields,
            device_defender_indexing_mode=device_defender_indexing_mode,
            managed_fields=managed_fields,
            named_shadow_indexing_mode=named_shadow_indexing_mode,
            thing_connectivity_indexing_mode=thing_connectivity_indexing_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             thing_indexing_mode: Optional[pulumi.Input[str]] = None,
             custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]] = None,
             device_defender_indexing_mode: Optional[pulumi.Input[str]] = None,
             managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]] = None,
             named_shadow_indexing_mode: Optional[pulumi.Input[str]] = None,
             thing_connectivity_indexing_mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if thing_indexing_mode is None and 'thingIndexingMode' in kwargs:
            thing_indexing_mode = kwargs['thingIndexingMode']
        if thing_indexing_mode is None:
            raise TypeError("Missing 'thing_indexing_mode' argument")
        if custom_fields is None and 'customFields' in kwargs:
            custom_fields = kwargs['customFields']
        if device_defender_indexing_mode is None and 'deviceDefenderIndexingMode' in kwargs:
            device_defender_indexing_mode = kwargs['deviceDefenderIndexingMode']
        if managed_fields is None and 'managedFields' in kwargs:
            managed_fields = kwargs['managedFields']
        if named_shadow_indexing_mode is None and 'namedShadowIndexingMode' in kwargs:
            named_shadow_indexing_mode = kwargs['namedShadowIndexingMode']
        if thing_connectivity_indexing_mode is None and 'thingConnectivityIndexingMode' in kwargs:
            thing_connectivity_indexing_mode = kwargs['thingConnectivityIndexingMode']

        _setter("thing_indexing_mode", thing_indexing_mode)
        if custom_fields is not None:
            _setter("custom_fields", custom_fields)
        if device_defender_indexing_mode is not None:
            _setter("device_defender_indexing_mode", device_defender_indexing_mode)
        if managed_fields is not None:
            _setter("managed_fields", managed_fields)
        if named_shadow_indexing_mode is not None:
            _setter("named_shadow_indexing_mode", named_shadow_indexing_mode)
        if thing_connectivity_indexing_mode is not None:
            _setter("thing_connectivity_indexing_mode", thing_connectivity_indexing_mode)

    @property
    @pulumi.getter(name="thingIndexingMode")
    def thing_indexing_mode(self) -> pulumi.Input[str]:
        """
        Thing indexing mode. Valid values: `REGISTRY`, `REGISTRY_AND_SHADOW`, `OFF`.
        """
        return pulumi.get(self, "thing_indexing_mode")

    @thing_indexing_mode.setter
    def thing_indexing_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "thing_indexing_mode", value)

    @property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]]:
        """
        Contains custom field names and their data type. See below.
        """
        return pulumi.get(self, "custom_fields")

    @custom_fields.setter
    def custom_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]]):
        pulumi.set(self, "custom_fields", value)

    @property
    @pulumi.getter(name="deviceDefenderIndexingMode")
    def device_defender_indexing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Device Defender indexing mode. Valid values: `VIOLATIONS`, `OFF`. Default: `OFF`.
        """
        return pulumi.get(self, "device_defender_indexing_mode")

    @device_defender_indexing_mode.setter
    def device_defender_indexing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_defender_indexing_mode", value)

    @property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]]:
        """
        Contains fields that are indexed and whose types are already known by the Fleet Indexing service. See below.
        """
        return pulumi.get(self, "managed_fields")

    @managed_fields.setter
    def managed_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]]):
        pulumi.set(self, "managed_fields", value)

    @property
    @pulumi.getter(name="namedShadowIndexingMode")
    def named_shadow_indexing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        [Named shadow](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html) indexing mode. Valid values: `ON`, `OFF`. Default: `OFF`.
        """
        return pulumi.get(self, "named_shadow_indexing_mode")

    @named_shadow_indexing_mode.setter
    def named_shadow_indexing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "named_shadow_indexing_mode", value)

    @property
    @pulumi.getter(name="thingConnectivityIndexingMode")
    def thing_connectivity_indexing_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Thing connectivity indexing mode. Valid values: `STATUS`, `OFF`. Default: `OFF`.
        """
        return pulumi.get(self, "thing_connectivity_indexing_mode")

    @thing_connectivity_indexing_mode.setter
    def thing_connectivity_indexing_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thing_connectivity_indexing_mode", value)


@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationCustomFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the field.
        :param pulumi.Input[str] type: The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        IndexingConfigurationThingIndexingConfigurationCustomFieldArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationManagedFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the field.
        :param pulumi.Input[str] type: The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        IndexingConfigurationThingIndexingConfigurationManagedFieldArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The data type of the field. Valid values: `Number`, `String`, `Boolean`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ProvisioningTemplatePreProvisioningHookArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[str],
                 payload_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_arn: The ARN of the target function.
        :param pulumi.Input[str] payload_version: The version of the payload that was sent to the target function. The only valid (and the default) payload version is `"2020-04-01"`.
        """
        ProvisioningTemplatePreProvisioningHookArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_arn=target_arn,
            payload_version=payload_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_arn: Optional[pulumi.Input[str]] = None,
             payload_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_arn is None and 'targetArn' in kwargs:
            target_arn = kwargs['targetArn']
        if target_arn is None:
            raise TypeError("Missing 'target_arn' argument")
        if payload_version is None and 'payloadVersion' in kwargs:
            payload_version = kwargs['payloadVersion']

        _setter("target_arn", target_arn)
        if payload_version is not None:
            _setter("payload_version", payload_version)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the target function.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)

    @property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the payload that was sent to the target function. The only valid (and the default) payload version is `"2020-04-01"`.
        """
        return pulumi.get(self, "payload_version")

    @payload_version.setter
    def payload_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_version", value)


@pulumi.input_type
class ThingGroupMetadataArgs:
    def __init__(__self__, *,
                 creation_date: Optional[pulumi.Input[str]] = None,
                 parent_group_name: Optional[pulumi.Input[str]] = None,
                 root_to_parent_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]] = None):
        """
        :param pulumi.Input[str] parent_group_name: The name of the parent Thing Group.
        """
        ThingGroupMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_date=creation_date,
            parent_group_name=parent_group_name,
            root_to_parent_groups=root_to_parent_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_date: Optional[pulumi.Input[str]] = None,
             parent_group_name: Optional[pulumi.Input[str]] = None,
             root_to_parent_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_date is None and 'creationDate' in kwargs:
            creation_date = kwargs['creationDate']
        if parent_group_name is None and 'parentGroupName' in kwargs:
            parent_group_name = kwargs['parentGroupName']
        if root_to_parent_groups is None and 'rootToParentGroups' in kwargs:
            root_to_parent_groups = kwargs['rootToParentGroups']

        if creation_date is not None:
            _setter("creation_date", creation_date)
        if parent_group_name is not None:
            _setter("parent_group_name", parent_group_name)
        if root_to_parent_groups is not None:
            _setter("root_to_parent_groups", root_to_parent_groups)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_date", value)

    @property
    @pulumi.getter(name="parentGroupName")
    def parent_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the parent Thing Group.
        """
        return pulumi.get(self, "parent_group_name")

    @parent_group_name.setter
    def parent_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_group_name", value)

    @property
    @pulumi.getter(name="rootToParentGroups")
    def root_to_parent_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]]:
        return pulumi.get(self, "root_to_parent_groups")

    @root_to_parent_groups.setter
    def root_to_parent_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]]):
        pulumi.set(self, "root_to_parent_groups", value)


@pulumi.input_type
class ThingGroupMetadataRootToParentGroupArgs:
    def __init__(__self__, *,
                 group_arn: Optional[pulumi.Input[str]] = None,
                 group_name: Optional[pulumi.Input[str]] = None):
        ThingGroupMetadataRootToParentGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_arn=group_arn,
            group_name=group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_arn: Optional[pulumi.Input[str]] = None,
             group_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_arn is None and 'groupArn' in kwargs:
            group_arn = kwargs['groupArn']
        if group_name is None and 'groupName' in kwargs:
            group_name = kwargs['groupName']

        if group_arn is not None:
            _setter("group_arn", group_arn)
        if group_name is not None:
            _setter("group_name", group_name)

    @property
    @pulumi.getter(name="groupArn")
    def group_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_arn")

    @group_arn.setter
    def group_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_arn", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)


@pulumi.input_type
class ThingGroupPropertiesArgs:
    def __init__(__self__, *,
                 attribute_payload: Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ThingGroupPropertiesAttributePayloadArgs'] attribute_payload: The Thing Group attributes. Defined below.
        :param pulumi.Input[str] description: A description of the Thing Group.
        """
        ThingGroupPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_payload=attribute_payload,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_payload: Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']] = None,
             description: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if attribute_payload is None and 'attributePayload' in kwargs:
            attribute_payload = kwargs['attributePayload']

        if attribute_payload is not None:
            _setter("attribute_payload", attribute_payload)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']]:
        """
        The Thing Group attributes. Defined below.
        """
        return pulumi.get(self, "attribute_payload")

    @attribute_payload.setter
    def attribute_payload(self, value: Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']]):
        pulumi.set(self, "attribute_payload", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the Thing Group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ThingGroupPropertiesAttributePayloadArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: Key-value map.
        """
        ThingGroupPropertiesAttributePayloadArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attributes=attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if attributes is not None:
            _setter("attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value map.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)


@pulumi.input_type
class ThingTypePropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 searchable_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] description: The description of the thing type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] searchable_attributes: A list of searchable thing attribute names.
        """
        ThingTypePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            searchable_attributes=searchable_attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             searchable_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if searchable_attributes is None and 'searchableAttributes' in kwargs:
            searchable_attributes = kwargs['searchableAttributes']

        if description is not None:
            _setter("description", description)
        if searchable_attributes is not None:
            _setter("searchable_attributes", searchable_attributes)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the thing type.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of searchable thing attribute names.
        """
        return pulumi.get(self, "searchable_attributes")

    @searchable_attributes.setter
    def searchable_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "searchable_attributes", value)


@pulumi.input_type
class TopicRuleCloudwatchAlarmArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 state_reason: pulumi.Input[str],
                 state_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alarm_name: The CloudWatch alarm name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input[str] state_reason: The reason for the alarm change.
        :param pulumi.Input[str] state_value: The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        TopicRuleCloudwatchAlarmArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarm_name=alarm_name,
            role_arn=role_arn,
            state_reason=state_reason,
            state_value=state_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarm_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             state_reason: Optional[pulumi.Input[str]] = None,
             state_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alarm_name is None and 'alarmName' in kwargs:
            alarm_name = kwargs['alarmName']
        if alarm_name is None:
            raise TypeError("Missing 'alarm_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if state_reason is None and 'stateReason' in kwargs:
            state_reason = kwargs['stateReason']
        if state_reason is None:
            raise TypeError("Missing 'state_reason' argument")
        if state_value is None and 'stateValue' in kwargs:
            state_value = kwargs['stateValue']
        if state_value is None:
            raise TypeError("Missing 'state_value' argument")

        _setter("alarm_name", alarm_name)
        _setter("role_arn", role_arn)
        _setter("state_reason", state_reason)
        _setter("state_value", state_value)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch alarm name.
        """
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "alarm_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> pulumi.Input[str]:
        """
        The reason for the alarm change.
        """
        return pulumi.get(self, "state_reason")

    @state_reason.setter
    def state_reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_reason", value)

    @property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> pulumi.Input[str]:
        """
        The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        return pulumi.get(self, "state_value")

    @state_value.setter
    def state_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_value", value)


@pulumi.input_type
class TopicRuleCloudwatchLogArgs:
    def __init__(__self__, *,
                 log_group_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_group_name: The CloudWatch log group name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        """
        TopicRuleCloudwatchLogArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_group_name=log_group_name,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_group_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")

        _setter("log_group_name", log_group_name)
        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch log group name.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class TopicRuleCloudwatchMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_namespace: pulumi.Input[str],
                 metric_unit: pulumi.Input[str],
                 metric_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 metric_timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The CloudWatch metric name.
        :param pulumi.Input[str] metric_namespace: The CloudWatch metric namespace name.
        :param pulumi.Input[str] metric_unit: The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
        :param pulumi.Input[str] metric_value: The CloudWatch metric value.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch metric.
        :param pulumi.Input[str] metric_timestamp: An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        """
        TopicRuleCloudwatchMetricArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            metric_namespace=metric_namespace,
            metric_unit=metric_unit,
            metric_value=metric_value,
            role_arn=role_arn,
            metric_timestamp=metric_timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: Optional[pulumi.Input[str]] = None,
             metric_namespace: Optional[pulumi.Input[str]] = None,
             metric_unit: Optional[pulumi.Input[str]] = None,
             metric_value: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             metric_timestamp: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if metric_namespace is None and 'metricNamespace' in kwargs:
            metric_namespace = kwargs['metricNamespace']
        if metric_namespace is None:
            raise TypeError("Missing 'metric_namespace' argument")
        if metric_unit is None and 'metricUnit' in kwargs:
            metric_unit = kwargs['metricUnit']
        if metric_unit is None:
            raise TypeError("Missing 'metric_unit' argument")
        if metric_value is None and 'metricValue' in kwargs:
            metric_value = kwargs['metricValue']
        if metric_value is None:
            raise TypeError("Missing 'metric_value' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if metric_timestamp is None and 'metricTimestamp' in kwargs:
            metric_timestamp = kwargs['metricTimestamp']

        _setter("metric_name", metric_name)
        _setter("metric_namespace", metric_namespace)
        _setter("metric_unit", metric_unit)
        _setter("metric_value", metric_value)
        _setter("role_arn", role_arn)
        if metric_timestamp is not None:
            _setter("metric_timestamp", metric_timestamp)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric namespace name.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> pulumi.Input[str]:
        """
        The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
        """
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_unit", value)

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric value.
        """
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch metric.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        """
        return pulumi.get(self, "metric_timestamp")

    @metric_timestamp.setter
    def metric_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_timestamp", value)


@pulumi.input_type
class TopicRuleDestinationVpcConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 vpc_id: pulumi.Input[str],
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The subnet IDs of the VPC destination.
        :param pulumi.Input[str] vpc_id: The ID of the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups of the VPC destination.
        """
        TopicRuleDestinationVpcConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
            security_groups=security_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             vpc_id: Optional[pulumi.Input[str]] = None,
             security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if subnet_ids is None and 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if subnet_ids is None:
            raise TypeError("Missing 'subnet_ids' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")
        if security_groups is None and 'securityGroups' in kwargs:
            security_groups = kwargs['securityGroups']

        _setter("role_arn", role_arn)
        _setter("subnet_ids", subnet_ids)
        _setter("vpc_id", vpc_id)
        if security_groups is not None:
            _setter("security_groups", security_groups)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The subnet IDs of the VPC destination.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups of the VPC destination.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)


@pulumi.input_type
class TopicRuleDynamodbArgs:
    def __init__(__self__, *,
                 hash_key_field: pulumi.Input[str],
                 hash_key_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 hash_key_type: Optional[pulumi.Input[str]] = None,
                 operation: Optional[pulumi.Input[str]] = None,
                 payload_field: Optional[pulumi.Input[str]] = None,
                 range_key_field: Optional[pulumi.Input[str]] = None,
                 range_key_type: Optional[pulumi.Input[str]] = None,
                 range_key_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hash_key_field: The hash key name.
        :param pulumi.Input[str] hash_key_value: The hash key value.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        :param pulumi.Input[str] table_name: The name of the DynamoDB table.
        :param pulumi.Input[str] hash_key_type: The hash key type. Valid values are "STRING" or "NUMBER".
        :param pulumi.Input[str] operation: The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
        :param pulumi.Input[str] payload_field: The action payload.
        :param pulumi.Input[str] range_key_field: The range key name.
        :param pulumi.Input[str] range_key_type: The range key type. Valid values are "STRING" or "NUMBER".
        :param pulumi.Input[str] range_key_value: The range key value.
        """
        TopicRuleDynamodbArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hash_key_field=hash_key_field,
            hash_key_value=hash_key_value,
            role_arn=role_arn,
            table_name=table_name,
            hash_key_type=hash_key_type,
            operation=operation,
            payload_field=payload_field,
            range_key_field=range_key_field,
            range_key_type=range_key_type,
            range_key_value=range_key_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hash_key_field: Optional[pulumi.Input[str]] = None,
             hash_key_value: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             table_name: Optional[pulumi.Input[str]] = None,
             hash_key_type: Optional[pulumi.Input[str]] = None,
             operation: Optional[pulumi.Input[str]] = None,
             payload_field: Optional[pulumi.Input[str]] = None,
             range_key_field: Optional[pulumi.Input[str]] = None,
             range_key_type: Optional[pulumi.Input[str]] = None,
             range_key_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hash_key_field is None and 'hashKeyField' in kwargs:
            hash_key_field = kwargs['hashKeyField']
        if hash_key_field is None:
            raise TypeError("Missing 'hash_key_field' argument")
        if hash_key_value is None and 'hashKeyValue' in kwargs:
            hash_key_value = kwargs['hashKeyValue']
        if hash_key_value is None:
            raise TypeError("Missing 'hash_key_value' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if hash_key_type is None and 'hashKeyType' in kwargs:
            hash_key_type = kwargs['hashKeyType']
        if payload_field is None and 'payloadField' in kwargs:
            payload_field = kwargs['payloadField']
        if range_key_field is None and 'rangeKeyField' in kwargs:
            range_key_field = kwargs['rangeKeyField']
        if range_key_type is None and 'rangeKeyType' in kwargs:
            range_key_type = kwargs['rangeKeyType']
        if range_key_value is None and 'rangeKeyValue' in kwargs:
            range_key_value = kwargs['rangeKeyValue']

        _setter("hash_key_field", hash_key_field)
        _setter("hash_key_value", hash_key_value)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if hash_key_type is not None:
            _setter("hash_key_type", hash_key_type)
        if operation is not None:
            _setter("operation", operation)
        if payload_field is not None:
            _setter("payload_field", payload_field)
        if range_key_field is not None:
            _setter("range_key_field", range_key_field)
        if range_key_type is not None:
            _setter("range_key_type", range_key_type)
        if range_key_value is not None:
            _setter("range_key_value", range_key_value)

    @property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> pulumi.Input[str]:
        """
        The hash key name.
        """
        return pulumi.get(self, "hash_key_field")

    @hash_key_field.setter
    def hash_key_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_field", value)

    @property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> pulumi.Input[str]:
        """
        The hash key value.
        """
        return pulumi.get(self, "hash_key_value")

    @hash_key_value.setter
    def hash_key_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The hash key type. Valid values are "STRING" or "NUMBER".
        """
        return pulumi.get(self, "hash_key_type")

    @hash_key_type.setter
    def hash_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_key_type", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[str]]:
        """
        The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[pulumi.Input[str]]:
        """
        The action payload.
        """
        return pulumi.get(self, "payload_field")

    @payload_field.setter
    def payload_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_field", value)

    @property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[pulumi.Input[str]]:
        """
        The range key name.
        """
        return pulumi.get(self, "range_key_field")

    @range_key_field.setter
    def range_key_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_field", value)

    @property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The range key type. Valid values are "STRING" or "NUMBER".
        """
        return pulumi.get(self, "range_key_type")

    @range_key_type.setter
    def range_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_type", value)

    @property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[pulumi.Input[str]]:
        """
        The range key value.
        """
        return pulumi.get(self, "range_key_value")

    @range_key_value.setter
    def range_key_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_value", value)


@pulumi.input_type
class TopicRuleDynamodbv2Args:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 put_item: Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']] = None):
        """
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input['TopicRuleDynamodbv2PutItemArgs'] put_item: Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
        """
        TopicRuleDynamodbv2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            put_item=put_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             put_item: Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if put_item is None and 'putItem' in kwargs:
            put_item = kwargs['putItem']

        _setter("role_arn", role_arn)
        if put_item is not None:
            _setter("put_item", put_item)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']]:
        """
        Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
        """
        return pulumi.get(self, "put_item")

    @put_item.setter
    def put_item(self, value: Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']]):
        pulumi.set(self, "put_item", value)


@pulumi.input_type
class TopicRuleDynamodbv2PutItemArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] table_name: The name of the DynamoDB table.
        """
        TopicRuleDynamodbv2PutItemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class TopicRuleElasticsearchArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 id: pulumi.Input[str],
                 index: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: The endpoint of your Elasticsearch domain.
        :param pulumi.Input[str] id: The unique identifier for the document you are storing.
        :param pulumi.Input[str] index: The Elasticsearch index where you want to store your data.
        :param pulumi.Input[str] role_arn: The IAM role ARN that has access to Elasticsearch.
        :param pulumi.Input[str] type: The type of document you are storing.
        """
        TopicRuleElasticsearchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            id=id,
            index=index,
            role_arn=role_arn,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             index: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if index is None:
            raise TypeError("Missing 'index' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("endpoint", endpoint)
        _setter("id", id)
        _setter("index", index)
        _setter("role_arn", role_arn)
        _setter("type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of your Elasticsearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The Elasticsearch index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that has access to Elasticsearch.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TopicRuleErrorActionArgs:
    def __init__(__self__, *,
                 cloudwatch_alarm: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']] = None,
                 cloudwatch_logs: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']] = None,
                 cloudwatch_metric: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']] = None,
                 dynamodb: Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']] = None,
                 dynamodbv2: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']] = None,
                 elasticsearch: Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']] = None,
                 firehose: Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']] = None,
                 http: Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']] = None,
                 iot_analytics: Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']] = None,
                 iot_events: Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']] = None,
                 kafka: Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']] = None,
                 kinesis: Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']] = None,
                 lambda_: Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']] = None,
                 republish: Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']] = None,
                 s3: Optional[pulumi.Input['TopicRuleErrorActionS3Args']] = None,
                 sns: Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']] = None,
                 sqs: Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']] = None,
                 step_functions: Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']] = None,
                 timestream: Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']] = None):
        TopicRuleErrorActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_alarm=cloudwatch_alarm,
            cloudwatch_logs=cloudwatch_logs,
            cloudwatch_metric=cloudwatch_metric,
            dynamodb=dynamodb,
            dynamodbv2=dynamodbv2,
            elasticsearch=elasticsearch,
            firehose=firehose,
            http=http,
            iot_analytics=iot_analytics,
            iot_events=iot_events,
            kafka=kafka,
            kinesis=kinesis,
            lambda_=lambda_,
            republish=republish,
            s3=s3,
            sns=sns,
            sqs=sqs,
            step_functions=step_functions,
            timestream=timestream,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_alarm: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']] = None,
             cloudwatch_logs: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']] = None,
             cloudwatch_metric: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']] = None,
             dynamodb: Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']] = None,
             dynamodbv2: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']] = None,
             elasticsearch: Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']] = None,
             firehose: Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']] = None,
             http: Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']] = None,
             iot_analytics: Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']] = None,
             iot_events: Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']] = None,
             kafka: Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']] = None,
             kinesis: Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']] = None,
             lambda_: Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']] = None,
             republish: Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']] = None,
             s3: Optional[pulumi.Input['TopicRuleErrorActionS3Args']] = None,
             sns: Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']] = None,
             sqs: Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']] = None,
             step_functions: Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']] = None,
             timestream: Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_alarm is None and 'cloudwatchAlarm' in kwargs:
            cloudwatch_alarm = kwargs['cloudwatchAlarm']
        if cloudwatch_logs is None and 'cloudwatchLogs' in kwargs:
            cloudwatch_logs = kwargs['cloudwatchLogs']
        if cloudwatch_metric is None and 'cloudwatchMetric' in kwargs:
            cloudwatch_metric = kwargs['cloudwatchMetric']
        if iot_analytics is None and 'iotAnalytics' in kwargs:
            iot_analytics = kwargs['iotAnalytics']
        if iot_events is None and 'iotEvents' in kwargs:
            iot_events = kwargs['iotEvents']
        if lambda_ is None and 'lambda' in kwargs:
            lambda_ = kwargs['lambda']
        if step_functions is None and 'stepFunctions' in kwargs:
            step_functions = kwargs['stepFunctions']

        if cloudwatch_alarm is not None:
            _setter("cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            _setter("cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            _setter("cloudwatch_metric", cloudwatch_metric)
        if dynamodb is not None:
            _setter("dynamodb", dynamodb)
        if dynamodbv2 is not None:
            _setter("dynamodbv2", dynamodbv2)
        if elasticsearch is not None:
            _setter("elasticsearch", elasticsearch)
        if firehose is not None:
            _setter("firehose", firehose)
        if http is not None:
            _setter("http", http)
        if iot_analytics is not None:
            _setter("iot_analytics", iot_analytics)
        if iot_events is not None:
            _setter("iot_events", iot_events)
        if kafka is not None:
            _setter("kafka", kafka)
        if kinesis is not None:
            _setter("kinesis", kinesis)
        if lambda_ is not None:
            _setter("lambda_", lambda_)
        if republish is not None:
            _setter("republish", republish)
        if s3 is not None:
            _setter("s3", s3)
        if sns is not None:
            _setter("sns", sns)
        if sqs is not None:
            _setter("sqs", sqs)
        if step_functions is not None:
            _setter("step_functions", step_functions)
        if timestream is not None:
            _setter("timestream", timestream)

    @property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']]:
        return pulumi.get(self, "cloudwatch_alarm")

    @cloudwatch_alarm.setter
    def cloudwatch_alarm(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']]):
        pulumi.set(self, "cloudwatch_alarm", value)

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']]:
        return pulumi.get(self, "cloudwatch_metric")

    @cloudwatch_metric.setter
    def cloudwatch_metric(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']]):
        pulumi.set(self, "cloudwatch_metric", value)

    @property
    @pulumi.getter
    def dynamodb(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']]:
        return pulumi.get(self, "dynamodb")

    @dynamodb.setter
    def dynamodb(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']]):
        pulumi.set(self, "dynamodb", value)

    @property
    @pulumi.getter
    def dynamodbv2(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']]:
        return pulumi.get(self, "dynamodbv2")

    @dynamodbv2.setter
    def dynamodbv2(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']]):
        pulumi.set(self, "dynamodbv2", value)

    @property
    @pulumi.getter
    def elasticsearch(self) -> Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']]:
        return pulumi.get(self, "elasticsearch")

    @elasticsearch.setter
    def elasticsearch(self, value: Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']]):
        pulumi.set(self, "elasticsearch", value)

    @property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']]:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']]:
        return pulumi.get(self, "iot_analytics")

    @iot_analytics.setter
    def iot_analytics(self, value: Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']]):
        pulumi.set(self, "iot_analytics", value)

    @property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']]:
        return pulumi.get(self, "iot_events")

    @iot_events.setter
    def iot_events(self, value: Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']]):
        pulumi.set(self, "iot_events", value)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']]:
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']]):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter
    def kinesis(self) -> Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']]:
        return pulumi.get(self, "kinesis")

    @kinesis.setter
    def kinesis(self, value: Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']]):
        pulumi.set(self, "kinesis", value)

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']]:
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']]):
        pulumi.set(self, "lambda_", value)

    @property
    @pulumi.getter
    def republish(self) -> Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']]:
        return pulumi.get(self, "republish")

    @republish.setter
    def republish(self, value: Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']]):
        pulumi.set(self, "republish", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['TopicRuleErrorActionS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['TopicRuleErrorActionS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']]:
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']]):
        pulumi.set(self, "sns", value)

    @property
    @pulumi.getter
    def sqs(self) -> Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']]:
        return pulumi.get(self, "sqs")

    @sqs.setter
    def sqs(self, value: Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']]):
        pulumi.set(self, "sqs", value)

    @property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']]:
        return pulumi.get(self, "step_functions")

    @step_functions.setter
    def step_functions(self, value: Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']]):
        pulumi.set(self, "step_functions", value)

    @property
    @pulumi.getter
    def timestream(self) -> Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']]:
        return pulumi.get(self, "timestream")

    @timestream.setter
    def timestream(self, value: Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']]):
        pulumi.set(self, "timestream", value)


@pulumi.input_type
class TopicRuleErrorActionCloudwatchAlarmArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 state_reason: pulumi.Input[str],
                 state_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alarm_name: The CloudWatch alarm name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input[str] state_reason: The reason for the alarm change.
        :param pulumi.Input[str] state_value: The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        TopicRuleErrorActionCloudwatchAlarmArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarm_name=alarm_name,
            role_arn=role_arn,
            state_reason=state_reason,
            state_value=state_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarm_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             state_reason: Optional[pulumi.Input[str]] = None,
             state_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alarm_name is None and 'alarmName' in kwargs:
            alarm_name = kwargs['alarmName']
        if alarm_name is None:
            raise TypeError("Missing 'alarm_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if state_reason is None and 'stateReason' in kwargs:
            state_reason = kwargs['stateReason']
        if state_reason is None:
            raise TypeError("Missing 'state_reason' argument")
        if state_value is None and 'stateValue' in kwargs:
            state_value = kwargs['stateValue']
        if state_value is None:
            raise TypeError("Missing 'state_value' argument")

        _setter("alarm_name", alarm_name)
        _setter("role_arn", role_arn)
        _setter("state_reason", state_reason)
        _setter("state_value", state_value)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch alarm name.
        """
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "alarm_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> pulumi.Input[str]:
        """
        The reason for the alarm change.
        """
        return pulumi.get(self, "state_reason")

    @state_reason.setter
    def state_reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_reason", value)

    @property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> pulumi.Input[str]:
        """
        The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        return pulumi.get(self, "state_value")

    @state_value.setter
    def state_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_value", value)


@pulumi.input_type
class TopicRuleErrorActionCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_group_name: The CloudWatch log group name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        """
        TopicRuleErrorActionCloudwatchLogsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_group_name=log_group_name,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_group_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if log_group_name is None and 'logGroupName' in kwargs:
            log_group_name = kwargs['logGroupName']
        if log_group_name is None:
            raise TypeError("Missing 'log_group_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")

        _setter("log_group_name", log_group_name)
        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch log group name.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class TopicRuleErrorActionCloudwatchMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_namespace: pulumi.Input[str],
                 metric_unit: pulumi.Input[str],
                 metric_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 metric_timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The CloudWatch metric name.
        :param pulumi.Input[str] metric_namespace: The CloudWatch metric namespace name.
        :param pulumi.Input[str] metric_unit: The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
        :param pulumi.Input[str] metric_value: The CloudWatch metric value.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch metric.
        :param pulumi.Input[str] metric_timestamp: An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        """
        TopicRuleErrorActionCloudwatchMetricArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            metric_namespace=metric_namespace,
            metric_unit=metric_unit,
            metric_value=metric_value,
            role_arn=role_arn,
            metric_timestamp=metric_timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: Optional[pulumi.Input[str]] = None,
             metric_namespace: Optional[pulumi.Input[str]] = None,
             metric_unit: Optional[pulumi.Input[str]] = None,
             metric_value: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             metric_timestamp: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if metric_namespace is None and 'metricNamespace' in kwargs:
            metric_namespace = kwargs['metricNamespace']
        if metric_namespace is None:
            raise TypeError("Missing 'metric_namespace' argument")
        if metric_unit is None and 'metricUnit' in kwargs:
            metric_unit = kwargs['metricUnit']
        if metric_unit is None:
            raise TypeError("Missing 'metric_unit' argument")
        if metric_value is None and 'metricValue' in kwargs:
            metric_value = kwargs['metricValue']
        if metric_value is None:
            raise TypeError("Missing 'metric_value' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if metric_timestamp is None and 'metricTimestamp' in kwargs:
            metric_timestamp = kwargs['metricTimestamp']

        _setter("metric_name", metric_name)
        _setter("metric_namespace", metric_namespace)
        _setter("metric_unit", metric_unit)
        _setter("metric_value", metric_value)
        _setter("role_arn", role_arn)
        if metric_timestamp is not None:
            _setter("metric_timestamp", metric_timestamp)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric namespace name.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> pulumi.Input[str]:
        """
        The metric unit (supported units can be found here: http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
        """
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_unit", value)

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric value.
        """
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch metric.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        """
        return pulumi.get(self, "metric_timestamp")

    @metric_timestamp.setter
    def metric_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_timestamp", value)


@pulumi.input_type
class TopicRuleErrorActionDynamodbArgs:
    def __init__(__self__, *,
                 hash_key_field: pulumi.Input[str],
                 hash_key_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 hash_key_type: Optional[pulumi.Input[str]] = None,
                 operation: Optional[pulumi.Input[str]] = None,
                 payload_field: Optional[pulumi.Input[str]] = None,
                 range_key_field: Optional[pulumi.Input[str]] = None,
                 range_key_type: Optional[pulumi.Input[str]] = None,
                 range_key_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hash_key_field: The hash key name.
        :param pulumi.Input[str] hash_key_value: The hash key value.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        :param pulumi.Input[str] table_name: The name of the DynamoDB table.
        :param pulumi.Input[str] hash_key_type: The hash key type. Valid values are "STRING" or "NUMBER".
        :param pulumi.Input[str] operation: The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
        :param pulumi.Input[str] payload_field: The action payload.
        :param pulumi.Input[str] range_key_field: The range key name.
        :param pulumi.Input[str] range_key_type: The range key type. Valid values are "STRING" or "NUMBER".
        :param pulumi.Input[str] range_key_value: The range key value.
        """
        TopicRuleErrorActionDynamodbArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hash_key_field=hash_key_field,
            hash_key_value=hash_key_value,
            role_arn=role_arn,
            table_name=table_name,
            hash_key_type=hash_key_type,
            operation=operation,
            payload_field=payload_field,
            range_key_field=range_key_field,
            range_key_type=range_key_type,
            range_key_value=range_key_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hash_key_field: Optional[pulumi.Input[str]] = None,
             hash_key_value: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             table_name: Optional[pulumi.Input[str]] = None,
             hash_key_type: Optional[pulumi.Input[str]] = None,
             operation: Optional[pulumi.Input[str]] = None,
             payload_field: Optional[pulumi.Input[str]] = None,
             range_key_field: Optional[pulumi.Input[str]] = None,
             range_key_type: Optional[pulumi.Input[str]] = None,
             range_key_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hash_key_field is None and 'hashKeyField' in kwargs:
            hash_key_field = kwargs['hashKeyField']
        if hash_key_field is None:
            raise TypeError("Missing 'hash_key_field' argument")
        if hash_key_value is None and 'hashKeyValue' in kwargs:
            hash_key_value = kwargs['hashKeyValue']
        if hash_key_value is None:
            raise TypeError("Missing 'hash_key_value' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if hash_key_type is None and 'hashKeyType' in kwargs:
            hash_key_type = kwargs['hashKeyType']
        if payload_field is None and 'payloadField' in kwargs:
            payload_field = kwargs['payloadField']
        if range_key_field is None and 'rangeKeyField' in kwargs:
            range_key_field = kwargs['rangeKeyField']
        if range_key_type is None and 'rangeKeyType' in kwargs:
            range_key_type = kwargs['rangeKeyType']
        if range_key_value is None and 'rangeKeyValue' in kwargs:
            range_key_value = kwargs['rangeKeyValue']

        _setter("hash_key_field", hash_key_field)
        _setter("hash_key_value", hash_key_value)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if hash_key_type is not None:
            _setter("hash_key_type", hash_key_type)
        if operation is not None:
            _setter("operation", operation)
        if payload_field is not None:
            _setter("payload_field", payload_field)
        if range_key_field is not None:
            _setter("range_key_field", range_key_field)
        if range_key_type is not None:
            _setter("range_key_type", range_key_type)
        if range_key_value is not None:
            _setter("range_key_value", range_key_value)

    @property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> pulumi.Input[str]:
        """
        The hash key name.
        """
        return pulumi.get(self, "hash_key_field")

    @hash_key_field.setter
    def hash_key_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_field", value)

    @property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> pulumi.Input[str]:
        """
        The hash key value.
        """
        return pulumi.get(self, "hash_key_value")

    @hash_key_value.setter
    def hash_key_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The hash key type. Valid values are "STRING" or "NUMBER".
        """
        return pulumi.get(self, "hash_key_type")

    @hash_key_type.setter
    def hash_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_key_type", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[str]]:
        """
        The operation. Valid values are "INSERT", "UPDATE", or "DELETE".
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[pulumi.Input[str]]:
        """
        The action payload.
        """
        return pulumi.get(self, "payload_field")

    @payload_field.setter
    def payload_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_field", value)

    @property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[pulumi.Input[str]]:
        """
        The range key name.
        """
        return pulumi.get(self, "range_key_field")

    @range_key_field.setter
    def range_key_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_field", value)

    @property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The range key type. Valid values are "STRING" or "NUMBER".
        """
        return pulumi.get(self, "range_key_type")

    @range_key_type.setter
    def range_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_type", value)

    @property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[pulumi.Input[str]]:
        """
        The range key value.
        """
        return pulumi.get(self, "range_key_value")

    @range_key_value.setter
    def range_key_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_value", value)


@pulumi.input_type
class TopicRuleErrorActionDynamodbv2Args:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 put_item: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']] = None):
        """
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs'] put_item: Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
        """
        TopicRuleErrorActionDynamodbv2Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            put_item=put_item,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             put_item: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if put_item is None and 'putItem' in kwargs:
            put_item = kwargs['putItem']

        _setter("role_arn", role_arn)
        if put_item is not None:
            _setter("put_item", put_item)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']]:
        """
        Configuration block with DynamoDB Table to which the message will be written. Nested arguments below.
        """
        return pulumi.get(self, "put_item")

    @put_item.setter
    def put_item(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']]):
        pulumi.set(self, "put_item", value)


@pulumi.input_type
class TopicRuleErrorActionDynamodbv2PutItemArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] table_name: The name of the DynamoDB table.
        """
        TopicRuleErrorActionDynamodbv2PutItemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class TopicRuleErrorActionElasticsearchArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 id: pulumi.Input[str],
                 index: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: The endpoint of your Elasticsearch domain.
        :param pulumi.Input[str] id: The unique identifier for the document you are storing.
        :param pulumi.Input[str] index: The Elasticsearch index where you want to store your data.
        :param pulumi.Input[str] role_arn: The IAM role ARN that has access to Elasticsearch.
        :param pulumi.Input[str] type: The type of document you are storing.
        """
        TopicRuleErrorActionElasticsearchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            id=id,
            index=index,
            role_arn=role_arn,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             index: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if index is None:
            raise TypeError("Missing 'index' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("endpoint", endpoint)
        _setter("id", id)
        _setter("index", index)
        _setter("role_arn", role_arn)
        _setter("type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of your Elasticsearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The Elasticsearch index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that has access to Elasticsearch.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TopicRuleErrorActionFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 separator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delivery_stream_name: The delivery stream name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
        :param pulumi.Input[str] separator: A character separator that is used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        TopicRuleErrorActionFirehoseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delivery_stream_name=delivery_stream_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            separator=separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delivery_stream_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             separator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delivery_stream_name is None and 'deliveryStreamName' in kwargs:
            delivery_stream_name = kwargs['deliveryStreamName']
        if delivery_stream_name is None:
            raise TypeError("Missing 'delivery_stream_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']

        _setter("delivery_stream_name", delivery_stream_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if separator is not None:
            _setter("separator", separator)

    @property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> pulumi.Input[str]:
        """
        The delivery stream name.
        """
        return pulumi.get(self, "delivery_stream_name")

    @delivery_stream_name.setter
    def delivery_stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "delivery_stream_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        A character separator that is used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)


@pulumi.input_type
class TopicRuleErrorActionHttpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 confirmation_url: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]] = None):
        """
        :param pulumi.Input[str] url: The HTTPS URL.
        :param pulumi.Input[str] confirmation_url: The HTTPS URL used to verify ownership of `url`.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]] http_headers: Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
        """
        TopicRuleErrorActionHttpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            confirmation_url=confirmation_url,
            http_headers=http_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             confirmation_url: Optional[pulumi.Input[str]] = None,
             http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if confirmation_url is None and 'confirmationUrl' in kwargs:
            confirmation_url = kwargs['confirmationUrl']
        if http_headers is None and 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        _setter("url", url)
        if confirmation_url is not None:
            _setter("confirmation_url", confirmation_url)
        if http_headers is not None:
            _setter("http_headers", http_headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The HTTPS URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTPS URL used to verify ownership of `url`.
        """
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confirmation_url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]]:
        """
        Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)


@pulumi.input_type
class TopicRuleErrorActionHttpHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The name of the HTTP header.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleErrorActionHttpHttpHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicRuleErrorActionIotAnalyticsArgs:
    def __init__(__self__, *,
                 channel_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_name: Name of AWS IOT Analytics channel.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
        """
        TopicRuleErrorActionIotAnalyticsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_name=channel_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_name is None and 'channelName' in kwargs:
            channel_name = kwargs['channelName']
        if channel_name is None:
            raise TypeError("Missing 'channel_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']

        _setter("channel_name", channel_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> pulumi.Input[str]:
        """
        Name of AWS IOT Analytics channel.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)


@pulumi.input_type
class TopicRuleErrorActionIotEventsArgs:
    def __init__(__self__, *,
                 input_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 message_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] input_name: The name of the AWS IoT Events input.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
        :param pulumi.Input[str] message_id: Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
        """
        TopicRuleErrorActionIotEventsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_name=input_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            message_id=message_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             message_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_name is None and 'inputName' in kwargs:
            input_name = kwargs['inputName']
        if input_name is None:
            raise TypeError("Missing 'input_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']
        if message_id is None and 'messageId' in kwargs:
            message_id = kwargs['messageId']

        _setter("input_name", input_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if message_id is not None:
            _setter("message_id", message_id)

    @property
    @pulumi.getter(name="inputName")
    def input_name(self) -> pulumi.Input[str]:
        """
        The name of the AWS IoT Events input.
        """
        return pulumi.get(self, "input_name")

    @input_name.setter
    def input_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_id", value)


@pulumi.input_type
class TopicRuleErrorActionKafkaArgs:
    def __init__(__self__, *,
                 client_properties: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 destination_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 partition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] client_properties: Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
        :param pulumi.Input[str] destination_arn: The ARN of Kafka action's VPC `iot.TopicRuleDestination` .
        :param pulumi.Input[str] topic: The Kafka topic for messages to be sent to the Kafka broker.
        :param pulumi.Input[str] key: The Kafka message key.
        :param pulumi.Input[str] partition: The Kafka message partition.
        """
        TopicRuleErrorActionKafkaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_properties=client_properties,
            destination_arn=destination_arn,
            topic=topic,
            key=key,
            partition=partition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             destination_arn: Optional[pulumi.Input[str]] = None,
             topic: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             partition: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_properties is None and 'clientProperties' in kwargs:
            client_properties = kwargs['clientProperties']
        if client_properties is None:
            raise TypeError("Missing 'client_properties' argument")
        if destination_arn is None and 'destinationArn' in kwargs:
            destination_arn = kwargs['destinationArn']
        if destination_arn is None:
            raise TypeError("Missing 'destination_arn' argument")
        if topic is None:
            raise TypeError("Missing 'topic' argument")

        _setter("client_properties", client_properties)
        _setter("destination_arn", destination_arn)
        _setter("topic", topic)
        if key is not None:
            _setter("key", key)
        if partition is not None:
            _setter("partition", partition)

    @property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
        """
        return pulumi.get(self, "client_properties")

    @client_properties.setter
    def client_properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "client_properties", value)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        The ARN of Kafka action's VPC `iot.TopicRuleDestination` .
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Kafka topic for messages to be sent to the Kafka broker.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message partition.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition", value)


@pulumi.input_type
class TopicRuleErrorActionKinesisArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 stream_name: pulumi.Input[str],
                 partition_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        :param pulumi.Input[str] stream_name: The name of the Amazon Kinesis stream.
        :param pulumi.Input[str] partition_key: The partition key.
        """
        TopicRuleErrorActionKinesisArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            stream_name=stream_name,
            partition_key=partition_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             stream_name: Optional[pulumi.Input[str]] = None,
             partition_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")
        if partition_key is None and 'partitionKey' in kwargs:
            partition_key = kwargs['partitionKey']

        _setter("role_arn", role_arn)
        _setter("stream_name", stream_name)
        if partition_key is not None:
            _setter("partition_key", partition_key)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        The name of the Amazon Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input[str]]:
        """
        The partition key.
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition_key", value)


@pulumi.input_type
class TopicRuleErrorActionLambdaArgs:
    def __init__(__self__, *,
                 function_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] function_arn: The ARN of the Lambda function.
        """
        TopicRuleErrorActionLambdaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function_arn=function_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if function_arn is None and 'functionArn' in kwargs:
            function_arn = kwargs['functionArn']
        if function_arn is None:
            raise TypeError("Missing 'function_arn' argument")

        _setter("function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the Lambda function.
        """
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_arn", value)


@pulumi.input_type
class TopicRuleErrorActionRepublishArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 qos: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] topic: The name of the MQTT topic the message should be republished to.
        :param pulumi.Input[int] qos: The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
               
               The `s3` object takes the following arguments:
        """
        TopicRuleErrorActionRepublishArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            topic=topic,
            qos=qos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             topic: Optional[pulumi.Input[str]] = None,
             qos: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if topic is None:
            raise TypeError("Missing 'topic' argument")

        _setter("role_arn", role_arn)
        _setter("topic", topic)
        if qos is not None:
            _setter("qos", qos)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the MQTT topic the message should be republished to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.

        The `s3` object takes the following arguments:
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)


@pulumi.input_type
class TopicRuleErrorActionS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 key: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The Amazon S3 bucket name.
        :param pulumi.Input[str] key: The name of the HTTP header.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input[str] canned_acl: The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
        """
        TopicRuleErrorActionS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            key=key,
            role_arn=role_arn,
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        _setter("bucket_name", bucket_name)
        _setter("key", key)
        _setter("role_arn", role_arn)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)


@pulumi.input_type
class TopicRuleErrorActionSnsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 target_arn: pulumi.Input[str],
                 message_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] target_arn: The ARN of the SNS topic.
        :param pulumi.Input[str] message_format: The message format of the message to publish. Accepted values are "JSON" and "RAW".
        """
        TopicRuleErrorActionSnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            target_arn=target_arn,
            message_format=message_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             target_arn: Optional[pulumi.Input[str]] = None,
             message_format: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if target_arn is None and 'targetArn' in kwargs:
            target_arn = kwargs['targetArn']
        if target_arn is None:
            raise TypeError("Missing 'target_arn' argument")
        if message_format is None and 'messageFormat' in kwargs:
            message_format = kwargs['messageFormat']

        _setter("role_arn", role_arn)
        _setter("target_arn", target_arn)
        if message_format is not None:
            _setter("message_format", message_format)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        The message format of the message to publish. Accepted values are "JSON" and "RAW".
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)


@pulumi.input_type
class TopicRuleErrorActionSqsArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 use_base64: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] queue_url: The URL of the Amazon SQS queue.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] use_base64: Specifies whether to use Base64 encoding.
        """
        TopicRuleErrorActionSqsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue_url=queue_url,
            role_arn=role_arn,
            use_base64=use_base64,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue_url: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             use_base64: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if queue_url is None and 'queueUrl' in kwargs:
            queue_url = kwargs['queueUrl']
        if queue_url is None:
            raise TypeError("Missing 'queue_url' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if use_base64 is None and 'useBase64' in kwargs:
            use_base64 = kwargs['useBase64']
        if use_base64 is None:
            raise TypeError("Missing 'use_base64' argument")

        _setter("queue_url", queue_url)
        _setter("role_arn", role_arn)
        _setter("use_base64", use_base64)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[str]:
        """
        The URL of the Amazon SQS queue.
        """
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_url", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> pulumi.Input[bool]:
        """
        Specifies whether to use Base64 encoding.
        """
        return pulumi.get(self, "use_base64")

    @use_base64.setter
    def use_base64(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_base64", value)


@pulumi.input_type
class TopicRuleErrorActionStepFunctionsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 state_machine_name: pulumi.Input[str],
                 execution_name_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to start execution of the state machine.
        :param pulumi.Input[str] state_machine_name: The name of the Step Functions state machine whose execution will be started.
        :param pulumi.Input[str] execution_name_prefix: The prefix used to generate, along with a UUID, the unique state machine execution name.
        """
        TopicRuleErrorActionStepFunctionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            state_machine_name=state_machine_name,
            execution_name_prefix=execution_name_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             state_machine_name: Optional[pulumi.Input[str]] = None,
             execution_name_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if state_machine_name is None and 'stateMachineName' in kwargs:
            state_machine_name = kwargs['stateMachineName']
        if state_machine_name is None:
            raise TypeError("Missing 'state_machine_name' argument")
        if execution_name_prefix is None and 'executionNamePrefix' in kwargs:
            execution_name_prefix = kwargs['executionNamePrefix']

        _setter("role_arn", role_arn)
        _setter("state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            _setter("execution_name_prefix", execution_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to start execution of the state machine.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> pulumi.Input[str]:
        """
        The name of the Step Functions state machine whose execution will be started.
        """
        return pulumi.get(self, "state_machine_name")

    @state_machine_name.setter
    def state_machine_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_machine_name", value)

    @property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix used to generate, along with a UUID, the unique state machine execution name.
        """
        return pulumi.get(self, "execution_name_prefix")

    @execution_name_prefix.setter
    def execution_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_name_prefix", value)


@pulumi.input_type
class TopicRuleErrorActionTimestreamArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 timestamp: Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']] = None):
        """
        :param pulumi.Input[str] database_name: The name of an Amazon Timestream database.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]] dimensions: Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants permission to write to the Amazon Timestream database table.
        :param pulumi.Input[str] table_name: The name of the database table into which to write the measure records.
        :param pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs'] timestamp: Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
        """
        TopicRuleErrorActionTimestreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            dimensions=dimensions,
            role_arn=role_arn,
            table_name=table_name,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[pulumi.Input[str]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             table_name: Optional[pulumi.Input[str]] = None,
             timestamp: Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("database_name", database_name)
        _setter("dimensions", dimensions)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if timestamp is not None:
            _setter("timestamp", timestamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of an Amazon Timestream database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]]:
        """
        Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants permission to write to the Amazon Timestream database table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the database table into which to write the measure records.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']]:
        """
        Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


@pulumi.input_type
class TopicRuleErrorActionTimestreamDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the rule.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleErrorActionTimestreamDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicRuleErrorActionTimestreamTimestampArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] unit: The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleErrorActionTimestreamTimestampArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicRuleFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 separator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delivery_stream_name: The delivery stream name.
        :param pulumi.Input[str] role_arn: The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
        :param pulumi.Input[str] separator: A character separator that is used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        TopicRuleFirehoseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delivery_stream_name=delivery_stream_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            separator=separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delivery_stream_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             separator: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delivery_stream_name is None and 'deliveryStreamName' in kwargs:
            delivery_stream_name = kwargs['deliveryStreamName']
        if delivery_stream_name is None:
            raise TypeError("Missing 'delivery_stream_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']

        _setter("delivery_stream_name", delivery_stream_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if separator is not None:
            _setter("separator", separator)

    @property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> pulumi.Input[str]:
        """
        The delivery stream name.
        """
        return pulumi.get(self, "delivery_stream_name")

    @delivery_stream_name.setter
    def delivery_stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "delivery_stream_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that grants access to the Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to Kinesis Firehose via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        A character separator that is used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)


@pulumi.input_type
class TopicRuleHttpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 confirmation_url: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]] = None):
        """
        :param pulumi.Input[str] url: The HTTPS URL.
        :param pulumi.Input[str] confirmation_url: The HTTPS URL used to verify ownership of `url`.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]] http_headers: Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
        """
        TopicRuleHttpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            confirmation_url=confirmation_url,
            http_headers=http_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             confirmation_url: Optional[pulumi.Input[str]] = None,
             http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if confirmation_url is None and 'confirmationUrl' in kwargs:
            confirmation_url = kwargs['confirmationUrl']
        if http_headers is None and 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        _setter("url", url)
        if confirmation_url is not None:
            _setter("confirmation_url", confirmation_url)
        if http_headers is not None:
            _setter("http_headers", http_headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The HTTPS URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTPS URL used to verify ownership of `url`.
        """
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confirmation_url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]]:
        """
        Custom HTTP header IoT Core should send. It is possible to define more than one custom header.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)


@pulumi.input_type
class TopicRuleHttpHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The name of the HTTP header.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleHttpHttpHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicRuleIotAnalyticArgs:
    def __init__(__self__, *,
                 channel_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_name: Name of AWS IOT Analytics channel.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
        """
        TopicRuleIotAnalyticArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_name=channel_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if channel_name is None and 'channelName' in kwargs:
            channel_name = kwargs['channelName']
        if channel_name is None:
            raise TypeError("Missing 'channel_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']

        _setter("channel_name", channel_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> pulumi.Input[str]:
        """
        Name of AWS IOT Analytics channel.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to IoT Analytics via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)


@pulumi.input_type
class TopicRuleIotEventArgs:
    def __init__(__self__, *,
                 input_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 message_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] input_name: The name of the AWS IoT Events input.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] batch_mode: The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
        :param pulumi.Input[str] message_id: Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
        """
        TopicRuleIotEventArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_name=input_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            message_id=message_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_name: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             batch_mode: Optional[pulumi.Input[bool]] = None,
             message_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_name is None and 'inputName' in kwargs:
            input_name = kwargs['inputName']
        if input_name is None:
            raise TypeError("Missing 'input_name' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if batch_mode is None and 'batchMode' in kwargs:
            batch_mode = kwargs['batchMode']
        if message_id is None and 'messageId' in kwargs:
            message_id = kwargs['messageId']

        _setter("input_name", input_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if message_id is not None:
            _setter("message_id", message_id)

    @property
    @pulumi.getter(name="inputName")
    def input_name(self) -> pulumi.Input[str]:
        """
        The name of the AWS IoT Events input.
        """
        return pulumi.get(self, "input_name")

    @input_name.setter
    def input_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        The payload that contains a JSON array of records will be sent to IoT Events via a batch call.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[str]]:
        """
        Use this to ensure that only one input (message) with a given messageId is processed by an AWS IoT Events detector.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_id", value)


@pulumi.input_type
class TopicRuleKafkaArgs:
    def __init__(__self__, *,
                 client_properties: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 destination_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 partition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] client_properties: Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
        :param pulumi.Input[str] destination_arn: The ARN of Kafka action's VPC `iot.TopicRuleDestination` .
        :param pulumi.Input[str] topic: The Kafka topic for messages to be sent to the Kafka broker.
        :param pulumi.Input[str] key: The Kafka message key.
        :param pulumi.Input[str] partition: The Kafka message partition.
        """
        TopicRuleKafkaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_properties=client_properties,
            destination_arn=destination_arn,
            topic=topic,
            key=key,
            partition=partition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             destination_arn: Optional[pulumi.Input[str]] = None,
             topic: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             partition: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_properties is None and 'clientProperties' in kwargs:
            client_properties = kwargs['clientProperties']
        if client_properties is None:
            raise TypeError("Missing 'client_properties' argument")
        if destination_arn is None and 'destinationArn' in kwargs:
            destination_arn = kwargs['destinationArn']
        if destination_arn is None:
            raise TypeError("Missing 'destination_arn' argument")
        if topic is None:
            raise TypeError("Missing 'topic' argument")

        _setter("client_properties", client_properties)
        _setter("destination_arn", destination_arn)
        _setter("topic", topic)
        if key is not None:
            _setter("key", key)
        if partition is not None:
            _setter("partition", partition)

    @property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Properties of the Apache Kafka producer client. For more info, see the [AWS documentation](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
        """
        return pulumi.get(self, "client_properties")

    @client_properties.setter
    def client_properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "client_properties", value)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        The ARN of Kafka action's VPC `iot.TopicRuleDestination` .
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Kafka topic for messages to be sent to the Kafka broker.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message partition.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition", value)


@pulumi.input_type
class TopicRuleKinesisArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 stream_name: pulumi.Input[str],
                 partition_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        :param pulumi.Input[str] stream_name: The name of the Amazon Kinesis stream.
        :param pulumi.Input[str] partition_key: The partition key.
        """
        TopicRuleKinesisArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            stream_name=stream_name,
            partition_key=partition_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             stream_name: Optional[pulumi.Input[str]] = None,
             partition_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")
        if partition_key is None and 'partitionKey' in kwargs:
            partition_key = kwargs['partitionKey']

        _setter("role_arn", role_arn)
        _setter("stream_name", stream_name)
        if partition_key is not None:
            _setter("partition_key", partition_key)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        The name of the Amazon Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input[str]]:
        """
        The partition key.
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition_key", value)


@pulumi.input_type
class TopicRuleLambdaArgs:
    def __init__(__self__, *,
                 function_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] function_arn: The ARN of the Lambda function.
        """
        TopicRuleLambdaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function_arn=function_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if function_arn is None and 'functionArn' in kwargs:
            function_arn = kwargs['functionArn']
        if function_arn is None:
            raise TypeError("Missing 'function_arn' argument")

        _setter("function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the Lambda function.
        """
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_arn", value)


@pulumi.input_type
class TopicRuleRepublishArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 qos: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] topic: The name of the MQTT topic the message should be republished to.
        :param pulumi.Input[int] qos: The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.
               
               The `s3` object takes the following arguments:
        """
        TopicRuleRepublishArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            topic=topic,
            qos=qos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             topic: Optional[pulumi.Input[str]] = None,
             qos: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if topic is None:
            raise TypeError("Missing 'topic' argument")

        _setter("role_arn", role_arn)
        _setter("topic", topic)
        if qos is not None:
            _setter("qos", qos)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the MQTT topic the message should be republished to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        The Quality of Service (QoS) level to use when republishing messages. Valid values are 0 or 1. The default value is 0.

        The `s3` object takes the following arguments:
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)


@pulumi.input_type
class TopicRuleS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 key: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The Amazon S3 bucket name.
        :param pulumi.Input[str] key: The name of the HTTP header.
        :param pulumi.Input[str] role_arn: The IAM role ARN that allows access to the CloudWatch alarm.
        :param pulumi.Input[str] canned_acl: The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
        """
        TopicRuleS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            key=key,
            role_arn=role_arn,
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']

        _setter("bucket_name", bucket_name)
        _setter("key", key)
        _setter("role_arn", role_arn)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the HTTP header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 canned ACL that controls access to the object identified by the object key. [Valid values](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl).
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)


@pulumi.input_type
class TopicRuleSnsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 target_arn: pulumi.Input[str],
                 message_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] target_arn: The ARN of the SNS topic.
        :param pulumi.Input[str] message_format: The message format of the message to publish. Accepted values are "JSON" and "RAW".
        """
        TopicRuleSnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            target_arn=target_arn,
            message_format=message_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             target_arn: Optional[pulumi.Input[str]] = None,
             message_format: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if target_arn is None and 'targetArn' in kwargs:
            target_arn = kwargs['targetArn']
        if target_arn is None:
            raise TypeError("Missing 'target_arn' argument")
        if message_format is None and 'messageFormat' in kwargs:
            message_format = kwargs['messageFormat']

        _setter("role_arn", role_arn)
        _setter("target_arn", target_arn)
        if message_format is not None:
            _setter("message_format", message_format)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        The message format of the message to publish. Accepted values are "JSON" and "RAW".
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)


@pulumi.input_type
class TopicRuleSqsArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 use_base64: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] queue_url: The URL of the Amazon SQS queue.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] use_base64: Specifies whether to use Base64 encoding.
        """
        TopicRuleSqsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue_url=queue_url,
            role_arn=role_arn,
            use_base64=use_base64,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue_url: Optional[pulumi.Input[str]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             use_base64: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if queue_url is None and 'queueUrl' in kwargs:
            queue_url = kwargs['queueUrl']
        if queue_url is None:
            raise TypeError("Missing 'queue_url' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if use_base64 is None and 'useBase64' in kwargs:
            use_base64 = kwargs['useBase64']
        if use_base64 is None:
            raise TypeError("Missing 'use_base64' argument")

        _setter("queue_url", queue_url)
        _setter("role_arn", role_arn)
        _setter("use_base64", use_base64)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[str]:
        """
        The URL of the Amazon SQS queue.
        """
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_url", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> pulumi.Input[bool]:
        """
        Specifies whether to use Base64 encoding.
        """
        return pulumi.get(self, "use_base64")

    @use_base64.setter
    def use_base64(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_base64", value)


@pulumi.input_type
class TopicRuleStepFunctionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 state_machine_name: pulumi.Input[str],
                 execution_name_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to start execution of the state machine.
        :param pulumi.Input[str] state_machine_name: The name of the Step Functions state machine whose execution will be started.
        :param pulumi.Input[str] execution_name_prefix: The prefix used to generate, along with a UUID, the unique state machine execution name.
        """
        TopicRuleStepFunctionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            state_machine_name=state_machine_name,
            execution_name_prefix=execution_name_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             state_machine_name: Optional[pulumi.Input[str]] = None,
             execution_name_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if state_machine_name is None and 'stateMachineName' in kwargs:
            state_machine_name = kwargs['stateMachineName']
        if state_machine_name is None:
            raise TypeError("Missing 'state_machine_name' argument")
        if execution_name_prefix is None and 'executionNamePrefix' in kwargs:
            execution_name_prefix = kwargs['executionNamePrefix']

        _setter("role_arn", role_arn)
        _setter("state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            _setter("execution_name_prefix", execution_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to start execution of the state machine.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> pulumi.Input[str]:
        """
        The name of the Step Functions state machine whose execution will be started.
        """
        return pulumi.get(self, "state_machine_name")

    @state_machine_name.setter
    def state_machine_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_machine_name", value)

    @property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix used to generate, along with a UUID, the unique state machine execution name.
        """
        return pulumi.get(self, "execution_name_prefix")

    @execution_name_prefix.setter
    def execution_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_name_prefix", value)


@pulumi.input_type
class TopicRuleTimestreamArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 timestamp: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']] = None):
        """
        :param pulumi.Input[str] database_name: The name of an Amazon Timestream database.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]] dimensions: Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants permission to write to the Amazon Timestream database table.
        :param pulumi.Input[str] table_name: The name of the database table into which to write the measure records.
        :param pulumi.Input['TopicRuleTimestreamTimestampArgs'] timestamp: Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
        """
        TopicRuleTimestreamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            dimensions=dimensions,
            role_arn=role_arn,
            table_name=table_name,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[pulumi.Input[str]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]] = None,
             role_arn: Optional[pulumi.Input[str]] = None,
             table_name: Optional[pulumi.Input[str]] = None,
             timestamp: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if dimensions is None:
            raise TypeError("Missing 'dimensions' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("database_name", database_name)
        _setter("dimensions", dimensions)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if timestamp is not None:
            _setter("timestamp", timestamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of an Amazon Timestream database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]:
        """
        Configuration blocks with metadata attributes of the time series that are written in each measure record. Nested arguments below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants permission to write to the Amazon Timestream database table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the database table into which to write the measure records.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]:
        """
        Configuration block specifying an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. Nested arguments below.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


@pulumi.input_type
class TopicRuleTimestreamDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the rule.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleTimestreamDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicRuleTimestreamTimestampArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] unit: The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
        :param pulumi.Input[str] value: The value of the HTTP header.
        """
        TopicRuleTimestreamTimestampArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unit is None:
            raise TypeError("Missing 'unit' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        The precision of the timestamp value that results from the expression described in value. Valid values: `SECONDS`, `MILLISECONDS`, `MICROSECONDS`, `NANOSECONDS`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the HTTP header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


