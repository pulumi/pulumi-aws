# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BillingGroupMetadataArgs',
    'BillingGroupMetadataArgsDict',
    'BillingGroupPropertiesArgs',
    'BillingGroupPropertiesArgsDict',
    'CaCertificateRegistrationConfigArgs',
    'CaCertificateRegistrationConfigArgsDict',
    'CaCertificateValidityArgs',
    'CaCertificateValidityArgsDict',
    'DomainConfigurationAuthorizerConfigArgs',
    'DomainConfigurationAuthorizerConfigArgsDict',
    'DomainConfigurationTlsConfigArgs',
    'DomainConfigurationTlsConfigArgsDict',
    'IndexingConfigurationThingGroupIndexingConfigurationArgs',
    'IndexingConfigurationThingGroupIndexingConfigurationArgsDict',
    'IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs',
    'IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgsDict',
    'IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs',
    'IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgsDict',
    'IndexingConfigurationThingIndexingConfigurationArgs',
    'IndexingConfigurationThingIndexingConfigurationArgsDict',
    'IndexingConfigurationThingIndexingConfigurationCustomFieldArgs',
    'IndexingConfigurationThingIndexingConfigurationCustomFieldArgsDict',
    'IndexingConfigurationThingIndexingConfigurationFilterArgs',
    'IndexingConfigurationThingIndexingConfigurationFilterArgsDict',
    'IndexingConfigurationThingIndexingConfigurationManagedFieldArgs',
    'IndexingConfigurationThingIndexingConfigurationManagedFieldArgsDict',
    'ProvisioningTemplatePreProvisioningHookArgs',
    'ProvisioningTemplatePreProvisioningHookArgsDict',
    'ThingGroupMetadataArgs',
    'ThingGroupMetadataArgsDict',
    'ThingGroupMetadataRootToParentGroupArgs',
    'ThingGroupMetadataRootToParentGroupArgsDict',
    'ThingGroupPropertiesArgs',
    'ThingGroupPropertiesArgsDict',
    'ThingGroupPropertiesAttributePayloadArgs',
    'ThingGroupPropertiesAttributePayloadArgsDict',
    'ThingTypePropertiesArgs',
    'ThingTypePropertiesArgsDict',
    'TopicRuleCloudwatchAlarmArgs',
    'TopicRuleCloudwatchAlarmArgsDict',
    'TopicRuleCloudwatchLogArgs',
    'TopicRuleCloudwatchLogArgsDict',
    'TopicRuleCloudwatchMetricArgs',
    'TopicRuleCloudwatchMetricArgsDict',
    'TopicRuleDestinationVpcConfigurationArgs',
    'TopicRuleDestinationVpcConfigurationArgsDict',
    'TopicRuleDynamodbArgs',
    'TopicRuleDynamodbArgsDict',
    'TopicRuleDynamodbv2Args',
    'TopicRuleDynamodbv2ArgsDict',
    'TopicRuleDynamodbv2PutItemArgs',
    'TopicRuleDynamodbv2PutItemArgsDict',
    'TopicRuleElasticsearchArgs',
    'TopicRuleElasticsearchArgsDict',
    'TopicRuleErrorActionArgs',
    'TopicRuleErrorActionArgsDict',
    'TopicRuleErrorActionCloudwatchAlarmArgs',
    'TopicRuleErrorActionCloudwatchAlarmArgsDict',
    'TopicRuleErrorActionCloudwatchLogsArgs',
    'TopicRuleErrorActionCloudwatchLogsArgsDict',
    'TopicRuleErrorActionCloudwatchMetricArgs',
    'TopicRuleErrorActionCloudwatchMetricArgsDict',
    'TopicRuleErrorActionDynamodbArgs',
    'TopicRuleErrorActionDynamodbArgsDict',
    'TopicRuleErrorActionDynamodbv2Args',
    'TopicRuleErrorActionDynamodbv2ArgsDict',
    'TopicRuleErrorActionDynamodbv2PutItemArgs',
    'TopicRuleErrorActionDynamodbv2PutItemArgsDict',
    'TopicRuleErrorActionElasticsearchArgs',
    'TopicRuleErrorActionElasticsearchArgsDict',
    'TopicRuleErrorActionFirehoseArgs',
    'TopicRuleErrorActionFirehoseArgsDict',
    'TopicRuleErrorActionHttpArgs',
    'TopicRuleErrorActionHttpArgsDict',
    'TopicRuleErrorActionHttpHttpHeaderArgs',
    'TopicRuleErrorActionHttpHttpHeaderArgsDict',
    'TopicRuleErrorActionIotAnalyticsArgs',
    'TopicRuleErrorActionIotAnalyticsArgsDict',
    'TopicRuleErrorActionIotEventsArgs',
    'TopicRuleErrorActionIotEventsArgsDict',
    'TopicRuleErrorActionKafkaArgs',
    'TopicRuleErrorActionKafkaArgsDict',
    'TopicRuleErrorActionKafkaHeaderArgs',
    'TopicRuleErrorActionKafkaHeaderArgsDict',
    'TopicRuleErrorActionKinesisArgs',
    'TopicRuleErrorActionKinesisArgsDict',
    'TopicRuleErrorActionLambdaArgs',
    'TopicRuleErrorActionLambdaArgsDict',
    'TopicRuleErrorActionRepublishArgs',
    'TopicRuleErrorActionRepublishArgsDict',
    'TopicRuleErrorActionS3Args',
    'TopicRuleErrorActionS3ArgsDict',
    'TopicRuleErrorActionSnsArgs',
    'TopicRuleErrorActionSnsArgsDict',
    'TopicRuleErrorActionSqsArgs',
    'TopicRuleErrorActionSqsArgsDict',
    'TopicRuleErrorActionStepFunctionsArgs',
    'TopicRuleErrorActionStepFunctionsArgsDict',
    'TopicRuleErrorActionTimestreamArgs',
    'TopicRuleErrorActionTimestreamArgsDict',
    'TopicRuleErrorActionTimestreamDimensionArgs',
    'TopicRuleErrorActionTimestreamDimensionArgsDict',
    'TopicRuleErrorActionTimestreamTimestampArgs',
    'TopicRuleErrorActionTimestreamTimestampArgsDict',
    'TopicRuleFirehoseArgs',
    'TopicRuleFirehoseArgsDict',
    'TopicRuleHttpArgs',
    'TopicRuleHttpArgsDict',
    'TopicRuleHttpHttpHeaderArgs',
    'TopicRuleHttpHttpHeaderArgsDict',
    'TopicRuleIotAnalyticArgs',
    'TopicRuleIotAnalyticArgsDict',
    'TopicRuleIotEventArgs',
    'TopicRuleIotEventArgsDict',
    'TopicRuleKafkaArgs',
    'TopicRuleKafkaArgsDict',
    'TopicRuleKafkaHeaderArgs',
    'TopicRuleKafkaHeaderArgsDict',
    'TopicRuleKinesisArgs',
    'TopicRuleKinesisArgsDict',
    'TopicRuleLambdaArgs',
    'TopicRuleLambdaArgsDict',
    'TopicRuleRepublishArgs',
    'TopicRuleRepublishArgsDict',
    'TopicRuleS3Args',
    'TopicRuleS3ArgsDict',
    'TopicRuleSnsArgs',
    'TopicRuleSnsArgsDict',
    'TopicRuleSqsArgs',
    'TopicRuleSqsArgsDict',
    'TopicRuleStepFunctionArgs',
    'TopicRuleStepFunctionArgsDict',
    'TopicRuleTimestreamArgs',
    'TopicRuleTimestreamArgsDict',
    'TopicRuleTimestreamDimensionArgs',
    'TopicRuleTimestreamDimensionArgsDict',
    'TopicRuleTimestreamTimestampArgs',
    'TopicRuleTimestreamTimestampArgsDict',
]

MYPY = False

if not MYPY:
    class BillingGroupMetadataArgsDict(TypedDict):
        creation_date: pulumi.Input[_builtins.str]
elif False:
    BillingGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BillingGroupMetadataArgs:
    def __init__(__self__, *,
                 creation_date: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "creation_date", creation_date)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "creation_date", value)


if not MYPY:
    class BillingGroupPropertiesArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BillingGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BillingGroupPropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class CaCertificateRegistrationConfigArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        template_body: NotRequired[pulumi.Input[_builtins.str]]
        template_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CaCertificateRegistrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CaCertificateRegistrationConfigArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 template_body: Optional[pulumi.Input[_builtins.str]] = None,
                 template_name: Optional[pulumi.Input[_builtins.str]] = None):
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "template_body")

    @template_body.setter
    def template_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_body", value)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_name", value)


if not MYPY:
    class CaCertificateValidityArgsDict(TypedDict):
        not_after: NotRequired[pulumi.Input[_builtins.str]]
        not_before: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CaCertificateValidityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CaCertificateValidityArgs:
    def __init__(__self__, *,
                 not_after: Optional[pulumi.Input[_builtins.str]] = None,
                 not_before: Optional[pulumi.Input[_builtins.str]] = None):
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_after", value)

    @_builtins.property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "not_before")

    @not_before.setter
    def not_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_before", value)


if not MYPY:
    class DomainConfigurationAuthorizerConfigArgsDict(TypedDict):
        allow_authorizer_override: NotRequired[pulumi.Input[_builtins.bool]]
        default_authorizer_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainConfigurationAuthorizerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationAuthorizerConfigArgs:
    def __init__(__self__, *,
                 allow_authorizer_override: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_authorizer_name: Optional[pulumi.Input[_builtins.str]] = None):
        if allow_authorizer_override is not None:
            pulumi.set(__self__, "allow_authorizer_override", allow_authorizer_override)
        if default_authorizer_name is not None:
            pulumi.set(__self__, "default_authorizer_name", default_authorizer_name)

    @_builtins.property
    @pulumi.getter(name="allowAuthorizerOverride")
    def allow_authorizer_override(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "allow_authorizer_override")

    @allow_authorizer_override.setter
    def allow_authorizer_override(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_authorizer_override", value)

    @_builtins.property
    @pulumi.getter(name="defaultAuthorizerName")
    def default_authorizer_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_authorizer_name")

    @default_authorizer_name.setter
    def default_authorizer_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_authorizer_name", value)


if not MYPY:
    class DomainConfigurationTlsConfigArgsDict(TypedDict):
        security_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainConfigurationTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationTlsConfigArgs:
    def __init__(__self__, *,
                 security_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_policy")

    @security_policy.setter
    def security_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_policy", value)


if not MYPY:
    class IndexingConfigurationThingGroupIndexingConfigurationArgsDict(TypedDict):
        thing_group_indexing_mode: pulumi.Input[_builtins.str]
        custom_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgsDict']]]]
        managed_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgsDict']]]]
elif False:
    IndexingConfigurationThingGroupIndexingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationArgs:
    def __init__(__self__, *,
                 thing_group_indexing_mode: pulumi.Input[_builtins.str],
                 custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]] = None,
                 managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]] = None):
        pulumi.set(__self__, "thing_group_indexing_mode", thing_group_indexing_mode)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)

    @_builtins.property
    @pulumi.getter(name="thingGroupIndexingMode")
    def thing_group_indexing_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "thing_group_indexing_mode")

    @thing_group_indexing_mode.setter
    def thing_group_indexing_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "thing_group_indexing_mode", value)

    @_builtins.property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]]:
        return pulumi.get(self, "custom_fields")

    @custom_fields.setter
    def custom_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs']]]]):
        pulumi.set(self, "custom_fields", value)

    @_builtins.property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]]:
        return pulumi.get(self, "managed_fields")

    @managed_fields.setter
    def managed_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs']]]]):
        pulumi.set(self, "managed_fields", value)


if not MYPY:
    class IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationCustomFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingGroupIndexingConfigurationManagedFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IndexingConfigurationThingIndexingConfigurationArgsDict(TypedDict):
        thing_indexing_mode: pulumi.Input[_builtins.str]
        custom_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgsDict']]]]
        device_defender_indexing_mode: NotRequired[pulumi.Input[_builtins.str]]
        filter: NotRequired[pulumi.Input['IndexingConfigurationThingIndexingConfigurationFilterArgsDict']]
        managed_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgsDict']]]]
        named_shadow_indexing_mode: NotRequired[pulumi.Input[_builtins.str]]
        thing_connectivity_indexing_mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IndexingConfigurationThingIndexingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationArgs:
    def __init__(__self__, *,
                 thing_indexing_mode: pulumi.Input[_builtins.str],
                 custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]] = None,
                 device_defender_indexing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input['IndexingConfigurationThingIndexingConfigurationFilterArgs']] = None,
                 managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]] = None,
                 named_shadow_indexing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 thing_connectivity_indexing_mode: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "thing_indexing_mode", thing_indexing_mode)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if device_defender_indexing_mode is not None:
            pulumi.set(__self__, "device_defender_indexing_mode", device_defender_indexing_mode)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)
        if named_shadow_indexing_mode is not None:
            pulumi.set(__self__, "named_shadow_indexing_mode", named_shadow_indexing_mode)
        if thing_connectivity_indexing_mode is not None:
            pulumi.set(__self__, "thing_connectivity_indexing_mode", thing_connectivity_indexing_mode)

    @_builtins.property
    @pulumi.getter(name="thingIndexingMode")
    def thing_indexing_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "thing_indexing_mode")

    @thing_indexing_mode.setter
    def thing_indexing_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "thing_indexing_mode", value)

    @_builtins.property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]]:
        return pulumi.get(self, "custom_fields")

    @custom_fields.setter
    def custom_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationCustomFieldArgs']]]]):
        pulumi.set(self, "custom_fields", value)

    @_builtins.property
    @pulumi.getter(name="deviceDefenderIndexingMode")
    def device_defender_indexing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "device_defender_indexing_mode")

    @device_defender_indexing_mode.setter
    def device_defender_indexing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_defender_indexing_mode", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['IndexingConfigurationThingIndexingConfigurationFilterArgs']]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['IndexingConfigurationThingIndexingConfigurationFilterArgs']]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]]:
        return pulumi.get(self, "managed_fields")

    @managed_fields.setter
    def managed_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexingConfigurationThingIndexingConfigurationManagedFieldArgs']]]]):
        pulumi.set(self, "managed_fields", value)

    @_builtins.property
    @pulumi.getter(name="namedShadowIndexingMode")
    def named_shadow_indexing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "named_shadow_indexing_mode")

    @named_shadow_indexing_mode.setter
    def named_shadow_indexing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "named_shadow_indexing_mode", value)

    @_builtins.property
    @pulumi.getter(name="thingConnectivityIndexingMode")
    def thing_connectivity_indexing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "thing_connectivity_indexing_mode")

    @thing_connectivity_indexing_mode.setter
    def thing_connectivity_indexing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "thing_connectivity_indexing_mode", value)


if not MYPY:
    class IndexingConfigurationThingIndexingConfigurationCustomFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IndexingConfigurationThingIndexingConfigurationCustomFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationCustomFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IndexingConfigurationThingIndexingConfigurationFilterArgsDict(TypedDict):
        named_shadow_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    IndexingConfigurationThingIndexingConfigurationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationFilterArgs:
    def __init__(__self__, *,
                 named_shadow_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if named_shadow_names is not None:
            pulumi.set(__self__, "named_shadow_names", named_shadow_names)

    @_builtins.property
    @pulumi.getter(name="namedShadowNames")
    def named_shadow_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "named_shadow_names")

    @named_shadow_names.setter
    def named_shadow_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "named_shadow_names", value)


if not MYPY:
    class IndexingConfigurationThingIndexingConfigurationManagedFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IndexingConfigurationThingIndexingConfigurationManagedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingConfigurationThingIndexingConfigurationManagedFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProvisioningTemplatePreProvisioningHookArgsDict(TypedDict):
        target_arn: pulumi.Input[_builtins.str]
        payload_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProvisioningTemplatePreProvisioningHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisioningTemplatePreProvisioningHookArgs:
    def __init__(__self__, *,
                 target_arn: pulumi.Input[_builtins.str],
                 payload_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "target_arn", target_arn)
        if payload_version is not None:
            pulumi.set(__self__, "payload_version", payload_version)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)

    @_builtins.property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload_version")

    @payload_version.setter
    def payload_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload_version", value)


if not MYPY:
    class ThingGroupMetadataArgsDict(TypedDict):
        creation_date: NotRequired[pulumi.Input[_builtins.str]]
        parent_group_name: NotRequired[pulumi.Input[_builtins.str]]
        root_to_parent_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgsDict']]]]
elif False:
    ThingGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupMetadataArgs:
    def __init__(__self__, *,
                 creation_date: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 root_to_parent_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]] = None):
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if parent_group_name is not None:
            pulumi.set(__self__, "parent_group_name", parent_group_name)
        if root_to_parent_groups is not None:
            pulumi.set(__self__, "root_to_parent_groups", root_to_parent_groups)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creation_date", value)

    @_builtins.property
    @pulumi.getter(name="parentGroupName")
    def parent_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "parent_group_name")

    @parent_group_name.setter
    def parent_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_group_name", value)

    @_builtins.property
    @pulumi.getter(name="rootToParentGroups")
    def root_to_parent_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]]:
        return pulumi.get(self, "root_to_parent_groups")

    @root_to_parent_groups.setter
    def root_to_parent_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThingGroupMetadataRootToParentGroupArgs']]]]):
        pulumi.set(self, "root_to_parent_groups", value)


if not MYPY:
    class ThingGroupMetadataRootToParentGroupArgsDict(TypedDict):
        group_arn: NotRequired[pulumi.Input[_builtins.str]]
        group_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ThingGroupMetadataRootToParentGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupMetadataRootToParentGroupArgs:
    def __init__(__self__, *,
                 group_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None):
        if group_arn is not None:
            pulumi.set(__self__, "group_arn", group_arn)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="groupArn")
    def group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group_arn")

    @group_arn.setter
    def group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_arn", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)


if not MYPY:
    class ThingGroupPropertiesArgsDict(TypedDict):
        attribute_payload: NotRequired[pulumi.Input['ThingGroupPropertiesAttributePayloadArgsDict']]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ThingGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupPropertiesArgs:
    def __init__(__self__, *,
                 attribute_payload: Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        if attribute_payload is not None:
            pulumi.set(__self__, "attribute_payload", attribute_payload)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']]:
        return pulumi.get(self, "attribute_payload")

    @attribute_payload.setter
    def attribute_payload(self, value: Optional[pulumi.Input['ThingGroupPropertiesAttributePayloadArgs']]):
        pulumi.set(self, "attribute_payload", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ThingGroupPropertiesAttributePayloadArgsDict(TypedDict):
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ThingGroupPropertiesAttributePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupPropertiesAttributePayloadArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class ThingTypePropertiesArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        searchable_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ThingTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingTypePropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 searchable_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if searchable_attributes is not None:
            pulumi.set(__self__, "searchable_attributes", searchable_attributes)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "searchable_attributes")

    @searchable_attributes.setter
    def searchable_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "searchable_attributes", value)


if not MYPY:
    class TopicRuleCloudwatchAlarmArgsDict(TypedDict):
        alarm_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        state_reason: pulumi.Input[_builtins.str]
        state_value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleCloudwatchAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchAlarmArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 state_reason: pulumi.Input[_builtins.str],
                 state_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @_builtins.property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_reason")

    @state_reason.setter
    def state_reason(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_reason", value)

    @_builtins.property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_value")

    @state_value.setter
    def state_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_value", value)


if not MYPY:
    class TopicRuleCloudwatchLogArgsDict(TypedDict):
        log_group_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TopicRuleCloudwatchLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchLogArgs:
    def __init__(__self__, *,
                 log_group_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleCloudwatchMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        metric_namespace: pulumi.Input[_builtins.str]
        metric_unit: pulumi.Input[_builtins.str]
        metric_value: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        metric_timestamp: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleCloudwatchMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 metric_namespace: pulumi.Input[_builtins.str],
                 metric_unit: pulumi.Input[_builtins.str],
                 metric_value: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 metric_timestamp: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_unit", value)

    @_builtins.property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_value", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_timestamp")

    @metric_timestamp.setter
    def metric_timestamp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_timestamp", value)


if not MYPY:
    class TopicRuleDestinationVpcConfigurationArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        vpc_id: pulumi.Input[_builtins.str]
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    TopicRuleDestinationVpcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDestinationVpcConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 vpc_id: pulumi.Input[_builtins.str],
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class TopicRuleDynamodbArgsDict(TypedDict):
        hash_key_field: pulumi.Input[_builtins.str]
        hash_key_value: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        hash_key_type: NotRequired[pulumi.Input[_builtins.str]]
        operation: NotRequired[pulumi.Input[_builtins.str]]
        payload_field: NotRequired[pulumi.Input[_builtins.str]]
        range_key_field: NotRequired[pulumi.Input[_builtins.str]]
        range_key_type: NotRequired[pulumi.Input[_builtins.str]]
        range_key_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleDynamodbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDynamodbArgs:
    def __init__(__self__, *,
                 hash_key_field: pulumi.Input[_builtins.str],
                 hash_key_value: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 hash_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_field: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_field: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @_builtins.property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hash_key_field")

    @hash_key_field.setter
    def hash_key_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hash_key_field", value)

    @_builtins.property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hash_key_value")

    @hash_key_value.setter
    def hash_key_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hash_key_value", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hash_key_type")

    @hash_key_type.setter
    def hash_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash_key_type", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload_field")

    @payload_field.setter
    def payload_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload_field", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_field")

    @range_key_field.setter
    def range_key_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_field", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_type")

    @range_key_type.setter
    def range_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_type", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_value")

    @range_key_value.setter
    def range_key_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_value", value)


if not MYPY:
    class TopicRuleDynamodbv2ArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        put_item: NotRequired[pulumi.Input['TopicRuleDynamodbv2PutItemArgsDict']]
elif False:
    TopicRuleDynamodbv2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDynamodbv2Args:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 put_item: Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']]:
        return pulumi.get(self, "put_item")

    @put_item.setter
    def put_item(self, value: Optional[pulumi.Input['TopicRuleDynamodbv2PutItemArgs']]):
        pulumi.set(self, "put_item", value)


if not MYPY:
    class TopicRuleDynamodbv2PutItemArgsDict(TypedDict):
        table_name: pulumi.Input[_builtins.str]
elif False:
    TopicRuleDynamodbv2PutItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDynamodbv2PutItemArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class TopicRuleElasticsearchArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        id: pulumi.Input[_builtins.str]
        index: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    TopicRuleElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleElasticsearchArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 index: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicRuleErrorActionArgsDict(TypedDict):
        cloudwatch_alarm: NotRequired[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgsDict']]
        cloudwatch_logs: NotRequired[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgsDict']]
        cloudwatch_metric: NotRequired[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgsDict']]
        dynamodb: NotRequired[pulumi.Input['TopicRuleErrorActionDynamodbArgsDict']]
        dynamodbv2: NotRequired[pulumi.Input['TopicRuleErrorActionDynamodbv2ArgsDict']]
        elasticsearch: NotRequired[pulumi.Input['TopicRuleErrorActionElasticsearchArgsDict']]
        firehose: NotRequired[pulumi.Input['TopicRuleErrorActionFirehoseArgsDict']]
        http: NotRequired[pulumi.Input['TopicRuleErrorActionHttpArgsDict']]
        iot_analytics: NotRequired[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgsDict']]
        iot_events: NotRequired[pulumi.Input['TopicRuleErrorActionIotEventsArgsDict']]
        kafka: NotRequired[pulumi.Input['TopicRuleErrorActionKafkaArgsDict']]
        kinesis: NotRequired[pulumi.Input['TopicRuleErrorActionKinesisArgsDict']]
        lambda_: NotRequired[pulumi.Input['TopicRuleErrorActionLambdaArgsDict']]
        republish: NotRequired[pulumi.Input['TopicRuleErrorActionRepublishArgsDict']]
        s3: NotRequired[pulumi.Input['TopicRuleErrorActionS3ArgsDict']]
        sns: NotRequired[pulumi.Input['TopicRuleErrorActionSnsArgsDict']]
        sqs: NotRequired[pulumi.Input['TopicRuleErrorActionSqsArgsDict']]
        step_functions: NotRequired[pulumi.Input['TopicRuleErrorActionStepFunctionsArgsDict']]
        timestream: NotRequired[pulumi.Input['TopicRuleErrorActionTimestreamArgsDict']]
elif False:
    TopicRuleErrorActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionArgs:
    def __init__(__self__, *,
                 cloudwatch_alarm: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']] = None,
                 cloudwatch_logs: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']] = None,
                 cloudwatch_metric: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']] = None,
                 dynamodb: Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']] = None,
                 dynamodbv2: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']] = None,
                 elasticsearch: Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']] = None,
                 firehose: Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']] = None,
                 http: Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']] = None,
                 iot_analytics: Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']] = None,
                 iot_events: Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']] = None,
                 kafka: Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']] = None,
                 kinesis: Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']] = None,
                 lambda_: Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']] = None,
                 republish: Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']] = None,
                 s3: Optional[pulumi.Input['TopicRuleErrorActionS3Args']] = None,
                 sns: Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']] = None,
                 sqs: Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']] = None,
                 step_functions: Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']] = None,
                 timestream: Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']] = None):
        if cloudwatch_alarm is not None:
            pulumi.set(__self__, "cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            pulumi.set(__self__, "cloudwatch_metric", cloudwatch_metric)
        if dynamodb is not None:
            pulumi.set(__self__, "dynamodb", dynamodb)
        if dynamodbv2 is not None:
            pulumi.set(__self__, "dynamodbv2", dynamodbv2)
        if elasticsearch is not None:
            pulumi.set(__self__, "elasticsearch", elasticsearch)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if iot_analytics is not None:
            pulumi.set(__self__, "iot_analytics", iot_analytics)
        if iot_events is not None:
            pulumi.set(__self__, "iot_events", iot_events)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kinesis is not None:
            pulumi.set(__self__, "kinesis", kinesis)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)
        if republish is not None:
            pulumi.set(__self__, "republish", republish)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sqs is not None:
            pulumi.set(__self__, "sqs", sqs)
        if step_functions is not None:
            pulumi.set(__self__, "step_functions", step_functions)
        if timestream is not None:
            pulumi.set(__self__, "timestream", timestream)

    @_builtins.property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']]:
        return pulumi.get(self, "cloudwatch_alarm")

    @cloudwatch_alarm.setter
    def cloudwatch_alarm(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchAlarmArgs']]):
        pulumi.set(self, "cloudwatch_alarm", value)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']]:
        return pulumi.get(self, "cloudwatch_metric")

    @cloudwatch_metric.setter
    def cloudwatch_metric(self, value: Optional[pulumi.Input['TopicRuleErrorActionCloudwatchMetricArgs']]):
        pulumi.set(self, "cloudwatch_metric", value)

    @_builtins.property
    @pulumi.getter
    def dynamodb(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']]:
        return pulumi.get(self, "dynamodb")

    @dynamodb.setter
    def dynamodb(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbArgs']]):
        pulumi.set(self, "dynamodb", value)

    @_builtins.property
    @pulumi.getter
    def dynamodbv2(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']]:
        return pulumi.get(self, "dynamodbv2")

    @dynamodbv2.setter
    def dynamodbv2(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2Args']]):
        pulumi.set(self, "dynamodbv2", value)

    @_builtins.property
    @pulumi.getter
    def elasticsearch(self) -> Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']]:
        return pulumi.get(self, "elasticsearch")

    @elasticsearch.setter
    def elasticsearch(self, value: Optional[pulumi.Input['TopicRuleErrorActionElasticsearchArgs']]):
        pulumi.set(self, "elasticsearch", value)

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']]:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['TopicRuleErrorActionFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['TopicRuleErrorActionHttpArgs']]):
        pulumi.set(self, "http", value)

    @_builtins.property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']]:
        return pulumi.get(self, "iot_analytics")

    @iot_analytics.setter
    def iot_analytics(self, value: Optional[pulumi.Input['TopicRuleErrorActionIotAnalyticsArgs']]):
        pulumi.set(self, "iot_analytics", value)

    @_builtins.property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']]:
        return pulumi.get(self, "iot_events")

    @iot_events.setter
    def iot_events(self, value: Optional[pulumi.Input['TopicRuleErrorActionIotEventsArgs']]):
        pulumi.set(self, "iot_events", value)

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']]:
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input['TopicRuleErrorActionKafkaArgs']]):
        pulumi.set(self, "kafka", value)

    @_builtins.property
    @pulumi.getter
    def kinesis(self) -> Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']]:
        return pulumi.get(self, "kinesis")

    @kinesis.setter
    def kinesis(self, value: Optional[pulumi.Input['TopicRuleErrorActionKinesisArgs']]):
        pulumi.set(self, "kinesis", value)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']]:
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input['TopicRuleErrorActionLambdaArgs']]):
        pulumi.set(self, "lambda_", value)

    @_builtins.property
    @pulumi.getter
    def republish(self) -> Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']]:
        return pulumi.get(self, "republish")

    @republish.setter
    def republish(self, value: Optional[pulumi.Input['TopicRuleErrorActionRepublishArgs']]):
        pulumi.set(self, "republish", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['TopicRuleErrorActionS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['TopicRuleErrorActionS3Args']]):
        pulumi.set(self, "s3", value)

    @_builtins.property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']]:
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input['TopicRuleErrorActionSnsArgs']]):
        pulumi.set(self, "sns", value)

    @_builtins.property
    @pulumi.getter
    def sqs(self) -> Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']]:
        return pulumi.get(self, "sqs")

    @sqs.setter
    def sqs(self, value: Optional[pulumi.Input['TopicRuleErrorActionSqsArgs']]):
        pulumi.set(self, "sqs", value)

    @_builtins.property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']]:
        return pulumi.get(self, "step_functions")

    @step_functions.setter
    def step_functions(self, value: Optional[pulumi.Input['TopicRuleErrorActionStepFunctionsArgs']]):
        pulumi.set(self, "step_functions", value)

    @_builtins.property
    @pulumi.getter
    def timestream(self) -> Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']]:
        return pulumi.get(self, "timestream")

    @timestream.setter
    def timestream(self, value: Optional[pulumi.Input['TopicRuleErrorActionTimestreamArgs']]):
        pulumi.set(self, "timestream", value)


if not MYPY:
    class TopicRuleErrorActionCloudwatchAlarmArgsDict(TypedDict):
        alarm_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        state_reason: pulumi.Input[_builtins.str]
        state_value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionCloudwatchAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionCloudwatchAlarmArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 state_reason: pulumi.Input[_builtins.str],
                 state_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @_builtins.property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_reason")

    @state_reason.setter
    def state_reason(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_reason", value)

    @_builtins.property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_value")

    @state_value.setter
    def state_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_value", value)


if not MYPY:
    class TopicRuleErrorActionCloudwatchLogsArgsDict(TypedDict):
        log_group_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TopicRuleErrorActionCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleErrorActionCloudwatchMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        metric_namespace: pulumi.Input[_builtins.str]
        metric_unit: pulumi.Input[_builtins.str]
        metric_value: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        metric_timestamp: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionCloudwatchMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionCloudwatchMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 metric_namespace: pulumi.Input[_builtins.str],
                 metric_unit: pulumi.Input[_builtins.str],
                 metric_value: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 metric_timestamp: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_unit", value)

    @_builtins.property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_value", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_timestamp")

    @metric_timestamp.setter
    def metric_timestamp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_timestamp", value)


if not MYPY:
    class TopicRuleErrorActionDynamodbArgsDict(TypedDict):
        hash_key_field: pulumi.Input[_builtins.str]
        hash_key_value: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        hash_key_type: NotRequired[pulumi.Input[_builtins.str]]
        operation: NotRequired[pulumi.Input[_builtins.str]]
        payload_field: NotRequired[pulumi.Input[_builtins.str]]
        range_key_field: NotRequired[pulumi.Input[_builtins.str]]
        range_key_type: NotRequired[pulumi.Input[_builtins.str]]
        range_key_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionDynamodbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionDynamodbArgs:
    def __init__(__self__, *,
                 hash_key_field: pulumi.Input[_builtins.str],
                 hash_key_value: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 hash_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 payload_field: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_field: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 range_key_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @_builtins.property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hash_key_field")

    @hash_key_field.setter
    def hash_key_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hash_key_field", value)

    @_builtins.property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hash_key_value")

    @hash_key_value.setter
    def hash_key_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hash_key_value", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hash_key_type")

    @hash_key_type.setter
    def hash_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash_key_type", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload_field")

    @payload_field.setter
    def payload_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload_field", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_field")

    @range_key_field.setter
    def range_key_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_field", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_type")

    @range_key_type.setter
    def range_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_type", value)

    @_builtins.property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "range_key_value")

    @range_key_value.setter
    def range_key_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "range_key_value", value)


if not MYPY:
    class TopicRuleErrorActionDynamodbv2ArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        put_item: NotRequired[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgsDict']]
elif False:
    TopicRuleErrorActionDynamodbv2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionDynamodbv2Args:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 put_item: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']]:
        return pulumi.get(self, "put_item")

    @put_item.setter
    def put_item(self, value: Optional[pulumi.Input['TopicRuleErrorActionDynamodbv2PutItemArgs']]):
        pulumi.set(self, "put_item", value)


if not MYPY:
    class TopicRuleErrorActionDynamodbv2PutItemArgsDict(TypedDict):
        table_name: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionDynamodbv2PutItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionDynamodbv2PutItemArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class TopicRuleErrorActionElasticsearchArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        id: pulumi.Input[_builtins.str]
        index: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionElasticsearchArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 index: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicRuleErrorActionFirehoseArgsDict(TypedDict):
        delivery_stream_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
        separator: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 separator: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @_builtins.property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "delivery_stream_name")

    @delivery_stream_name.setter
    def delivery_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delivery_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "separator", value)


if not MYPY:
    class TopicRuleErrorActionHttpArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        confirmation_url: NotRequired[pulumi.Input[_builtins.str]]
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgsDict']]]]
elif False:
    TopicRuleErrorActionHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionHttpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 confirmation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]] = None):
        pulumi.set(__self__, "url", url)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "confirmation_url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionHttpHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)


if not MYPY:
    class TopicRuleErrorActionHttpHttpHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionHttpHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionHttpHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleErrorActionIotAnalyticsArgsDict(TypedDict):
        channel_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TopicRuleErrorActionIotAnalyticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionIotAnalyticsArgs:
    def __init__(__self__, *,
                 channel_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleErrorActionIotEventsArgsDict(TypedDict):
        input_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
        message_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionIotEventsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionIotEventsArgs:
    def __init__(__self__, *,
                 input_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="inputName")
    def input_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "input_name")

    @input_name.setter
    def input_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class TopicRuleErrorActionKafkaArgsDict(TypedDict):
        client_properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        destination_arn: pulumi.Input[_builtins.str]
        topic: pulumi.Input[_builtins.str]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionKafkaHeaderArgsDict']]]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        partition: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionKafkaArgs:
    def __init__(__self__, *,
                 client_properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 destination_arn: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionKafkaHeaderArgs']]]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 partition: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "client_properties")

    @client_properties.setter
    def client_properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "client_properties", value)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionKafkaHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionKafkaHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition", value)


if not MYPY:
    class TopicRuleErrorActionKafkaHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionKafkaHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionKafkaHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleErrorActionKinesisArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        stream_name: pulumi.Input[_builtins.str]
        partition_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionKinesisArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 partition_key: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition_key", value)


if not MYPY:
    class TopicRuleErrorActionLambdaArgsDict(TypedDict):
        function_arn: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionLambdaArgs:
    def __init__(__self__, *,
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class TopicRuleErrorActionRepublishArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        topic: pulumi.Input[_builtins.str]
        qos: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TopicRuleErrorActionRepublishArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionRepublishArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 qos: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qos", value)


if not MYPY:
    class TopicRuleErrorActionS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        canned_acl: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 canned_acl: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canned_acl", value)


if not MYPY:
    class TopicRuleErrorActionSnsArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        target_arn: pulumi.Input[_builtins.str]
        message_format: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionSnsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 target_arn: pulumi.Input[_builtins.str],
                 message_format: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)


if not MYPY:
    class TopicRuleErrorActionSqsArgsDict(TypedDict):
        queue_url: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        use_base64: pulumi.Input[_builtins.bool]
elif False:
    TopicRuleErrorActionSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionSqsArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 use_base64: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "use_base64", use_base64)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_url", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "use_base64")

    @use_base64.setter
    def use_base64(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "use_base64", value)


if not MYPY:
    class TopicRuleErrorActionStepFunctionsArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        state_machine_name: pulumi.Input[_builtins.str]
        execution_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleErrorActionStepFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionStepFunctionsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 state_machine_name: pulumi.Input[_builtins.str],
                 execution_name_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_machine_name")

    @state_machine_name.setter
    def state_machine_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_machine_name", value)

    @_builtins.property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "execution_name_prefix")

    @execution_name_prefix.setter
    def execution_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_name_prefix", value)


if not MYPY:
    class TopicRuleErrorActionTimestreamArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgsDict']]]
        role_arn: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        timestamp: NotRequired[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgsDict']]
elif False:
    TopicRuleErrorActionTimestreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionTimestreamArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]],
                 role_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 timestamp: Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleErrorActionTimestreamDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleErrorActionTimestreamTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class TopicRuleErrorActionTimestreamDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionTimestreamDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionTimestreamDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleErrorActionTimestreamTimestampArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleErrorActionTimestreamTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleErrorActionTimestreamTimestampArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleFirehoseArgsDict(TypedDict):
        delivery_stream_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
        separator: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 separator: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @_builtins.property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "delivery_stream_name")

    @delivery_stream_name.setter
    def delivery_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delivery_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "separator", value)


if not MYPY:
    class TopicRuleHttpArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        confirmation_url: NotRequired[pulumi.Input[_builtins.str]]
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgsDict']]]]
elif False:
    TopicRuleHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleHttpArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 confirmation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]] = None):
        pulumi.set(__self__, "url", url)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "confirmation_url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)


if not MYPY:
    class TopicRuleHttpHttpHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleHttpHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleHttpHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleIotAnalyticArgsDict(TypedDict):
        channel_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TopicRuleIotAnalyticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleIotAnalyticArgs:
    def __init__(__self__, *,
                 channel_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleIotEventArgsDict(TypedDict):
        input_name: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        batch_mode: NotRequired[pulumi.Input[_builtins.bool]]
        message_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleIotEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleIotEventArgs:
    def __init__(__self__, *,
                 input_name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 batch_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="inputName")
    def input_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "input_name")

    @input_name.setter
    def input_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "batch_mode", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class TopicRuleKafkaArgsDict(TypedDict):
        client_properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        destination_arn: pulumi.Input[_builtins.str]
        topic: pulumi.Input[_builtins.str]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaHeaderArgsDict']]]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        partition: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKafkaArgs:
    def __init__(__self__, *,
                 client_properties: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 destination_arn: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaHeaderArgs']]]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 partition: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "client_properties")

    @client_properties.setter
    def client_properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "client_properties", value)

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_arn", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition", value)


if not MYPY:
    class TopicRuleKafkaHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleKafkaHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKafkaHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleKinesisArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        stream_name: pulumi.Input[_builtins.str]
        partition_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKinesisArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 partition_key: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition_key", value)


if not MYPY:
    class TopicRuleLambdaArgsDict(TypedDict):
        function_arn: pulumi.Input[_builtins.str]
elif False:
    TopicRuleLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleLambdaArgs:
    def __init__(__self__, *,
                 function_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class TopicRuleRepublishArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        topic: pulumi.Input[_builtins.str]
        qos: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TopicRuleRepublishArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleRepublishArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 qos: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qos", value)


if not MYPY:
    class TopicRuleS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        canned_acl: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 canned_acl: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canned_acl", value)


if not MYPY:
    class TopicRuleSnsArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        target_arn: pulumi.Input[_builtins.str]
        message_format: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleSnsArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 target_arn: pulumi.Input[_builtins.str],
                 message_format: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_arn", value)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)


if not MYPY:
    class TopicRuleSqsArgsDict(TypedDict):
        queue_url: pulumi.Input[_builtins.str]
        role_arn: pulumi.Input[_builtins.str]
        use_base64: pulumi.Input[_builtins.bool]
elif False:
    TopicRuleSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleSqsArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 use_base64: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "use_base64", use_base64)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_url", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "use_base64")

    @use_base64.setter
    def use_base64(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "use_base64", value)


if not MYPY:
    class TopicRuleStepFunctionArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        state_machine_name: pulumi.Input[_builtins.str]
        execution_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TopicRuleStepFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleStepFunctionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 state_machine_name: pulumi.Input[_builtins.str],
                 execution_name_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "state_machine_name")

    @state_machine_name.setter
    def state_machine_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state_machine_name", value)

    @_builtins.property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "execution_name_prefix")

    @execution_name_prefix.setter
    def execution_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_name_prefix", value)


if not MYPY:
    class TopicRuleTimestreamArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgsDict']]]
        role_arn: pulumi.Input[_builtins.str]
        table_name: pulumi.Input[_builtins.str]
        timestamp: NotRequired[pulumi.Input['TopicRuleTimestreamTimestampArgsDict']]
elif False:
    TopicRuleTimestreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]],
                 role_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str],
                 timestamp: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class TopicRuleTimestreamDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleTimestreamDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleTimestreamTimestampArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    TopicRuleTimestreamTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamTimestampArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


