# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BillingGroupMetadata',
    'BillingGroupProperties',
    'CaCertificateRegistrationConfig',
    'CaCertificateValidity',
    'DomainConfigurationAuthorizerConfig',
    'DomainConfigurationTlsConfig',
    'IndexingConfigurationThingGroupIndexingConfiguration',
    'IndexingConfigurationThingGroupIndexingConfigurationCustomField',
    'IndexingConfigurationThingGroupIndexingConfigurationManagedField',
    'IndexingConfigurationThingIndexingConfiguration',
    'IndexingConfigurationThingIndexingConfigurationCustomField',
    'IndexingConfigurationThingIndexingConfigurationFilter',
    'IndexingConfigurationThingIndexingConfigurationManagedField',
    'ProvisioningTemplatePreProvisioningHook',
    'ThingGroupMetadata',
    'ThingGroupMetadataRootToParentGroup',
    'ThingGroupProperties',
    'ThingGroupPropertiesAttributePayload',
    'ThingTypeProperties',
    'TopicRuleCloudwatchAlarm',
    'TopicRuleCloudwatchLog',
    'TopicRuleCloudwatchMetric',
    'TopicRuleDestinationVpcConfiguration',
    'TopicRuleDynamodb',
    'TopicRuleDynamodbv2',
    'TopicRuleDynamodbv2PutItem',
    'TopicRuleElasticsearch',
    'TopicRuleErrorAction',
    'TopicRuleErrorActionCloudwatchAlarm',
    'TopicRuleErrorActionCloudwatchLogs',
    'TopicRuleErrorActionCloudwatchMetric',
    'TopicRuleErrorActionDynamodb',
    'TopicRuleErrorActionDynamodbv2',
    'TopicRuleErrorActionDynamodbv2PutItem',
    'TopicRuleErrorActionElasticsearch',
    'TopicRuleErrorActionFirehose',
    'TopicRuleErrorActionHttp',
    'TopicRuleErrorActionHttpHttpHeader',
    'TopicRuleErrorActionIotAnalytics',
    'TopicRuleErrorActionIotEvents',
    'TopicRuleErrorActionKafka',
    'TopicRuleErrorActionKafkaHeader',
    'TopicRuleErrorActionKinesis',
    'TopicRuleErrorActionLambda',
    'TopicRuleErrorActionRepublish',
    'TopicRuleErrorActionS3',
    'TopicRuleErrorActionSns',
    'TopicRuleErrorActionSqs',
    'TopicRuleErrorActionStepFunctions',
    'TopicRuleErrorActionTimestream',
    'TopicRuleErrorActionTimestreamDimension',
    'TopicRuleErrorActionTimestreamTimestamp',
    'TopicRuleFirehose',
    'TopicRuleHttp',
    'TopicRuleHttpHttpHeader',
    'TopicRuleIotAnalytic',
    'TopicRuleIotEvent',
    'TopicRuleKafka',
    'TopicRuleKafkaHeader',
    'TopicRuleKinesis',
    'TopicRuleLambda',
    'TopicRuleRepublish',
    'TopicRuleS3',
    'TopicRuleSns',
    'TopicRuleSqs',
    'TopicRuleStepFunction',
    'TopicRuleTimestream',
    'TopicRuleTimestreamDimension',
    'TopicRuleTimestreamTimestamp',
]

@pulumi.output_type
class BillingGroupMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDate":
            suggest = "creation_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BillingGroupMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BillingGroupMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BillingGroupMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date: _builtins.str):
        pulumi.set(__self__, "creation_date", creation_date)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> _builtins.str:
        return pulumi.get(self, "creation_date")


@pulumi.output_type
class BillingGroupProperties(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class CaCertificateRegistrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "templateBody":
            suggest = "template_body"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaCertificateRegistrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[_builtins.str] = None,
                 template_body: Optional[_builtins.str] = None,
                 template_name: Optional[_builtins.str] = None):
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "template_body")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "template_name")


@pulumi.output_type
class CaCertificateValidity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaCertificateValidity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaCertificateValidity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaCertificateValidity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 not_after: Optional[_builtins.str] = None,
                 not_before: Optional[_builtins.str] = None):
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "not_before")


@pulumi.output_type
class DomainConfigurationAuthorizerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAuthorizerOverride":
            suggest = "allow_authorizer_override"
        elif key == "defaultAuthorizerName":
            suggest = "default_authorizer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationAuthorizerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_authorizer_override: Optional[_builtins.bool] = None,
                 default_authorizer_name: Optional[_builtins.str] = None):
        if allow_authorizer_override is not None:
            pulumi.set(__self__, "allow_authorizer_override", allow_authorizer_override)
        if default_authorizer_name is not None:
            pulumi.set(__self__, "default_authorizer_name", default_authorizer_name)

    @_builtins.property
    @pulumi.getter(name="allowAuthorizerOverride")
    def allow_authorizer_override(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_authorizer_override")

    @_builtins.property
    @pulumi.getter(name="defaultAuthorizerName")
    def default_authorizer_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_authorizer_name")


@pulumi.output_type
class DomainConfigurationTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_policy: Optional[_builtins.str] = None):
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @_builtins.property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class IndexingConfigurationThingGroupIndexingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thingGroupIndexingMode":
            suggest = "thing_group_indexing_mode"
        elif key == "customFields":
            suggest = "custom_fields"
        elif key == "managedFields":
            suggest = "managed_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexingConfigurationThingGroupIndexingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexingConfigurationThingGroupIndexingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexingConfigurationThingGroupIndexingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 thing_group_indexing_mode: _builtins.str,
                 custom_fields: Optional[Sequence['outputs.IndexingConfigurationThingGroupIndexingConfigurationCustomField']] = None,
                 managed_fields: Optional[Sequence['outputs.IndexingConfigurationThingGroupIndexingConfigurationManagedField']] = None):
        pulumi.set(__self__, "thing_group_indexing_mode", thing_group_indexing_mode)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)

    @_builtins.property
    @pulumi.getter(name="thingGroupIndexingMode")
    def thing_group_indexing_mode(self) -> _builtins.str:
        return pulumi.get(self, "thing_group_indexing_mode")

    @_builtins.property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[Sequence['outputs.IndexingConfigurationThingGroupIndexingConfigurationCustomField']]:
        return pulumi.get(self, "custom_fields")

    @_builtins.property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[Sequence['outputs.IndexingConfigurationThingGroupIndexingConfigurationManagedField']]:
        return pulumi.get(self, "managed_fields")


@pulumi.output_type
class IndexingConfigurationThingGroupIndexingConfigurationCustomField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class IndexingConfigurationThingGroupIndexingConfigurationManagedField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class IndexingConfigurationThingIndexingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thingIndexingMode":
            suggest = "thing_indexing_mode"
        elif key == "customFields":
            suggest = "custom_fields"
        elif key == "deviceDefenderIndexingMode":
            suggest = "device_defender_indexing_mode"
        elif key == "managedFields":
            suggest = "managed_fields"
        elif key == "namedShadowIndexingMode":
            suggest = "named_shadow_indexing_mode"
        elif key == "thingConnectivityIndexingMode":
            suggest = "thing_connectivity_indexing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexingConfigurationThingIndexingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexingConfigurationThingIndexingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexingConfigurationThingIndexingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 thing_indexing_mode: _builtins.str,
                 custom_fields: Optional[Sequence['outputs.IndexingConfigurationThingIndexingConfigurationCustomField']] = None,
                 device_defender_indexing_mode: Optional[_builtins.str] = None,
                 filter: Optional['outputs.IndexingConfigurationThingIndexingConfigurationFilter'] = None,
                 managed_fields: Optional[Sequence['outputs.IndexingConfigurationThingIndexingConfigurationManagedField']] = None,
                 named_shadow_indexing_mode: Optional[_builtins.str] = None,
                 thing_connectivity_indexing_mode: Optional[_builtins.str] = None):
        pulumi.set(__self__, "thing_indexing_mode", thing_indexing_mode)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if device_defender_indexing_mode is not None:
            pulumi.set(__self__, "device_defender_indexing_mode", device_defender_indexing_mode)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)
        if named_shadow_indexing_mode is not None:
            pulumi.set(__self__, "named_shadow_indexing_mode", named_shadow_indexing_mode)
        if thing_connectivity_indexing_mode is not None:
            pulumi.set(__self__, "thing_connectivity_indexing_mode", thing_connectivity_indexing_mode)

    @_builtins.property
    @pulumi.getter(name="thingIndexingMode")
    def thing_indexing_mode(self) -> _builtins.str:
        return pulumi.get(self, "thing_indexing_mode")

    @_builtins.property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[Sequence['outputs.IndexingConfigurationThingIndexingConfigurationCustomField']]:
        return pulumi.get(self, "custom_fields")

    @_builtins.property
    @pulumi.getter(name="deviceDefenderIndexingMode")
    def device_defender_indexing_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_defender_indexing_mode")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional['outputs.IndexingConfigurationThingIndexingConfigurationFilter']:
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[Sequence['outputs.IndexingConfigurationThingIndexingConfigurationManagedField']]:
        return pulumi.get(self, "managed_fields")

    @_builtins.property
    @pulumi.getter(name="namedShadowIndexingMode")
    def named_shadow_indexing_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "named_shadow_indexing_mode")

    @_builtins.property
    @pulumi.getter(name="thingConnectivityIndexingMode")
    def thing_connectivity_indexing_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "thing_connectivity_indexing_mode")


@pulumi.output_type
class IndexingConfigurationThingIndexingConfigurationCustomField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class IndexingConfigurationThingIndexingConfigurationFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namedShadowNames":
            suggest = "named_shadow_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexingConfigurationThingIndexingConfigurationFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexingConfigurationThingIndexingConfigurationFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexingConfigurationThingIndexingConfigurationFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 named_shadow_names: Optional[Sequence[_builtins.str]] = None):
        if named_shadow_names is not None:
            pulumi.set(__self__, "named_shadow_names", named_shadow_names)

    @_builtins.property
    @pulumi.getter(name="namedShadowNames")
    def named_shadow_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "named_shadow_names")


@pulumi.output_type
class IndexingConfigurationThingIndexingConfigurationManagedField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ProvisioningTemplatePreProvisioningHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"
        elif key == "payloadVersion":
            suggest = "payload_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisioningTemplatePreProvisioningHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisioningTemplatePreProvisioningHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisioningTemplatePreProvisioningHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: _builtins.str,
                 payload_version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "target_arn", target_arn)
        if payload_version is not None:
            pulumi.set(__self__, "payload_version", payload_version)

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        return pulumi.get(self, "target_arn")

    @_builtins.property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "payload_version")


@pulumi.output_type
class ThingGroupMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDate":
            suggest = "creation_date"
        elif key == "parentGroupName":
            suggest = "parent_group_name"
        elif key == "rootToParentGroups":
            suggest = "root_to_parent_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingGroupMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingGroupMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingGroupMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date: Optional[_builtins.str] = None,
                 parent_group_name: Optional[_builtins.str] = None,
                 root_to_parent_groups: Optional[Sequence['outputs.ThingGroupMetadataRootToParentGroup']] = None):
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if parent_group_name is not None:
            pulumi.set(__self__, "parent_group_name", parent_group_name)
        if root_to_parent_groups is not None:
            pulumi.set(__self__, "root_to_parent_groups", root_to_parent_groups)

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creation_date")

    @_builtins.property
    @pulumi.getter(name="parentGroupName")
    def parent_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "parent_group_name")

    @_builtins.property
    @pulumi.getter(name="rootToParentGroups")
    def root_to_parent_groups(self) -> Optional[Sequence['outputs.ThingGroupMetadataRootToParentGroup']]:
        return pulumi.get(self, "root_to_parent_groups")


@pulumi.output_type
class ThingGroupMetadataRootToParentGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupArn":
            suggest = "group_arn"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingGroupMetadataRootToParentGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingGroupMetadataRootToParentGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingGroupMetadataRootToParentGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_arn: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None):
        if group_arn is not None:
            pulumi.set(__self__, "group_arn", group_arn)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="groupArn")
    def group_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_arn")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_name")


@pulumi.output_type
class ThingGroupProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributePayload":
            suggest = "attribute_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingGroupProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingGroupProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingGroupProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_payload: Optional['outputs.ThingGroupPropertiesAttributePayload'] = None,
                 description: Optional[_builtins.str] = None):
        if attribute_payload is not None:
            pulumi.set(__self__, "attribute_payload", attribute_payload)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional['outputs.ThingGroupPropertiesAttributePayload']:
        return pulumi.get(self, "attribute_payload")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ThingGroupPropertiesAttributePayload(dict):
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, _builtins.str]] = None):
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ThingTypeProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchableAttributes":
            suggest = "searchable_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingTypeProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingTypeProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingTypeProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 searchable_attributes: Optional[Sequence[_builtins.str]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if searchable_attributes is not None:
            pulumi.set(__self__, "searchable_attributes", searchable_attributes)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "searchable_attributes")


@pulumi.output_type
class TopicRuleCloudwatchAlarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmName":
            suggest = "alarm_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "stateValue":
            suggest = "state_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchAlarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchAlarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchAlarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_name: _builtins.str,
                 role_arn: _builtins.str,
                 state_reason: _builtins.str,
                 state_value: _builtins.str):
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @_builtins.property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> _builtins.str:
        return pulumi.get(self, "alarm_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> _builtins.str:
        return pulumi.get(self, "state_reason")

    @_builtins.property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> _builtins.str:
        return pulumi.get(self, "state_value")


@pulumi.output_type
class TopicRuleCloudwatchLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupName":
            suggest = "log_group_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleCloudwatchMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "metricValue":
            suggest = "metric_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "metricTimestamp":
            suggest = "metric_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 metric_namespace: _builtins.str,
                 metric_unit: _builtins.str,
                 metric_value: _builtins.str,
                 role_arn: _builtins.str,
                 metric_timestamp: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> _builtins.str:
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> _builtins.str:
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> _builtins.str:
        return pulumi.get(self, "metric_value")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_timestamp")


@pulumi.output_type
class TopicRuleDestinationVpcConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDestinationVpcConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDestinationVpcConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDestinationVpcConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 subnet_ids: Sequence[_builtins.str],
                 vpc_id: _builtins.str,
                 security_groups: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")


@pulumi.output_type
class TopicRuleDynamodb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKeyField":
            suggest = "hash_key_field"
        elif key == "hashKeyValue":
            suggest = "hash_key_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "hashKeyType":
            suggest = "hash_key_type"
        elif key == "payloadField":
            suggest = "payload_field"
        elif key == "rangeKeyField":
            suggest = "range_key_field"
        elif key == "rangeKeyType":
            suggest = "range_key_type"
        elif key == "rangeKeyValue":
            suggest = "range_key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamodb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamodb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamodb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key_field: _builtins.str,
                 hash_key_value: _builtins.str,
                 role_arn: _builtins.str,
                 table_name: _builtins.str,
                 hash_key_type: Optional[_builtins.str] = None,
                 operation: Optional[_builtins.str] = None,
                 payload_field: Optional[_builtins.str] = None,
                 range_key_field: Optional[_builtins.str] = None,
                 range_key_type: Optional[_builtins.str] = None,
                 range_key_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @_builtins.property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> _builtins.str:
        return pulumi.get(self, "hash_key_field")

    @_builtins.property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> _builtins.str:
        return pulumi.get(self, "hash_key_value")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hash_key_type")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "payload_field")

    @_builtins.property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_field")

    @_builtins.property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_type")

    @_builtins.property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_value")


@pulumi.output_type
class TopicRuleDynamodbv2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "putItem":
            suggest = "put_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamodbv2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamodbv2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamodbv2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 put_item: Optional['outputs.TopicRuleDynamodbv2PutItem'] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional['outputs.TopicRuleDynamodbv2PutItem']:
        return pulumi.get(self, "put_item")


@pulumi.output_type
class TopicRuleDynamodbv2PutItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamodbv2PutItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamodbv2PutItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamodbv2PutItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_name: _builtins.str):
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class TopicRuleElasticsearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleElasticsearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleElasticsearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleElasticsearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 id: _builtins.str,
                 index: _builtins.str,
                 role_arn: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.str:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRuleErrorAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchAlarm":
            suggest = "cloudwatch_alarm"
        elif key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"
        elif key == "cloudwatchMetric":
            suggest = "cloudwatch_metric"
        elif key == "iotAnalytics":
            suggest = "iot_analytics"
        elif key == "iotEvents":
            suggest = "iot_events"
        elif key == "lambda":
            suggest = "lambda_"
        elif key == "stepFunctions":
            suggest = "step_functions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_alarm: Optional['outputs.TopicRuleErrorActionCloudwatchAlarm'] = None,
                 cloudwatch_logs: Optional['outputs.TopicRuleErrorActionCloudwatchLogs'] = None,
                 cloudwatch_metric: Optional['outputs.TopicRuleErrorActionCloudwatchMetric'] = None,
                 dynamodb: Optional['outputs.TopicRuleErrorActionDynamodb'] = None,
                 dynamodbv2: Optional['outputs.TopicRuleErrorActionDynamodbv2'] = None,
                 elasticsearch: Optional['outputs.TopicRuleErrorActionElasticsearch'] = None,
                 firehose: Optional['outputs.TopicRuleErrorActionFirehose'] = None,
                 http: Optional['outputs.TopicRuleErrorActionHttp'] = None,
                 iot_analytics: Optional['outputs.TopicRuleErrorActionIotAnalytics'] = None,
                 iot_events: Optional['outputs.TopicRuleErrorActionIotEvents'] = None,
                 kafka: Optional['outputs.TopicRuleErrorActionKafka'] = None,
                 kinesis: Optional['outputs.TopicRuleErrorActionKinesis'] = None,
                 lambda_: Optional['outputs.TopicRuleErrorActionLambda'] = None,
                 republish: Optional['outputs.TopicRuleErrorActionRepublish'] = None,
                 s3: Optional['outputs.TopicRuleErrorActionS3'] = None,
                 sns: Optional['outputs.TopicRuleErrorActionSns'] = None,
                 sqs: Optional['outputs.TopicRuleErrorActionSqs'] = None,
                 step_functions: Optional['outputs.TopicRuleErrorActionStepFunctions'] = None,
                 timestream: Optional['outputs.TopicRuleErrorActionTimestream'] = None):
        if cloudwatch_alarm is not None:
            pulumi.set(__self__, "cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            pulumi.set(__self__, "cloudwatch_metric", cloudwatch_metric)
        if dynamodb is not None:
            pulumi.set(__self__, "dynamodb", dynamodb)
        if dynamodbv2 is not None:
            pulumi.set(__self__, "dynamodbv2", dynamodbv2)
        if elasticsearch is not None:
            pulumi.set(__self__, "elasticsearch", elasticsearch)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if iot_analytics is not None:
            pulumi.set(__self__, "iot_analytics", iot_analytics)
        if iot_events is not None:
            pulumi.set(__self__, "iot_events", iot_events)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kinesis is not None:
            pulumi.set(__self__, "kinesis", kinesis)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)
        if republish is not None:
            pulumi.set(__self__, "republish", republish)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sqs is not None:
            pulumi.set(__self__, "sqs", sqs)
        if step_functions is not None:
            pulumi.set(__self__, "step_functions", step_functions)
        if timestream is not None:
            pulumi.set(__self__, "timestream", timestream)

    @_builtins.property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional['outputs.TopicRuleErrorActionCloudwatchAlarm']:
        return pulumi.get(self, "cloudwatch_alarm")

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.TopicRuleErrorActionCloudwatchLogs']:
        return pulumi.get(self, "cloudwatch_logs")

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional['outputs.TopicRuleErrorActionCloudwatchMetric']:
        return pulumi.get(self, "cloudwatch_metric")

    @_builtins.property
    @pulumi.getter
    def dynamodb(self) -> Optional['outputs.TopicRuleErrorActionDynamodb']:
        return pulumi.get(self, "dynamodb")

    @_builtins.property
    @pulumi.getter
    def dynamodbv2(self) -> Optional['outputs.TopicRuleErrorActionDynamodbv2']:
        return pulumi.get(self, "dynamodbv2")

    @_builtins.property
    @pulumi.getter
    def elasticsearch(self) -> Optional['outputs.TopicRuleErrorActionElasticsearch']:
        return pulumi.get(self, "elasticsearch")

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional['outputs.TopicRuleErrorActionFirehose']:
        return pulumi.get(self, "firehose")

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional['outputs.TopicRuleErrorActionHttp']:
        return pulumi.get(self, "http")

    @_builtins.property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional['outputs.TopicRuleErrorActionIotAnalytics']:
        return pulumi.get(self, "iot_analytics")

    @_builtins.property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional['outputs.TopicRuleErrorActionIotEvents']:
        return pulumi.get(self, "iot_events")

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.TopicRuleErrorActionKafka']:
        return pulumi.get(self, "kafka")

    @_builtins.property
    @pulumi.getter
    def kinesis(self) -> Optional['outputs.TopicRuleErrorActionKinesis']:
        return pulumi.get(self, "kinesis")

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional['outputs.TopicRuleErrorActionLambda']:
        return pulumi.get(self, "lambda_")

    @_builtins.property
    @pulumi.getter
    def republish(self) -> Optional['outputs.TopicRuleErrorActionRepublish']:
        return pulumi.get(self, "republish")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.TopicRuleErrorActionS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def sns(self) -> Optional['outputs.TopicRuleErrorActionSns']:
        return pulumi.get(self, "sns")

    @_builtins.property
    @pulumi.getter
    def sqs(self) -> Optional['outputs.TopicRuleErrorActionSqs']:
        return pulumi.get(self, "sqs")

    @_builtins.property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional['outputs.TopicRuleErrorActionStepFunctions']:
        return pulumi.get(self, "step_functions")

    @_builtins.property
    @pulumi.getter
    def timestream(self) -> Optional['outputs.TopicRuleErrorActionTimestream']:
        return pulumi.get(self, "timestream")


@pulumi.output_type
class TopicRuleErrorActionCloudwatchAlarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmName":
            suggest = "alarm_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "stateValue":
            suggest = "state_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionCloudwatchAlarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionCloudwatchAlarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionCloudwatchAlarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_name: _builtins.str,
                 role_arn: _builtins.str,
                 state_reason: _builtins.str,
                 state_value: _builtins.str):
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @_builtins.property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> _builtins.str:
        return pulumi.get(self, "alarm_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> _builtins.str:
        return pulumi.get(self, "state_reason")

    @_builtins.property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> _builtins.str:
        return pulumi.get(self, "state_value")


@pulumi.output_type
class TopicRuleErrorActionCloudwatchLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupName":
            suggest = "log_group_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionCloudwatchLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionCloudwatchLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionCloudwatchLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleErrorActionCloudwatchMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "metricValue":
            suggest = "metric_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "metricTimestamp":
            suggest = "metric_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionCloudwatchMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionCloudwatchMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionCloudwatchMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 metric_namespace: _builtins.str,
                 metric_unit: _builtins.str,
                 metric_value: _builtins.str,
                 role_arn: _builtins.str,
                 metric_timestamp: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> _builtins.str:
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> _builtins.str:
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> _builtins.str:
        return pulumi.get(self, "metric_value")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_timestamp")


@pulumi.output_type
class TopicRuleErrorActionDynamodb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKeyField":
            suggest = "hash_key_field"
        elif key == "hashKeyValue":
            suggest = "hash_key_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "hashKeyType":
            suggest = "hash_key_type"
        elif key == "payloadField":
            suggest = "payload_field"
        elif key == "rangeKeyField":
            suggest = "range_key_field"
        elif key == "rangeKeyType":
            suggest = "range_key_type"
        elif key == "rangeKeyValue":
            suggest = "range_key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionDynamodb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionDynamodb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionDynamodb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key_field: _builtins.str,
                 hash_key_value: _builtins.str,
                 role_arn: _builtins.str,
                 table_name: _builtins.str,
                 hash_key_type: Optional[_builtins.str] = None,
                 operation: Optional[_builtins.str] = None,
                 payload_field: Optional[_builtins.str] = None,
                 range_key_field: Optional[_builtins.str] = None,
                 range_key_type: Optional[_builtins.str] = None,
                 range_key_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @_builtins.property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> _builtins.str:
        return pulumi.get(self, "hash_key_field")

    @_builtins.property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> _builtins.str:
        return pulumi.get(self, "hash_key_value")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hash_key_type")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "payload_field")

    @_builtins.property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_field")

    @_builtins.property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_type")

    @_builtins.property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "range_key_value")


@pulumi.output_type
class TopicRuleErrorActionDynamodbv2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "putItem":
            suggest = "put_item"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionDynamodbv2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionDynamodbv2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionDynamodbv2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 put_item: Optional['outputs.TopicRuleErrorActionDynamodbv2PutItem'] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional['outputs.TopicRuleErrorActionDynamodbv2PutItem']:
        return pulumi.get(self, "put_item")


@pulumi.output_type
class TopicRuleErrorActionDynamodbv2PutItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionDynamodbv2PutItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionDynamodbv2PutItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionDynamodbv2PutItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_name: _builtins.str):
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class TopicRuleErrorActionElasticsearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionElasticsearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionElasticsearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionElasticsearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 id: _builtins.str,
                 index: _builtins.str,
                 role_arn: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.str:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRuleErrorActionFirehose(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamName":
            suggest = "delivery_stream_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionFirehose. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionFirehose.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionFirehose.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None,
                 separator: Optional[_builtins.str] = None):
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @_builtins.property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> _builtins.str:
        return pulumi.get(self, "delivery_stream_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "separator")


@pulumi.output_type
class TopicRuleErrorActionHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"
        elif key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 confirmation_url: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.TopicRuleErrorActionHttpHttpHeader']] = None):
        pulumi.set(__self__, "url", url)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "confirmation_url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.TopicRuleErrorActionHttpHttpHeader']]:
        return pulumi.get(self, "http_headers")


@pulumi.output_type
class TopicRuleErrorActionHttpHttpHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleErrorActionIotAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelName":
            suggest = "channel_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionIotAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionIotAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionIotAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> _builtins.str:
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleErrorActionIotEvents(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputName":
            suggest = "input_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionIotEvents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionIotEvents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionIotEvents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None,
                 message_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="inputName")
    def input_name(self) -> _builtins.str:
        return pulumi.get(self, "input_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message_id")


@pulumi.output_type
class TopicRuleErrorActionKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProperties":
            suggest = "client_properties"
        elif key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_properties: Mapping[str, _builtins.str],
                 destination_arn: _builtins.str,
                 topic: _builtins.str,
                 headers: Optional[Sequence['outputs.TopicRuleErrorActionKafkaHeader']] = None,
                 key: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None):
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "client_properties")

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> _builtins.str:
        return pulumi.get(self, "destination_arn")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.TopicRuleErrorActionKafkaHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")


@pulumi.output_type
class TopicRuleErrorActionKafkaHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleErrorActionKinesis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "partitionKey":
            suggest = "partition_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionKinesis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionKinesis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionKinesis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 stream_name: _builtins.str,
                 partition_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition_key")


@pulumi.output_type
class TopicRuleErrorActionLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class TopicRuleErrorActionRepublish(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionRepublish. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionRepublish.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionRepublish.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 topic: _builtins.str,
                 qos: Optional[_builtins.int] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "qos")


@pulumi.output_type
class TopicRuleErrorActionS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 key: _builtins.str,
                 role_arn: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class TopicRuleErrorActionSns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"
        elif key == "messageFormat":
            suggest = "message_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionSns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionSns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionSns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 target_arn: _builtins.str,
                 message_format: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        return pulumi.get(self, "target_arn")

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message_format")


@pulumi.output_type
class TopicRuleErrorActionSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "useBase64":
            suggest = "use_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: _builtins.str,
                 role_arn: _builtins.str,
                 use_base64: _builtins.bool):
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "use_base64", use_base64)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> _builtins.str:
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> _builtins.bool:
        return pulumi.get(self, "use_base64")


@pulumi.output_type
class TopicRuleErrorActionStepFunctions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "stateMachineName":
            suggest = "state_machine_name"
        elif key == "executionNamePrefix":
            suggest = "execution_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionStepFunctions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionStepFunctions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionStepFunctions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 state_machine_name: _builtins.str,
                 execution_name_prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> _builtins.str:
        return pulumi.get(self, "state_machine_name")

    @_builtins.property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "execution_name_prefix")


@pulumi.output_type
class TopicRuleErrorActionTimestream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleErrorActionTimestream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleErrorActionTimestream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleErrorActionTimestream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 dimensions: Sequence['outputs.TopicRuleErrorActionTimestreamDimension'],
                 role_arn: _builtins.str,
                 table_name: _builtins.str,
                 timestamp: Optional['outputs.TopicRuleErrorActionTimestreamTimestamp'] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.TopicRuleErrorActionTimestreamDimension']:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleErrorActionTimestreamTimestamp']:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleErrorActionTimestreamDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleErrorActionTimestreamTimestamp(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleFirehose(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamName":
            suggest = "delivery_stream_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleFirehose. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleFirehose.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleFirehose.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None,
                 separator: Optional[_builtins.str] = None):
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @_builtins.property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> _builtins.str:
        return pulumi.get(self, "delivery_stream_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "separator")


@pulumi.output_type
class TopicRuleHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"
        elif key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 confirmation_url: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.TopicRuleHttpHttpHeader']] = None):
        pulumi.set(__self__, "url", url)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "confirmation_url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.TopicRuleHttpHttpHeader']]:
        return pulumi.get(self, "http_headers")


@pulumi.output_type
class TopicRuleHttpHttpHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleIotAnalytic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelName":
            suggest = "channel_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotAnalytic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotAnalytic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotAnalytic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> _builtins.str:
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleIotEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputName":
            suggest = "input_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_name: _builtins.str,
                 role_arn: _builtins.str,
                 batch_mode: Optional[_builtins.bool] = None,
                 message_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="inputName")
    def input_name(self) -> _builtins.str:
        return pulumi.get(self, "input_name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "batch_mode")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message_id")


@pulumi.output_type
class TopicRuleKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProperties":
            suggest = "client_properties"
        elif key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_properties: Mapping[str, _builtins.str],
                 destination_arn: _builtins.str,
                 topic: _builtins.str,
                 headers: Optional[Sequence['outputs.TopicRuleKafkaHeader']] = None,
                 key: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None):
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @_builtins.property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "client_properties")

    @_builtins.property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> _builtins.str:
        return pulumi.get(self, "destination_arn")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.TopicRuleKafkaHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")


@pulumi.output_type
class TopicRuleKafkaHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleKinesis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "partitionKey":
            suggest = "partition_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKinesis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKinesis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKinesis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 stream_name: _builtins.str,
                 partition_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition_key")


@pulumi.output_type
class TopicRuleLambda(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleLambda. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleLambda.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleLambda.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_arn: _builtins.str):
        pulumi.set(__self__, "function_arn", function_arn)

    @_builtins.property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> _builtins.str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class TopicRuleRepublish(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleRepublish. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleRepublish.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleRepublish.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 topic: _builtins.str,
                 qos: Optional[_builtins.int] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "qos")


@pulumi.output_type
class TopicRuleS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 key: _builtins.str,
                 role_arn: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class TopicRuleSns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"
        elif key == "messageFormat":
            suggest = "message_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 target_arn: _builtins.str,
                 message_format: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> _builtins.str:
        return pulumi.get(self, "target_arn")

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message_format")


@pulumi.output_type
class TopicRuleSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "useBase64":
            suggest = "use_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: _builtins.str,
                 role_arn: _builtins.str,
                 use_base64: _builtins.bool):
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "use_base64", use_base64)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> _builtins.str:
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> _builtins.bool:
        return pulumi.get(self, "use_base64")


@pulumi.output_type
class TopicRuleStepFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "stateMachineName":
            suggest = "state_machine_name"
        elif key == "executionNamePrefix":
            suggest = "execution_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleStepFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleStepFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleStepFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 state_machine_name: _builtins.str,
                 execution_name_prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> _builtins.str:
        return pulumi.get(self, "state_machine_name")

    @_builtins.property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "execution_name_prefix")


@pulumi.output_type
class TopicRuleTimestream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleTimestream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleTimestream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleTimestream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 dimensions: Sequence['outputs.TopicRuleTimestreamDimension'],
                 role_arn: _builtins.str,
                 table_name: _builtins.str,
                 timestamp: Optional['outputs.TopicRuleTimestreamTimestamp'] = None):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.TopicRuleTimestreamDimension']:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleTimestreamTimestamp']:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleTimestreamDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleTimestreamTimestamp(dict):
    def __init__(__self__, *,
                 unit: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


