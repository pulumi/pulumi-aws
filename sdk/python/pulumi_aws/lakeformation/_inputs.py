# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DataCellsFilterTableDataArgs',
    'DataCellsFilterTableDataArgsDict',
    'DataCellsFilterTableDataColumnWildcardArgs',
    'DataCellsFilterTableDataColumnWildcardArgsDict',
    'DataCellsFilterTableDataRowFilterArgs',
    'DataCellsFilterTableDataRowFilterArgsDict',
    'DataCellsFilterTableDataRowFilterAllRowsWildcardArgs',
    'DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict',
    'DataCellsFilterTimeoutsArgs',
    'DataCellsFilterTimeoutsArgsDict',
    'DataLakeSettingsCreateDatabaseDefaultPermissionArgs',
    'DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict',
    'DataLakeSettingsCreateTableDefaultPermissionArgs',
    'DataLakeSettingsCreateTableDefaultPermissionArgsDict',
    'OptInConditionArgs',
    'OptInConditionArgsDict',
    'OptInPrincipalArgs',
    'OptInPrincipalArgsDict',
    'OptInResourceDataArgs',
    'OptInResourceDataArgsDict',
    'OptInResourceDataCatalogArgs',
    'OptInResourceDataCatalogArgsDict',
    'OptInResourceDataDataCellsFilterArgs',
    'OptInResourceDataDataCellsFilterArgsDict',
    'OptInResourceDataDataLocationArgs',
    'OptInResourceDataDataLocationArgsDict',
    'OptInResourceDataDatabaseArgs',
    'OptInResourceDataDatabaseArgsDict',
    'OptInResourceDataLfTagArgs',
    'OptInResourceDataLfTagArgsDict',
    'OptInResourceDataLfTagExpressionArgs',
    'OptInResourceDataLfTagExpressionArgsDict',
    'OptInResourceDataLfTagPolicyArgs',
    'OptInResourceDataLfTagPolicyArgsDict',
    'OptInResourceDataTableArgs',
    'OptInResourceDataTableArgsDict',
    'OptInResourceDataTableWithColumnsArgs',
    'OptInResourceDataTableWithColumnsArgsDict',
    'OptInResourceDataTableWithColumnsColumnWildcardArgs',
    'OptInResourceDataTableWithColumnsColumnWildcardArgsDict',
    'PermissionsDataCellsFilterArgs',
    'PermissionsDataCellsFilterArgsDict',
    'PermissionsDataLocationArgs',
    'PermissionsDataLocationArgsDict',
    'PermissionsDatabaseArgs',
    'PermissionsDatabaseArgsDict',
    'PermissionsLfTagArgs',
    'PermissionsLfTagArgsDict',
    'PermissionsLfTagPolicyArgs',
    'PermissionsLfTagPolicyArgsDict',
    'PermissionsLfTagPolicyExpressionArgs',
    'PermissionsLfTagPolicyExpressionArgsDict',
    'PermissionsTableArgs',
    'PermissionsTableArgsDict',
    'PermissionsTableWithColumnsArgs',
    'PermissionsTableWithColumnsArgsDict',
    'ResourceLfTagDatabaseArgs',
    'ResourceLfTagDatabaseArgsDict',
    'ResourceLfTagLfTagArgs',
    'ResourceLfTagLfTagArgsDict',
    'ResourceLfTagTableArgs',
    'ResourceLfTagTableArgsDict',
    'ResourceLfTagTableWithColumnsArgs',
    'ResourceLfTagTableWithColumnsArgsDict',
    'ResourceLfTagTableWithColumnsColumnWildcardArgs',
    'ResourceLfTagTableWithColumnsColumnWildcardArgsDict',
    'ResourceLfTagTimeoutsArgs',
    'ResourceLfTagTimeoutsArgsDict',
    'ResourceLfTagsDatabaseArgs',
    'ResourceLfTagsDatabaseArgsDict',
    'ResourceLfTagsLfTagArgs',
    'ResourceLfTagsLfTagArgsDict',
    'ResourceLfTagsTableArgs',
    'ResourceLfTagsTableArgsDict',
    'ResourceLfTagsTableWithColumnsArgs',
    'ResourceLfTagsTableWithColumnsArgsDict',
    'GetPermissionsDataCellsFilterArgs',
    'GetPermissionsDataCellsFilterArgsDict',
    'GetPermissionsDataLocationArgs',
    'GetPermissionsDataLocationArgsDict',
    'GetPermissionsDatabaseArgs',
    'GetPermissionsDatabaseArgsDict',
    'GetPermissionsLfTagArgs',
    'GetPermissionsLfTagArgsDict',
    'GetPermissionsLfTagPolicyArgs',
    'GetPermissionsLfTagPolicyArgsDict',
    'GetPermissionsLfTagPolicyExpressionArgs',
    'GetPermissionsLfTagPolicyExpressionArgsDict',
    'GetPermissionsTableArgs',
    'GetPermissionsTableArgsDict',
    'GetPermissionsTableWithColumnsArgs',
    'GetPermissionsTableWithColumnsArgsDict',
]

MYPY = False

if not MYPY:
    class DataCellsFilterTableDataArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        The name of the database.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data cells filter.
        """
        table_catalog_id: pulumi.Input[builtins.str]
        """
        The ID of the Data Catalog.
        """
        table_name: pulumi.Input[builtins.str]
        """
        The name of the table.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of column names and/or nested column attributes.
        """
        column_wildcard: NotRequired[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgsDict']]
        """
        A wildcard with exclusions. See Column Wildcard below for details.
        """
        row_filter: NotRequired[pulumi.Input['DataCellsFilterTableDataRowFilterArgsDict']]
        """
        A PartiQL predicate. See Row Filter below for details.
        """
        version_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the data cells filter version.
        """
elif False:
    DataCellsFilterTableDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 table_catalog_id: pulumi.Input[builtins.str],
                 table_name: pulumi.Input[builtins.str],
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 column_wildcard: Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']] = None,
                 row_filter: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']] = None,
                 version_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: The name of the database.
        :param pulumi.Input[builtins.str] name: The name of the data cells filter.
        :param pulumi.Input[builtins.str] table_catalog_id: The ID of the Data Catalog.
        :param pulumi.Input[builtins.str] table_name: The name of the table.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: A list of column names and/or nested column attributes.
        :param pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs'] column_wildcard: A wildcard with exclusions. See Column Wildcard below for details.
        :param pulumi.Input['DataCellsFilterTableDataRowFilterArgs'] row_filter: A PartiQL predicate. See Row Filter below for details.
        :param pulumi.Input[builtins.str] version_id: ID of the data cells filter version.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_wildcard is not None:
            pulumi.set(__self__, "column_wildcard", column_wildcard)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of column names and/or nested column attributes.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnWildcard")
    def column_wildcard(self) -> Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']]:
        """
        A wildcard with exclusions. See Column Wildcard below for details.
        """
        return pulumi.get(self, "column_wildcard")

    @column_wildcard.setter
    def column_wildcard(self, value: Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']]):
        pulumi.set(self, "column_wildcard", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']]:
        """
        A PartiQL predicate. See Row Filter below for details.
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the data cells filter version.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class DataCellsFilterTableDataColumnWildcardArgsDict(TypedDict):
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        (Optional) Excludes column names. Any column with this name will be excluded.
        """
elif False:
    DataCellsFilterTableDataColumnWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataColumnWildcardArgs:
    def __init__(__self__, *,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excluded_column_names: (Optional) Excludes column names. Any column with this name will be excluded.
        """
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        (Optional) Excludes column names. Any column with this name will be excluded.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_column_names", value)


if not MYPY:
    class DataCellsFilterTableDataRowFilterArgsDict(TypedDict):
        all_rows_wildcard: NotRequired[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict']]
        """
        (Optional) A wildcard that matches all rows.
        """
        filter_expression: NotRequired[pulumi.Input[builtins.str]]
        """
        (Optional) A filter expression.
        """
elif False:
    DataCellsFilterTableDataRowFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataRowFilterArgs:
    def __init__(__self__, *,
                 all_rows_wildcard: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']] = None,
                 filter_expression: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs'] all_rows_wildcard: (Optional) A wildcard that matches all rows.
        :param pulumi.Input[builtins.str] filter_expression: (Optional) A filter expression.
        """
        if all_rows_wildcard is not None:
            pulumi.set(__self__, "all_rows_wildcard", all_rows_wildcard)
        if filter_expression is not None:
            pulumi.set(__self__, "filter_expression", filter_expression)

    @property
    @pulumi.getter(name="allRowsWildcard")
    def all_rows_wildcard(self) -> Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']]:
        """
        (Optional) A wildcard that matches all rows.
        """
        return pulumi.get(self, "all_rows_wildcard")

    @all_rows_wildcard.setter
    def all_rows_wildcard(self, value: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']]):
        pulumi.set(self, "all_rows_wildcard", value)

    @property
    @pulumi.getter(name="filterExpression")
    def filter_expression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Optional) A filter expression.
        """
        return pulumi.get(self, "filter_expression")

    @filter_expression.setter
    def filter_expression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filter_expression", value)


if not MYPY:
    class DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict(TypedDict):
        pass
elif False:
    DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataRowFilterAllRowsWildcardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataCellsFilterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DataCellsFilterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        principal: NotRequired[pulumi.Input[builtins.str]]
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
elif False:
    DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeSettingsCreateDatabaseDefaultPermissionArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 principal: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] permissions: List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        :param pulumi.Input[builtins.str] principal: Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataLakeSettingsCreateTableDefaultPermissionArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        principal: NotRequired[pulumi.Input[builtins.str]]
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
elif False:
    DataLakeSettingsCreateTableDefaultPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeSettingsCreateTableDefaultPermissionArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 principal: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] permissions: List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        :param pulumi.Input[builtins.str] principal: Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class OptInConditionArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[builtins.str]]
        """
        List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
elif False:
    OptInConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInConditionArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] expression: List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class OptInPrincipalArgsDict(TypedDict):
        data_lake_principal_identifier: pulumi.Input[builtins.str]
elif False:
    OptInPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInPrincipalArgs:
    def __init__(__self__, *,
                 data_lake_principal_identifier: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "data_lake_principal_identifier", data_lake_principal_identifier)

    @property
    @pulumi.getter(name="dataLakePrincipalIdentifier")
    def data_lake_principal_identifier(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "data_lake_principal_identifier")

    @data_lake_principal_identifier.setter
    def data_lake_principal_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_lake_principal_identifier", value)


if not MYPY:
    class OptInResourceDataArgsDict(TypedDict):
        catalogs: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataCatalogArgsDict']]]]
        """
        Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. See Catalog for more details.
        """
        data_cells_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataCellsFilterArgsDict']]]]
        """
        Data cell filter. See Data Cells Filter for more details.
        """
        data_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataLocationArgsDict']]]]
        """
        Location of an Amazon S3 path where permissions are granted or revoked. See Data Location for more details.
        """
        database: NotRequired[pulumi.Input['OptInResourceDataDatabaseArgsDict']]
        """
        Database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. See Database for more details.
        """
        lf_tag: NotRequired[pulumi.Input['OptInResourceDataLfTagArgsDict']]
        """
        LF-tag key and values attached to a resource.
        """
        lf_tag_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagExpressionArgsDict']]]]
        """
        Logical expression composed of one or more LF-Tag key:value pairs. See LF-Tag Expression for more details.
        """
        lf_tag_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagPolicyArgsDict']]]]
        """
        List of LF-Tag conditions or saved LF-Tag expressions that define a resource's LF-Tag policy. See LF-Tag Policy for more details.
        """
        table: NotRequired[pulumi.Input['OptInResourceDataTableArgsDict']]
        """
        Table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. See Table for more details.
        """
        table_with_columns: NotRequired[pulumi.Input['OptInResourceDataTableWithColumnsArgsDict']]
        """
        Table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3. See Table With Columns for more details.
        """
elif False:
    OptInResourceDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataArgs:
    def __init__(__self__, *,
                 catalogs: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataCatalogArgs']]]] = None,
                 data_cells_filters: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataCellsFilterArgs']]]] = None,
                 data_locations: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataLocationArgs']]]] = None,
                 database: Optional[pulumi.Input['OptInResourceDataDatabaseArgs']] = None,
                 lf_tag: Optional[pulumi.Input['OptInResourceDataLfTagArgs']] = None,
                 lf_tag_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagExpressionArgs']]]] = None,
                 lf_tag_policies: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagPolicyArgs']]]] = None,
                 table: Optional[pulumi.Input['OptInResourceDataTableArgs']] = None,
                 table_with_columns: Optional[pulumi.Input['OptInResourceDataTableWithColumnsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OptInResourceDataCatalogArgs']]] catalogs: Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. See Catalog for more details.
        :param pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataCellsFilterArgs']]] data_cells_filters: Data cell filter. See Data Cells Filter for more details.
        :param pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataLocationArgs']]] data_locations: Location of an Amazon S3 path where permissions are granted or revoked. See Data Location for more details.
        :param pulumi.Input['OptInResourceDataDatabaseArgs'] database: Database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. See Database for more details.
        :param pulumi.Input['OptInResourceDataLfTagArgs'] lf_tag: LF-tag key and values attached to a resource.
        :param pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagExpressionArgs']]] lf_tag_expressions: Logical expression composed of one or more LF-Tag key:value pairs. See LF-Tag Expression for more details.
        :param pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagPolicyArgs']]] lf_tag_policies: List of LF-Tag conditions or saved LF-Tag expressions that define a resource's LF-Tag policy. See LF-Tag Policy for more details.
        :param pulumi.Input['OptInResourceDataTableArgs'] table: Table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. See Table for more details.
        :param pulumi.Input['OptInResourceDataTableWithColumnsArgs'] table_with_columns: Table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3. See Table With Columns for more details.
        """
        if catalogs is not None:
            pulumi.set(__self__, "catalogs", catalogs)
        if data_cells_filters is not None:
            pulumi.set(__self__, "data_cells_filters", data_cells_filters)
        if data_locations is not None:
            pulumi.set(__self__, "data_locations", data_locations)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if lf_tag is not None:
            pulumi.set(__self__, "lf_tag", lf_tag)
        if lf_tag_expressions is not None:
            pulumi.set(__self__, "lf_tag_expressions", lf_tag_expressions)
        if lf_tag_policies is not None:
            pulumi.set(__self__, "lf_tag_policies", lf_tag_policies)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_with_columns is not None:
            pulumi.set(__self__, "table_with_columns", table_with_columns)

    @property
    @pulumi.getter
    def catalogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataCatalogArgs']]]]:
        """
        Identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. See Catalog for more details.
        """
        return pulumi.get(self, "catalogs")

    @catalogs.setter
    def catalogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataCatalogArgs']]]]):
        pulumi.set(self, "catalogs", value)

    @property
    @pulumi.getter(name="dataCellsFilters")
    def data_cells_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataCellsFilterArgs']]]]:
        """
        Data cell filter. See Data Cells Filter for more details.
        """
        return pulumi.get(self, "data_cells_filters")

    @data_cells_filters.setter
    def data_cells_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataCellsFilterArgs']]]]):
        pulumi.set(self, "data_cells_filters", value)

    @property
    @pulumi.getter(name="dataLocations")
    def data_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataLocationArgs']]]]:
        """
        Location of an Amazon S3 path where permissions are granted or revoked. See Data Location for more details.
        """
        return pulumi.get(self, "data_locations")

    @data_locations.setter
    def data_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataDataLocationArgs']]]]):
        pulumi.set(self, "data_locations", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input['OptInResourceDataDatabaseArgs']]:
        """
        Database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal. See Database for more details.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input['OptInResourceDataDatabaseArgs']]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="lfTag")
    def lf_tag(self) -> Optional[pulumi.Input['OptInResourceDataLfTagArgs']]:
        """
        LF-tag key and values attached to a resource.
        """
        return pulumi.get(self, "lf_tag")

    @lf_tag.setter
    def lf_tag(self, value: Optional[pulumi.Input['OptInResourceDataLfTagArgs']]):
        pulumi.set(self, "lf_tag", value)

    @property
    @pulumi.getter(name="lfTagExpressions")
    def lf_tag_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagExpressionArgs']]]]:
        """
        Logical expression composed of one or more LF-Tag key:value pairs. See LF-Tag Expression for more details.
        """
        return pulumi.get(self, "lf_tag_expressions")

    @lf_tag_expressions.setter
    def lf_tag_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagExpressionArgs']]]]):
        pulumi.set(self, "lf_tag_expressions", value)

    @property
    @pulumi.getter(name="lfTagPolicies")
    def lf_tag_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagPolicyArgs']]]]:
        """
        List of LF-Tag conditions or saved LF-Tag expressions that define a resource's LF-Tag policy. See LF-Tag Policy for more details.
        """
        return pulumi.get(self, "lf_tag_policies")

    @lf_tag_policies.setter
    def lf_tag_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptInResourceDataLfTagPolicyArgs']]]]):
        pulumi.set(self, "lf_tag_policies", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input['OptInResourceDataTableArgs']]:
        """
        Table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. See Table for more details.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input['OptInResourceDataTableArgs']]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableWithColumns")
    def table_with_columns(self) -> Optional[pulumi.Input['OptInResourceDataTableWithColumnsArgs']]:
        """
        Table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3. See Table With Columns for more details.
        """
        return pulumi.get(self, "table_with_columns")

    @table_with_columns.setter
    def table_with_columns(self, value: Optional[pulumi.Input['OptInResourceDataTableWithColumnsArgs']]):
        pulumi.set(self, "table_with_columns", value)


if not MYPY:
    class OptInResourceDataCatalogArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the catalog resource.
        """
elif False:
    OptInResourceDataCatalogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataCatalogArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Identifier for the catalog resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the catalog resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OptInResourceDataDataCellsFilterArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
        table_catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the catalog to which the table belongs.
        """
        table_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
elif False:
    OptInResourceDataDataCellsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataDataCellsFilterArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 table_catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 table_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.str] table_catalog_id: ID of the catalog to which the table belongs.
        :param pulumi.Input[builtins.str] table_name: Name of the table.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if table_catalog_id is not None:
            pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the catalog to which the table belongs.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class OptInResourceDataDataLocationArgsDict(TypedDict):
        resource_arn: pulumi.Input[builtins.str]
        """
        ARN that uniquely identifies the data location resource.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    OptInResourceDataDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataDataLocationArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] resource_arn: ARN that uniquely identifies the data location resource.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "resource_arn", resource_arn)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN that uniquely identifies the data location resource.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class OptInResourceDataDatabaseArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the table.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    OptInResourceDataDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class OptInResourceDataLfTagArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    OptInResourceDataLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class OptInResourceDataLfTagExpressionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the table.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    OptInResourceDataLfTagExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataLfTagExpressionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class OptInResourceDataLfTagPolicyArgsDict(TypedDict):
        resource_type: pulumi.Input[builtins.str]
        """
        Resource type for which the LF-tag policy applies.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        expression_name: NotRequired[pulumi.Input[builtins.str]]
        """
        If provided, permissions are granted to the Data Catalog resources whose assigned LF-Tags match the expression body of the saved expression under the provided ExpressionName .
        """
        expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
elif False:
    OptInResourceDataLfTagPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataLfTagPolicyArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 expression_name: Optional[pulumi.Input[builtins.str]] = None,
                 expressions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] resource_type: Resource type for which the LF-tag policy applies.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[builtins.str] expression_name: If provided, permissions are granted to the Data Catalog resources whose assigned LF-Tags match the expression body of the saved expression under the provided ExpressionName .
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] expressions: List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if expression_name is not None:
            pulumi.set(__self__, "expression_name", expression_name)
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[builtins.str]:
        """
        Resource type for which the LF-tag policy applies.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="expressionName")
    def expression_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If provided, permissions are granted to the Data Catalog resources whose assigned LF-Tags match the expression body of the saved expression under the provided ExpressionName .
        """
        return pulumi.get(self, "expression_name")

    @expression_name.setter
    def expression_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expression_name", value)

    @property
    @pulumi.getter
    def expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of LF-tag conditions or a saved expression that apply to the resource's LF-Tag policy.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "expressions", value)


if not MYPY:
    class OptInResourceDataTableArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean value that indicates whether to use a wildcard representing every table under the specified database. When set to true, this represents all tables within the specified database. At least one of TableResource$Name or TableResource$Wildcard is required.
        """
elif False:
    OptInResourceDataTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.bool] wildcard: Boolean value that indicates whether to use a wildcard representing every table under the specified database. When set to true, this represents all tables within the specified database. At least one of TableResource$Name or TableResource$Wildcard is required.
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean value that indicates whether to use a wildcard representing every table under the specified database. When set to true, this represents all tables within the specified database. At least one of TableResource$Name or TableResource$Wildcard is required.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class OptInResourceDataTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the table.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of column names for the table. At least one of ColumnNames or ColumnWildcard is required.
        """
        column_wildcard: NotRequired[pulumi.Input['OptInResourceDataTableWithColumnsColumnWildcardArgsDict']]
        """
        Wildcard specified by a ColumnWildcard object. At least one of ColumnNames or ColumnWildcard is required.
        """
elif False:
    OptInResourceDataTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 column_wildcard: Optional[pulumi.Input['OptInResourceDataTableWithColumnsColumnWildcardArgs']] = None):
        """
        :param pulumi.Input[builtins.str] database_name: The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: List of column names for the table. At least one of ColumnNames or ColumnWildcard is required.
        :param pulumi.Input['OptInResourceDataTableWithColumnsColumnWildcardArgs'] column_wildcard: Wildcard specified by a ColumnWildcard object. At least one of ColumnNames or ColumnWildcard is required.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_wildcard is not None:
            pulumi.set(__self__, "column_wildcard", column_wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of column names for the table. At least one of ColumnNames or ColumnWildcard is required.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnWildcard")
    def column_wildcard(self) -> Optional[pulumi.Input['OptInResourceDataTableWithColumnsColumnWildcardArgs']]:
        """
        Wildcard specified by a ColumnWildcard object. At least one of ColumnNames or ColumnWildcard is required.
        """
        return pulumi.get(self, "column_wildcard")

    @column_wildcard.setter
    def column_wildcard(self, value: Optional[pulumi.Input['OptInResourceDataTableWithColumnsColumnWildcardArgs']]):
        pulumi.set(self, "column_wildcard", value)


if not MYPY:
    class OptInResourceDataTableWithColumnsColumnWildcardArgsDict(TypedDict):
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    OptInResourceDataTableWithColumnsColumnWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptInResourceDataTableWithColumnsColumnWildcardArgs:
    def __init__(__self__, *,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_column_names", value)


if not MYPY:
    class PermissionsDataCellsFilterArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        The name of the database.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data cells filter.
        """
        table_catalog_id: pulumi.Input[builtins.str]
        """
        The ID of the Data Catalog.
        """
        table_name: pulumi.Input[builtins.str]
        """
        The name of the table.
        """
elif False:
    PermissionsDataCellsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDataCellsFilterArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 table_catalog_id: pulumi.Input[builtins.str],
                 table_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] database_name: The name of the database.
        :param pulumi.Input[builtins.str] name: The name of the data cells filter.
        :param pulumi.Input[builtins.str] table_catalog_id: The ID of the Data Catalog.
        :param pulumi.Input[builtins.str] table_name: The name of the table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class PermissionsDataLocationArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        Amazon Resource Name (ARN) that uniquely identifies the data location resource.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDataLocationArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] arn: Amazon Resource Name (ARN) that uniquely identifies the data location resource.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "arn", arn)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        Amazon Resource Name (ARN) that uniquely identifies the data location resource.

        The following argument is optional:
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsDatabaseArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The key-name for the tag.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of possible values an attribute can take.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: The key-name for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: A list of possible values an attribute can take.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The key-name for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of possible values an attribute can take.

        The following argument is optional:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagPolicyArgsDict(TypedDict):
        expressions: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgsDict']]]
        """
        A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        resource_type: pulumi.Input[builtins.str]
        """
        The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsLfTagPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagPolicyArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]],
                 resource_type: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]] expressions: A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] resource_type: The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "resource_type", resource_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]]:
        """
        A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]]):
        pulumi.set(self, "expressions", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[builtins.str]:
        """
        The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagPolicyExpressionArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The key-name of an LF-Tag.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of possible values of an LF-Tag.
        """
elif False:
    PermissionsLfTagPolicyExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagPolicyExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] key: The key-name of an LF-Tag.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: A list of possible values of an LF-Tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The key-name of an LF-Tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of possible values of an LF-Tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PermissionsTableArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    PermissionsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class PermissionsTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the table resource.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Set of column names for the table.
        """
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
elif False:
    PermissionsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[builtins.str] name: Name of the table resource.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: Set of column names for the table.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excluded_column_names: Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        :param pulumi.Input[builtins.bool] wildcard: Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagDatabaseArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagLfTagArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key name for an existing LF-tag.
        """
        value: pulumi.Input[builtins.str]
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: Key name for an existing LF-tag.
        :param pulumi.Input[builtins.str] value: Value from the possible values for the LF-tag.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key name for an existing LF-tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagTableArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the table resource.

        The following arguments are optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Set of column names for the table.
        """
        column_wildcard: NotRequired[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgsDict']]
        """
        Option to add column wildcard. See Column Wildcard for more details.
        """
elif False:
    ResourceLfTagTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 column_wildcard: Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[builtins.str] name: Name of the table resource.
               
               The following arguments are optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: Set of column names for the table.
        :param pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs'] column_wildcard: Option to add column wildcard. See Column Wildcard for more details.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_wildcard is not None:
            pulumi.set(__self__, "column_wildcard", column_wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table resource.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnWildcard")
    def column_wildcard(self) -> Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']]:
        """
        Option to add column wildcard. See Column Wildcard for more details.
        """
        return pulumi.get(self, "column_wildcard")

    @column_wildcard.setter
    def column_wildcard(self, value: Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']]):
        pulumi.set(self, "column_wildcard", value)


if not MYPY:
    class ResourceLfTagTableWithColumnsColumnWildcardArgsDict(TypedDict):
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    ResourceLfTagTableWithColumnsColumnWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableWithColumnsColumnWildcardArgs:
    def __init__(__self__, *,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_column_names", value)


if not MYPY:
    class ResourceLfTagTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ResourceLfTagTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class ResourceLfTagsDatabaseArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagsLfTagArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key name for an existing LF-tag.
        """
        value: pulumi.Input[builtins.str]
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: Key name for an existing LF-tag.
        :param pulumi.Input[builtins.str] value: Value from the possible values for the LF-tag.
               
               The following argument is optional:
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key name for an existing LF-tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagsTableArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[builtins.str] name: Name of the table.
        :param pulumi.Input[builtins.bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagsTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[builtins.str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the table resource.
        """
        catalog_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Set of column names for the table.
        """
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        wildcard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 catalog_id: Optional[pulumi.Input[builtins.str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wildcard: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[builtins.str] name: Name of the table resource.
        :param pulumi.Input[builtins.str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: Set of column names for the table.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excluded_column_names: Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        :param pulumi.Input[builtins.bool] wildcard: Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the table resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class GetPermissionsDataCellsFilterArgsDict(TypedDict):
        database_name: builtins.str
        """
        The name of the database.
        """
        name: builtins.str
        """
        The name of the data cells filter.
        """
        table_catalog_id: builtins.str
        """
        The ID of the Data Catalog.
        """
        table_name: builtins.str
        """
        The name of the table.
        """
elif False:
    GetPermissionsDataCellsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDataCellsFilterArgs:
    def __init__(__self__, *,
                 database_name: builtins.str,
                 name: builtins.str,
                 table_catalog_id: builtins.str,
                 table_name: builtins.str):
        """
        :param builtins.str database_name: The name of the database.
        :param builtins.str name: The name of the data cells filter.
        :param builtins.str table_catalog_id: The ID of the Data Catalog.
        :param builtins.str table_name: The name of the table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: builtins.str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> builtins.str:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: builtins.str):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> builtins.str:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: builtins.str):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class GetPermissionsDataLocationArgsDict(TypedDict):
        arn: builtins.str
        """
        ARN that uniquely identifies the data location resource.

        The following argument is optional:
        """
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
elif False:
    GetPermissionsDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDataLocationArgs:
    def __init__(__self__, *,
                 arn: builtins.str,
                 catalog_id: builtins.str):
        """
        :param builtins.str arn: ARN that uniquely identifies the data location resource.
               
               The following argument is optional:
        :param builtins.str catalog_id: Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def arn(self) -> builtins.str:
        """
        ARN that uniquely identifies the data location resource.

        The following argument is optional:
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: builtins.str):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class GetPermissionsDatabaseArgsDict(TypedDict):
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: builtins.str
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
elif False:
    GetPermissionsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDatabaseArgs:
    def __init__(__self__, *,
                 catalog_id: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param builtins.str name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetPermissionsLfTagArgsDict(TypedDict):
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        key: builtins.str
        """
        Key-name for the tag.
        """
        values: Sequence[builtins.str]
        """
        List of possible values an attribute can take.

        The following argument is optional:
        """
elif False:
    GetPermissionsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagArgs:
    def __init__(__self__, *,
                 catalog_id: builtins.str,
                 key: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param builtins.str key: Key-name for the tag.
        :param Sequence[builtins.str] values: List of possible values an attribute can take.
               
               The following argument is optional:
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key-name for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        List of possible values an attribute can take.

        The following argument is optional:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPermissionsLfTagPolicyArgsDict(TypedDict):
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        expressions: Sequence['GetPermissionsLfTagPolicyExpressionArgsDict']
        """
        List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        resource_type: builtins.str
        """
        Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
elif False:
    GetPermissionsLfTagPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagPolicyArgs:
    def __init__(__self__, *,
                 catalog_id: builtins.str,
                 expressions: Sequence['GetPermissionsLfTagPolicyExpressionArgs'],
                 resource_type: builtins.str):
        """
        :param builtins.str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param Sequence['GetPermissionsLfTagPolicyExpressionArgs'] expressions: List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
               
               The following argument is optional:
        :param builtins.str resource_type: Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['GetPermissionsLfTagPolicyExpressionArgs']:
        """
        List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Sequence['GetPermissionsLfTagPolicyExpressionArgs']):
        pulumi.set(self, "expressions", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> builtins.str:
        """
        Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: builtins.str):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class GetPermissionsLfTagPolicyExpressionArgsDict(TypedDict):
        key: builtins.str
        """
        Key-name of an LF-Tag.
        """
        values: Sequence[builtins.str]
        """
        List of possible values of an LF-Tag.
        """
elif False:
    GetPermissionsLfTagPolicyExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagPolicyExpressionArgs:
    def __init__(__self__, *,
                 key: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param builtins.str key: Key-name of an LF-Tag.
        :param Sequence[builtins.str] values: List of possible values of an LF-Tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key-name of an LF-Tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        List of possible values of an LF-Tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPermissionsTableArgsDict(TypedDict):
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        database_name: builtins.str
        """
        Name of the database for the table. Unique to a Data Catalog.

        The following arguments are optional:
        """
        name: builtins.str
        """
        Name of the table. At least one of `name` or `wildcard` is required.
        """
        wildcard: NotRequired[builtins.bool]
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
elif False:
    GetPermissionsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsTableArgs:
    def __init__(__self__, *,
                 catalog_id: builtins.str,
                 database_name: builtins.str,
                 name: builtins.str,
                 wildcard: Optional[builtins.bool] = None):
        """
        :param builtins.str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param builtins.str database_name: Name of the database for the table. Unique to a Data Catalog.
               
               The following arguments are optional:
        :param builtins.str name: Name of the table. At least one of `name` or `wildcard` is required.
        :param builtins.bool wildcard: Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        """
        Name of the database for the table. Unique to a Data Catalog.

        The following arguments are optional:
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: builtins.str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the table. At least one of `name` or `wildcard` is required.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[builtins.bool]:
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[builtins.bool]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class GetPermissionsTableWithColumnsArgsDict(TypedDict):
        catalog_id: builtins.str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        database_name: builtins.str
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: builtins.str
        """
        Name of the table resource.

        The following arguments are optional:
        """
        column_names: NotRequired[Sequence[builtins.str]]
        """
        Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        """
        excluded_column_names: NotRequired[Sequence[builtins.str]]
        """
        Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        """
        wildcard: NotRequired[builtins.bool]
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
elif False:
    GetPermissionsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsTableWithColumnsArgs:
    def __init__(__self__, *,
                 catalog_id: builtins.str,
                 database_name: builtins.str,
                 name: builtins.str,
                 column_names: Optional[Sequence[builtins.str]] = None,
                 excluded_column_names: Optional[Sequence[builtins.str]] = None,
                 wildcard: Optional[builtins.bool] = None):
        """
        :param builtins.str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param builtins.str database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param builtins.str name: Name of the table resource.
               
               The following arguments are optional:
        :param Sequence[builtins.str] column_names: Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        :param Sequence[builtins.str] excluded_column_names: Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        :param builtins.bool wildcard: Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> builtins.str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: builtins.str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> builtins.str:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: builtins.str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the table resource.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[builtins.bool]:
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[builtins.bool]):
        pulumi.set(self, "wildcard", value)


