# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DataCellsFilterTableDataArgs',
    'DataCellsFilterTableDataArgsDict',
    'DataCellsFilterTableDataColumnWildcardArgs',
    'DataCellsFilterTableDataColumnWildcardArgsDict',
    'DataCellsFilterTableDataRowFilterArgs',
    'DataCellsFilterTableDataRowFilterArgsDict',
    'DataCellsFilterTableDataRowFilterAllRowsWildcardArgs',
    'DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict',
    'DataCellsFilterTimeoutsArgs',
    'DataCellsFilterTimeoutsArgsDict',
    'DataLakeSettingsCreateDatabaseDefaultPermissionArgs',
    'DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict',
    'DataLakeSettingsCreateTableDefaultPermissionArgs',
    'DataLakeSettingsCreateTableDefaultPermissionArgsDict',
    'PermissionsDataCellsFilterArgs',
    'PermissionsDataCellsFilterArgsDict',
    'PermissionsDataLocationArgs',
    'PermissionsDataLocationArgsDict',
    'PermissionsDatabaseArgs',
    'PermissionsDatabaseArgsDict',
    'PermissionsLfTagArgs',
    'PermissionsLfTagArgsDict',
    'PermissionsLfTagPolicyArgs',
    'PermissionsLfTagPolicyArgsDict',
    'PermissionsLfTagPolicyExpressionArgs',
    'PermissionsLfTagPolicyExpressionArgsDict',
    'PermissionsTableArgs',
    'PermissionsTableArgsDict',
    'PermissionsTableWithColumnsArgs',
    'PermissionsTableWithColumnsArgsDict',
    'ResourceLfTagDatabaseArgs',
    'ResourceLfTagDatabaseArgsDict',
    'ResourceLfTagLfTagArgs',
    'ResourceLfTagLfTagArgsDict',
    'ResourceLfTagTableArgs',
    'ResourceLfTagTableArgsDict',
    'ResourceLfTagTableWithColumnsArgs',
    'ResourceLfTagTableWithColumnsArgsDict',
    'ResourceLfTagTableWithColumnsColumnWildcardArgs',
    'ResourceLfTagTableWithColumnsColumnWildcardArgsDict',
    'ResourceLfTagTimeoutsArgs',
    'ResourceLfTagTimeoutsArgsDict',
    'ResourceLfTagsDatabaseArgs',
    'ResourceLfTagsDatabaseArgsDict',
    'ResourceLfTagsLfTagArgs',
    'ResourceLfTagsLfTagArgsDict',
    'ResourceLfTagsTableArgs',
    'ResourceLfTagsTableArgsDict',
    'ResourceLfTagsTableWithColumnsArgs',
    'ResourceLfTagsTableWithColumnsArgsDict',
    'GetPermissionsDataCellsFilterArgs',
    'GetPermissionsDataCellsFilterArgsDict',
    'GetPermissionsDataLocationArgs',
    'GetPermissionsDataLocationArgsDict',
    'GetPermissionsDatabaseArgs',
    'GetPermissionsDatabaseArgsDict',
    'GetPermissionsLfTagArgs',
    'GetPermissionsLfTagArgsDict',
    'GetPermissionsLfTagPolicyArgs',
    'GetPermissionsLfTagPolicyArgsDict',
    'GetPermissionsLfTagPolicyExpressionArgs',
    'GetPermissionsLfTagPolicyExpressionArgsDict',
    'GetPermissionsTableArgs',
    'GetPermissionsTableArgsDict',
    'GetPermissionsTableWithColumnsArgs',
    'GetPermissionsTableWithColumnsArgsDict',
]

MYPY = False

if not MYPY:
    class DataCellsFilterTableDataArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database.
        """
        name: pulumi.Input[str]
        """
        The name of the data cells filter.
        """
        table_catalog_id: pulumi.Input[str]
        """
        The ID of the Data Catalog.
        """
        table_name: pulumi.Input[str]
        """
        The name of the table.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of column names and/or nested column attributes.
        """
        column_wildcard: NotRequired[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgsDict']]
        """
        A wildcard with exclusions. See Column Wildcard below for details.
        """
        row_filter: NotRequired[pulumi.Input['DataCellsFilterTableDataRowFilterArgsDict']]
        """
        A PartiQL predicate. See Row Filter below for details.
        """
        version_id: NotRequired[pulumi.Input[str]]
        """
        ID of the data cells filter version.
        """
elif False:
    DataCellsFilterTableDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 table_catalog_id: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 column_wildcard: Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']] = None,
                 row_filter: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']] = None,
                 version_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: The name of the database.
        :param pulumi.Input[str] name: The name of the data cells filter.
        :param pulumi.Input[str] table_catalog_id: The ID of the Data Catalog.
        :param pulumi.Input[str] table_name: The name of the table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: A list of column names and/or nested column attributes.
        :param pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs'] column_wildcard: A wildcard with exclusions. See Column Wildcard below for details.
        :param pulumi.Input['DataCellsFilterTableDataRowFilterArgs'] row_filter: A PartiQL predicate. See Row Filter below for details.
        :param pulumi.Input[str] version_id: ID of the data cells filter version.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_wildcard is not None:
            pulumi.set(__self__, "column_wildcard", column_wildcard)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> pulumi.Input[str]:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of column names and/or nested column attributes.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnWildcard")
    def column_wildcard(self) -> Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']]:
        """
        A wildcard with exclusions. See Column Wildcard below for details.
        """
        return pulumi.get(self, "column_wildcard")

    @column_wildcard.setter
    def column_wildcard(self, value: Optional[pulumi.Input['DataCellsFilterTableDataColumnWildcardArgs']]):
        pulumi.set(self, "column_wildcard", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']]:
        """
        A PartiQL predicate. See Row Filter below for details.
        """
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterArgs']]):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the data cells filter version.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class DataCellsFilterTableDataColumnWildcardArgsDict(TypedDict):
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Optional) Excludes column names. Any column with this name will be excluded.
        """
elif False:
    DataCellsFilterTableDataColumnWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataColumnWildcardArgs:
    def __init__(__self__, *,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_column_names: (Optional) Excludes column names. Any column with this name will be excluded.
        """
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Optional) Excludes column names. Any column with this name will be excluded.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_column_names", value)


if not MYPY:
    class DataCellsFilterTableDataRowFilterArgsDict(TypedDict):
        all_rows_wildcard: NotRequired[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict']]
        """
        (Optional) A wildcard that matches all rows.
        """
        filter_expression: NotRequired[pulumi.Input[str]]
        """
        (Optional) A filter expression.
        """
elif False:
    DataCellsFilterTableDataRowFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataRowFilterArgs:
    def __init__(__self__, *,
                 all_rows_wildcard: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']] = None,
                 filter_expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs'] all_rows_wildcard: (Optional) A wildcard that matches all rows.
        :param pulumi.Input[str] filter_expression: (Optional) A filter expression.
        """
        if all_rows_wildcard is not None:
            pulumi.set(__self__, "all_rows_wildcard", all_rows_wildcard)
        if filter_expression is not None:
            pulumi.set(__self__, "filter_expression", filter_expression)

    @property
    @pulumi.getter(name="allRowsWildcard")
    def all_rows_wildcard(self) -> Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']]:
        """
        (Optional) A wildcard that matches all rows.
        """
        return pulumi.get(self, "all_rows_wildcard")

    @all_rows_wildcard.setter
    def all_rows_wildcard(self, value: Optional[pulumi.Input['DataCellsFilterTableDataRowFilterAllRowsWildcardArgs']]):
        pulumi.set(self, "all_rows_wildcard", value)

    @property
    @pulumi.getter(name="filterExpression")
    def filter_expression(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) A filter expression.
        """
        return pulumi.get(self, "filter_expression")

    @filter_expression.setter
    def filter_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_expression", value)


if not MYPY:
    class DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict(TypedDict):
        pass
elif False:
    DataCellsFilterTableDataRowFilterAllRowsWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTableDataRowFilterAllRowsWildcardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataCellsFilterTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    DataCellsFilterTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCellsFilterTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
elif False:
    DataLakeSettingsCreateDatabaseDefaultPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeSettingsCreateDatabaseDefaultPermissionArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        :param pulumi.Input[str] principal: Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, `DESCRIBE`, and `CREATE_TABLE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataLakeSettingsCreateTableDefaultPermissionArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        principal: NotRequired[pulumi.Input[str]]
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
elif False:
    DataLakeSettingsCreateTableDefaultPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakeSettingsCreateTableDefaultPermissionArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 principal: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        :param pulumi.Input[str] principal: Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of permissions that are granted to the principal. Valid values may include `ALL`, `SELECT`, `ALTER`, `DROP`, `DELETE`, `INSERT`, and `DESCRIBE`. For more details, see [Lake Formation Permissions Reference](https://docs.aws.amazon.com/lake-formation/latest/dg/lf-permissions-reference.html).
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input[str]]:
        """
        Principal who is granted permissions. To enforce metadata and underlying data access control only by IAM on new databases and tables set `principal` to `IAM_ALLOWED_PRINCIPALS` and `permissions` to `["ALL"]`.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class PermissionsDataCellsFilterArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of the database.
        """
        name: pulumi.Input[str]
        """
        The name of the data cells filter.
        """
        table_catalog_id: pulumi.Input[str]
        """
        The ID of the Data Catalog.
        """
        table_name: pulumi.Input[str]
        """
        The name of the table.
        """
elif False:
    PermissionsDataCellsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDataCellsFilterArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 table_catalog_id: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: The name of the database.
        :param pulumi.Input[str] name: The name of the data cells filter.
        :param pulumi.Input[str] table_catalog_id: The ID of the Data Catalog.
        :param pulumi.Input[str] table_name: The name of the table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> pulumi.Input[str]:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class PermissionsDataLocationArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        Amazon Resource Name (ARN) that uniquely identifies the data location resource.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDataLocationArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: Amazon Resource Name (ARN) that uniquely identifies the data location resource.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "arn", arn)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name (ARN) that uniquely identifies the data location resource.

        The following argument is optional:
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key-name for the tag.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of possible values an attribute can take.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key-name for the tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of possible values an attribute can take.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key-name for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of possible values an attribute can take.

        The following argument is optional:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagPolicyArgsDict(TypedDict):
        expressions: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgsDict']]]
        """
        A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        resource_type: pulumi.Input[str]
        """
        The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    PermissionsLfTagPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagPolicyArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]],
                 resource_type: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]] expressions: A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
               
               The following argument is optional:
        :param pulumi.Input[str] resource_type: The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "resource_type", resource_type)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]]:
        """
        A list of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['PermissionsLfTagPolicyExpressionArgs']]]):
        pulumi.set(self, "expressions", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        The resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class PermissionsLfTagPolicyExpressionArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key-name of an LF-Tag.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of possible values of an LF-Tag.
        """
elif False:
    PermissionsLfTagPolicyExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsLfTagPolicyExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] key: The key-name of an LF-Tag.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of possible values of an LF-Tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key-name of an LF-Tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of possible values of an LF-Tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PermissionsTableArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    PermissionsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[str] name: Name of the table.
        :param pulumi.Input[bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class PermissionsTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[str]
        """
        Name of the table resource.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of column names for the table.
        """
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
elif False:
    PermissionsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[str] name: Name of the table resource.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: Set of column names for the table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_column_names: Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        :param pulumi.Input[bool] wildcard: Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the table resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagLfTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key name for an existing LF-tag.
        """
        value: pulumi.Input[str]
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key name for an existing LF-tag.
        :param pulumi.Input[str] value: Value from the possible values for the LF-tag.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key name for an existing LF-tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagTableArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[str] name: Name of the table.
        :param pulumi.Input[bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[str]
        """
        Name of the table resource.

        The following arguments are optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of column names for the table.
        """
        column_wildcard: NotRequired[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgsDict']]
        """
        Option to add column wildcard. See Column Wildcard for more details.
        """
elif False:
    ResourceLfTagTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 column_wildcard: Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[str] name: Name of the table resource.
               
               The following arguments are optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: Set of column names for the table.
        :param pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs'] column_wildcard: Option to add column wildcard. See Column Wildcard for more details.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_wildcard is not None:
            pulumi.set(__self__, "column_wildcard", column_wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the table resource.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnWildcard")
    def column_wildcard(self) -> Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']]:
        """
        Option to add column wildcard. See Column Wildcard for more details.
        """
        return pulumi.get(self, "column_wildcard")

    @column_wildcard.setter
    def column_wildcard(self, value: Optional[pulumi.Input['ResourceLfTagTableWithColumnsColumnWildcardArgs']]):
        pulumi.set(self, "column_wildcard", value)


if not MYPY:
    class ResourceLfTagTableWithColumnsColumnWildcardArgsDict(TypedDict):
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ResourceLfTagTableWithColumnsColumnWildcardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTableWithColumnsColumnWildcardArgs:
    def __init__(__self__, *,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_column_names", value)


if not MYPY:
    class ResourceLfTagTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ResourceLfTagTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class ResourceLfTagsDatabaseArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagsLfTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key name for an existing LF-tag.
        """
        value: pulumi.Input[str]
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
elif False:
    ResourceLfTagsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsLfTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key name for an existing LF-tag.
        :param pulumi.Input[str] value: Value from the possible values for the LF-tag.
               
               The following argument is optional:
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key name for an existing LF-tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value from the possible values for the LF-tag.

        The following argument is optional:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class ResourceLfTagsTableArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the table.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsTableArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table. Unique to a Data Catalog.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[str] name: Name of the table.
        :param pulumi.Input[bool] wildcard: Whether to use a wildcard representing every table under a database. Defaults to `false`.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table. Unique to a Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a wildcard representing every table under a database. Defaults to `false`.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class ResourceLfTagsTableWithColumnsArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: pulumi.Input[str]
        """
        Name of the table resource.
        """
        catalog_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of column names for the table.
        """
        excluded_column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
elif False:
    ResourceLfTagsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceLfTagsTableWithColumnsArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 catalog_id: Optional[pulumi.Input[str]] = None,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param pulumi.Input[str] name: Name of the table resource.
        :param pulumi.Input[str] catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: Set of column names for the table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_column_names: Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        :param pulumi.Input[bool] wildcard: Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if catalog_id is not None:
            pulumi.set(__self__, "catalog_id", catalog_id)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the table resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of column names for the table.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference.

        The following arguments are optional:
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class GetPermissionsDataCellsFilterArgsDict(TypedDict):
        database_name: str
        """
        The name of the database.
        """
        name: str
        """
        The name of the data cells filter.
        """
        table_catalog_id: str
        """
        The ID of the Data Catalog.
        """
        table_name: str
        """
        The name of the table.
        """
elif False:
    GetPermissionsDataCellsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDataCellsFilterArgs:
    def __init__(__self__, *,
                 database_name: str,
                 name: str,
                 table_catalog_id: str,
                 table_name: str):
        """
        :param str database_name: The name of the database.
        :param str name: The name of the data cells filter.
        :param str table_catalog_id: The ID of the Data Catalog.
        :param str table_name: The name of the table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "table_catalog_id", table_catalog_id)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the data cells filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tableCatalogId")
    def table_catalog_id(self) -> str:
        """
        The ID of the Data Catalog.
        """
        return pulumi.get(self, "table_catalog_id")

    @table_catalog_id.setter
    def table_catalog_id(self, value: str):
        pulumi.set(self, "table_catalog_id", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: str):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class GetPermissionsDataLocationArgsDict(TypedDict):
        arn: str
        """
        ARN that uniquely identifies the data location resource.

        The following argument is optional:
        """
        catalog_id: str
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
elif False:
    GetPermissionsDataLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDataLocationArgs:
    def __init__(__self__, *,
                 arn: str,
                 catalog_id: str):
        """
        :param str arn: ARN that uniquely identifies the data location resource.
               
               The following argument is optional:
        :param str catalog_id: Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "catalog_id", catalog_id)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN that uniquely identifies the data location resource.

        The following argument is optional:
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: str):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)


if not MYPY:
    class GetPermissionsDatabaseArgsDict(TypedDict):
        catalog_id: str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        name: str
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
elif False:
    GetPermissionsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsDatabaseArgs:
    def __init__(__self__, *,
                 catalog_id: str,
                 name: str):
        """
        :param str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param str name: Name of the database resource. Unique to the Data Catalog.
               
               The following argument is optional:
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the database resource. Unique to the Data Catalog.

        The following argument is optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetPermissionsLfTagArgsDict(TypedDict):
        catalog_id: str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        key: str
        """
        Key-name for the tag.
        """
        values: Sequence[str]
        """
        List of possible values an attribute can take.

        The following argument is optional:
        """
elif False:
    GetPermissionsLfTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagArgs:
    def __init__(__self__, *,
                 catalog_id: str,
                 key: str,
                 values: Sequence[str]):
        """
        :param str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param str key: Key-name for the tag.
        :param Sequence[str] values: List of possible values an attribute can take.
               
               The following argument is optional:
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key-name for the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of possible values an attribute can take.

        The following argument is optional:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPermissionsLfTagPolicyArgsDict(TypedDict):
        catalog_id: str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        expressions: Sequence['GetPermissionsLfTagPolicyExpressionArgsDict']
        """
        List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        resource_type: str
        """
        Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
elif False:
    GetPermissionsLfTagPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagPolicyArgs:
    def __init__(__self__, *,
                 catalog_id: str,
                 expressions: Sequence['GetPermissionsLfTagPolicyExpressionArgs'],
                 resource_type: str):
        """
        :param str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param Sequence['GetPermissionsLfTagPolicyExpressionArgs'] expressions: List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.
               
               The following argument is optional:
        :param str resource_type: Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['GetPermissionsLfTagPolicyExpressionArgs']:
        """
        List of tag conditions that apply to the resource's tag policy. Configuration block for tag conditions that apply to the policy. See `expression` below.

        The following argument is optional:
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Sequence['GetPermissionsLfTagPolicyExpressionArgs']):
        pulumi.set(self, "expressions", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Resource type for which the tag policy applies. Valid values are `DATABASE` and `TABLE`.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: str):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class GetPermissionsLfTagPolicyExpressionArgsDict(TypedDict):
        key: str
        """
        Key-name of an LF-Tag.
        """
        values: Sequence[str]
        """
        List of possible values of an LF-Tag.
        """
elif False:
    GetPermissionsLfTagPolicyExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsLfTagPolicyExpressionArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: Key-name of an LF-Tag.
        :param Sequence[str] values: List of possible values of an LF-Tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key-name of an LF-Tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of possible values of an LF-Tag.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetPermissionsTableArgsDict(TypedDict):
        catalog_id: str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        database_name: str
        """
        Name of the database for the table. Unique to a Data Catalog.

        The following arguments are optional:
        """
        name: str
        """
        Name of the table. At least one of `name` or `wildcard` is required.
        """
        wildcard: NotRequired[bool]
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
elif False:
    GetPermissionsTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsTableArgs:
    def __init__(__self__, *,
                 catalog_id: str,
                 database_name: str,
                 name: str,
                 wildcard: Optional[bool] = None):
        """
        :param str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param str database_name: Name of the database for the table. Unique to a Data Catalog.
               
               The following arguments are optional:
        :param str name: Name of the table. At least one of `name` or `wildcard` is required.
        :param bool wildcard: Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database for the table. Unique to a Data Catalog.

        The following arguments are optional:
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table. At least one of `name` or `wildcard` is required.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[bool]:
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[bool]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class GetPermissionsTableWithColumnsArgsDict(TypedDict):
        catalog_id: str
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        database_name: str
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        name: str
        """
        Name of the table resource.

        The following arguments are optional:
        """
        column_names: NotRequired[Sequence[str]]
        """
        Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        """
        excluded_column_names: NotRequired[Sequence[str]]
        """
        Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        """
        wildcard: NotRequired[bool]
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
elif False:
    GetPermissionsTableWithColumnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsTableWithColumnsArgs:
    def __init__(__self__, *,
                 catalog_id: str,
                 database_name: str,
                 name: str,
                 column_names: Optional[Sequence[str]] = None,
                 excluded_column_names: Optional[Sequence[str]] = None,
                 wildcard: Optional[bool] = None):
        """
        :param str catalog_id: Identifier for the Data Catalog. By default, it is the account ID of the caller.
        :param str database_name: Name of the database for the table with columns resource. Unique to the Data Catalog.
        :param str name: Name of the table resource.
               
               The following arguments are optional:
        :param Sequence[str] column_names: Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        :param Sequence[str] excluded_column_names: Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        :param bool wildcard: Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        pulumi.set(__self__, "catalog_id", catalog_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if excluded_column_names is not None:
            pulumi.set(__self__, "excluded_column_names", excluded_column_names)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> str:
        """
        Identifier for the Data Catalog. By default, it is the account ID of the caller.
        """
        return pulumi.get(self, "catalog_id")

    @catalog_id.setter
    def catalog_id(self, value: str):
        pulumi.set(self, "catalog_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database for the table with columns resource. Unique to the Data Catalog.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the table resource.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        """
        Set of column names for the table. At least one of `column_names` or `excluded_column_names` is required.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="excludedColumnNames")
    def excluded_column_names(self) -> Optional[Sequence[str]]:
        """
        Set of column names for the table to exclude. At least one of `column_names` or `excluded_column_names` is required.
        """
        return pulumi.get(self, "excluded_column_names")

    @excluded_column_names.setter
    def excluded_column_names(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excluded_column_names", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[bool]:
        """
        Whether to use a wildcard representing every table under a database. At least one of `name` or `wildcard` is required. Defaults to `false`.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[bool]):
        pulumi.set(self, "wildcard", value)


