# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'QueryLoggingConfigurationDestinationArgs',
    'QueryLoggingConfigurationDestinationArgsDict',
    'QueryLoggingConfigurationDestinationCloudwatchLogsArgs',
    'QueryLoggingConfigurationDestinationCloudwatchLogsArgsDict',
    'QueryLoggingConfigurationDestinationFiltersArgs',
    'QueryLoggingConfigurationDestinationFiltersArgsDict',
    'QueryLoggingConfigurationTimeoutsArgs',
    'QueryLoggingConfigurationTimeoutsArgsDict',
    'ScraperDestinationArgs',
    'ScraperDestinationArgsDict',
    'ScraperDestinationAmpArgs',
    'ScraperDestinationAmpArgsDict',
    'ScraperRoleConfigurationArgs',
    'ScraperRoleConfigurationArgsDict',
    'ScraperSourceArgs',
    'ScraperSourceArgsDict',
    'ScraperSourceEksArgs',
    'ScraperSourceEksArgsDict',
    'ScraperTimeoutsArgs',
    'ScraperTimeoutsArgsDict',
    'WorkspaceConfigurationLimitsPerLabelSetArgs',
    'WorkspaceConfigurationLimitsPerLabelSetArgsDict',
    'WorkspaceConfigurationLimitsPerLabelSetLimitsArgs',
    'WorkspaceConfigurationLimitsPerLabelSetLimitsArgsDict',
    'WorkspaceConfigurationTimeoutsArgs',
    'WorkspaceConfigurationTimeoutsArgsDict',
    'WorkspaceLoggingConfigurationArgs',
    'WorkspaceLoggingConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class QueryLoggingConfigurationDestinationArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['QueryLoggingConfigurationDestinationCloudwatchLogsArgsDict']]
        """
        Configuration block for CloudWatch Logs destination. See `cloudwatch_logs`.
        """
        filters: NotRequired[pulumi.Input['QueryLoggingConfigurationDestinationFiltersArgsDict']]
        """
        A list of filter configurations that specify which logs should be sent to the destination. See `filters`.
        """
elif False:
    QueryLoggingConfigurationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryLoggingConfigurationDestinationArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['QueryLoggingConfigurationDestinationCloudwatchLogsArgs']] = None,
                 filters: Optional[pulumi.Input['QueryLoggingConfigurationDestinationFiltersArgs']] = None):
        """
        :param pulumi.Input['QueryLoggingConfigurationDestinationCloudwatchLogsArgs'] cloudwatch_logs: Configuration block for CloudWatch Logs destination. See `cloudwatch_logs`.
        :param pulumi.Input['QueryLoggingConfigurationDestinationFiltersArgs'] filters: A list of filter configurations that specify which logs should be sent to the destination. See `filters`.
        """
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['QueryLoggingConfigurationDestinationCloudwatchLogsArgs']]:
        """
        Configuration block for CloudWatch Logs destination. See `cloudwatch_logs`.
        """
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['QueryLoggingConfigurationDestinationCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input['QueryLoggingConfigurationDestinationFiltersArgs']]:
        """
        A list of filter configurations that specify which logs should be sent to the destination. See `filters`.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input['QueryLoggingConfigurationDestinationFiltersArgs']]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class QueryLoggingConfigurationDestinationCloudwatchLogsArgsDict(TypedDict):
        log_group_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the CloudWatch log group to which query logs will be sent.
        """
elif False:
    QueryLoggingConfigurationDestinationCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryLoggingConfigurationDestinationCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_arn: The ARN of the CloudWatch log group to which query logs will be sent.
        """
        pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the CloudWatch log group to which query logs will be sent.
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_arn", value)


if not MYPY:
    class QueryLoggingConfigurationDestinationFiltersArgsDict(TypedDict):
        qsp_threshold: pulumi.Input[_builtins.int]
        """
        The Query Samples Processed (QSP) threshold above which queries will be logged. Queries processing more samples than this threshold will be captured in logs.
        """
elif False:
    QueryLoggingConfigurationDestinationFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryLoggingConfigurationDestinationFiltersArgs:
    def __init__(__self__, *,
                 qsp_threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] qsp_threshold: The Query Samples Processed (QSP) threshold above which queries will be logged. Queries processing more samples than this threshold will be captured in logs.
        """
        pulumi.set(__self__, "qsp_threshold", qsp_threshold)

    @_builtins.property
    @pulumi.getter(name="qspThreshold")
    def qsp_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        The Query Samples Processed (QSP) threshold above which queries will be logged. Queries processing more samples than this threshold will be captured in logs.
        """
        return pulumi.get(self, "qsp_threshold")

    @qsp_threshold.setter
    def qsp_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "qsp_threshold", value)


if not MYPY:
    class QueryLoggingConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    QueryLoggingConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryLoggingConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ScraperDestinationArgsDict(TypedDict):
        amp: NotRequired[pulumi.Input['ScraperDestinationAmpArgsDict']]
        """
        Configuration block for an Amazon Managed Prometheus workspace destination. See `amp`.
        """
elif False:
    ScraperDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationArgs:
    def __init__(__self__, *,
                 amp: Optional[pulumi.Input['ScraperDestinationAmpArgs']] = None):
        """
        :param pulumi.Input['ScraperDestinationAmpArgs'] amp: Configuration block for an Amazon Managed Prometheus workspace destination. See `amp`.
        """
        if amp is not None:
            pulumi.set(__self__, "amp", amp)

    @_builtins.property
    @pulumi.getter
    def amp(self) -> Optional[pulumi.Input['ScraperDestinationAmpArgs']]:
        """
        Configuration block for an Amazon Managed Prometheus workspace destination. See `amp`.
        """
        return pulumi.get(self, "amp")

    @amp.setter
    def amp(self, value: Optional[pulumi.Input['ScraperDestinationAmpArgs']]):
        pulumi.set(self, "amp", value)


if not MYPY:
    class ScraperDestinationAmpArgsDict(TypedDict):
        workspace_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the prometheus workspace.
        """
elif False:
    ScraperDestinationAmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationAmpArgs:
    def __init__(__self__, *,
                 workspace_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] workspace_arn: The Amazon Resource Name (ARN) of the prometheus workspace.
        """
        pulumi.set(__self__, "workspace_arn", workspace_arn)

    @_builtins.property
    @pulumi.getter(name="workspaceArn")
    def workspace_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the prometheus workspace.
        """
        return pulumi.get(self, "workspace_arn")

    @workspace_arn.setter
    def workspace_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_arn", value)


if not MYPY:
    class ScraperRoleConfigurationArgsDict(TypedDict):
        source_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the source role configuration. Must be an IAM role ARN.
        """
        target_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the target role configuration. Must be an IAM role ARN.
        """
elif False:
    ScraperRoleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperRoleConfigurationArgs:
    def __init__(__self__, *,
                 source_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 target_role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_role_arn: The Amazon Resource Name (ARN) of the source role configuration. Must be an IAM role ARN.
        :param pulumi.Input[_builtins.str] target_role_arn: The Amazon Resource Name (ARN) of the target role configuration. Must be an IAM role ARN.
        """
        if source_role_arn is not None:
            pulumi.set(__self__, "source_role_arn", source_role_arn)
        if target_role_arn is not None:
            pulumi.set(__self__, "target_role_arn", target_role_arn)

    @_builtins.property
    @pulumi.getter(name="sourceRoleArn")
    def source_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the source role configuration. Must be an IAM role ARN.
        """
        return pulumi.get(self, "source_role_arn")

    @source_role_arn.setter
    def source_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetRoleArn")
    def target_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the target role configuration. Must be an IAM role ARN.
        """
        return pulumi.get(self, "target_role_arn")

    @target_role_arn.setter
    def target_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_role_arn", value)


if not MYPY:
    class ScraperSourceArgsDict(TypedDict):
        eks: NotRequired[pulumi.Input['ScraperSourceEksArgsDict']]
        """
        Configuration block for an EKS cluster source. See `eks`.
        """
elif False:
    ScraperSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceArgs:
    def __init__(__self__, *,
                 eks: Optional[pulumi.Input['ScraperSourceEksArgs']] = None):
        """
        :param pulumi.Input['ScraperSourceEksArgs'] eks: Configuration block for an EKS cluster source. See `eks`.
        """
        if eks is not None:
            pulumi.set(__self__, "eks", eks)

    @_builtins.property
    @pulumi.getter
    def eks(self) -> Optional[pulumi.Input['ScraperSourceEksArgs']]:
        """
        Configuration block for an EKS cluster source. See `eks`.
        """
        return pulumi.get(self, "eks")

    @eks.setter
    def eks(self, value: Optional[pulumi.Input['ScraperSourceEksArgs']]):
        pulumi.set(self, "eks", value)


if not MYPY:
    class ScraperSourceEksArgsDict(TypedDict):
        cluster_arn: pulumi.Input[_builtins.str]
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of subnet IDs. Must be in at least two different availability zones.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of the security group IDs for the Amazon EKS cluster VPC configuration.
        """
elif False:
    ScraperSourceEksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceEksArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: List of subnet IDs. Must be in at least two different availability zones.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: List of the security group IDs for the Amazon EKS cluster VPC configuration.
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of subnet IDs. Must be in at least two different availability zones.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of the security group IDs for the Amazon EKS cluster VPC configuration.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class ScraperTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ScraperTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class WorkspaceConfigurationLimitsPerLabelSetArgsDict(TypedDict):
        label_set: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Map of label key-value pairs that identify the metrics to which the limits apply. An empty map represents the default bucket for metrics that don't match any other label set.
        """
        limits: NotRequired[pulumi.Input['WorkspaceConfigurationLimitsPerLabelSetLimitsArgsDict']]
        """
        Configuration block for the limits to apply to the specified label set. Detailed below.
        """
elif False:
    WorkspaceConfigurationLimitsPerLabelSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceConfigurationLimitsPerLabelSetArgs:
    def __init__(__self__, *,
                 label_set: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 limits: Optional[pulumi.Input['WorkspaceConfigurationLimitsPerLabelSetLimitsArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] label_set: Map of label key-value pairs that identify the metrics to which the limits apply. An empty map represents the default bucket for metrics that don't match any other label set.
        :param pulumi.Input['WorkspaceConfigurationLimitsPerLabelSetLimitsArgs'] limits: Configuration block for the limits to apply to the specified label set. Detailed below.
        """
        pulumi.set(__self__, "label_set", label_set)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)

    @_builtins.property
    @pulumi.getter(name="labelSet")
    def label_set(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Map of label key-value pairs that identify the metrics to which the limits apply. An empty map represents the default bucket for metrics that don't match any other label set.
        """
        return pulumi.get(self, "label_set")

    @label_set.setter
    def label_set(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "label_set", value)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['WorkspaceConfigurationLimitsPerLabelSetLimitsArgs']]:
        """
        Configuration block for the limits to apply to the specified label set. Detailed below.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['WorkspaceConfigurationLimitsPerLabelSetLimitsArgs']]):
        pulumi.set(self, "limits", value)


if not MYPY:
    class WorkspaceConfigurationLimitsPerLabelSetLimitsArgsDict(TypedDict):
        max_series: pulumi.Input[_builtins.int]
        """
        Maximum number of active time series that can be ingested for metrics matching the label set.
        """
elif False:
    WorkspaceConfigurationLimitsPerLabelSetLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceConfigurationLimitsPerLabelSetLimitsArgs:
    def __init__(__self__, *,
                 max_series: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_series: Maximum number of active time series that can be ingested for metrics matching the label set.
        """
        pulumi.set(__self__, "max_series", max_series)

    @_builtins.property
    @pulumi.getter(name="maxSeries")
    def max_series(self) -> pulumi.Input[_builtins.int]:
        """
        Maximum number of active time series that can be ingested for metrics matching the label set.
        """
        return pulumi.get(self, "max_series")

    @max_series.setter
    def max_series(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_series", value)


if not MYPY:
    class WorkspaceConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    WorkspaceConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class WorkspaceLoggingConfigurationArgsDict(TypedDict):
        log_group_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
        """
elif False:
    WorkspaceLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_group_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_arn: The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
        """
        pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist.
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_arn", value)


