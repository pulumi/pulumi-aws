# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ApiCorsConfigurationArgs',
    'AuthorizerJwtConfigurationArgs',
    'DomainNameDomainNameConfigurationArgs',
    'DomainNameMutualTlsAuthenticationArgs',
    'IntegrationResponseParameterArgs',
    'IntegrationTlsConfigArgs',
    'RouteRequestParameterArgs',
    'StageAccessLogSettingsArgs',
    'StageDefaultRouteSettingsArgs',
    'StageRouteSettingArgs',
]

@pulumi.input_type
class ApiCorsConfigurationArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether credentials are included in the CORS request.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: Set of allowed HTTP headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: Set of allowed HTTP methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_origins: Set of allowed origins.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Set of exposed HTTP headers.
        :param pulumi.Input[int] max_age: Number of seconds that the browser should cache preflight request results.
        """
        ApiCorsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[pulumi.Input[bool]] = None,
             allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_credentials is None and 'allowCredentials' in kwargs:
            allow_credentials = kwargs['allowCredentials']
        if allow_headers is None and 'allowHeaders' in kwargs:
            allow_headers = kwargs['allowHeaders']
        if allow_methods is None and 'allowMethods' in kwargs:
            allow_methods = kwargs['allowMethods']
        if allow_origins is None and 'allowOrigins' in kwargs:
            allow_origins = kwargs['allowOrigins']
        if expose_headers is None and 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if max_age is None and 'maxAge' in kwargs:
            max_age = kwargs['maxAge']

        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allow_headers is not None:
            _setter("allow_headers", allow_headers)
        if allow_methods is not None:
            _setter("allow_methods", allow_methods)
        if allow_origins is not None:
            _setter("allow_origins", allow_origins)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether credentials are included in the CORS request.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of allowed HTTP headers.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of allowed HTTP methods.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of exposed HTTP headers.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds that the browser should cache preflight request results.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class AuthorizerJwtConfigurationArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 issuer: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audiences: List of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.
        :param pulumi.Input[str] issuer: Base domain of the identity provider that issues JSON Web Tokens, such as the `endpoint` attribute of the `cognito.UserPool` resource.
        """
        AuthorizerJwtConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audiences=audiences,
            issuer=issuer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             issuer: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if audiences is not None:
            _setter("audiences", audiences)
        if issuer is not None:
            _setter("issuer", issuer)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Base domain of the identity provider that issues JSON Web Tokens, such as the `endpoint` attribute of the `cognito.UserPool` resource.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)


@pulumi.input_type
class DomainNameDomainNameConfigurationArgs:
    def __init__(__self__, *,
                 certificate_arn: pulumi.Input[str],
                 endpoint_type: pulumi.Input[str],
                 security_policy: pulumi.Input[str],
                 hosted_zone_id: Optional[pulumi.Input[str]] = None,
                 ownership_verification_certificate_arn: Optional[pulumi.Input[str]] = None,
                 target_domain_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_arn: ARN of an AWS-managed certificate that will be used by the endpoint for the domain name. AWS Certificate Manager is the only supported source. Use the `acm.Certificate` resource to configure an ACM certificate.
        :param pulumi.Input[str] endpoint_type: Endpoint type. Valid values: `REGIONAL`.
        :param pulumi.Input[str] security_policy: Transport Layer Security (TLS) version of the [security policy](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-custom-domain-tls-version.html) for the domain name. Valid values: `TLS_1_2`.
        :param pulumi.Input[str] hosted_zone_id: Amazon Route 53 Hosted Zone ID of the endpoint.
        :param pulumi.Input[str] ownership_verification_certificate_arn: ARN of the AWS-issued certificate used to validate custom domain ownership (when `certificate_arn` is issued via an ACM Private CA or `mutual_tls_authentication` is configured with an ACM-imported certificate.)
        :param pulumi.Input[str] target_domain_name: Target domain name.
        """
        DomainNameDomainNameConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_arn=certificate_arn,
            endpoint_type=endpoint_type,
            security_policy=security_policy,
            hosted_zone_id=hosted_zone_id,
            ownership_verification_certificate_arn=ownership_verification_certificate_arn,
            target_domain_name=target_domain_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_arn: Optional[pulumi.Input[str]] = None,
             endpoint_type: Optional[pulumi.Input[str]] = None,
             security_policy: Optional[pulumi.Input[str]] = None,
             hosted_zone_id: Optional[pulumi.Input[str]] = None,
             ownership_verification_certificate_arn: Optional[pulumi.Input[str]] = None,
             target_domain_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_arn is None and 'certificateArn' in kwargs:
            certificate_arn = kwargs['certificateArn']
        if certificate_arn is None:
            raise TypeError("Missing 'certificate_arn' argument")
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if security_policy is None and 'securityPolicy' in kwargs:
            security_policy = kwargs['securityPolicy']
        if security_policy is None:
            raise TypeError("Missing 'security_policy' argument")
        if hosted_zone_id is None and 'hostedZoneId' in kwargs:
            hosted_zone_id = kwargs['hostedZoneId']
        if ownership_verification_certificate_arn is None and 'ownershipVerificationCertificateArn' in kwargs:
            ownership_verification_certificate_arn = kwargs['ownershipVerificationCertificateArn']
        if target_domain_name is None and 'targetDomainName' in kwargs:
            target_domain_name = kwargs['targetDomainName']

        _setter("certificate_arn", certificate_arn)
        _setter("endpoint_type", endpoint_type)
        _setter("security_policy", security_policy)
        if hosted_zone_id is not None:
            _setter("hosted_zone_id", hosted_zone_id)
        if ownership_verification_certificate_arn is not None:
            _setter("ownership_verification_certificate_arn", ownership_verification_certificate_arn)
        if target_domain_name is not None:
            _setter("target_domain_name", target_domain_name)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> pulumi.Input[str]:
        """
        ARN of an AWS-managed certificate that will be used by the endpoint for the domain name. AWS Certificate Manager is the only supported source. Use the `acm.Certificate` resource to configure an ACM certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @certificate_arn.setter
    def certificate_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_arn", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Endpoint type. Valid values: `REGIONAL`.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> pulumi.Input[str]:
        """
        Transport Layer Security (TLS) version of the [security policy](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-custom-domain-tls-version.html) for the domain name. Valid values: `TLS_1_2`.
        """
        return pulumi.get(self, "security_policy")

    @security_policy.setter
    def security_policy(self, value: pulumi.Input[str]):
        pulumi.set(self, "security_policy", value)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Route 53 Hosted Zone ID of the endpoint.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hosted_zone_id", value)

    @property
    @pulumi.getter(name="ownershipVerificationCertificateArn")
    def ownership_verification_certificate_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the AWS-issued certificate used to validate custom domain ownership (when `certificate_arn` is issued via an ACM Private CA or `mutual_tls_authentication` is configured with an ACM-imported certificate.)
        """
        return pulumi.get(self, "ownership_verification_certificate_arn")

    @ownership_verification_certificate_arn.setter
    def ownership_verification_certificate_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ownership_verification_certificate_arn", value)

    @property
    @pulumi.getter(name="targetDomainName")
    def target_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target domain name.
        """
        return pulumi.get(self, "target_domain_name")

    @target_domain_name.setter
    def target_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_domain_name", value)


@pulumi.input_type
class DomainNameMutualTlsAuthenticationArgs:
    def __init__(__self__, *,
                 truststore_uri: pulumi.Input[str],
                 truststore_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] truststore_uri: Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
        :param pulumi.Input[str] truststore_version: Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        """
        DomainNameMutualTlsAuthenticationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            truststore_uri=truststore_uri,
            truststore_version=truststore_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             truststore_uri: Optional[pulumi.Input[str]] = None,
             truststore_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if truststore_uri is None and 'truststoreUri' in kwargs:
            truststore_uri = kwargs['truststoreUri']
        if truststore_uri is None:
            raise TypeError("Missing 'truststore_uri' argument")
        if truststore_version is None and 'truststoreVersion' in kwargs:
            truststore_version = kwargs['truststoreVersion']

        _setter("truststore_uri", truststore_uri)
        if truststore_version is not None:
            _setter("truststore_version", truststore_version)

    @property
    @pulumi.getter(name="truststoreUri")
    def truststore_uri(self) -> pulumi.Input[str]:
        """
        Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, `s3://bucket-name/key-name`. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
        """
        return pulumi.get(self, "truststore_uri")

    @truststore_uri.setter
    def truststore_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "truststore_uri", value)

    @property
    @pulumi.getter(name="truststoreVersion")
    def truststore_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        """
        return pulumi.get(self, "truststore_version")

    @truststore_version.setter
    def truststore_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "truststore_version", value)


@pulumi.input_type
class IntegrationResponseParameterArgs:
    def __init__(__self__, *,
                 mappings: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 status_code: pulumi.Input[str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] mappings: Key-value map. The key of this map identifies the location of the request parameter to change, and how to change it. The corresponding value specifies the new data for the parameter.
               See the [Amazon API Gateway Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html) for details.
        :param pulumi.Input[str] status_code: HTTP status code in the range 200-599.
        """
        IntegrationResponseParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mappings=mappings,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mappings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             status_code: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mappings is None:
            raise TypeError("Missing 'mappings' argument")
        if status_code is None and 'statusCode' in kwargs:
            status_code = kwargs['statusCode']
        if status_code is None:
            raise TypeError("Missing 'status_code' argument")

        _setter("mappings", mappings)
        _setter("status_code", status_code)

    @property
    @pulumi.getter
    def mappings(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Key-value map. The key of this map identifies the location of the request parameter to change, and how to change it. The corresponding value specifies the new data for the parameter.
        See the [Amazon API Gateway Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html) for details.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "mappings", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[str]:
        """
        HTTP status code in the range 200-599.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class IntegrationTlsConfigArgs:
    def __init__(__self__, *,
                 server_name_to_verify: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server_name_to_verify: If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        """
        IntegrationTlsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_name_to_verify=server_name_to_verify,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_name_to_verify: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if server_name_to_verify is None and 'serverNameToVerify' in kwargs:
            server_name_to_verify = kwargs['serverNameToVerify']

        if server_name_to_verify is not None:
            _setter("server_name_to_verify", server_name_to_verify)

    @property
    @pulumi.getter(name="serverNameToVerify")
    def server_name_to_verify(self) -> Optional[pulumi.Input[str]]:
        """
        If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        """
        return pulumi.get(self, "server_name_to_verify")

    @server_name_to_verify.setter
    def server_name_to_verify(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name_to_verify", value)


@pulumi.input_type
class RouteRequestParameterArgs:
    def __init__(__self__, *,
                 request_parameter_key: pulumi.Input[str],
                 required: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] request_parameter_key: Request parameter key. This is a [request data mapping parameter](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-data-mapping.html#websocket-mapping-request-parameters).
        :param pulumi.Input[bool] required: Boolean whether or not the parameter is required.
        """
        RouteRequestParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_parameter_key=request_parameter_key,
            required=required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_parameter_key: Optional[pulumi.Input[str]] = None,
             required: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if request_parameter_key is None and 'requestParameterKey' in kwargs:
            request_parameter_key = kwargs['requestParameterKey']
        if request_parameter_key is None:
            raise TypeError("Missing 'request_parameter_key' argument")
        if required is None:
            raise TypeError("Missing 'required' argument")

        _setter("request_parameter_key", request_parameter_key)
        _setter("required", required)

    @property
    @pulumi.getter(name="requestParameterKey")
    def request_parameter_key(self) -> pulumi.Input[str]:
        """
        Request parameter key. This is a [request data mapping parameter](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-data-mapping.html#websocket-mapping-request-parameters).
        """
        return pulumi.get(self, "request_parameter_key")

    @request_parameter_key.setter
    def request_parameter_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "request_parameter_key", value)

    @property
    @pulumi.getter
    def required(self) -> pulumi.Input[bool]:
        """
        Boolean whether or not the parameter is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[bool]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class StageAccessLogSettingsArgs:
    def __init__(__self__, *,
                 destination_arn: pulumi.Input[str],
                 format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_arn: ARN of the CloudWatch Logs log group to receive access logs. Any trailing `:*` is trimmed from the ARN.
        :param pulumi.Input[str] format: Single line [format](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html#apigateway-cloudwatch-log-formats) of the access logs of data. Refer to log settings for [HTTP](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-logging-variables.html) or [Websocket](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-logging.html).
        """
        StageAccessLogSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_arn=destination_arn,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_arn: Optional[pulumi.Input[str]] = None,
             format: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_arn is None and 'destinationArn' in kwargs:
            destination_arn = kwargs['destinationArn']
        if destination_arn is None:
            raise TypeError("Missing 'destination_arn' argument")
        if format is None:
            raise TypeError("Missing 'format' argument")

        _setter("destination_arn", destination_arn)
        _setter("format", format)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        ARN of the CloudWatch Logs log group to receive access logs. Any trailing `:*` is trimmed from the ARN.
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Single line [format](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html#apigateway-cloudwatch-log-formats) of the access logs of data. Refer to log settings for [HTTP](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-logging-variables.html) or [Websocket](https://docs.aws.amazon.com/apigateway/latest/developerguide/websocket-api-logging.html).
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)


@pulumi.input_type
class StageDefaultRouteSettingsArgs:
    def __init__(__self__, *,
                 data_trace_enabled: Optional[pulumi.Input[bool]] = None,
                 detailed_metrics_enabled: Optional[pulumi.Input[bool]] = None,
                 logging_level: Optional[pulumi.Input[str]] = None,
                 throttling_burst_limit: Optional[pulumi.Input[int]] = None,
                 throttling_rate_limit: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] data_trace_enabled: Whether data trace logging is enabled for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
               Defaults to `false`. Supported only for WebSocket APIs.
        :param pulumi.Input[bool] detailed_metrics_enabled: Whether detailed metrics are enabled for the default route. Defaults to `false`.
        :param pulumi.Input[str] logging_level: Logging level for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
               Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
        :param pulumi.Input[int] throttling_burst_limit: Throttling burst limit for the default route.
        :param pulumi.Input[float] throttling_rate_limit: Throttling rate limit for the default route.
        """
        StageDefaultRouteSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_trace_enabled=data_trace_enabled,
            detailed_metrics_enabled=detailed_metrics_enabled,
            logging_level=logging_level,
            throttling_burst_limit=throttling_burst_limit,
            throttling_rate_limit=throttling_rate_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_trace_enabled: Optional[pulumi.Input[bool]] = None,
             detailed_metrics_enabled: Optional[pulumi.Input[bool]] = None,
             logging_level: Optional[pulumi.Input[str]] = None,
             throttling_burst_limit: Optional[pulumi.Input[int]] = None,
             throttling_rate_limit: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_trace_enabled is None and 'dataTraceEnabled' in kwargs:
            data_trace_enabled = kwargs['dataTraceEnabled']
        if detailed_metrics_enabled is None and 'detailedMetricsEnabled' in kwargs:
            detailed_metrics_enabled = kwargs['detailedMetricsEnabled']
        if logging_level is None and 'loggingLevel' in kwargs:
            logging_level = kwargs['loggingLevel']
        if throttling_burst_limit is None and 'throttlingBurstLimit' in kwargs:
            throttling_burst_limit = kwargs['throttlingBurstLimit']
        if throttling_rate_limit is None and 'throttlingRateLimit' in kwargs:
            throttling_rate_limit = kwargs['throttlingRateLimit']

        if data_trace_enabled is not None:
            _setter("data_trace_enabled", data_trace_enabled)
        if detailed_metrics_enabled is not None:
            _setter("detailed_metrics_enabled", detailed_metrics_enabled)
        if logging_level is not None:
            _setter("logging_level", logging_level)
        if throttling_burst_limit is not None:
            _setter("throttling_burst_limit", throttling_burst_limit)
        if throttling_rate_limit is not None:
            _setter("throttling_rate_limit", throttling_rate_limit)

    @property
    @pulumi.getter(name="dataTraceEnabled")
    def data_trace_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether data trace logging is enabled for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
        Defaults to `false`. Supported only for WebSocket APIs.
        """
        return pulumi.get(self, "data_trace_enabled")

    @data_trace_enabled.setter
    def data_trace_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_trace_enabled", value)

    @property
    @pulumi.getter(name="detailedMetricsEnabled")
    def detailed_metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether detailed metrics are enabled for the default route. Defaults to `false`.
        """
        return pulumi.get(self, "detailed_metrics_enabled")

    @detailed_metrics_enabled.setter
    def detailed_metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_metrics_enabled", value)

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[pulumi.Input[str]]:
        """
        Logging level for the default route. Affects the log entries pushed to Amazon CloudWatch Logs.
        Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
        """
        return pulumi.get(self, "logging_level")

    @logging_level.setter
    def logging_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logging_level", value)

    @property
    @pulumi.getter(name="throttlingBurstLimit")
    def throttling_burst_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Throttling burst limit for the default route.
        """
        return pulumi.get(self, "throttling_burst_limit")

    @throttling_burst_limit.setter
    def throttling_burst_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttling_burst_limit", value)

    @property
    @pulumi.getter(name="throttlingRateLimit")
    def throttling_rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        Throttling rate limit for the default route.
        """
        return pulumi.get(self, "throttling_rate_limit")

    @throttling_rate_limit.setter
    def throttling_rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "throttling_rate_limit", value)


@pulumi.input_type
class StageRouteSettingArgs:
    def __init__(__self__, *,
                 route_key: pulumi.Input[str],
                 data_trace_enabled: Optional[pulumi.Input[bool]] = None,
                 detailed_metrics_enabled: Optional[pulumi.Input[bool]] = None,
                 logging_level: Optional[pulumi.Input[str]] = None,
                 throttling_burst_limit: Optional[pulumi.Input[int]] = None,
                 throttling_rate_limit: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] route_key: Route key.
        :param pulumi.Input[bool] data_trace_enabled: Whether data trace logging is enabled for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
               Defaults to `false`. Supported only for WebSocket APIs.
        :param pulumi.Input[bool] detailed_metrics_enabled: Whether detailed metrics are enabled for the route. Defaults to `false`.
        :param pulumi.Input[str] logging_level: Logging level for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
               Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
        :param pulumi.Input[int] throttling_burst_limit: Throttling burst limit for the route.
        :param pulumi.Input[float] throttling_rate_limit: Throttling rate limit for the route.
        """
        StageRouteSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            route_key=route_key,
            data_trace_enabled=data_trace_enabled,
            detailed_metrics_enabled=detailed_metrics_enabled,
            logging_level=logging_level,
            throttling_burst_limit=throttling_burst_limit,
            throttling_rate_limit=throttling_rate_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             route_key: Optional[pulumi.Input[str]] = None,
             data_trace_enabled: Optional[pulumi.Input[bool]] = None,
             detailed_metrics_enabled: Optional[pulumi.Input[bool]] = None,
             logging_level: Optional[pulumi.Input[str]] = None,
             throttling_burst_limit: Optional[pulumi.Input[int]] = None,
             throttling_rate_limit: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if route_key is None and 'routeKey' in kwargs:
            route_key = kwargs['routeKey']
        if route_key is None:
            raise TypeError("Missing 'route_key' argument")
        if data_trace_enabled is None and 'dataTraceEnabled' in kwargs:
            data_trace_enabled = kwargs['dataTraceEnabled']
        if detailed_metrics_enabled is None and 'detailedMetricsEnabled' in kwargs:
            detailed_metrics_enabled = kwargs['detailedMetricsEnabled']
        if logging_level is None and 'loggingLevel' in kwargs:
            logging_level = kwargs['loggingLevel']
        if throttling_burst_limit is None and 'throttlingBurstLimit' in kwargs:
            throttling_burst_limit = kwargs['throttlingBurstLimit']
        if throttling_rate_limit is None and 'throttlingRateLimit' in kwargs:
            throttling_rate_limit = kwargs['throttlingRateLimit']

        _setter("route_key", route_key)
        if data_trace_enabled is not None:
            _setter("data_trace_enabled", data_trace_enabled)
        if detailed_metrics_enabled is not None:
            _setter("detailed_metrics_enabled", detailed_metrics_enabled)
        if logging_level is not None:
            _setter("logging_level", logging_level)
        if throttling_burst_limit is not None:
            _setter("throttling_burst_limit", throttling_burst_limit)
        if throttling_rate_limit is not None:
            _setter("throttling_rate_limit", throttling_rate_limit)

    @property
    @pulumi.getter(name="routeKey")
    def route_key(self) -> pulumi.Input[str]:
        """
        Route key.
        """
        return pulumi.get(self, "route_key")

    @route_key.setter
    def route_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_key", value)

    @property
    @pulumi.getter(name="dataTraceEnabled")
    def data_trace_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether data trace logging is enabled for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
        Defaults to `false`. Supported only for WebSocket APIs.
        """
        return pulumi.get(self, "data_trace_enabled")

    @data_trace_enabled.setter
    def data_trace_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_trace_enabled", value)

    @property
    @pulumi.getter(name="detailedMetricsEnabled")
    def detailed_metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether detailed metrics are enabled for the route. Defaults to `false`.
        """
        return pulumi.get(self, "detailed_metrics_enabled")

    @detailed_metrics_enabled.setter
    def detailed_metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_metrics_enabled", value)

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[pulumi.Input[str]]:
        """
        Logging level for the route. Affects the log entries pushed to Amazon CloudWatch Logs.
        Valid values: `ERROR`, `INFO`, `OFF`. Defaults to `OFF`. Supported only for WebSocket APIs. This provider will only perform drift detection of its value when present in a configuration.
        """
        return pulumi.get(self, "logging_level")

    @logging_level.setter
    def logging_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logging_level", value)

    @property
    @pulumi.getter(name="throttlingBurstLimit")
    def throttling_burst_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Throttling burst limit for the route.
        """
        return pulumi.get(self, "throttling_burst_limit")

    @throttling_burst_limit.setter
    def throttling_burst_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttling_burst_limit", value)

    @property
    @pulumi.getter(name="throttlingRateLimit")
    def throttling_rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        Throttling rate limit for the route.
        """
        return pulumi.get(self, "throttling_rate_limit")

    @throttling_rate_limit.setter
    def throttling_rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "throttling_rate_limit", value)


