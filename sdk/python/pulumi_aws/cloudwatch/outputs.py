# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CompositeAlarmActionsSuppressor',
    'EventBusDeadLetterConfig',
    'EventBusLogConfig',
    'EventConnectionAuthParameters',
    'EventConnectionAuthParametersApiKey',
    'EventConnectionAuthParametersBasic',
    'EventConnectionAuthParametersInvocationHttpParameters',
    'EventConnectionAuthParametersInvocationHttpParametersBody',
    'EventConnectionAuthParametersInvocationHttpParametersHeader',
    'EventConnectionAuthParametersInvocationHttpParametersQueryString',
    'EventConnectionAuthParametersOauth',
    'EventConnectionAuthParametersOauthClientParameters',
    'EventConnectionAuthParametersOauthOauthHttpParameters',
    'EventConnectionAuthParametersOauthOauthHttpParametersBody',
    'EventConnectionAuthParametersOauthOauthHttpParametersHeader',
    'EventConnectionAuthParametersOauthOauthHttpParametersQueryString',
    'EventConnectionInvocationConnectivityParameters',
    'EventConnectionInvocationConnectivityParametersResourceParameters',
    'EventEndpointEventBus',
    'EventEndpointReplicationConfig',
    'EventEndpointRoutingConfig',
    'EventEndpointRoutingConfigFailoverConfig',
    'EventEndpointRoutingConfigFailoverConfigPrimary',
    'EventEndpointRoutingConfigFailoverConfigSecondary',
    'EventPermissionCondition',
    'EventTargetAppsyncTarget',
    'EventTargetBatchTarget',
    'EventTargetDeadLetterConfig',
    'EventTargetEcsTarget',
    'EventTargetEcsTargetCapacityProviderStrategy',
    'EventTargetEcsTargetNetworkConfiguration',
    'EventTargetEcsTargetOrderedPlacementStrategy',
    'EventTargetEcsTargetPlacementConstraint',
    'EventTargetHttpTarget',
    'EventTargetInputTransformer',
    'EventTargetKinesisTarget',
    'EventTargetRedshiftTarget',
    'EventTargetRetryPolicy',
    'EventTargetRunCommandTarget',
    'EventTargetSagemakerPipelineTarget',
    'EventTargetSagemakerPipelineTargetPipelineParameterList',
    'EventTargetSqsTarget',
    'InternetMonitorHealthEventsConfig',
    'InternetMonitorInternetMeasurementsLogDelivery',
    'InternetMonitorInternetMeasurementsLogDeliveryS3Config',
    'LogDeliveryDestinationDeliveryDestinationConfiguration',
    'LogDeliveryS3DeliveryConfiguration',
    'LogMetricFilterMetricTransformation',
    'LogTransformerTransformerConfig',
    'LogTransformerTransformerConfigAddKeys',
    'LogTransformerTransformerConfigAddKeysEntry',
    'LogTransformerTransformerConfigCopyValue',
    'LogTransformerTransformerConfigCopyValueEntry',
    'LogTransformerTransformerConfigCsv',
    'LogTransformerTransformerConfigDateTimeConverter',
    'LogTransformerTransformerConfigDeleteKey',
    'LogTransformerTransformerConfigGrok',
    'LogTransformerTransformerConfigListToMap',
    'LogTransformerTransformerConfigLowerCaseString',
    'LogTransformerTransformerConfigMoveKey',
    'LogTransformerTransformerConfigMoveKeyEntry',
    'LogTransformerTransformerConfigParseCloudfront',
    'LogTransformerTransformerConfigParseJson',
    'LogTransformerTransformerConfigParseKeyValue',
    'LogTransformerTransformerConfigParsePostgres',
    'LogTransformerTransformerConfigParseRoute53',
    'LogTransformerTransformerConfigParseToOcsf',
    'LogTransformerTransformerConfigParseVpc',
    'LogTransformerTransformerConfigParseWaf',
    'LogTransformerTransformerConfigRenameKey',
    'LogTransformerTransformerConfigRenameKeyEntry',
    'LogTransformerTransformerConfigSplitString',
    'LogTransformerTransformerConfigSplitStringEntry',
    'LogTransformerTransformerConfigSubstituteString',
    'LogTransformerTransformerConfigSubstituteStringEntry',
    'LogTransformerTransformerConfigTrimString',
    'LogTransformerTransformerConfigTypeConverter',
    'LogTransformerTransformerConfigTypeConverterEntry',
    'LogTransformerTransformerConfigUpperCaseString',
    'MetricAlarmMetricQuery',
    'MetricAlarmMetricQueryMetric',
    'MetricStreamExcludeFilter',
    'MetricStreamIncludeFilter',
    'MetricStreamStatisticsConfiguration',
    'MetricStreamStatisticsConfigurationIncludeMetric',
    'GetContributorManagedInsightRulesManagedRuleResult',
    'GetContributorManagedInsightRulesManagedRuleRuleStateResult',
    'GetEventBusDeadLetterConfigResult',
    'GetEventBusLogConfigResult',
    'GetEventBusesEventBusResult',
    'GetLogDataProtectionPolicyDocumentConfigurationResult',
    'GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierResult',
    'GetLogDataProtectionPolicyDocumentStatementResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Result',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyResult',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigResult',
]

@pulumi.output_type
class CompositeAlarmActionsSuppressor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionPeriod":
            suggest = "extension_period"
        elif key == "waitPeriod":
            suggest = "wait_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CompositeAlarmActionsSuppressor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CompositeAlarmActionsSuppressor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CompositeAlarmActionsSuppressor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm: _builtins.str,
                 extension_period: _builtins.int,
                 wait_period: _builtins.int):
        pulumi.set(__self__, "alarm", alarm)
        pulumi.set(__self__, "extension_period", extension_period)
        pulumi.set(__self__, "wait_period", wait_period)

    @_builtins.property
    @pulumi.getter
    def alarm(self) -> _builtins.str:
        return pulumi.get(self, "alarm")

    @_builtins.property
    @pulumi.getter(name="extensionPeriod")
    def extension_period(self) -> _builtins.int:
        return pulumi.get(self, "extension_period")

    @_builtins.property
    @pulumi.getter(name="waitPeriod")
    def wait_period(self) -> _builtins.int:
        return pulumi.get(self, "wait_period")


@pulumi.output_type
class EventBusDeadLetterConfig(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class EventBusLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeDetail":
            suggest = "include_detail"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventBusLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventBusLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventBusLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_detail: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        if include_detail is not None:
            pulumi.set(__self__, "include_detail", include_detail)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="includeDetail")
    def include_detail(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_detail")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "level")


@pulumi.output_type
class EventConnectionAuthParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "invocationHttpParameters":
            suggest = "invocation_http_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.EventConnectionAuthParametersApiKey'] = None,
                 basic: Optional['outputs.EventConnectionAuthParametersBasic'] = None,
                 invocation_http_parameters: Optional['outputs.EventConnectionAuthParametersInvocationHttpParameters'] = None,
                 oauth: Optional['outputs.EventConnectionAuthParametersOauth'] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if invocation_http_parameters is not None:
            pulumi.set(__self__, "invocation_http_parameters", invocation_http_parameters)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.EventConnectionAuthParametersApiKey']:
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional['outputs.EventConnectionAuthParametersBasic']:
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="invocationHttpParameters")
    def invocation_http_parameters(self) -> Optional['outputs.EventConnectionAuthParametersInvocationHttpParameters']:
        return pulumi.get(self, "invocation_http_parameters")

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional['outputs.EventConnectionAuthParametersOauth']:
        return pulumi.get(self, "oauth")


@pulumi.output_type
class EventConnectionAuthParametersApiKey(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersBasic(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class EventConnectionAuthParametersInvocationHttpParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryStrings":
            suggest = "query_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersInvocationHttpParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersInvocationHttpParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersInvocationHttpParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bodies: Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersBody']] = None,
                 headers: Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersHeader']] = None,
                 query_strings: Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersQueryString']] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersBody']]:
        return pulumi.get(self, "bodies")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersInvocationHttpParametersQueryString']]:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class EventConnectionAuthParametersInvocationHttpParametersBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersInvocationHttpParametersBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersInvocationHttpParametersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersInvocationHttpParametersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersInvocationHttpParametersQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersInvocationHttpParametersQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersInvocationHttpParametersQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "oauthHttpParameters":
            suggest = "oauth_http_parameters"
        elif key == "clientParameters":
            suggest = "client_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: _builtins.str,
                 http_method: _builtins.str,
                 oauth_http_parameters: 'outputs.EventConnectionAuthParametersOauthOauthHttpParameters',
                 client_parameters: Optional['outputs.EventConnectionAuthParametersOauthClientParameters'] = None):
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "oauth_http_parameters", oauth_http_parameters)
        if client_parameters is not None:
            pulumi.set(__self__, "client_parameters", client_parameters)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> _builtins.str:
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> _builtins.str:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="oauthHttpParameters")
    def oauth_http_parameters(self) -> 'outputs.EventConnectionAuthParametersOauthOauthHttpParameters':
        return pulumi.get(self, "oauth_http_parameters")

    @_builtins.property
    @pulumi.getter(name="clientParameters")
    def client_parameters(self) -> Optional['outputs.EventConnectionAuthParametersOauthClientParameters']:
        return pulumi.get(self, "client_parameters")


@pulumi.output_type
class EventConnectionAuthParametersOauthClientParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauthClientParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauthClientParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauthClientParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class EventConnectionAuthParametersOauthOauthHttpParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryStrings":
            suggest = "query_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauthOauthHttpParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bodies: Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersBody']] = None,
                 headers: Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersHeader']] = None,
                 query_strings: Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersQueryString']] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersBody']]:
        return pulumi.get(self, "bodies")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[Sequence['outputs.EventConnectionAuthParametersOauthOauthHttpParametersQueryString']]:
        return pulumi.get(self, "query_strings")


@pulumi.output_type
class EventConnectionAuthParametersOauthOauthHttpParametersBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauthOauthHttpParametersBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersOauthOauthHttpParametersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauthOauthHttpParametersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionAuthParametersOauthOauthHttpParametersQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValueSecret":
            suggest = "is_value_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionAuthParametersOauthOauthHttpParametersQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionAuthParametersOauthOauthHttpParametersQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_value_secret: Optional[_builtins.bool] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_value_secret")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventConnectionInvocationConnectivityParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceParameters":
            suggest = "resource_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionInvocationConnectivityParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionInvocationConnectivityParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionInvocationConnectivityParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_parameters: 'outputs.EventConnectionInvocationConnectivityParametersResourceParameters'):
        pulumi.set(__self__, "resource_parameters", resource_parameters)

    @_builtins.property
    @pulumi.getter(name="resourceParameters")
    def resource_parameters(self) -> 'outputs.EventConnectionInvocationConnectivityParametersResourceParameters':
        return pulumi.get(self, "resource_parameters")


@pulumi.output_type
class EventConnectionInvocationConnectivityParametersResourceParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceConfigurationArn":
            suggest = "resource_configuration_arn"
        elif key == "resourceAssociationArn":
            suggest = "resource_association_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventConnectionInvocationConnectivityParametersResourceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventConnectionInvocationConnectivityParametersResourceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventConnectionInvocationConnectivityParametersResourceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_configuration_arn: _builtins.str,
                 resource_association_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "resource_configuration_arn", resource_configuration_arn)
        if resource_association_arn is not None:
            pulumi.set(__self__, "resource_association_arn", resource_association_arn)

    @_builtins.property
    @pulumi.getter(name="resourceConfigurationArn")
    def resource_configuration_arn(self) -> _builtins.str:
        return pulumi.get(self, "resource_configuration_arn")

    @_builtins.property
    @pulumi.getter(name="resourceAssociationArn")
    def resource_association_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_association_arn")


@pulumi.output_type
class EventEndpointEventBus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventBusArn":
            suggest = "event_bus_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventEndpointEventBus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventEndpointEventBus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventEndpointEventBus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_bus_arn: _builtins.str):
        pulumi.set(__self__, "event_bus_arn", event_bus_arn)

    @_builtins.property
    @pulumi.getter(name="eventBusArn")
    def event_bus_arn(self) -> _builtins.str:
        return pulumi.get(self, "event_bus_arn")


@pulumi.output_type
class EventEndpointReplicationConfig(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class EventEndpointRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverConfig":
            suggest = "failover_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventEndpointRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventEndpointRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventEndpointRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_config: 'outputs.EventEndpointRoutingConfigFailoverConfig'):
        pulumi.set(__self__, "failover_config", failover_config)

    @_builtins.property
    @pulumi.getter(name="failoverConfig")
    def failover_config(self) -> 'outputs.EventEndpointRoutingConfigFailoverConfig':
        return pulumi.get(self, "failover_config")


@pulumi.output_type
class EventEndpointRoutingConfigFailoverConfig(dict):
    def __init__(__self__, *,
                 primary: 'outputs.EventEndpointRoutingConfigFailoverConfigPrimary',
                 secondary: 'outputs.EventEndpointRoutingConfigFailoverConfigSecondary'):
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> 'outputs.EventEndpointRoutingConfigFailoverConfigPrimary':
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> 'outputs.EventEndpointRoutingConfigFailoverConfigSecondary':
        return pulumi.get(self, "secondary")


@pulumi.output_type
class EventEndpointRoutingConfigFailoverConfigPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheck":
            suggest = "health_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventEndpointRoutingConfigFailoverConfigPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventEndpointRoutingConfigFailoverConfigPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventEndpointRoutingConfigFailoverConfigPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check: Optional[_builtins.str] = None):
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "health_check")


@pulumi.output_type
class EventEndpointRoutingConfigFailoverConfigSecondary(dict):
    def __init__(__self__, *,
                 route: Optional[_builtins.str] = None):
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route")


@pulumi.output_type
class EventPermissionCondition(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventTargetAppsyncTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphqlOperation":
            suggest = "graphql_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetAppsyncTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetAppsyncTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetAppsyncTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 graphql_operation: Optional[_builtins.str] = None):
        if graphql_operation is not None:
            pulumi.set(__self__, "graphql_operation", graphql_operation)

    @_builtins.property
    @pulumi.getter(name="graphqlOperation")
    def graphql_operation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "graphql_operation")


@pulumi.output_type
class EventTargetBatchTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobDefinition":
            suggest = "job_definition"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "arraySize":
            suggest = "array_size"
        elif key == "jobAttempts":
            suggest = "job_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetBatchTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetBatchTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetBatchTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_definition: _builtins.str,
                 job_name: _builtins.str,
                 array_size: Optional[_builtins.int] = None,
                 job_attempts: Optional[_builtins.int] = None):
        pulumi.set(__self__, "job_definition", job_definition)
        pulumi.set(__self__, "job_name", job_name)
        if array_size is not None:
            pulumi.set(__self__, "array_size", array_size)
        if job_attempts is not None:
            pulumi.set(__self__, "job_attempts", job_attempts)

    @_builtins.property
    @pulumi.getter(name="jobDefinition")
    def job_definition(self) -> _builtins.str:
        return pulumi.get(self, "job_definition")

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> _builtins.str:
        return pulumi.get(self, "job_name")

    @_builtins.property
    @pulumi.getter(name="arraySize")
    def array_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "array_size")

    @_builtins.property
    @pulumi.getter(name="jobAttempts")
    def job_attempts(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "job_attempts")


@pulumi.output_type
class EventTargetDeadLetterConfig(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class EventTargetEcsTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskDefinitionArn":
            suggest = "task_definition_arn"
        elif key == "capacityProviderStrategies":
            suggest = "capacity_provider_strategies"
        elif key == "enableEcsManagedTags":
            suggest = "enable_ecs_managed_tags"
        elif key == "enableExecuteCommand":
            suggest = "enable_execute_command"
        elif key == "launchType":
            suggest = "launch_type"
        elif key == "networkConfiguration":
            suggest = "network_configuration"
        elif key == "orderedPlacementStrategies":
            suggest = "ordered_placement_strategies"
        elif key == "placementConstraints":
            suggest = "placement_constraints"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "propagateTags":
            suggest = "propagate_tags"
        elif key == "taskCount":
            suggest = "task_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetEcsTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetEcsTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetEcsTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_definition_arn: _builtins.str,
                 capacity_provider_strategies: Optional[Sequence['outputs.EventTargetEcsTargetCapacityProviderStrategy']] = None,
                 enable_ecs_managed_tags: Optional[_builtins.bool] = None,
                 enable_execute_command: Optional[_builtins.bool] = None,
                 group: Optional[_builtins.str] = None,
                 launch_type: Optional[_builtins.str] = None,
                 network_configuration: Optional['outputs.EventTargetEcsTargetNetworkConfiguration'] = None,
                 ordered_placement_strategies: Optional[Sequence['outputs.EventTargetEcsTargetOrderedPlacementStrategy']] = None,
                 placement_constraints: Optional[Sequence['outputs.EventTargetEcsTargetPlacementConstraint']] = None,
                 platform_version: Optional[_builtins.str] = None,
                 propagate_tags: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 task_count: Optional[_builtins.int] = None):
        pulumi.set(__self__, "task_definition_arn", task_definition_arn)
        if capacity_provider_strategies is not None:
            pulumi.set(__self__, "capacity_provider_strategies", capacity_provider_strategies)
        if enable_ecs_managed_tags is not None:
            pulumi.set(__self__, "enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            pulumi.set(__self__, "enable_execute_command", enable_execute_command)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if launch_type is not None:
            pulumi.set(__self__, "launch_type", launch_type)
        if network_configuration is not None:
            pulumi.set(__self__, "network_configuration", network_configuration)
        if ordered_placement_strategies is not None:
            pulumi.set(__self__, "ordered_placement_strategies", ordered_placement_strategies)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @_builtins.property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> _builtins.str:
        return pulumi.get(self, "task_definition_arn")

    @_builtins.property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Optional[Sequence['outputs.EventTargetEcsTargetCapacityProviderStrategy']]:
        return pulumi.get(self, "capacity_provider_strategies")

    @_builtins.property
    @pulumi.getter(name="enableEcsManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_ecs_managed_tags")

    @_builtins.property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_execute_command")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_type")

    @_builtins.property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional['outputs.EventTargetEcsTargetNetworkConfiguration']:
        return pulumi.get(self, "network_configuration")

    @_builtins.property
    @pulumi.getter(name="orderedPlacementStrategies")
    def ordered_placement_strategies(self) -> Optional[Sequence['outputs.EventTargetEcsTargetOrderedPlacementStrategy']]:
        return pulumi.get(self, "ordered_placement_strategies")

    @_builtins.property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[Sequence['outputs.EventTargetEcsTargetPlacementConstraint']]:
        return pulumi.get(self, "placement_constraints")

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "platform_version")

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "propagate_tags")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "task_count")


@pulumi.output_type
class EventTargetEcsTargetCapacityProviderStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProvider":
            suggest = "capacity_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetEcsTargetCapacityProviderStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetEcsTargetCapacityProviderStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetEcsTargetCapacityProviderStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider: _builtins.str,
                 base: Optional[_builtins.int] = None,
                 weight: Optional[_builtins.int] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> _builtins.str:
        return pulumi.get(self, "capacity_provider")

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class EventTargetEcsTargetNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetEcsTargetNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetEcsTargetNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetEcsTargetNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Sequence[_builtins.str],
                 assign_public_ip: Optional[_builtins.bool] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_groups")


@pulumi.output_type
class EventTargetEcsTargetOrderedPlacementStrategy(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 field: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field")


@pulumi.output_type
class EventTargetEcsTargetPlacementConstraint(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 expression: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventTargetHttpTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerParameters":
            suggest = "header_parameters"
        elif key == "pathParameterValues":
            suggest = "path_parameter_values"
        elif key == "queryStringParameters":
            suggest = "query_string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetHttpTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetHttpTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetHttpTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 path_parameter_values: Optional[Sequence[_builtins.str]] = None,
                 query_string_parameters: Optional[Mapping[str, _builtins.str]] = None):
        if header_parameters is not None:
            pulumi.set(__self__, "header_parameters", header_parameters)
        if path_parameter_values is not None:
            pulumi.set(__self__, "path_parameter_values", path_parameter_values)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @_builtins.property
    @pulumi.getter(name="headerParameters")
    def header_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "header_parameters")

    @_builtins.property
    @pulumi.getter(name="pathParameterValues")
    def path_parameter_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "path_parameter_values")

    @_builtins.property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "query_string_parameters")


@pulumi.output_type
class EventTargetInputTransformer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputTemplate":
            suggest = "input_template"
        elif key == "inputPaths":
            suggest = "input_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetInputTransformer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetInputTransformer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetInputTransformer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_template: _builtins.str,
                 input_paths: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "input_template", input_template)
        if input_paths is not None:
            pulumi.set(__self__, "input_paths", input_paths)

    @_builtins.property
    @pulumi.getter(name="inputTemplate")
    def input_template(self) -> _builtins.str:
        return pulumi.get(self, "input_template")

    @_builtins.property
    @pulumi.getter(name="inputPaths")
    def input_paths(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "input_paths")


@pulumi.output_type
class EventTargetKinesisTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionKeyPath":
            suggest = "partition_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetKinesisTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetKinesisTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetKinesisTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_key_path: Optional[_builtins.str] = None):
        if partition_key_path is not None:
            pulumi.set(__self__, "partition_key_path", partition_key_path)

    @_builtins.property
    @pulumi.getter(name="partitionKeyPath")
    def partition_key_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition_key_path")


@pulumi.output_type
class EventTargetRedshiftTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbUser":
            suggest = "db_user"
        elif key == "secretsManagerArn":
            suggest = "secrets_manager_arn"
        elif key == "statementName":
            suggest = "statement_name"
        elif key == "withEvent":
            suggest = "with_event"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetRedshiftTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetRedshiftTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetRedshiftTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 db_user: Optional[_builtins.str] = None,
                 secrets_manager_arn: Optional[_builtins.str] = None,
                 sql: Optional[_builtins.str] = None,
                 statement_name: Optional[_builtins.str] = None,
                 with_event: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "database", database)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if secrets_manager_arn is not None:
            pulumi.set(__self__, "secrets_manager_arn", secrets_manager_arn)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if statement_name is not None:
            pulumi.set(__self__, "statement_name", statement_name)
        if with_event is not None:
            pulumi.set(__self__, "with_event", with_event)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "db_user")

    @_builtins.property
    @pulumi.getter(name="secretsManagerArn")
    def secrets_manager_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secrets_manager_arn")

    @_builtins.property
    @pulumi.getter
    def sql(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sql")

    @_builtins.property
    @pulumi.getter(name="statementName")
    def statement_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "statement_name")

    @_builtins.property
    @pulumi.getter(name="withEvent")
    def with_event(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "with_event")


@pulumi.output_type
class EventTargetRetryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumEventAgeInSeconds":
            suggest = "maximum_event_age_in_seconds"
        elif key == "maximumRetryAttempts":
            suggest = "maximum_retry_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetRetryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetRetryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetRetryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_event_age_in_seconds: Optional[_builtins.int] = None,
                 maximum_retry_attempts: Optional[_builtins.int] = None):
        if maximum_event_age_in_seconds is not None:
            pulumi.set(__self__, "maximum_event_age_in_seconds", maximum_event_age_in_seconds)
        if maximum_retry_attempts is not None:
            pulumi.set(__self__, "maximum_retry_attempts", maximum_retry_attempts)

    @_builtins.property
    @pulumi.getter(name="maximumEventAgeInSeconds")
    def maximum_event_age_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_event_age_in_seconds")

    @_builtins.property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_retry_attempts")


@pulumi.output_type
class EventTargetRunCommandTarget(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class EventTargetSagemakerPipelineTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineParameterLists":
            suggest = "pipeline_parameter_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetSagemakerPipelineTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetSagemakerPipelineTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetSagemakerPipelineTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_parameter_lists: Optional[Sequence['outputs.EventTargetSagemakerPipelineTargetPipelineParameterList']] = None):
        if pipeline_parameter_lists is not None:
            pulumi.set(__self__, "pipeline_parameter_lists", pipeline_parameter_lists)

    @_builtins.property
    @pulumi.getter(name="pipelineParameterLists")
    def pipeline_parameter_lists(self) -> Optional[Sequence['outputs.EventTargetSagemakerPipelineTargetPipelineParameterList']]:
        return pulumi.get(self, "pipeline_parameter_lists")


@pulumi.output_type
class EventTargetSagemakerPipelineTargetPipelineParameterList(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class EventTargetSqsTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageGroupId":
            suggest = "message_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTargetSqsTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTargetSqsTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTargetSqsTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_group_id: Optional[_builtins.str] = None):
        if message_group_id is not None:
            pulumi.set(__self__, "message_group_id", message_group_id)

    @_builtins.property
    @pulumi.getter(name="messageGroupId")
    def message_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message_group_id")


@pulumi.output_type
class InternetMonitorHealthEventsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityScoreThreshold":
            suggest = "availability_score_threshold"
        elif key == "performanceScoreThreshold":
            suggest = "performance_score_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetMonitorHealthEventsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetMonitorHealthEventsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetMonitorHealthEventsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_score_threshold: Optional[_builtins.float] = None,
                 performance_score_threshold: Optional[_builtins.float] = None):
        if availability_score_threshold is not None:
            pulumi.set(__self__, "availability_score_threshold", availability_score_threshold)
        if performance_score_threshold is not None:
            pulumi.set(__self__, "performance_score_threshold", performance_score_threshold)

    @_builtins.property
    @pulumi.getter(name="availabilityScoreThreshold")
    def availability_score_threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "availability_score_threshold")

    @_builtins.property
    @pulumi.getter(name="performanceScoreThreshold")
    def performance_score_threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "performance_score_threshold")


@pulumi.output_type
class InternetMonitorInternetMeasurementsLogDelivery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Config":
            suggest = "s3_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetMonitorInternetMeasurementsLogDelivery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetMonitorInternetMeasurementsLogDelivery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetMonitorInternetMeasurementsLogDelivery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_config: Optional['outputs.InternetMonitorInternetMeasurementsLogDeliveryS3Config'] = None):
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)

    @_builtins.property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional['outputs.InternetMonitorInternetMeasurementsLogDeliveryS3Config']:
        return pulumi.get(self, "s3_config")


@pulumi.output_type
class InternetMonitorInternetMeasurementsLogDeliveryS3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "logDeliveryStatus":
            suggest = "log_delivery_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetMonitorInternetMeasurementsLogDeliveryS3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetMonitorInternetMeasurementsLogDeliveryS3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetMonitorInternetMeasurementsLogDeliveryS3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 bucket_prefix: Optional[_builtins.str] = None,
                 log_delivery_status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if log_delivery_status is not None:
            pulumi.set(__self__, "log_delivery_status", log_delivery_status)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_prefix")

    @_builtins.property
    @pulumi.getter(name="logDeliveryStatus")
    def log_delivery_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_delivery_status")


@pulumi.output_type
class LogDeliveryDestinationDeliveryDestinationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationResourceArn":
            suggest = "destination_resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryDestinationDeliveryDestinationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryDestinationDeliveryDestinationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryDestinationDeliveryDestinationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_resource_arn: Optional[_builtins.str] = None):
        if destination_resource_arn is not None:
            pulumi.set(__self__, "destination_resource_arn", destination_resource_arn)

    @_builtins.property
    @pulumi.getter(name="destinationResourceArn")
    def destination_resource_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_resource_arn")


@pulumi.output_type
class LogDeliveryS3DeliveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableHiveCompatiblePath":
            suggest = "enable_hive_compatible_path"
        elif key == "suffixPath":
            suggest = "suffix_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogDeliveryS3DeliveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogDeliveryS3DeliveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogDeliveryS3DeliveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_hive_compatible_path: _builtins.bool,
                 suffix_path: _builtins.str):
        pulumi.set(__self__, "enable_hive_compatible_path", enable_hive_compatible_path)
        pulumi.set(__self__, "suffix_path", suffix_path)

    @_builtins.property
    @pulumi.getter(name="enableHiveCompatiblePath")
    def enable_hive_compatible_path(self) -> _builtins.bool:
        return pulumi.get(self, "enable_hive_compatible_path")

    @_builtins.property
    @pulumi.getter(name="suffixPath")
    def suffix_path(self) -> _builtins.str:
        return pulumi.get(self, "suffix_path")


@pulumi.output_type
class LogMetricFilterMetricTransformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogMetricFilterMetricTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogMetricFilterMetricTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogMetricFilterMetricTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 value: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class LogTransformerTransformerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addKeys":
            suggest = "add_keys"
        elif key == "copyValue":
            suggest = "copy_value"
        elif key == "dateTimeConverters":
            suggest = "date_time_converters"
        elif key == "deleteKeys":
            suggest = "delete_keys"
        elif key == "listToMaps":
            suggest = "list_to_maps"
        elif key == "lowerCaseStrings":
            suggest = "lower_case_strings"
        elif key == "moveKeys":
            suggest = "move_keys"
        elif key == "parseCloudfront":
            suggest = "parse_cloudfront"
        elif key == "parseJsons":
            suggest = "parse_jsons"
        elif key == "parseKeyValues":
            suggest = "parse_key_values"
        elif key == "parsePostgres":
            suggest = "parse_postgres"
        elif key == "parseRoute53":
            suggest = "parse_route53"
        elif key == "parseToOcsf":
            suggest = "parse_to_ocsf"
        elif key == "parseVpc":
            suggest = "parse_vpc"
        elif key == "parseWaf":
            suggest = "parse_waf"
        elif key == "renameKeys":
            suggest = "rename_keys"
        elif key == "splitStrings":
            suggest = "split_strings"
        elif key == "substituteStrings":
            suggest = "substitute_strings"
        elif key == "trimStrings":
            suggest = "trim_strings"
        elif key == "typeConverters":
            suggest = "type_converters"
        elif key == "upperCaseStrings":
            suggest = "upper_case_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_keys: Optional['outputs.LogTransformerTransformerConfigAddKeys'] = None,
                 copy_value: Optional['outputs.LogTransformerTransformerConfigCopyValue'] = None,
                 csvs: Optional[Sequence['outputs.LogTransformerTransformerConfigCsv']] = None,
                 date_time_converters: Optional[Sequence['outputs.LogTransformerTransformerConfigDateTimeConverter']] = None,
                 delete_keys: Optional[Sequence['outputs.LogTransformerTransformerConfigDeleteKey']] = None,
                 grok: Optional['outputs.LogTransformerTransformerConfigGrok'] = None,
                 list_to_maps: Optional[Sequence['outputs.LogTransformerTransformerConfigListToMap']] = None,
                 lower_case_strings: Optional[Sequence['outputs.LogTransformerTransformerConfigLowerCaseString']] = None,
                 move_keys: Optional[Sequence['outputs.LogTransformerTransformerConfigMoveKey']] = None,
                 parse_cloudfront: Optional['outputs.LogTransformerTransformerConfigParseCloudfront'] = None,
                 parse_jsons: Optional[Sequence['outputs.LogTransformerTransformerConfigParseJson']] = None,
                 parse_key_values: Optional[Sequence['outputs.LogTransformerTransformerConfigParseKeyValue']] = None,
                 parse_postgres: Optional['outputs.LogTransformerTransformerConfigParsePostgres'] = None,
                 parse_route53: Optional['outputs.LogTransformerTransformerConfigParseRoute53'] = None,
                 parse_to_ocsf: Optional['outputs.LogTransformerTransformerConfigParseToOcsf'] = None,
                 parse_vpc: Optional['outputs.LogTransformerTransformerConfigParseVpc'] = None,
                 parse_waf: Optional['outputs.LogTransformerTransformerConfigParseWaf'] = None,
                 rename_keys: Optional[Sequence['outputs.LogTransformerTransformerConfigRenameKey']] = None,
                 split_strings: Optional[Sequence['outputs.LogTransformerTransformerConfigSplitString']] = None,
                 substitute_strings: Optional[Sequence['outputs.LogTransformerTransformerConfigSubstituteString']] = None,
                 trim_strings: Optional[Sequence['outputs.LogTransformerTransformerConfigTrimString']] = None,
                 type_converters: Optional[Sequence['outputs.LogTransformerTransformerConfigTypeConverter']] = None,
                 upper_case_strings: Optional[Sequence['outputs.LogTransformerTransformerConfigUpperCaseString']] = None):
        if add_keys is not None:
            pulumi.set(__self__, "add_keys", add_keys)
        if copy_value is not None:
            pulumi.set(__self__, "copy_value", copy_value)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if date_time_converters is not None:
            pulumi.set(__self__, "date_time_converters", date_time_converters)
        if delete_keys is not None:
            pulumi.set(__self__, "delete_keys", delete_keys)
        if grok is not None:
            pulumi.set(__self__, "grok", grok)
        if list_to_maps is not None:
            pulumi.set(__self__, "list_to_maps", list_to_maps)
        if lower_case_strings is not None:
            pulumi.set(__self__, "lower_case_strings", lower_case_strings)
        if move_keys is not None:
            pulumi.set(__self__, "move_keys", move_keys)
        if parse_cloudfront is not None:
            pulumi.set(__self__, "parse_cloudfront", parse_cloudfront)
        if parse_jsons is not None:
            pulumi.set(__self__, "parse_jsons", parse_jsons)
        if parse_key_values is not None:
            pulumi.set(__self__, "parse_key_values", parse_key_values)
        if parse_postgres is not None:
            pulumi.set(__self__, "parse_postgres", parse_postgres)
        if parse_route53 is not None:
            pulumi.set(__self__, "parse_route53", parse_route53)
        if parse_to_ocsf is not None:
            pulumi.set(__self__, "parse_to_ocsf", parse_to_ocsf)
        if parse_vpc is not None:
            pulumi.set(__self__, "parse_vpc", parse_vpc)
        if parse_waf is not None:
            pulumi.set(__self__, "parse_waf", parse_waf)
        if rename_keys is not None:
            pulumi.set(__self__, "rename_keys", rename_keys)
        if split_strings is not None:
            pulumi.set(__self__, "split_strings", split_strings)
        if substitute_strings is not None:
            pulumi.set(__self__, "substitute_strings", substitute_strings)
        if trim_strings is not None:
            pulumi.set(__self__, "trim_strings", trim_strings)
        if type_converters is not None:
            pulumi.set(__self__, "type_converters", type_converters)
        if upper_case_strings is not None:
            pulumi.set(__self__, "upper_case_strings", upper_case_strings)

    @_builtins.property
    @pulumi.getter(name="addKeys")
    def add_keys(self) -> Optional['outputs.LogTransformerTransformerConfigAddKeys']:
        return pulumi.get(self, "add_keys")

    @_builtins.property
    @pulumi.getter(name="copyValue")
    def copy_value(self) -> Optional['outputs.LogTransformerTransformerConfigCopyValue']:
        return pulumi.get(self, "copy_value")

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigCsv']]:
        return pulumi.get(self, "csvs")

    @_builtins.property
    @pulumi.getter(name="dateTimeConverters")
    def date_time_converters(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigDateTimeConverter']]:
        return pulumi.get(self, "date_time_converters")

    @_builtins.property
    @pulumi.getter(name="deleteKeys")
    def delete_keys(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigDeleteKey']]:
        return pulumi.get(self, "delete_keys")

    @_builtins.property
    @pulumi.getter
    def grok(self) -> Optional['outputs.LogTransformerTransformerConfigGrok']:
        return pulumi.get(self, "grok")

    @_builtins.property
    @pulumi.getter(name="listToMaps")
    def list_to_maps(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigListToMap']]:
        return pulumi.get(self, "list_to_maps")

    @_builtins.property
    @pulumi.getter(name="lowerCaseStrings")
    def lower_case_strings(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigLowerCaseString']]:
        return pulumi.get(self, "lower_case_strings")

    @_builtins.property
    @pulumi.getter(name="moveKeys")
    def move_keys(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigMoveKey']]:
        return pulumi.get(self, "move_keys")

    @_builtins.property
    @pulumi.getter(name="parseCloudfront")
    def parse_cloudfront(self) -> Optional['outputs.LogTransformerTransformerConfigParseCloudfront']:
        return pulumi.get(self, "parse_cloudfront")

    @_builtins.property
    @pulumi.getter(name="parseJsons")
    def parse_jsons(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigParseJson']]:
        return pulumi.get(self, "parse_jsons")

    @_builtins.property
    @pulumi.getter(name="parseKeyValues")
    def parse_key_values(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigParseKeyValue']]:
        return pulumi.get(self, "parse_key_values")

    @_builtins.property
    @pulumi.getter(name="parsePostgres")
    def parse_postgres(self) -> Optional['outputs.LogTransformerTransformerConfigParsePostgres']:
        return pulumi.get(self, "parse_postgres")

    @_builtins.property
    @pulumi.getter(name="parseRoute53")
    def parse_route53(self) -> Optional['outputs.LogTransformerTransformerConfigParseRoute53']:
        return pulumi.get(self, "parse_route53")

    @_builtins.property
    @pulumi.getter(name="parseToOcsf")
    def parse_to_ocsf(self) -> Optional['outputs.LogTransformerTransformerConfigParseToOcsf']:
        return pulumi.get(self, "parse_to_ocsf")

    @_builtins.property
    @pulumi.getter(name="parseVpc")
    def parse_vpc(self) -> Optional['outputs.LogTransformerTransformerConfigParseVpc']:
        return pulumi.get(self, "parse_vpc")

    @_builtins.property
    @pulumi.getter(name="parseWaf")
    def parse_waf(self) -> Optional['outputs.LogTransformerTransformerConfigParseWaf']:
        return pulumi.get(self, "parse_waf")

    @_builtins.property
    @pulumi.getter(name="renameKeys")
    def rename_keys(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigRenameKey']]:
        return pulumi.get(self, "rename_keys")

    @_builtins.property
    @pulumi.getter(name="splitStrings")
    def split_strings(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigSplitString']]:
        return pulumi.get(self, "split_strings")

    @_builtins.property
    @pulumi.getter(name="substituteStrings")
    def substitute_strings(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigSubstituteString']]:
        return pulumi.get(self, "substitute_strings")

    @_builtins.property
    @pulumi.getter(name="trimStrings")
    def trim_strings(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigTrimString']]:
        return pulumi.get(self, "trim_strings")

    @_builtins.property
    @pulumi.getter(name="typeConverters")
    def type_converters(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigTypeConverter']]:
        return pulumi.get(self, "type_converters")

    @_builtins.property
    @pulumi.getter(name="upperCaseStrings")
    def upper_case_strings(self) -> Optional[Sequence['outputs.LogTransformerTransformerConfigUpperCaseString']]:
        return pulumi.get(self, "upper_case_strings")


@pulumi.output_type
class LogTransformerTransformerConfigAddKeys(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigAddKeysEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigAddKeysEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigAddKeysEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overwriteIfExists":
            suggest = "overwrite_if_exists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigAddKeysEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigAddKeysEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigAddKeysEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 overwrite_if_exists: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_if_exists")


@pulumi.output_type
class LogTransformerTransformerConfigCopyValue(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigCopyValueEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigCopyValueEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigCopyValueEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overwriteIfExists":
            suggest = "overwrite_if_exists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigCopyValueEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigCopyValueEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigCopyValueEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 target: _builtins.str,
                 overwrite_if_exists: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_if_exists")


@pulumi.output_type
class LogTransformerTransformerConfigCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quoteCharacter":
            suggest = "quote_character"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[_builtins.str]] = None,
                 delimiter: Optional[_builtins.str] = None,
                 quote_character: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if quote_character is not None:
            pulumi.set(__self__, "quote_character", quote_character)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="quoteCharacter")
    def quote_character(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "quote_character")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigDateTimeConverter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "sourceTimezone":
            suggest = "source_timezone"
        elif key == "targetFormat":
            suggest = "target_format"
        elif key == "targetTimezone":
            suggest = "target_timezone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigDateTimeConverter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigDateTimeConverter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigDateTimeConverter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence[_builtins.str],
                 source: _builtins.str,
                 target: _builtins.str,
                 locale: Optional[_builtins.str] = None,
                 source_timezone: Optional[_builtins.str] = None,
                 target_format: Optional[_builtins.str] = None,
                 target_timezone: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if source_timezone is not None:
            pulumi.set(__self__, "source_timezone", source_timezone)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)
        if target_timezone is not None:
            pulumi.set(__self__, "target_timezone", target_timezone)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter(name="sourceTimezone")
    def source_timezone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_timezone")

    @_builtins.property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_format")

    @_builtins.property
    @pulumi.getter(name="targetTimezone")
    def target_timezone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target_timezone")


@pulumi.output_type
class LogTransformerTransformerConfigDeleteKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withKeys":
            suggest = "with_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigDeleteKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigDeleteKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigDeleteKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 with_keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "with_keys")


@pulumi.output_type
class LogTransformerTransformerConfigGrok(dict):
    def __init__(__self__, *,
                 match: _builtins.str,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match", match)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigListToMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flattenedElement":
            suggest = "flattened_element"
        elif key == "valueKey":
            suggest = "value_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigListToMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigListToMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigListToMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 source: _builtins.str,
                 flatten: Optional[_builtins.bool] = None,
                 flattened_element: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 value_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if flatten is not None:
            pulumi.set(__self__, "flatten", flatten)
        if flattened_element is not None:
            pulumi.set(__self__, "flattened_element", flattened_element)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value_key is not None:
            pulumi.set(__self__, "value_key", value_key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def flatten(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "flatten")

    @_builtins.property
    @pulumi.getter(name="flattenedElement")
    def flattened_element(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "flattened_element")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value_key")


@pulumi.output_type
class LogTransformerTransformerConfigLowerCaseString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withKeys":
            suggest = "with_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigLowerCaseString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigLowerCaseString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigLowerCaseString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 with_keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "with_keys")


@pulumi.output_type
class LogTransformerTransformerConfigMoveKey(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigMoveKeyEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigMoveKeyEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigMoveKeyEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overwriteIfExists":
            suggest = "overwrite_if_exists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigMoveKeyEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigMoveKeyEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigMoveKeyEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 target: _builtins.str,
                 overwrite_if_exists: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_if_exists")


@pulumi.output_type
class LogTransformerTransformerConfigParseCloudfront(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseJson(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseKeyValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "keyPrefix":
            suggest = "key_prefix"
        elif key == "keyValueDelimiter":
            suggest = "key_value_delimiter"
        elif key == "nonMatchValue":
            suggest = "non_match_value"
        elif key == "overwriteIfExists":
            suggest = "overwrite_if_exists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigParseKeyValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigParseKeyValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigParseKeyValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 field_delimiter: Optional[_builtins.str] = None,
                 key_prefix: Optional[_builtins.str] = None,
                 key_value_delimiter: Optional[_builtins.str] = None,
                 non_match_value: Optional[_builtins.str] = None,
                 overwrite_if_exists: Optional[_builtins.bool] = None,
                 source: Optional[_builtins.str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if key_value_delimiter is not None:
            pulumi.set(__self__, "key_value_delimiter", key_value_delimiter)
        if non_match_value is not None:
            pulumi.set(__self__, "non_match_value", non_match_value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_delimiter")

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_prefix")

    @_builtins.property
    @pulumi.getter(name="keyValueDelimiter")
    def key_value_delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_value_delimiter")

    @_builtins.property
    @pulumi.getter(name="nonMatchValue")
    def non_match_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "non_match_value")

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_if_exists")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParsePostgres(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseRoute53(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseToOcsf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSource":
            suggest = "event_source"
        elif key == "ocsfVersion":
            suggest = "ocsf_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigParseToOcsf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigParseToOcsf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigParseToOcsf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_source: _builtins.str,
                 ocsf_version: _builtins.str,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "ocsf_version", ocsf_version)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> _builtins.str:
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="ocsfVersion")
    def ocsf_version(self) -> _builtins.str:
        return pulumi.get(self, "ocsf_version")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseVpc(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigParseWaf(dict):
    def __init__(__self__, *,
                 source: Optional[_builtins.str] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigRenameKey(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigRenameKeyEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigRenameKeyEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigRenameKeyEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renameTo":
            suggest = "rename_to"
        elif key == "overwriteIfExists":
            suggest = "overwrite_if_exists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigRenameKeyEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigRenameKeyEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigRenameKeyEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 rename_to: _builtins.str,
                 overwrite_if_exists: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "rename_to", rename_to)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="renameTo")
    def rename_to(self) -> _builtins.str:
        return pulumi.get(self, "rename_to")

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_if_exists")


@pulumi.output_type
class LogTransformerTransformerConfigSplitString(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigSplitStringEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigSplitStringEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigSplitStringEntry(dict):
    def __init__(__self__, *,
                 delimiter: _builtins.str,
                 source: _builtins.str):
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> _builtins.str:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")


@pulumi.output_type
class LogTransformerTransformerConfigSubstituteString(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigSubstituteStringEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigSubstituteStringEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigSubstituteStringEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigSubstituteStringEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigSubstituteStringEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigSubstituteStringEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: _builtins.str,
                 source: _builtins.str,
                 to: _builtins.str):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> _builtins.str:
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def to(self) -> _builtins.str:
        return pulumi.get(self, "to")


@pulumi.output_type
class LogTransformerTransformerConfigTrimString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withKeys":
            suggest = "with_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigTrimString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigTrimString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigTrimString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 with_keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "with_keys")


@pulumi.output_type
class LogTransformerTransformerConfigTypeConverter(dict):
    def __init__(__self__, *,
                 entries: Sequence['outputs.LogTransformerTransformerConfigTypeConverterEntry']):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> Sequence['outputs.LogTransformerTransformerConfigTypeConverterEntry']:
        return pulumi.get(self, "entries")


@pulumi.output_type
class LogTransformerTransformerConfigTypeConverterEntry(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class LogTransformerTransformerConfigUpperCaseString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "withKeys":
            suggest = "with_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogTransformerTransformerConfigUpperCaseString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogTransformerTransformerConfigUpperCaseString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogTransformerTransformerConfigUpperCaseString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 with_keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "with_keys")


@pulumi.output_type
class MetricAlarmMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlarmMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlarmMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlarmMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 account_id: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 metric: Optional['outputs.MetricAlarmMetricQueryMetric'] = None,
                 period: Optional[_builtins.int] = None,
                 return_data: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional['outputs.MetricAlarmMetricQueryMetric']:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class MetricAlarmMetricQueryMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricAlarmMetricQueryMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricAlarmMetricQueryMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricAlarmMetricQueryMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 period: _builtins.int,
                 stat: _builtins.str,
                 dimensions: Optional[Mapping[str, _builtins.str]] = None,
                 namespace: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "stat", stat)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def stat(self) -> _builtins.str:
        return pulumi.get(self, "stat")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class MetricStreamExcludeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricNames":
            suggest = "metric_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricStreamExcludeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricStreamExcludeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricStreamExcludeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace: _builtins.str,
                 metric_names: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "metric_names")


@pulumi.output_type
class MetricStreamIncludeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricNames":
            suggest = "metric_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricStreamIncludeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricStreamIncludeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricStreamIncludeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace: _builtins.str,
                 metric_names: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "metric_names")


@pulumi.output_type
class MetricStreamStatisticsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStatistics":
            suggest = "additional_statistics"
        elif key == "includeMetrics":
            suggest = "include_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricStreamStatisticsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricStreamStatisticsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricStreamStatisticsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_statistics: Sequence[_builtins.str],
                 include_metrics: Sequence['outputs.MetricStreamStatisticsConfigurationIncludeMetric']):
        pulumi.set(__self__, "additional_statistics", additional_statistics)
        pulumi.set(__self__, "include_metrics", include_metrics)

    @_builtins.property
    @pulumi.getter(name="additionalStatistics")
    def additional_statistics(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "additional_statistics")

    @_builtins.property
    @pulumi.getter(name="includeMetrics")
    def include_metrics(self) -> Sequence['outputs.MetricStreamStatisticsConfigurationIncludeMetric']:
        return pulumi.get(self, "include_metrics")


@pulumi.output_type
class MetricStreamStatisticsConfigurationIncludeMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricStreamStatisticsConfigurationIncludeMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricStreamStatisticsConfigurationIncludeMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricStreamStatisticsConfigurationIncludeMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GetContributorManagedInsightRulesManagedRuleResult(dict):
    def __init__(__self__, *,
                 resource_arn: _builtins.str,
                 rule_states: Sequence['outputs.GetContributorManagedInsightRulesManagedRuleRuleStateResult'],
                 template_name: _builtins.str):
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "rule_states", rule_states)
        pulumi.set(__self__, "template_name", template_name)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> _builtins.str:
        return pulumi.get(self, "resource_arn")

    @_builtins.property
    @pulumi.getter(name="ruleStates")
    def rule_states(self) -> Sequence['outputs.GetContributorManagedInsightRulesManagedRuleRuleStateResult']:
        return pulumi.get(self, "rule_states")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        return pulumi.get(self, "template_name")


@pulumi.output_type
class GetContributorManagedInsightRulesManagedRuleRuleStateResult(dict):
    def __init__(__self__, *,
                 rule_name: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "rule_name", rule_name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> _builtins.str:
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetEventBusDeadLetterConfigResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str):
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")


@pulumi.output_type
class GetEventBusLogConfigResult(dict):
    def __init__(__self__, *,
                 include_detail: _builtins.str,
                 level: _builtins.str):
        pulumi.set(__self__, "include_detail", include_detail)
        pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="includeDetail")
    def include_detail(self) -> _builtins.str:
        return pulumi.get(self, "include_detail")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        return pulumi.get(self, "level")


@pulumi.output_type
class GetEventBusesEventBusResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 creation_time: _builtins.str,
                 description: _builtins.str,
                 last_modified_time: _builtins.str,
                 name: _builtins.str,
                 policy: _builtins.str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> _builtins.str:
        return pulumi.get(self, "last_modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentConfigurationResult(dict):
    def __init__(__self__, *,
                 custom_data_identifiers: Optional[Sequence['outputs.GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierResult']] = None):
        if custom_data_identifiers is not None:
            pulumi.set(__self__, "custom_data_identifiers", custom_data_identifiers)

    @_builtins.property
    @pulumi.getter(name="customDataIdentifiers")
    def custom_data_identifiers(self) -> Optional[Sequence['outputs.GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierResult']]:
        return pulumi.get(self, "custom_data_identifiers")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 regex: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementResult(dict):
    def __init__(__self__, *,
                 data_identifiers: Sequence[_builtins.str],
                 operation: 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationResult',
                 sid: Optional[_builtins.str] = None):
        pulumi.set(__self__, "data_identifiers", data_identifiers)
        pulumi.set(__self__, "operation", operation)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)

    @_builtins.property
    @pulumi.getter(name="dataIdentifiers")
    def data_identifiers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "data_identifiers")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationResult':
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sid")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationResult(dict):
    def __init__(__self__, *,
                 audit: Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditResult'] = None,
                 deidentify: Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyResult'] = None):
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if deidentify is not None:
            pulumi.set(__self__, "deidentify", deidentify)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditResult']:
        return pulumi.get(self, "audit")

    @_builtins.property
    @pulumi.getter
    def deidentify(self) -> Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyResult']:
        return pulumi.get(self, "deidentify")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditResult(dict):
    def __init__(__self__, *,
                 findings_destination: 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationResult'):
        pulumi.set(__self__, "findings_destination", findings_destination)

    @_builtins.property
    @pulumi.getter(name="findingsDestination")
    def findings_destination(self) -> 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationResult':
        return pulumi.get(self, "findings_destination")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationResult(dict):
    def __init__(__self__, *,
                 cloudwatch_logs: Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsResult'] = None,
                 firehose: Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseResult'] = None,
                 s3: Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Result'] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsResult']:
        return pulumi.get(self, "cloudwatch_logs")

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseResult']:
        return pulumi.get(self, "firehose")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsResult(dict):
    def __init__(__self__, *,
                 log_group: _builtins.str):
        pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> _builtins.str:
        return pulumi.get(self, "log_group")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseResult(dict):
    def __init__(__self__, *,
                 delivery_stream: _builtins.str):
        pulumi.set(__self__, "delivery_stream", delivery_stream)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> _builtins.str:
        return pulumi.get(self, "delivery_stream")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Result(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str):
        pulumi.set(__self__, "bucket", bucket)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyResult(dict):
    def __init__(__self__, *,
                 mask_config: 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigResult'):
        pulumi.set(__self__, "mask_config", mask_config)

    @_builtins.property
    @pulumi.getter(name="maskConfig")
    def mask_config(self) -> 'outputs.GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigResult':
        return pulumi.get(self, "mask_config")


@pulumi.output_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigResult(dict):
    def __init__(__self__):
        pass


