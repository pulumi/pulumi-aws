# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from .. import iam
from .. import iam as _iam

__all__ = [
    'CompositeAlarmActionsSuppressorArgs',
    'CompositeAlarmActionsSuppressorArgsDict',
    'EventBusDeadLetterConfigArgs',
    'EventBusDeadLetterConfigArgsDict',
    'EventBusLogConfigArgs',
    'EventBusLogConfigArgsDict',
    'EventConnectionAuthParametersArgs',
    'EventConnectionAuthParametersArgsDict',
    'EventConnectionAuthParametersApiKeyArgs',
    'EventConnectionAuthParametersApiKeyArgsDict',
    'EventConnectionAuthParametersBasicArgs',
    'EventConnectionAuthParametersBasicArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersArgs',
    'EventConnectionAuthParametersInvocationHttpParametersArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersBodyArgs',
    'EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersHeaderArgs',
    'EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs',
    'EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict',
    'EventConnectionAuthParametersOauthArgs',
    'EventConnectionAuthParametersOauthArgsDict',
    'EventConnectionAuthParametersOauthClientParametersArgs',
    'EventConnectionAuthParametersOauthClientParametersArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict',
    'EventConnectionInvocationConnectivityParametersArgs',
    'EventConnectionInvocationConnectivityParametersArgsDict',
    'EventConnectionInvocationConnectivityParametersResourceParametersArgs',
    'EventConnectionInvocationConnectivityParametersResourceParametersArgsDict',
    'EventEndpointEventBusArgs',
    'EventEndpointEventBusArgsDict',
    'EventEndpointReplicationConfigArgs',
    'EventEndpointReplicationConfigArgsDict',
    'EventEndpointRoutingConfigArgs',
    'EventEndpointRoutingConfigArgsDict',
    'EventEndpointRoutingConfigFailoverConfigArgs',
    'EventEndpointRoutingConfigFailoverConfigArgsDict',
    'EventEndpointRoutingConfigFailoverConfigPrimaryArgs',
    'EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict',
    'EventEndpointRoutingConfigFailoverConfigSecondaryArgs',
    'EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict',
    'EventPermissionConditionArgs',
    'EventPermissionConditionArgsDict',
    'EventTargetAppsyncTargetArgs',
    'EventTargetAppsyncTargetArgsDict',
    'EventTargetBatchTargetArgs',
    'EventTargetBatchTargetArgsDict',
    'EventTargetDeadLetterConfigArgs',
    'EventTargetDeadLetterConfigArgsDict',
    'EventTargetEcsTargetArgs',
    'EventTargetEcsTargetArgsDict',
    'EventTargetEcsTargetCapacityProviderStrategyArgs',
    'EventTargetEcsTargetCapacityProviderStrategyArgsDict',
    'EventTargetEcsTargetNetworkConfigurationArgs',
    'EventTargetEcsTargetNetworkConfigurationArgsDict',
    'EventTargetEcsTargetOrderedPlacementStrategyArgs',
    'EventTargetEcsTargetOrderedPlacementStrategyArgsDict',
    'EventTargetEcsTargetPlacementConstraintArgs',
    'EventTargetEcsTargetPlacementConstraintArgsDict',
    'EventTargetHttpTargetArgs',
    'EventTargetHttpTargetArgsDict',
    'EventTargetInputTransformerArgs',
    'EventTargetInputTransformerArgsDict',
    'EventTargetKinesisTargetArgs',
    'EventTargetKinesisTargetArgsDict',
    'EventTargetRedshiftTargetArgs',
    'EventTargetRedshiftTargetArgsDict',
    'EventTargetRetryPolicyArgs',
    'EventTargetRetryPolicyArgsDict',
    'EventTargetRunCommandTargetArgs',
    'EventTargetRunCommandTargetArgsDict',
    'EventTargetSagemakerPipelineTargetArgs',
    'EventTargetSagemakerPipelineTargetArgsDict',
    'EventTargetSagemakerPipelineTargetPipelineParameterListArgs',
    'EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict',
    'EventTargetSqsTargetArgs',
    'EventTargetSqsTargetArgsDict',
    'InternetMonitorHealthEventsConfigArgs',
    'InternetMonitorHealthEventsConfigArgsDict',
    'InternetMonitorInternetMeasurementsLogDeliveryArgs',
    'InternetMonitorInternetMeasurementsLogDeliveryArgsDict',
    'InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs',
    'InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict',
    'LogDeliveryDestinationDeliveryDestinationConfigurationArgs',
    'LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict',
    'LogDeliveryS3DeliveryConfigurationArgs',
    'LogDeliveryS3DeliveryConfigurationArgsDict',
    'LogMetricFilterMetricTransformationArgs',
    'LogMetricFilterMetricTransformationArgsDict',
    'LogTransformerTransformerConfigArgs',
    'LogTransformerTransformerConfigArgsDict',
    'LogTransformerTransformerConfigAddKeysArgs',
    'LogTransformerTransformerConfigAddKeysArgsDict',
    'LogTransformerTransformerConfigAddKeysEntryArgs',
    'LogTransformerTransformerConfigAddKeysEntryArgsDict',
    'LogTransformerTransformerConfigCopyValueArgs',
    'LogTransformerTransformerConfigCopyValueArgsDict',
    'LogTransformerTransformerConfigCopyValueEntryArgs',
    'LogTransformerTransformerConfigCopyValueEntryArgsDict',
    'LogTransformerTransformerConfigCsvArgs',
    'LogTransformerTransformerConfigCsvArgsDict',
    'LogTransformerTransformerConfigDateTimeConverterArgs',
    'LogTransformerTransformerConfigDateTimeConverterArgsDict',
    'LogTransformerTransformerConfigDeleteKeyArgs',
    'LogTransformerTransformerConfigDeleteKeyArgsDict',
    'LogTransformerTransformerConfigGrokArgs',
    'LogTransformerTransformerConfigGrokArgsDict',
    'LogTransformerTransformerConfigListToMapArgs',
    'LogTransformerTransformerConfigListToMapArgsDict',
    'LogTransformerTransformerConfigLowerCaseStringArgs',
    'LogTransformerTransformerConfigLowerCaseStringArgsDict',
    'LogTransformerTransformerConfigMoveKeyArgs',
    'LogTransformerTransformerConfigMoveKeyArgsDict',
    'LogTransformerTransformerConfigMoveKeyEntryArgs',
    'LogTransformerTransformerConfigMoveKeyEntryArgsDict',
    'LogTransformerTransformerConfigParseCloudfrontArgs',
    'LogTransformerTransformerConfigParseCloudfrontArgsDict',
    'LogTransformerTransformerConfigParseJsonArgs',
    'LogTransformerTransformerConfigParseJsonArgsDict',
    'LogTransformerTransformerConfigParseKeyValueArgs',
    'LogTransformerTransformerConfigParseKeyValueArgsDict',
    'LogTransformerTransformerConfigParsePostgresArgs',
    'LogTransformerTransformerConfigParsePostgresArgsDict',
    'LogTransformerTransformerConfigParseRoute53Args',
    'LogTransformerTransformerConfigParseRoute53ArgsDict',
    'LogTransformerTransformerConfigParseToOcsfArgs',
    'LogTransformerTransformerConfigParseToOcsfArgsDict',
    'LogTransformerTransformerConfigParseVpcArgs',
    'LogTransformerTransformerConfigParseVpcArgsDict',
    'LogTransformerTransformerConfigParseWafArgs',
    'LogTransformerTransformerConfigParseWafArgsDict',
    'LogTransformerTransformerConfigRenameKeyArgs',
    'LogTransformerTransformerConfigRenameKeyArgsDict',
    'LogTransformerTransformerConfigRenameKeyEntryArgs',
    'LogTransformerTransformerConfigRenameKeyEntryArgsDict',
    'LogTransformerTransformerConfigSplitStringArgs',
    'LogTransformerTransformerConfigSplitStringArgsDict',
    'LogTransformerTransformerConfigSplitStringEntryArgs',
    'LogTransformerTransformerConfigSplitStringEntryArgsDict',
    'LogTransformerTransformerConfigSubstituteStringArgs',
    'LogTransformerTransformerConfigSubstituteStringArgsDict',
    'LogTransformerTransformerConfigSubstituteStringEntryArgs',
    'LogTransformerTransformerConfigSubstituteStringEntryArgsDict',
    'LogTransformerTransformerConfigTrimStringArgs',
    'LogTransformerTransformerConfigTrimStringArgsDict',
    'LogTransformerTransformerConfigTypeConverterArgs',
    'LogTransformerTransformerConfigTypeConverterArgsDict',
    'LogTransformerTransformerConfigTypeConverterEntryArgs',
    'LogTransformerTransformerConfigTypeConverterEntryArgsDict',
    'LogTransformerTransformerConfigUpperCaseStringArgs',
    'LogTransformerTransformerConfigUpperCaseStringArgsDict',
    'MetricAlarmMetricQueryArgs',
    'MetricAlarmMetricQueryArgsDict',
    'MetricAlarmMetricQueryMetricArgs',
    'MetricAlarmMetricQueryMetricArgsDict',
    'MetricStreamExcludeFilterArgs',
    'MetricStreamExcludeFilterArgsDict',
    'MetricStreamIncludeFilterArgs',
    'MetricStreamIncludeFilterArgsDict',
    'MetricStreamStatisticsConfigurationArgs',
    'MetricStreamStatisticsConfigurationArgsDict',
    'MetricStreamStatisticsConfigurationIncludeMetricArgs',
    'MetricStreamStatisticsConfigurationIncludeMetricArgsDict',
    'PolicyDocumentArgs',
    'PolicyDocumentArgsDict',
    'GetLogDataProtectionPolicyDocumentConfigurationArgs',
    'GetLogDataProtectionPolicyDocumentConfigurationArgsDict',
    'GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs',
    'GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementArgs',
    'GetLogDataProtectionPolicyDocumentStatementArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict',
]

MYPY = False

if not MYPY:
    class CompositeAlarmActionsSuppressorArgsDict(TypedDict):
        alarm: pulumi.Input[_builtins.str]
        """
        Can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.
        """
        extension_period: pulumi.Input[_builtins.int]
        """
        The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the `ALARM` state. After this time, the composite alarm performs its actions.
        """
        wait_period: pulumi.Input[_builtins.int]
        """
        The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the `ALARM` state. After this time, the composite alarm performs its actions.
        """
elif False:
    CompositeAlarmActionsSuppressorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompositeAlarmActionsSuppressorArgs:
    def __init__(__self__, *,
                 alarm: pulumi.Input[_builtins.str],
                 extension_period: pulumi.Input[_builtins.int],
                 wait_period: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] alarm: Can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.
        :param pulumi.Input[_builtins.int] extension_period: The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the `ALARM` state. After this time, the composite alarm performs its actions.
        :param pulumi.Input[_builtins.int] wait_period: The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the `ALARM` state. After this time, the composite alarm performs its actions.
        """
        pulumi.set(__self__, "alarm", alarm)
        pulumi.set(__self__, "extension_period", extension_period)
        pulumi.set(__self__, "wait_period", wait_period)

    @_builtins.property
    @pulumi.getter
    def alarm(self) -> pulumi.Input[_builtins.str]:
        """
        Can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm.
        """
        return pulumi.get(self, "alarm")

    @alarm.setter
    def alarm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm", value)

    @_builtins.property
    @pulumi.getter(name="extensionPeriod")
    def extension_period(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the `ALARM` state. After this time, the composite alarm performs its actions.
        """
        return pulumi.get(self, "extension_period")

    @extension_period.setter
    def extension_period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "extension_period", value)

    @_builtins.property
    @pulumi.getter(name="waitPeriod")
    def wait_period(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the `ALARM` state. After this time, the composite alarm performs its actions.
        """
        return pulumi.get(self, "wait_period")

    @wait_period.setter
    def wait_period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "wait_period", value)


if not MYPY:
    class EventBusDeadLetterConfigArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the SQS queue specified as the target for the dead-letter queue.
        """
elif False:
    EventBusDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventBusDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: The ARN of the SQS queue specified as the target for the dead-letter queue.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the SQS queue specified as the target for the dead-letter queue.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class EventBusLogConfigArgsDict(TypedDict):
        include_detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether EventBridge include detailed event information in the records it generates. Valid values are `NONE` and `FULL`.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Level of logging detail to include. Valid values are `OFF`, `ERROR`, `INFO`, and `TRACE`.
        """
elif False:
    EventBusLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventBusLogConfigArgs:
    def __init__(__self__, *,
                 include_detail: Optional[pulumi.Input[_builtins.str]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] include_detail: Whether EventBridge include detailed event information in the records it generates. Valid values are `NONE` and `FULL`.
        :param pulumi.Input[_builtins.str] level: Level of logging detail to include. Valid values are `OFF`, `ERROR`, `INFO`, and `TRACE`.
        """
        if include_detail is not None:
            pulumi.set(__self__, "include_detail", include_detail)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="includeDetail")
    def include_detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether EventBridge include detailed event information in the records it generates. Valid values are `NONE` and `FULL`.
        """
        return pulumi.get(self, "include_detail")

    @include_detail.setter
    def include_detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_detail", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Level of logging detail to include. Valid values are `OFF`, `ERROR`, `INFO`, and `TRACE`.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class EventConnectionAuthParametersArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['EventConnectionAuthParametersApiKeyArgsDict']]
        """
        Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with `basic` and `oauth`. Documented below.
        """
        basic: NotRequired[pulumi.Input['EventConnectionAuthParametersBasicArgsDict']]
        """
        Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with `api_key` and `oauth`. Documented below.
        """
        invocation_http_parameters: NotRequired[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgsDict']]
        """
        Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        """
        oauth: NotRequired[pulumi.Input['EventConnectionAuthParametersOauthArgsDict']]
        """
        Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with `basic` and `api_key`. Documented below.
        """
elif False:
    EventConnectionAuthParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']] = None,
                 invocation_http_parameters: Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']] = None,
                 oauth: Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']] = None):
        """
        :param pulumi.Input['EventConnectionAuthParametersApiKeyArgs'] api_key: Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with `basic` and `oauth`. Documented below.
        :param pulumi.Input['EventConnectionAuthParametersBasicArgs'] basic: Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with `api_key` and `oauth`. Documented below.
        :param pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs'] invocation_http_parameters: Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        :param pulumi.Input['EventConnectionAuthParametersOauthArgs'] oauth: Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with `basic` and `api_key`. Documented below.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if invocation_http_parameters is not None:
            pulumi.set(__self__, "invocation_http_parameters", invocation_http_parameters)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']]:
        """
        Parameters used for API_KEY authorization. An API key to include in the header for each authentication request. A maximum of 1 are allowed. Conflicts with `basic` and `oauth`. Documented below.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']]:
        """
        Parameters used for BASIC authorization. A maximum of 1 are allowed. Conflicts with `api_key` and `oauth`. Documented below.
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="invocationHttpParameters")
    def invocation_http_parameters(self) -> Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']]:
        """
        Invocation Http Parameters are additional credentials used to sign each Invocation of the ApiDestination created from this Connection. If the ApiDestination Rule Target has additional HttpParameters, the values will be merged together, with the Connection Invocation Http Parameters taking precedence. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        """
        return pulumi.get(self, "invocation_http_parameters")

    @invocation_http_parameters.setter
    def invocation_http_parameters(self, value: Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']]):
        pulumi.set(self, "invocation_http_parameters", value)

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']]:
        """
        Parameters used for OAUTH_CLIENT_CREDENTIALS authorization. A maximum of 1 are allowed. Conflicts with `basic` and `api_key`. Documented below.
        """
        return pulumi.get(self, "oauth")

    @oauth.setter
    def oauth(self, value: Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']]):
        pulumi.set(self, "oauth", value)


if not MYPY:
    class EventConnectionAuthParametersApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Header Name.
        """
        value: pulumi.Input[_builtins.str]
        """
        Header Value. Created and stored in AWS Secrets Manager.
        """
elif False:
    EventConnectionAuthParametersApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Header Name.
        :param pulumi.Input[_builtins.str] value: Header Value. Created and stored in AWS Secrets Manager.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Header Name.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Header Value. Created and stored in AWS Secrets Manager.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        A password for the authorization. Created and stored in AWS Secrets Manager.
        """
        username: pulumi.Input[_builtins.str]
        """
        A username for the authorization.
        """
elif False:
    EventConnectionAuthParametersBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: A password for the authorization. Created and stored in AWS Secrets Manager.
        :param pulumi.Input[_builtins.str] username: A username for the authorization.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        A password for the authorization. Created and stored in AWS Secrets Manager.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        A username for the authorization.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersArgsDict(TypedDict):
        bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict']]]]
        """
        Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict']]]]
        """
        Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        query_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict']]]]
        """
        Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
elif False:
    EventConnectionAuthParametersInvocationHttpParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersArgs:
    def __init__(__self__, *,
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]] = None,
                 query_strings: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]] bodies: Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]] headers: Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]] query_strings: Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]]:
        """
        Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]]:
        """
        Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]]:
        """
        Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersBodyArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersHeaderArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        """
        The URL to the authorization endpoint.
        """
        http_method: pulumi.Input[_builtins.str]
        """
        A password for the authorization. Created and stored in AWS Secrets Manager.
        """
        oauth_http_parameters: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgsDict']
        """
        OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        """
        client_parameters: NotRequired[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgsDict']]
        """
        Contains the client parameters for OAuth authorization. Contains the following two parameters.
        """
elif False:
    EventConnectionAuthParametersOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 http_method: pulumi.Input[_builtins.str],
                 oauth_http_parameters: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs'],
                 client_parameters: Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL to the authorization endpoint.
        :param pulumi.Input[_builtins.str] http_method: A password for the authorization. Created and stored in AWS Secrets Manager.
        :param pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs'] oauth_http_parameters: OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        :param pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs'] client_parameters: Contains the client parameters for OAuth authorization. Contains the following two parameters.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "oauth_http_parameters", oauth_http_parameters)
        if client_parameters is not None:
            pulumi.set(__self__, "client_parameters", client_parameters)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to the authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> pulumi.Input[_builtins.str]:
        """
        A password for the authorization. Created and stored in AWS Secrets Manager.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="oauthHttpParameters")
    def oauth_http_parameters(self) -> pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs']:
        """
        OAuth Http Parameters are additional credentials used to sign the request to the authorization endpoint to exchange the OAuth Client information for an access token. Secret values are stored and managed by AWS Secrets Manager. A maximum of 1 are allowed. Documented below.
        """
        return pulumi.get(self, "oauth_http_parameters")

    @oauth_http_parameters.setter
    def oauth_http_parameters(self, value: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs']):
        pulumi.set(self, "oauth_http_parameters", value)

    @_builtins.property
    @pulumi.getter(name="clientParameters")
    def client_parameters(self) -> Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']]:
        """
        Contains the client parameters for OAuth authorization. Contains the following two parameters.
        """
        return pulumi.get(self, "client_parameters")

    @client_parameters.setter
    def client_parameters(self, value: Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']]):
        pulumi.set(self, "client_parameters", value)


if not MYPY:
    class EventConnectionAuthParametersOauthClientParametersArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        """
elif False:
    EventConnectionAuthParametersOauthClientParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthClientParametersArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The client secret for the credentials to use for authorization. Created and stored in AWS Secrets Manager.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersArgsDict(TypedDict):
        bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict']]]]
        """
        Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict']]]]
        """
        Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        query_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict']]]]
        """
        Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersArgs:
    def __init__(__self__, *,
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]] = None,
                 query_strings: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]] bodies: Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]] headers: Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        :param pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]] query_strings: Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]]:
        """
        Contains additional body string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]]:
        """
        Contains additional header parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]]:
        """
        Contains additional query string parameters for the connection. You can include up to 100 additional body string parameters per request. Each additional parameter counts towards the event payload size, which cannot exceed 64 KB. Each parameter can contain the following:
        """
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specified whether the value is secret.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_value_secret: Specified whether the value is secret.
        :param pulumi.Input[_builtins.str] key: The key for the parameter.
        :param pulumi.Input[_builtins.str] value: The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specified whether the value is secret.
        """
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for the parameter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value associated with the key. Created and stored in AWS Secrets Manager if is secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionInvocationConnectivityParametersArgsDict(TypedDict):
        resource_parameters: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgsDict']
        """
        The parameters for EventBridge to use when invoking the resource endpoint. Documented below.
        """
elif False:
    EventConnectionInvocationConnectivityParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionInvocationConnectivityParametersArgs:
    def __init__(__self__, *,
                 resource_parameters: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']):
        """
        :param pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs'] resource_parameters: The parameters for EventBridge to use when invoking the resource endpoint. Documented below.
        """
        pulumi.set(__self__, "resource_parameters", resource_parameters)

    @_builtins.property
    @pulumi.getter(name="resourceParameters")
    def resource_parameters(self) -> pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']:
        """
        The parameters for EventBridge to use when invoking the resource endpoint. Documented below.
        """
        return pulumi.get(self, "resource_parameters")

    @resource_parameters.setter
    def resource_parameters(self, value: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']):
        pulumi.set(self, "resource_parameters", value)


if not MYPY:
    class EventConnectionInvocationConnectivityParametersResourceParametersArgsDict(TypedDict):
        resource_configuration_arn: pulumi.Input[_builtins.str]
        """
        ARN of the Amazon VPC Lattice resource configuration for the resource endpoint.
        """
        resource_association_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionInvocationConnectivityParametersResourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionInvocationConnectivityParametersResourceParametersArgs:
    def __init__(__self__, *,
                 resource_configuration_arn: pulumi.Input[_builtins.str],
                 resource_association_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_configuration_arn: ARN of the Amazon VPC Lattice resource configuration for the resource endpoint.
        """
        pulumi.set(__self__, "resource_configuration_arn", resource_configuration_arn)
        if resource_association_arn is not None:
            pulumi.set(__self__, "resource_association_arn", resource_association_arn)

    @_builtins.property
    @pulumi.getter(name="resourceConfigurationArn")
    def resource_configuration_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Amazon VPC Lattice resource configuration for the resource endpoint.
        """
        return pulumi.get(self, "resource_configuration_arn")

    @resource_configuration_arn.setter
    def resource_configuration_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_configuration_arn", value)

    @_builtins.property
    @pulumi.getter(name="resourceAssociationArn")
    def resource_association_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_association_arn")

    @resource_association_arn.setter
    def resource_association_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_association_arn", value)


if not MYPY:
    class EventEndpointEventBusArgsDict(TypedDict):
        event_bus_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the event bus the endpoint is associated with.
        """
elif False:
    EventEndpointEventBusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointEventBusArgs:
    def __init__(__self__, *,
                 event_bus_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] event_bus_arn: The ARN of the event bus the endpoint is associated with.
        """
        pulumi.set(__self__, "event_bus_arn", event_bus_arn)

    @_builtins.property
    @pulumi.getter(name="eventBusArn")
    def event_bus_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the event bus the endpoint is associated with.
        """
        return pulumi.get(self, "event_bus_arn")

    @event_bus_arn.setter
    def event_bus_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_bus_arn", value)


if not MYPY:
    class EventEndpointReplicationConfigArgsDict(TypedDict):
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of event replication. Valid values: `ENABLED`, `DISABLED`. The default state is `ENABLED`, which means you must supply a `role_arn`. If you don't have a `role_arn` or you don't want event replication enabled, set `state` to `DISABLED`.
        """
elif False:
    EventEndpointReplicationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointReplicationConfigArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] state: The state of event replication. Valid values: `ENABLED`, `DISABLED`. The default state is `ENABLED`, which means you must supply a `role_arn`. If you don't have a `role_arn` or you don't want event replication enabled, set `state` to `DISABLED`.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of event replication. Valid values: `ENABLED`, `DISABLED`. The default state is `ENABLED`, which means you must supply a `role_arn`. If you don't have a `role_arn` or you don't want event replication enabled, set `state` to `DISABLED`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class EventEndpointRoutingConfigArgsDict(TypedDict):
        failover_config: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgsDict']
        """
        Parameters used for failover. This includes what triggers failover and what happens when it's triggered. Documented below.
        """
elif False:
    EventEndpointRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigArgs:
    def __init__(__self__, *,
                 failover_config: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']):
        """
        :param pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs'] failover_config: Parameters used for failover. This includes what triggers failover and what happens when it's triggered. Documented below.
        """
        pulumi.set(__self__, "failover_config", failover_config)

    @_builtins.property
    @pulumi.getter(name="failoverConfig")
    def failover_config(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']:
        """
        Parameters used for failover. This includes what triggers failover and what happens when it's triggered. Documented below.
        """
        return pulumi.get(self, "failover_config")

    @failover_config.setter
    def failover_config(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']):
        pulumi.set(self, "failover_config", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigArgsDict(TypedDict):
        primary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict']
        """
        Parameters used for the primary Region. Documented below.
        """
        secondary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict']
        """
        Parameters used for the secondary Region, the Region that events are routed to when failover is triggered or event replication is enabled. Documented below.
        """
elif False:
    EventEndpointRoutingConfigFailoverConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs'],
                 secondary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']):
        """
        :param pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs'] primary: Parameters used for the primary Region. Documented below.
        :param pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs'] secondary: Parameters used for the secondary Region, the Region that events are routed to when failover is triggered or event replication is enabled. Documented below.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs']:
        """
        Parameters used for the primary Region. Documented below.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs']):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']:
        """
        Parameters used for the secondary Region, the Region that events are routed to when failover is triggered or event replication is enabled. Documented below.
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict(TypedDict):
        health_check: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the health check used by the endpoint to determine whether failover is triggered.
        """
elif False:
    EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigPrimaryArgs:
    def __init__(__self__, *,
                 health_check: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] health_check: The ARN of the health check used by the endpoint to determine whether failover is triggered.
        """
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the health check used by the endpoint to determine whether failover is triggered.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict(TypedDict):
        route: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the secondary Region.
        """
elif False:
    EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigSecondaryArgs:
    def __init__(__self__, *,
                 route: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route: The name of the secondary Region.
        """
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the secondary Region.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route", value)


if not MYPY:
    class EventPermissionConditionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key for the condition. Valid values: `aws:PrincipalOrgID`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of condition. Value values: `StringEquals`.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value for the key.
        """
elif False:
    EventPermissionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventPermissionConditionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Key for the condition. Valid values: `aws:PrincipalOrgID`.
        :param pulumi.Input[_builtins.str] type: Type of condition. Value values: `StringEquals`.
        :param pulumi.Input[_builtins.str] value: Value for the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key for the condition. Valid values: `aws:PrincipalOrgID`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of condition. Value values: `StringEquals`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value for the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventTargetAppsyncTargetArgsDict(TypedDict):
        graphql_operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains the GraphQL mutation to be parsed and executed.
        """
elif False:
    EventTargetAppsyncTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetAppsyncTargetArgs:
    def __init__(__self__, *,
                 graphql_operation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] graphql_operation: Contains the GraphQL mutation to be parsed and executed.
        """
        if graphql_operation is not None:
            pulumi.set(__self__, "graphql_operation", graphql_operation)

    @_builtins.property
    @pulumi.getter(name="graphqlOperation")
    def graphql_operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains the GraphQL mutation to be parsed and executed.
        """
        return pulumi.get(self, "graphql_operation")

    @graphql_operation.setter
    def graphql_operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "graphql_operation", value)


if not MYPY:
    class EventTargetBatchTargetArgsDict(TypedDict):
        job_definition: pulumi.Input[_builtins.str]
        """
        The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
        """
        job_name: pulumi.Input[_builtins.str]
        """
        The name to use for this execution of the job, if the target is an AWS Batch job.
        """
        array_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
        """
        job_attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
        """
elif False:
    EventTargetBatchTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetBatchTargetArgs:
    def __init__(__self__, *,
                 job_definition: pulumi.Input[_builtins.str],
                 job_name: pulumi.Input[_builtins.str],
                 array_size: Optional[pulumi.Input[_builtins.int]] = None,
                 job_attempts: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] job_definition: The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
        :param pulumi.Input[_builtins.str] job_name: The name to use for this execution of the job, if the target is an AWS Batch job.
        :param pulumi.Input[_builtins.int] array_size: The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
        :param pulumi.Input[_builtins.int] job_attempts: The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
        """
        pulumi.set(__self__, "job_definition", job_definition)
        pulumi.set(__self__, "job_name", job_name)
        if array_size is not None:
            pulumi.set(__self__, "array_size", array_size)
        if job_attempts is not None:
            pulumi.set(__self__, "job_attempts", job_attempts)

    @_builtins.property
    @pulumi.getter(name="jobDefinition")
    def job_definition(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN or name of the job definition to use if the event target is an AWS Batch job. This job definition must already exist.
        """
        return pulumi.get(self, "job_definition")

    @job_definition.setter
    def job_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_definition", value)

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name to use for this execution of the job, if the target is an AWS Batch job.
        """
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_name", value)

    @_builtins.property
    @pulumi.getter(name="arraySize")
    def array_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the array, if this is an array batch job. Valid values are integers between 2 and 10,000.
        """
        return pulumi.get(self, "array_size")

    @array_size.setter
    def array_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "array_size", value)

    @_builtins.property
    @pulumi.getter(name="jobAttempts")
    def job_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of times to attempt to retry, if the job fails. Valid values are 1 to 10.
        """
        return pulumi.get(self, "job_attempts")

    @job_attempts.setter
    def job_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "job_attempts", value)


if not MYPY:
    class EventTargetDeadLetterConfigArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the SQS queue specified as the target for the dead-letter queue.
        """
elif False:
    EventTargetDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the SQS queue specified as the target for the dead-letter queue.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the SQS queue specified as the target for the dead-letter queue.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class EventTargetEcsTargetArgsDict(TypedDict):
        task_definition_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the task definition to use if the event target is an Amazon ECS cluster.
        """
        capacity_provider_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgsDict']]]]
        """
        The capacity provider strategy to use for the task. If a `capacity_provider_strategy` specified, the `launch_type` parameter must be omitted. If no `capacity_provider_strategy` or `launch_type` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
        """
        enable_ecs_managed_tags: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable Amazon ECS managed tags for the task.
        """
        enable_execute_command: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        """
        group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies an ECS task group for the task. The maximum length is 255 characters.
        """
        launch_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
        """
        network_configuration: NotRequired[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgsDict']]
        """
        Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launch_type` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
        """
        ordered_placement_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgsDict']]]]
        """
        An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
        """
        placement_constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgsDict']]]]
        """
        An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
        """
        platform_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        """
        propagate_tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of tags to assign to ecs resources.
        """
        task_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of tasks to create based on the TaskDefinition. Defaults to `1`.
        """
elif False:
    EventTargetEcsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetArgs:
    def __init__(__self__, *,
                 task_definition_arn: pulumi.Input[_builtins.str],
                 capacity_provider_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]] = None,
                 enable_ecs_managed_tags: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_execute_command: Optional[pulumi.Input[_builtins.bool]] = None,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 launch_type: Optional[pulumi.Input[_builtins.str]] = None,
                 network_configuration: Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']] = None,
                 ordered_placement_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]] = None,
                 placement_constraints: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]] = None,
                 platform_version: Optional[pulumi.Input[_builtins.str]] = None,
                 propagate_tags: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 task_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] task_definition_arn: The ARN of the task definition to use if the event target is an Amazon ECS cluster.
        :param pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]] capacity_provider_strategies: The capacity provider strategy to use for the task. If a `capacity_provider_strategy` specified, the `launch_type` parameter must be omitted. If no `capacity_provider_strategy` or `launch_type` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
        :param pulumi.Input[_builtins.bool] enable_ecs_managed_tags: Specifies whether to enable Amazon ECS managed tags for the task.
        :param pulumi.Input[_builtins.bool] enable_execute_command: Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        :param pulumi.Input[_builtins.str] group: Specifies an ECS task group for the task. The maximum length is 255 characters.
        :param pulumi.Input[_builtins.str] launch_type: Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
        :param pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs'] network_configuration: Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launch_type` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
        :param pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]] ordered_placement_strategies: An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
        :param pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]] placement_constraints: An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
        :param pulumi.Input[_builtins.str] platform_version: Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        :param pulumi.Input[_builtins.str] propagate_tags: Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: A map of tags to assign to ecs resources.
        :param pulumi.Input[_builtins.int] task_count: The number of tasks to create based on the TaskDefinition. Defaults to `1`.
        """
        pulumi.set(__self__, "task_definition_arn", task_definition_arn)
        if capacity_provider_strategies is not None:
            pulumi.set(__self__, "capacity_provider_strategies", capacity_provider_strategies)
        if enable_ecs_managed_tags is not None:
            pulumi.set(__self__, "enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            pulumi.set(__self__, "enable_execute_command", enable_execute_command)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if launch_type is not None:
            pulumi.set(__self__, "launch_type", launch_type)
        if network_configuration is not None:
            pulumi.set(__self__, "network_configuration", network_configuration)
        if ordered_placement_strategies is not None:
            pulumi.set(__self__, "ordered_placement_strategies", ordered_placement_strategies)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @_builtins.property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the task definition to use if the event target is an Amazon ECS cluster.
        """
        return pulumi.get(self, "task_definition_arn")

    @task_definition_arn.setter
    def task_definition_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_definition_arn", value)

    @_builtins.property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]]:
        """
        The capacity provider strategy to use for the task. If a `capacity_provider_strategy` specified, the `launch_type` parameter must be omitted. If no `capacity_provider_strategy` or `launch_type` is specified, the default capacity provider strategy for the cluster is used. Can be one or more. See below.
        """
        return pulumi.get(self, "capacity_provider_strategies")

    @capacity_provider_strategies.setter
    def capacity_provider_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]]):
        pulumi.set(self, "capacity_provider_strategies", value)

    @_builtins.property
    @pulumi.getter(name="enableEcsManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable Amazon ECS managed tags for the task.
        """
        return pulumi.get(self, "enable_ecs_managed_tags")

    @enable_ecs_managed_tags.setter
    def enable_ecs_managed_tags(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_ecs_managed_tags", value)

    @_builtins.property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        """
        return pulumi.get(self, "enable_execute_command")

    @enable_execute_command.setter
    def enable_execute_command(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_execute_command", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies an ECS task group for the task. The maximum length is 255 characters.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. Valid values include: `EC2`, `EXTERNAL`, or `FARGATE`.
        """
        return pulumi.get(self, "launch_type")

    @launch_type.setter
    def launch_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_type", value)

    @_builtins.property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']]:
        """
        Use this if the ECS task uses the awsvpc network mode. This specifies the VPC subnets and security groups associated with the task, and whether a public IP address is to be used. Required if `launch_type` is `FARGATE` because the awsvpc mode is required for Fargate tasks.
        """
        return pulumi.get(self, "network_configuration")

    @network_configuration.setter
    def network_configuration(self, value: Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']]):
        pulumi.set(self, "network_configuration", value)

    @_builtins.property
    @pulumi.getter(name="orderedPlacementStrategies")
    def ordered_placement_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]]:
        """
        An array of placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
        """
        return pulumi.get(self, "ordered_placement_strategies")

    @ordered_placement_strategies.setter
    def ordered_placement_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]]):
        pulumi.set(self, "ordered_placement_strategies", value)

    @_builtins.property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]]:
        """
        An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime). See Below.
        """
        return pulumi.get(self, "placement_constraints")

    @placement_constraints.setter
    def placement_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]]):
        pulumi.set(self, "placement_constraints", value)

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as `1.1.0`. This is used only if LaunchType is FARGATE. For more information about valid platform versions, see [AWS Fargate Platform Versions](http://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        """
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform_version", value)

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. The only valid value is: `TASK_DEFINITION`.
        """
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "propagate_tags", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of tags to assign to ecs resources.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of tasks to create based on the TaskDefinition. Defaults to `1`.
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_count", value)


if not MYPY:
    class EventTargetEcsTargetCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: pulumi.Input[_builtins.str]
        """
        Short name of the capacity provider.
        """
        base: NotRequired[pulumi.Input[_builtins.int]]
        """
        The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        """
elif False:
    EventTargetEcsTargetCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[_builtins.str],
                 base: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity_provider: Short name of the capacity provider.
        :param pulumi.Input[_builtins.int] base: The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
        :param pulumi.Input[_builtins.int] weight: The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        """
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[_builtins.str]:
        """
        Short name of the capacity provider.
        """
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to `0`.
        """
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class EventTargetEcsTargetNetworkConfigurationArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The subnets associated with the task or service.
        """
        assign_public_ip: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.

        For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
        """
elif False:
    EventTargetEcsTargetNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 assign_public_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: The subnets associated with the task or service.
        :param pulumi.Input[_builtins.bool] assign_public_ip: Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.
               
               For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
        """
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The subnets associated with the task or service.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Defaults to `false`.

        For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class EventTargetEcsTargetOrderedPlacementStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).
        """
elif False:
    EventTargetEcsTargetOrderedPlacementStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetOrderedPlacementStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
        :param pulumi.Input[_builtins.str] field: The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of placement strategy. The only valid values at this time are `binpack`, `random` and `spread`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The field to apply the placement strategy against. For the `spread` placement strategy, valid values are `instanceId` (or `host`, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as `attribute:ecs.availability-zone`. For the `binpack` placement strategy, valid values are `cpu` and `memory`. For the `random` placement strategy, this field is not used. For more information, see [Amazon ECS task placement strategies](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-placement-strategies.html).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class EventTargetEcsTargetPlacementConstraintArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
elif False:
    EventTargetEcsTargetPlacementConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetPlacementConstraintArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
        :param pulumi.Input[_builtins.str] expression: Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified for the `distinctInstance` type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventTargetHttpTargetArgsDict(TypedDict):
        header_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Enables you to specify HTTP headers to add to the request.
        """
        path_parameter_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*/POST/pets/*`).
        """
        query_string_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Represents keys/values of query string parameters that are appended to the invoked endpoint.
        """
elif False:
    EventTargetHttpTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetHttpTargetArgs:
    def __init__(__self__, *,
                 header_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path_parameter_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 query_string_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] header_parameters: Enables you to specify HTTP headers to add to the request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] path_parameter_values: The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*/POST/pets/*`).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] query_string_parameters: Represents keys/values of query string parameters that are appended to the invoked endpoint.
        """
        if header_parameters is not None:
            pulumi.set(__self__, "header_parameters", header_parameters)
        if path_parameter_values is not None:
            pulumi.set(__self__, "path_parameter_values", path_parameter_values)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @_builtins.property
    @pulumi.getter(name="headerParameters")
    def header_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Enables you to specify HTTP headers to add to the request.
        """
        return pulumi.get(self, "header_parameters")

    @header_parameters.setter
    def header_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header_parameters", value)

    @_builtins.property
    @pulumi.getter(name="pathParameterValues")
    def path_parameter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of values that correspond sequentially to any path variables in your endpoint ARN (for example `arn:aws:execute-api:us-east-1:123456:myapi/*/POST/pets/*`).
        """
        return pulumi.get(self, "path_parameter_values")

    @path_parameter_values.setter
    def path_parameter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_parameter_values", value)

    @_builtins.property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Represents keys/values of query string parameters that are appended to the invoked endpoint.
        """
        return pulumi.get(self, "query_string_parameters")

    @query_string_parameters.setter
    def query_string_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_string_parameters", value)


if not MYPY:
    class EventTargetInputTransformerArgsDict(TypedDict):
        input_template: pulumi.Input[_builtins.str]
        """
        Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.
        """
        input_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key value pairs specified in the form of JSONPath (for example, time = $.time)
        * You can have as many as 100 key-value pairs.
        * You must use JSON dot notation, not bracket notation.
        * The keys can't start with "AWS".
        """
elif False:
    EventTargetInputTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetInputTransformerArgs:
    def __init__(__self__, *,
                 input_template: pulumi.Input[_builtins.str],
                 input_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] input_template: Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] input_paths: Key value pairs specified in the form of JSONPath (for example, time = $.time)
               * You can have as many as 100 key-value pairs.
               * You must use JSON dot notation, not bracket notation.
               * The keys can't start with "AWS".
        """
        pulumi.set(__self__, "input_template", input_template)
        if input_paths is not None:
            pulumi.set(__self__, "input_paths", input_paths)

    @_builtins.property
    @pulumi.getter(name="inputTemplate")
    def input_template(self) -> pulumi.Input[_builtins.str]:
        """
        Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes.
        """
        return pulumi.get(self, "input_template")

    @input_template.setter
    def input_template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_template", value)

    @_builtins.property
    @pulumi.getter(name="inputPaths")
    def input_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key value pairs specified in the form of JSONPath (for example, time = $.time)
        * You can have as many as 100 key-value pairs.
        * You must use JSON dot notation, not bracket notation.
        * The keys can't start with "AWS".
        """
        return pulumi.get(self, "input_paths")

    @input_paths.setter
    def input_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_paths", value)


if not MYPY:
    class EventTargetKinesisTargetArgsDict(TypedDict):
        partition_key_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The JSON path to be extracted from the event and used as the partition key.
        """
elif False:
    EventTargetKinesisTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetKinesisTargetArgs:
    def __init__(__self__, *,
                 partition_key_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] partition_key_path: The JSON path to be extracted from the event and used as the partition key.
        """
        if partition_key_path is not None:
            pulumi.set(__self__, "partition_key_path", partition_key_path)

    @_builtins.property
    @pulumi.getter(name="partitionKeyPath")
    def partition_key_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The JSON path to be extracted from the event and used as the partition key.
        """
        return pulumi.get(self, "partition_key_path")

    @partition_key_path.setter
    def partition_key_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition_key_path", value)


if not MYPY:
    class EventTargetRedshiftTargetArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        The name of the database.
        """
        db_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The database user name.
        """
        secrets_manager_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name or ARN of the secret that enables access to the database.
        """
        sql: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SQL statement text to run.
        """
        statement_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the SQL statement.
        """
        with_event: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to send an event back to EventBridge after the SQL statement runs.
        """
elif False:
    EventTargetRedshiftTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRedshiftTargetArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 db_user: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets_manager_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 sql: Optional[pulumi.Input[_builtins.str]] = None,
                 statement_name: Optional[pulumi.Input[_builtins.str]] = None,
                 with_event: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The name of the database.
        :param pulumi.Input[_builtins.str] db_user: The database user name.
        :param pulumi.Input[_builtins.str] secrets_manager_arn: The name or ARN of the secret that enables access to the database.
        :param pulumi.Input[_builtins.str] sql: The SQL statement text to run.
        :param pulumi.Input[_builtins.str] statement_name: The name of the SQL statement.
        :param pulumi.Input[_builtins.bool] with_event: Indicates whether to send an event back to EventBridge after the SQL statement runs.
        """
        pulumi.set(__self__, "database", database)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if secrets_manager_arn is not None:
            pulumi.set(__self__, "secrets_manager_arn", secrets_manager_arn)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if statement_name is not None:
            pulumi.set(__self__, "statement_name", statement_name)
        if with_event is not None:
            pulumi.set(__self__, "with_event", with_event)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_user", value)

    @_builtins.property
    @pulumi.getter(name="secretsManagerArn")
    def secrets_manager_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name or ARN of the secret that enables access to the database.
        """
        return pulumi.get(self, "secrets_manager_arn")

    @secrets_manager_arn.setter
    def secrets_manager_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secrets_manager_arn", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SQL statement text to run.
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql", value)

    @_builtins.property
    @pulumi.getter(name="statementName")
    def statement_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the SQL statement.
        """
        return pulumi.get(self, "statement_name")

    @statement_name.setter
    def statement_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "statement_name", value)

    @_builtins.property
    @pulumi.getter(name="withEvent")
    def with_event(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to send an event back to EventBridge after the SQL statement runs.
        """
        return pulumi.get(self, "with_event")

    @with_event.setter
    def with_event(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "with_event", value)


if not MYPY:
    class EventTargetRetryPolicyArgsDict(TypedDict):
        maximum_event_age_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The age in seconds to continue to make retry attempts.
        """
        maximum_retry_attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        maximum number of retry attempts to make before the request fails
        """
elif False:
    EventTargetRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRetryPolicyArgs:
    def __init__(__self__, *,
                 maximum_event_age_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_retry_attempts: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] maximum_event_age_in_seconds: The age in seconds to continue to make retry attempts.
        :param pulumi.Input[_builtins.int] maximum_retry_attempts: maximum number of retry attempts to make before the request fails
        """
        if maximum_event_age_in_seconds is not None:
            pulumi.set(__self__, "maximum_event_age_in_seconds", maximum_event_age_in_seconds)
        if maximum_retry_attempts is not None:
            pulumi.set(__self__, "maximum_retry_attempts", maximum_retry_attempts)

    @_builtins.property
    @pulumi.getter(name="maximumEventAgeInSeconds")
    def maximum_event_age_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The age in seconds to continue to make retry attempts.
        """
        return pulumi.get(self, "maximum_event_age_in_seconds")

    @maximum_event_age_in_seconds.setter
    def maximum_event_age_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_event_age_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        maximum number of retry attempts to make before the request fails
        """
        return pulumi.get(self, "maximum_retry_attempts")

    @maximum_retry_attempts.setter
    def maximum_retry_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_retry_attempts", value)


if not MYPY:
    class EventTargetRunCommandTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Can be either `tag:tag-key` or `InstanceIds`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.
        """
elif False:
    EventTargetRunCommandTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRunCommandTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: Can be either `tag:tag-key` or `InstanceIds`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Can be either `tag:tag-key` or `InstanceIds`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        If Key is `tag:tag-key`, Values is a list of tag values. If Key is `InstanceIds`, Values is a list of Amazon EC2 instance IDs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventTargetSagemakerPipelineTargetArgsDict(TypedDict):
        pipeline_parameter_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict']]]]
        """
        List of Parameter names and values for SageMaker AI Model Building Pipeline execution.
        """
elif False:
    EventTargetSagemakerPipelineTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSagemakerPipelineTargetArgs:
    def __init__(__self__, *,
                 pipeline_parameter_lists: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]] pipeline_parameter_lists: List of Parameter names and values for SageMaker AI Model Building Pipeline execution.
        """
        if pipeline_parameter_lists is not None:
            pulumi.set(__self__, "pipeline_parameter_lists", pipeline_parameter_lists)

    @_builtins.property
    @pulumi.getter(name="pipelineParameterLists")
    def pipeline_parameter_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]]:
        """
        List of Parameter names and values for SageMaker AI Model Building Pipeline execution.
        """
        return pulumi.get(self, "pipeline_parameter_lists")

    @pipeline_parameter_lists.setter
    def pipeline_parameter_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]]):
        pulumi.set(self, "pipeline_parameter_lists", value)


if not MYPY:
    class EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of parameter to start execution of a SageMaker AI Model Building Pipeline.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of parameter to start execution of a SageMaker AI Model Building Pipeline.
        """
elif False:
    EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSagemakerPipelineTargetPipelineParameterListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of parameter to start execution of a SageMaker AI Model Building Pipeline.
        :param pulumi.Input[_builtins.str] value: Value of parameter to start execution of a SageMaker AI Model Building Pipeline.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of parameter to start execution of a SageMaker AI Model Building Pipeline.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of parameter to start execution of a SageMaker AI Model Building Pipeline.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventTargetSqsTargetArgsDict(TypedDict):
        message_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The FIFO message group ID to use as the target.
        """
elif False:
    EventTargetSqsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSqsTargetArgs:
    def __init__(__self__, *,
                 message_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_group_id: The FIFO message group ID to use as the target.
        """
        if message_group_id is not None:
            pulumi.set(__self__, "message_group_id", message_group_id)

    @_builtins.property
    @pulumi.getter(name="messageGroupId")
    def message_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The FIFO message group ID to use as the target.
        """
        return pulumi.get(self, "message_group_id")

    @message_group_id.setter
    def message_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_group_id", value)


if not MYPY:
    class InternetMonitorHealthEventsConfigArgsDict(TypedDict):
        availability_score_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The health event threshold percentage set for availability scores.
        """
        performance_score_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The health event threshold percentage set for performance scores.
        """
elif False:
    InternetMonitorHealthEventsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorHealthEventsConfigArgs:
    def __init__(__self__, *,
                 availability_score_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 performance_score_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] availability_score_threshold: The health event threshold percentage set for availability scores.
        :param pulumi.Input[_builtins.float] performance_score_threshold: The health event threshold percentage set for performance scores.
        """
        if availability_score_threshold is not None:
            pulumi.set(__self__, "availability_score_threshold", availability_score_threshold)
        if performance_score_threshold is not None:
            pulumi.set(__self__, "performance_score_threshold", performance_score_threshold)

    @_builtins.property
    @pulumi.getter(name="availabilityScoreThreshold")
    def availability_score_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The health event threshold percentage set for availability scores.
        """
        return pulumi.get(self, "availability_score_threshold")

    @availability_score_threshold.setter
    def availability_score_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "availability_score_threshold", value)

    @_builtins.property
    @pulumi.getter(name="performanceScoreThreshold")
    def performance_score_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The health event threshold percentage set for performance scores.
        """
        return pulumi.get(self, "performance_score_threshold")

    @performance_score_threshold.setter
    def performance_score_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "performance_score_threshold", value)


if not MYPY:
    class InternetMonitorInternetMeasurementsLogDeliveryArgsDict(TypedDict):
        s3_config: NotRequired[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict']]
elif False:
    InternetMonitorInternetMeasurementsLogDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorInternetMeasurementsLogDeliveryArgs:
    def __init__(__self__, *,
                 s3_config: Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']] = None):
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)

    @_builtins.property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']]:
        return pulumi.get(self, "s3_config")

    @s3_config.setter
    def s3_config(self, value: Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']]):
        pulumi.set(self, "s3_config", value)


if not MYPY:
    class InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        log_delivery_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_delivery_status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if log_delivery_status is not None:
            pulumi.set(__self__, "log_delivery_status", log_delivery_status)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logDeliveryStatus")
    def log_delivery_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_delivery_status")

    @log_delivery_status.setter
    def log_delivery_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_delivery_status", value)


if not MYPY:
    class LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict(TypedDict):
        destination_resource_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the AWS destination that this delivery destination represents. Required when `delivery_destination_configuration` is specified.
        """
elif False:
    LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogDeliveryDestinationDeliveryDestinationConfigurationArgs:
    def __init__(__self__, *,
                 destination_resource_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_resource_arn: The ARN of the AWS destination that this delivery destination represents. Required when `delivery_destination_configuration` is specified.
        """
        if destination_resource_arn is not None:
            pulumi.set(__self__, "destination_resource_arn", destination_resource_arn)

    @_builtins.property
    @pulumi.getter(name="destinationResourceArn")
    def destination_resource_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the AWS destination that this delivery destination represents. Required when `delivery_destination_configuration` is specified.
        """
        return pulumi.get(self, "destination_resource_arn")

    @destination_resource_arn.setter
    def destination_resource_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_resource_arn", value)


if not MYPY:
    class LogDeliveryS3DeliveryConfigurationArgsDict(TypedDict):
        enable_hive_compatible_path: pulumi.Input[_builtins.bool]
        """
        This parameter causes the S3 objects that contain delivered logs to use a prefix structure that allows for integration with Apache Hive.
        """
        suffix_path: pulumi.Input[_builtins.str]
        """
        This string allows re-configuring the S3 object prefix to contain either static or variable sections. The valid variables to use in the suffix path will vary by each log source.
        """
elif False:
    LogDeliveryS3DeliveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogDeliveryS3DeliveryConfigurationArgs:
    def __init__(__self__, *,
                 enable_hive_compatible_path: pulumi.Input[_builtins.bool],
                 suffix_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enable_hive_compatible_path: This parameter causes the S3 objects that contain delivered logs to use a prefix structure that allows for integration with Apache Hive.
        :param pulumi.Input[_builtins.str] suffix_path: This string allows re-configuring the S3 object prefix to contain either static or variable sections. The valid variables to use in the suffix path will vary by each log source.
        """
        pulumi.set(__self__, "enable_hive_compatible_path", enable_hive_compatible_path)
        pulumi.set(__self__, "suffix_path", suffix_path)

    @_builtins.property
    @pulumi.getter(name="enableHiveCompatiblePath")
    def enable_hive_compatible_path(self) -> pulumi.Input[_builtins.bool]:
        """
        This parameter causes the S3 objects that contain delivered logs to use a prefix structure that allows for integration with Apache Hive.
        """
        return pulumi.get(self, "enable_hive_compatible_path")

    @enable_hive_compatible_path.setter
    def enable_hive_compatible_path(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_hive_compatible_path", value)

    @_builtins.property
    @pulumi.getter(name="suffixPath")
    def suffix_path(self) -> pulumi.Input[_builtins.str]:
        """
        This string allows re-configuring the S3 object prefix to contain either static or variable sections. The valid variables to use in the suffix path will vary by each log source.
        """
        return pulumi.get(self, "suffix_path")

    @suffix_path.setter
    def suffix_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix_path", value)


if not MYPY:
    class LogMetricFilterMetricTransformationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the CloudWatch metric to which the monitored log information should be published (e.g., `ErrorCount`)
        """
        namespace: pulumi.Input[_builtins.str]
        """
        The destination namespace of the CloudWatch metric.
        """
        value: pulumi.Input[_builtins.str]
        """
        What to publish to the metric. For example, if you're counting the occurrences of a particular term like "Error", the value will be "1" for each occurrence. If you're counting the bytes transferred the published value will be the value in the log event.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value to emit when a filter pattern does not match a log event. Conflicts with `dimensions`.
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Map of fields to use as dimensions for the metric. Up to 3 dimensions are allowed. Conflicts with `default_value`.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unit to assign to the metric. If you omit this, the unit is set as `None`.
        """
elif False:
    LogMetricFilterMetricTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogMetricFilterMetricTransformationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the CloudWatch metric to which the monitored log information should be published (e.g., `ErrorCount`)
        :param pulumi.Input[_builtins.str] namespace: The destination namespace of the CloudWatch metric.
        :param pulumi.Input[_builtins.str] value: What to publish to the metric. For example, if you're counting the occurrences of a particular term like "Error", the value will be "1" for each occurrence. If you're counting the bytes transferred the published value will be the value in the log event.
        :param pulumi.Input[_builtins.str] default_value: The value to emit when a filter pattern does not match a log event. Conflicts with `dimensions`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] dimensions: Map of fields to use as dimensions for the metric. Up to 3 dimensions are allowed. Conflicts with `default_value`.
        :param pulumi.Input[_builtins.str] unit: The unit to assign to the metric. If you omit this, the unit is set as `None`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the CloudWatch metric to which the monitored log information should be published (e.g., `ErrorCount`)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The destination namespace of the CloudWatch metric.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        What to publish to the metric. For example, if you're counting the occurrences of a particular term like "Error", the value will be "1" for each occurrence. If you're counting the bytes transferred the published value will be the value in the log event.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value to emit when a filter pattern does not match a log event. Conflicts with `dimensions`.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Map of fields to use as dimensions for the metric. Up to 3 dimensions are allowed. Conflicts with `default_value`.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unit to assign to the metric. If you omit this, the unit is set as `None`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class LogTransformerTransformerConfigArgsDict(TypedDict):
        add_keys: NotRequired[pulumi.Input['LogTransformerTransformerConfigAddKeysArgsDict']]
        """
        Adds new key-value pairs to the log event. See `add_keys` below for details.
        """
        copy_value: NotRequired[pulumi.Input['LogTransformerTransformerConfigCopyValueArgsDict']]
        """
        Copies values within a log event. See `copy_value` below for details.
        """
        csvs: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgsDict']]]]
        """
        Parses comma-separated values (CSV) from the log events into columns. See `csv` below for details.
        """
        date_time_converters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgsDict']]]]
        """
        Converts a datetime string into a format that you specify. See `date_time_converter` below for details.
        """
        delete_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgsDict']]]]
        """
        Deletes entry from a log event. See `delete_keys` below for details.
        """
        grok: NotRequired[pulumi.Input['LogTransformerTransformerConfigGrokArgsDict']]
        """
        Parses and structures unstructured data by using pattern matching. See `grok` below for details.
        """
        list_to_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgsDict']]]]
        """
        Converts list of objects that contain key fields into a map of target keys. See `list_to_map` below for details.
        """
        lower_case_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgsDict']]]]
        """
        Converts a string to lowercase. See `lower_case_string` below for details.
        """
        move_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgsDict']]]]
        """
        Moves a key from one field to another. See `move_keys` below for details.
        """
        parse_cloudfront: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgsDict']]
        """
        Parses CloudFront vended logs, extracts fields, and converts them into JSON format. See `parse_cloudfront` below for details.
        """
        parse_jsons: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgsDict']]]]
        """
        Parses log events that are in JSON format. See `parse_json` below for details.
        """
        parse_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgsDict']]]]
        """
        Parses a specified field in the original log event into key-value pairs. See `parse_key_value` below for details.
        """
        parse_postgres: NotRequired[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgsDict']]
        """
        Parses RDS for PostgreSQL vended logs, extracts fields, and and convert them into a JSON format. See `parse_postgres` below for details.
        """
        parse_route53: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseRoute53ArgsDict']]
        """
        Parses Route 53 vended logs, extracts fields, and converts them into JSON format. See `parse_route53` below for details.
        """
        parse_to_ocsf: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgsDict']]
        """
        Parses logs events and converts them into Open Cybersecurity Schema Framework (OCSF) events. See `parse_to_ocsf` below for details.
        """
        parse_vpc: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseVpcArgsDict']]
        """
        Parses Amazon VPC vended logs, extracts fields, and converts them into JSON format. See `parse_vpc` below for details.
        """
        parse_waf: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseWafArgsDict']]
        """
        Parses AWS WAF vended logs, extracts fields, and converts them into JSON format. See `parse_waf` below for details.
        """
        rename_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgsDict']]]]
        """
        Renames keys in a log event. See `rename_keys` below for details.
        """
        split_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgsDict']]]]
        """
        Splits a field into an array of strings using a delimiting character. See `split_string` below for details.
        """
        substitute_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgsDict']]]]
        """
        Matches a keys value against a regular expression and replaces all matches with a replacement string. See `substitute_string` below for details.
        """
        trim_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgsDict']]]]
        """
        Removes leading and trailing whitespace from a string. See `trim_string` below for details.
        """
        type_converters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgsDict']]]]
        """
        Converts a value type associated with the specified key to the specified type. See `type_converter` below for details.
        """
        upper_case_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgsDict']]]]
        """
        Converts a string to uppercase. See `upper_case_string` below for details.
        """
elif False:
    LogTransformerTransformerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigArgs:
    def __init__(__self__, *,
                 add_keys: Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']] = None,
                 copy_value: Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']] = None,
                 csvs: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]] = None,
                 date_time_converters: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]] = None,
                 delete_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]] = None,
                 grok: Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']] = None,
                 list_to_maps: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]] = None,
                 lower_case_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]] = None,
                 move_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]] = None,
                 parse_cloudfront: Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']] = None,
                 parse_jsons: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]] = None,
                 parse_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]] = None,
                 parse_postgres: Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']] = None,
                 parse_route53: Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']] = None,
                 parse_to_ocsf: Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']] = None,
                 parse_vpc: Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']] = None,
                 parse_waf: Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']] = None,
                 rename_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]] = None,
                 split_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]] = None,
                 substitute_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]] = None,
                 trim_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]] = None,
                 type_converters: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]] = None,
                 upper_case_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]] = None):
        """
        :param pulumi.Input['LogTransformerTransformerConfigAddKeysArgs'] add_keys: Adds new key-value pairs to the log event. See `add_keys` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigCopyValueArgs'] copy_value: Copies values within a log event. See `copy_value` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]] csvs: Parses comma-separated values (CSV) from the log events into columns. See `csv` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]] date_time_converters: Converts a datetime string into a format that you specify. See `date_time_converter` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]] delete_keys: Deletes entry from a log event. See `delete_keys` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigGrokArgs'] grok: Parses and structures unstructured data by using pattern matching. See `grok` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]] list_to_maps: Converts list of objects that contain key fields into a map of target keys. See `list_to_map` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]] lower_case_strings: Converts a string to lowercase. See `lower_case_string` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]] move_keys: Moves a key from one field to another. See `move_keys` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs'] parse_cloudfront: Parses CloudFront vended logs, extracts fields, and converts them into JSON format. See `parse_cloudfront` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]] parse_jsons: Parses log events that are in JSON format. See `parse_json` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]] parse_key_values: Parses a specified field in the original log event into key-value pairs. See `parse_key_value` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs'] parse_postgres: Parses RDS for PostgreSQL vended logs, extracts fields, and and convert them into a JSON format. See `parse_postgres` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParseRoute53Args'] parse_route53: Parses Route 53 vended logs, extracts fields, and converts them into JSON format. See `parse_route53` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs'] parse_to_ocsf: Parses logs events and converts them into Open Cybersecurity Schema Framework (OCSF) events. See `parse_to_ocsf` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParseVpcArgs'] parse_vpc: Parses Amazon VPC vended logs, extracts fields, and converts them into JSON format. See `parse_vpc` below for details.
        :param pulumi.Input['LogTransformerTransformerConfigParseWafArgs'] parse_waf: Parses AWS WAF vended logs, extracts fields, and converts them into JSON format. See `parse_waf` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]] rename_keys: Renames keys in a log event. See `rename_keys` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]] split_strings: Splits a field into an array of strings using a delimiting character. See `split_string` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]] substitute_strings: Matches a keys value against a regular expression and replaces all matches with a replacement string. See `substitute_string` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]] trim_strings: Removes leading and trailing whitespace from a string. See `trim_string` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]] type_converters: Converts a value type associated with the specified key to the specified type. See `type_converter` below for details.
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]] upper_case_strings: Converts a string to uppercase. See `upper_case_string` below for details.
        """
        if add_keys is not None:
            pulumi.set(__self__, "add_keys", add_keys)
        if copy_value is not None:
            pulumi.set(__self__, "copy_value", copy_value)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if date_time_converters is not None:
            pulumi.set(__self__, "date_time_converters", date_time_converters)
        if delete_keys is not None:
            pulumi.set(__self__, "delete_keys", delete_keys)
        if grok is not None:
            pulumi.set(__self__, "grok", grok)
        if list_to_maps is not None:
            pulumi.set(__self__, "list_to_maps", list_to_maps)
        if lower_case_strings is not None:
            pulumi.set(__self__, "lower_case_strings", lower_case_strings)
        if move_keys is not None:
            pulumi.set(__self__, "move_keys", move_keys)
        if parse_cloudfront is not None:
            pulumi.set(__self__, "parse_cloudfront", parse_cloudfront)
        if parse_jsons is not None:
            pulumi.set(__self__, "parse_jsons", parse_jsons)
        if parse_key_values is not None:
            pulumi.set(__self__, "parse_key_values", parse_key_values)
        if parse_postgres is not None:
            pulumi.set(__self__, "parse_postgres", parse_postgres)
        if parse_route53 is not None:
            pulumi.set(__self__, "parse_route53", parse_route53)
        if parse_to_ocsf is not None:
            pulumi.set(__self__, "parse_to_ocsf", parse_to_ocsf)
        if parse_vpc is not None:
            pulumi.set(__self__, "parse_vpc", parse_vpc)
        if parse_waf is not None:
            pulumi.set(__self__, "parse_waf", parse_waf)
        if rename_keys is not None:
            pulumi.set(__self__, "rename_keys", rename_keys)
        if split_strings is not None:
            pulumi.set(__self__, "split_strings", split_strings)
        if substitute_strings is not None:
            pulumi.set(__self__, "substitute_strings", substitute_strings)
        if trim_strings is not None:
            pulumi.set(__self__, "trim_strings", trim_strings)
        if type_converters is not None:
            pulumi.set(__self__, "type_converters", type_converters)
        if upper_case_strings is not None:
            pulumi.set(__self__, "upper_case_strings", upper_case_strings)

    @_builtins.property
    @pulumi.getter(name="addKeys")
    def add_keys(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']]:
        """
        Adds new key-value pairs to the log event. See `add_keys` below for details.
        """
        return pulumi.get(self, "add_keys")

    @add_keys.setter
    def add_keys(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']]):
        pulumi.set(self, "add_keys", value)

    @_builtins.property
    @pulumi.getter(name="copyValue")
    def copy_value(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']]:
        """
        Copies values within a log event. See `copy_value` below for details.
        """
        return pulumi.get(self, "copy_value")

    @copy_value.setter
    def copy_value(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']]):
        pulumi.set(self, "copy_value", value)

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]]:
        """
        Parses comma-separated values (CSV) from the log events into columns. See `csv` below for details.
        """
        return pulumi.get(self, "csvs")

    @csvs.setter
    def csvs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]]):
        pulumi.set(self, "csvs", value)

    @_builtins.property
    @pulumi.getter(name="dateTimeConverters")
    def date_time_converters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]]:
        """
        Converts a datetime string into a format that you specify. See `date_time_converter` below for details.
        """
        return pulumi.get(self, "date_time_converters")

    @date_time_converters.setter
    def date_time_converters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]]):
        pulumi.set(self, "date_time_converters", value)

    @_builtins.property
    @pulumi.getter(name="deleteKeys")
    def delete_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]]:
        """
        Deletes entry from a log event. See `delete_keys` below for details.
        """
        return pulumi.get(self, "delete_keys")

    @delete_keys.setter
    def delete_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]]):
        pulumi.set(self, "delete_keys", value)

    @_builtins.property
    @pulumi.getter
    def grok(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']]:
        """
        Parses and structures unstructured data by using pattern matching. See `grok` below for details.
        """
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']]):
        pulumi.set(self, "grok", value)

    @_builtins.property
    @pulumi.getter(name="listToMaps")
    def list_to_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]]:
        """
        Converts list of objects that contain key fields into a map of target keys. See `list_to_map` below for details.
        """
        return pulumi.get(self, "list_to_maps")

    @list_to_maps.setter
    def list_to_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]]):
        pulumi.set(self, "list_to_maps", value)

    @_builtins.property
    @pulumi.getter(name="lowerCaseStrings")
    def lower_case_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]]:
        """
        Converts a string to lowercase. See `lower_case_string` below for details.
        """
        return pulumi.get(self, "lower_case_strings")

    @lower_case_strings.setter
    def lower_case_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]]):
        pulumi.set(self, "lower_case_strings", value)

    @_builtins.property
    @pulumi.getter(name="moveKeys")
    def move_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]]:
        """
        Moves a key from one field to another. See `move_keys` below for details.
        """
        return pulumi.get(self, "move_keys")

    @move_keys.setter
    def move_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]]):
        pulumi.set(self, "move_keys", value)

    @_builtins.property
    @pulumi.getter(name="parseCloudfront")
    def parse_cloudfront(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']]:
        """
        Parses CloudFront vended logs, extracts fields, and converts them into JSON format. See `parse_cloudfront` below for details.
        """
        return pulumi.get(self, "parse_cloudfront")

    @parse_cloudfront.setter
    def parse_cloudfront(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']]):
        pulumi.set(self, "parse_cloudfront", value)

    @_builtins.property
    @pulumi.getter(name="parseJsons")
    def parse_jsons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]]:
        """
        Parses log events that are in JSON format. See `parse_json` below for details.
        """
        return pulumi.get(self, "parse_jsons")

    @parse_jsons.setter
    def parse_jsons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]]):
        pulumi.set(self, "parse_jsons", value)

    @_builtins.property
    @pulumi.getter(name="parseKeyValues")
    def parse_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]]:
        """
        Parses a specified field in the original log event into key-value pairs. See `parse_key_value` below for details.
        """
        return pulumi.get(self, "parse_key_values")

    @parse_key_values.setter
    def parse_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]]):
        pulumi.set(self, "parse_key_values", value)

    @_builtins.property
    @pulumi.getter(name="parsePostgres")
    def parse_postgres(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']]:
        """
        Parses RDS for PostgreSQL vended logs, extracts fields, and and convert them into a JSON format. See `parse_postgres` below for details.
        """
        return pulumi.get(self, "parse_postgres")

    @parse_postgres.setter
    def parse_postgres(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']]):
        pulumi.set(self, "parse_postgres", value)

    @_builtins.property
    @pulumi.getter(name="parseRoute53")
    def parse_route53(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']]:
        """
        Parses Route 53 vended logs, extracts fields, and converts them into JSON format. See `parse_route53` below for details.
        """
        return pulumi.get(self, "parse_route53")

    @parse_route53.setter
    def parse_route53(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']]):
        pulumi.set(self, "parse_route53", value)

    @_builtins.property
    @pulumi.getter(name="parseToOcsf")
    def parse_to_ocsf(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']]:
        """
        Parses logs events and converts them into Open Cybersecurity Schema Framework (OCSF) events. See `parse_to_ocsf` below for details.
        """
        return pulumi.get(self, "parse_to_ocsf")

    @parse_to_ocsf.setter
    def parse_to_ocsf(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']]):
        pulumi.set(self, "parse_to_ocsf", value)

    @_builtins.property
    @pulumi.getter(name="parseVpc")
    def parse_vpc(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']]:
        """
        Parses Amazon VPC vended logs, extracts fields, and converts them into JSON format. See `parse_vpc` below for details.
        """
        return pulumi.get(self, "parse_vpc")

    @parse_vpc.setter
    def parse_vpc(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']]):
        pulumi.set(self, "parse_vpc", value)

    @_builtins.property
    @pulumi.getter(name="parseWaf")
    def parse_waf(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']]:
        """
        Parses AWS WAF vended logs, extracts fields, and converts them into JSON format. See `parse_waf` below for details.
        """
        return pulumi.get(self, "parse_waf")

    @parse_waf.setter
    def parse_waf(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']]):
        pulumi.set(self, "parse_waf", value)

    @_builtins.property
    @pulumi.getter(name="renameKeys")
    def rename_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]]:
        """
        Renames keys in a log event. See `rename_keys` below for details.
        """
        return pulumi.get(self, "rename_keys")

    @rename_keys.setter
    def rename_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]]):
        pulumi.set(self, "rename_keys", value)

    @_builtins.property
    @pulumi.getter(name="splitStrings")
    def split_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]]:
        """
        Splits a field into an array of strings using a delimiting character. See `split_string` below for details.
        """
        return pulumi.get(self, "split_strings")

    @split_strings.setter
    def split_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]]):
        pulumi.set(self, "split_strings", value)

    @_builtins.property
    @pulumi.getter(name="substituteStrings")
    def substitute_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]]:
        """
        Matches a keys value against a regular expression and replaces all matches with a replacement string. See `substitute_string` below for details.
        """
        return pulumi.get(self, "substitute_strings")

    @substitute_strings.setter
    def substitute_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]]):
        pulumi.set(self, "substitute_strings", value)

    @_builtins.property
    @pulumi.getter(name="trimStrings")
    def trim_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]]:
        """
        Removes leading and trailing whitespace from a string. See `trim_string` below for details.
        """
        return pulumi.get(self, "trim_strings")

    @trim_strings.setter
    def trim_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]]):
        pulumi.set(self, "trim_strings", value)

    @_builtins.property
    @pulumi.getter(name="typeConverters")
    def type_converters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]]:
        """
        Converts a value type associated with the specified key to the specified type. See `type_converter` below for details.
        """
        return pulumi.get(self, "type_converters")

    @type_converters.setter
    def type_converters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]]):
        pulumi.set(self, "type_converters", value)

    @_builtins.property
    @pulumi.getter(name="upperCaseStrings")
    def upper_case_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]]:
        """
        Converts a string to uppercase. See `upper_case_string` below for details.
        """
        return pulumi.get(self, "upper_case_strings")

    @upper_case_strings.setter
    def upper_case_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]]):
        pulumi.set(self, "upper_case_strings", value)


if not MYPY:
    class LogTransformerTransformerConfigAddKeysArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgsDict']]]
        """
        Objects containing the information about the keys to add to the log event. You must include at least one entry, and five at most. See `add_keys` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigAddKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigAddKeysArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]] entries: Objects containing the information about the keys to add to the log event. You must include at least one entry, and five at most. See `add_keys` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]:
        """
        Objects containing the information about the keys to add to the log event. You must include at least one entry, and five at most. See `add_keys` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigAddKeysEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key with the value that will be converted to a different type.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value of the new entry to be added to the log event.
        """
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
elif False:
    LogTransformerTransformerConfigAddKeysEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigAddKeysEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key with the value that will be converted to a different type.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the new entry to be added to the log event.
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
               * `renameTo` - (Required) Specifies the new name of the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key with the value that will be converted to a different type.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value of the new entry to be added to the log event.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigCopyValueArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgsDict']]]
        """
        Objects containing the information about the values to copy to the log event. You must include at least one entry, and five at most. See `copy_value` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigCopyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCopyValueArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]] entries: Objects containing the information about the values to copy to the log event. You must include at least one entry, and five at most. See `copy_value` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]:
        """
        Objects containing the information about the values to copy to the log event. You must include at least one entry, and five at most. See `copy_value` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigCopyValueEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key to modify.
        """
        target: pulumi.Input[_builtins.str]
        """
        Specifies the key to move to.
        """
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
elif False:
    LogTransformerTransformerConfigCopyValueEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCopyValueEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the key to modify.
        :param pulumi.Input[_builtins.str] target: Specifies the key to move to.
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
               * `renameTo` - (Required) Specifies the new name of the key.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to modify.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to move to.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigCsvArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the names to use for the columns in the transformed log event. If not specified, default column names (`[column_1, column_2 ...]`) are used.
        """
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the character used to separate each column in the original comma-separated value log event. Defaults to the comma `,` character.
        """
        quote_character: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the character used as a text qualifier for a single column of data. Defaults to the double quotation mark `"` character.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCsvArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 quote_character: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] columns: Specifies the names to use for the columns in the transformed log event. If not specified, default column names (`[column_1, column_2 ...]`) are used.
        :param pulumi.Input[_builtins.str] delimiter: Specifies the character used to separate each column in the original comma-separated value log event. Defaults to the comma `,` character.
        :param pulumi.Input[_builtins.str] quote_character: Specifies the character used as a text qualifier for a single column of data. Defaults to the double quotation mark `"` character.
        :param pulumi.Input[_builtins.str] source: Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if quote_character is not None:
            pulumi.set(__self__, "quote_character", quote_character)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the names to use for the columns in the transformed log event. If not specified, default column names (`[column_1, column_2 ...]`) are used.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the character used to separate each column in the original comma-separated value log event. Defaults to the comma `,` character.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="quoteCharacter")
    def quote_character(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the character used as a text qualifier for a single column of data. Defaults to the double quotation mark `"` character.
        """
        return pulumi.get(self, "quote_character")

    @quote_character.setter
    def quote_character(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quote_character", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigDateTimeConverterArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of patterns to match against the `source` field.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key to apply the date conversion to.
        """
        target: pulumi.Input[_builtins.str]
        """
        Specifies the JSON field to store the result in.
        """
        locale: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the locale of the source field. Defaults to `locale.ROOT`.
        """
        source_timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time zone of the source field. Defaults to `UTC`.
        """
        target_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the datetime format to use for the converted data in the target field. Defaults to `yyyy-MM-dd'T'HH:mm:ss.SSS'Z`.
        """
        target_timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time zone of the target field. Defaults to `UTC`.
        """
elif False:
    LogTransformerTransformerConfigDateTimeConverterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigDateTimeConverterArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 locale: Optional[pulumi.Input[_builtins.str]] = None,
                 source_timezone: Optional[pulumi.Input[_builtins.str]] = None,
                 target_format: Optional[pulumi.Input[_builtins.str]] = None,
                 target_timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] match_patterns: Specifies the list of patterns to match against the `source` field.
        :param pulumi.Input[_builtins.str] source: Specifies the key to apply the date conversion to.
        :param pulumi.Input[_builtins.str] target: Specifies the JSON field to store the result in.
        :param pulumi.Input[_builtins.str] locale: Specifies the locale of the source field. Defaults to `locale.ROOT`.
        :param pulumi.Input[_builtins.str] source_timezone: Specifies the time zone of the source field. Defaults to `UTC`.
        :param pulumi.Input[_builtins.str] target_format: Specifies the datetime format to use for the converted data in the target field. Defaults to `yyyy-MM-dd'T'HH:mm:ss.SSS'Z`.
        :param pulumi.Input[_builtins.str] target_timezone: Specifies the time zone of the target field. Defaults to `UTC`.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if source_timezone is not None:
            pulumi.set(__self__, "source_timezone", source_timezone)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)
        if target_timezone is not None:
            pulumi.set(__self__, "target_timezone", target_timezone)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of patterns to match against the `source` field.
        """
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to apply the date conversion to.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the JSON field to store the result in.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the locale of the source field. Defaults to `locale.ROOT`.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locale", value)

    @_builtins.property
    @pulumi.getter(name="sourceTimezone")
    def source_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time zone of the source field. Defaults to `UTC`.
        """
        return pulumi.get(self, "source_timezone")

    @source_timezone.setter
    def source_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_timezone", value)

    @_builtins.property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the datetime format to use for the converted data in the target field. Defaults to `yyyy-MM-dd'T'HH:mm:ss.SSS'Z`.
        """
        return pulumi.get(self, "target_format")

    @target_format.setter
    def target_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_format", value)

    @_builtins.property
    @pulumi.getter(name="targetTimezone")
    def target_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time zone of the target field. Defaults to `UTC`.
        """
        return pulumi.get(self, "target_timezone")

    @target_timezone.setter
    def target_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_timezone", value)


if not MYPY:
    class LogTransformerTransformerConfigDeleteKeyArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the keys to be deleted.
        """
elif False:
    LogTransformerTransformerConfigDeleteKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigDeleteKeyArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] with_keys: Specifies the keys to be deleted.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the keys to be deleted.
        """
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigGrokArgsDict(TypedDict):
        match: pulumi.Input[_builtins.str]
        """
        Specifies the grok pattern to match against the log event.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigGrokArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigGrokArgs:
    def __init__(__self__, *,
                 match: pulumi.Input[_builtins.str],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] match: Specifies the grok pattern to match against the log event.
        :param pulumi.Input[_builtins.str] source: Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
        pulumi.set(__self__, "match", match)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the grok pattern to match against the log event.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to the field in the log event that has the comma separated values to be parsed. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigListToMapArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key of the field to be extracted as keys in the generated map.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key in the log event that has a list of objects that will be converted to a map.
        """
        flatten: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the list will be flattened into single items. Defaults to `false`.
        """
        flattened_element: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required if `flatten` is set to true. Specifies the element to keep. Allowed values are `first` and `last`.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key of the field that will hold the generated map.
        """
        value_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the values that will be extracted from the source objects and put into the values of the generated map. If omitted, original objects in the source list will be put into the values of the generated map.
        """
elif False:
    LogTransformerTransformerConfigListToMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigListToMapArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 flatten: Optional[pulumi.Input[_builtins.bool]] = None,
                 flattened_element: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key of the field to be extracted as keys in the generated map.
        :param pulumi.Input[_builtins.str] source: Specifies the key in the log event that has a list of objects that will be converted to a map.
        :param pulumi.Input[_builtins.bool] flatten: Specifies whether the list will be flattened into single items. Defaults to `false`.
        :param pulumi.Input[_builtins.str] flattened_element: Required if `flatten` is set to true. Specifies the element to keep. Allowed values are `first` and `last`.
        :param pulumi.Input[_builtins.str] target: Specifies the key of the field that will hold the generated map.
        :param pulumi.Input[_builtins.str] value_key: Specifies the values that will be extracted from the source objects and put into the values of the generated map. If omitted, original objects in the source list will be put into the values of the generated map.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if flatten is not None:
            pulumi.set(__self__, "flatten", flatten)
        if flattened_element is not None:
            pulumi.set(__self__, "flattened_element", flattened_element)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value_key is not None:
            pulumi.set(__self__, "value_key", value_key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key of the field to be extracted as keys in the generated map.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key in the log event that has a list of objects that will be converted to a map.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def flatten(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the list will be flattened into single items. Defaults to `false`.
        """
        return pulumi.get(self, "flatten")

    @flatten.setter
    def flatten(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten", value)

    @_builtins.property
    @pulumi.getter(name="flattenedElement")
    def flattened_element(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if `flatten` is set to true. Specifies the element to keep. Allowed values are `first` and `last`.
        """
        return pulumi.get(self, "flattened_element")

    @flattened_element.setter
    def flattened_element(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flattened_element", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key of the field that will hold the generated map.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the values that will be extracted from the source objects and put into the values of the generated map. If omitted, original objects in the source list will be put into the values of the generated map.
        """
        return pulumi.get(self, "value_key")

    @value_key.setter
    def value_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_key", value)


if not MYPY:
    class LogTransformerTransformerConfigLowerCaseStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the keys of the fields to convert to lowercase.
        """
elif False:
    LogTransformerTransformerConfigLowerCaseStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigLowerCaseStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] with_keys: Specifies the keys of the fields to convert to lowercase.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the keys of the fields to convert to lowercase.
        """
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigMoveKeyArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgsDict']]]
        """
        Objects containing the information about the keys to move to the log event. You must include at least one entry, and five at most. See `move_keys` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigMoveKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigMoveKeyArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]] entries: Objects containing the information about the keys to move to the log event. You must include at least one entry, and five at most. See `move_keys` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]:
        """
        Objects containing the information about the keys to move to the log event. You must include at least one entry, and five at most. See `move_keys` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigMoveKeyEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key to modify.
        """
        target: pulumi.Input[_builtins.str]
        """
        Specifies the key to move to.
        """
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
elif False:
    LogTransformerTransformerConfigMoveKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigMoveKeyEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the key to modify.
        :param pulumi.Input[_builtins.str] target: Specifies the key to move to.
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
               * `renameTo` - (Required) Specifies the new name of the key.
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to modify.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to move to.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigParseCloudfrontArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParseCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseCloudfrontArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseJsonArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the location to put the parsed key value pair into. If omitted, it will be placed under the root node.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
elif False:
    LogTransformerTransformerConfigParseJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseJsonArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the location to put the parsed key value pair into. If omitted, it will be placed under the root node.
        :param pulumi.Input[_builtins.str] source: Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the location to put the parsed key value pair into. If omitted, it will be placed under the root node.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseKeyValueArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination field to put the extracted key-value pairs into.
        """
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the field delimiter string that is used between key-value pairs in the original log events. Defaults to the ampersand `&` character.
        """
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a prefix that will be added to all transformed keys.
        """
        key_value_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the delimiter string to use between the key and value in each pair in the transformed log event. Defaults to the equal `=` character.
        """
        non_match_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a value to insert into the value field in the result if a key-value pair is not successfully split.
        """
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
elif False:
    LogTransformerTransformerConfigParseKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseKeyValueArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 key_value_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 non_match_value: Optional[pulumi.Input[_builtins.str]] = None,
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the destination field to put the extracted key-value pairs into.
        :param pulumi.Input[_builtins.str] field_delimiter: Specifies the field delimiter string that is used between key-value pairs in the original log events. Defaults to the ampersand `&` character.
        :param pulumi.Input[_builtins.str] key_prefix: Specifies a prefix that will be added to all transformed keys.
        :param pulumi.Input[_builtins.str] key_value_delimiter: Specifies the delimiter string to use between the key and value in each pair in the transformed log event. Defaults to the equal `=` character.
        :param pulumi.Input[_builtins.str] non_match_value: Specifies a value to insert into the value field in the result if a key-value pair is not successfully split.
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        :param pulumi.Input[_builtins.str] source: Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if key_value_delimiter is not None:
            pulumi.set(__self__, "key_value_delimiter", key_value_delimiter)
        if non_match_value is not None:
            pulumi.set(__self__, "non_match_value", non_match_value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination field to put the extracted key-value pairs into.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the field delimiter string that is used between key-value pairs in the original log events. Defaults to the ampersand `&` character.
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a prefix that will be added to all transformed keys.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="keyValueDelimiter")
    def key_value_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the delimiter string to use between the key and value in each pair in the transformed log event. Defaults to the equal `=` character.
        """
        return pulumi.get(self, "key_value_delimiter")

    @key_value_delimiter.setter
    def key_value_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_value_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="nonMatchValue")
    def non_match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a value to insert into the value field in the result if a key-value pair is not successfully split.
        """
        return pulumi.get(self, "non_match_value")

    @non_match_value.setter
    def non_match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "non_match_value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to the field in the log event that will be parsed. Defaults to `@message`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParsePostgresArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParsePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParsePostgresArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseRoute53ArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParseRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseRoute53Args:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseToOcsfArgsDict(TypedDict):
        event_source: pulumi.Input[_builtins.str]
        ocsf_version: pulumi.Input[_builtins.str]
        """
        Specifies the version of the OCSF schema to use for the transformed log events. The only allowed value is `V1.1`.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParseToOcsfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseToOcsfArgs:
    def __init__(__self__, *,
                 event_source: pulumi.Input[_builtins.str],
                 ocsf_version: pulumi.Input[_builtins.str],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ocsf_version: Specifies the version of the OCSF schema to use for the transformed log events. The only allowed value is `V1.1`.
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "ocsf_version", ocsf_version)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="ocsfVersion")
    def ocsf_version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the version of the OCSF schema to use for the transformed log events. The only allowed value is `V1.1`.
        """
        return pulumi.get(self, "ocsf_version")

    @ocsf_version.setter
    def ocsf_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ocsf_version", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseVpcArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParseVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseVpcArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseWafArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
elif False:
    LogTransformerTransformerConfigParseWafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseWafArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source field to be parsed. The only allowed value is `@message`. If omitted, the whole log message is processed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigRenameKeyArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgsDict']]]
        """
        Objects containing the information about the keys to rename. You must include at least one entry, and five at most. See `rename_keys` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigRenameKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigRenameKeyArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]] entries: Objects containing the information about the keys to rename. You must include at least one entry, and five at most. See `rename_keys` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]:
        """
        Objects containing the information about the keys to rename. You must include at least one entry, and five at most. See `rename_keys` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigRenameKeyEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key with the value that will be converted to a different type.
        """
        rename_to: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
elif False:
    LogTransformerTransformerConfigRenameKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigRenameKeyEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 rename_to: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key with the value that will be converted to a different type.
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
               * `renameTo` - (Required) Specifies the new name of the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "rename_to", rename_to)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key with the value that will be converted to a different type.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="renameTo")
    def rename_to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "rename_to")

    @rename_to.setter
    def rename_to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rename_to", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the destination key already exists. Defaults to `false`.
        * `renameTo` - (Required) Specifies the new name of the key.
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigSplitStringArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgsDict']]]
        """
        Objects containing the information about the fields to split. You must include at least one entry, and ten at most. See `split_string` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigSplitStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSplitStringArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]] entries: Objects containing the information about the fields to split. You must include at least one entry, and ten at most. See `split_string` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]:
        """
        Objects containing the information about the fields to split. You must include at least one entry, and ten at most. See `split_string` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigSplitStringEntryArgsDict(TypedDict):
        delimiter: pulumi.Input[_builtins.str]
        """
        Specifies the separator characters to split the string entry on.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key to modify.
        """
elif False:
    LogTransformerTransformerConfigSplitStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSplitStringEntryArgs:
    def __init__(__self__, *,
                 delimiter: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] delimiter: Specifies the separator characters to split the string entry on.
        :param pulumi.Input[_builtins.str] source: Specifies the key to modify.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the separator characters to split the string entry on.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to modify.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigSubstituteStringArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgsDict']]]
        """
        Objects containing the information about the fields to substitute. You must include at least one entry, and ten at most. See `substitute_string` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigSubstituteStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSubstituteStringArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]] entries: Objects containing the information about the fields to substitute. You must include at least one entry, and ten at most. See `substitute_string` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]:
        """
        Objects containing the information about the fields to substitute. You must include at least one entry, and ten at most. See `substitute_string` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigSubstituteStringEntryArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        Specifies the regular expression string to be replaced.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the key to modify.
        """
        to: pulumi.Input[_builtins.str]
        """
        Specifies the string to be substituted for each match of `from`.
        """
elif False:
    LogTransformerTransformerConfigSubstituteStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSubstituteStringEntryArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] from_: Specifies the regular expression string to be replaced.
        :param pulumi.Input[_builtins.str] source: Specifies the key to modify.
        :param pulumi.Input[_builtins.str] to: Specifies the string to be substituted for each match of `from`.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the regular expression string to be replaced.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key to modify.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the string to be substituted for each match of `from`.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class LogTransformerTransformerConfigTrimStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the keys of the fields to trim.
        """
elif False:
    LogTransformerTransformerConfigTrimStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTrimStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] with_keys: Specifies the keys of the fields to trim.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the keys of the fields to trim.
        """
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigTypeConverterArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgsDict']]]
        """
        Objects containing the information about the fields to change the type of. You must include at least one entry, and five at most. See `type_converter` `entry` below for details.
        """
elif False:
    LogTransformerTransformerConfigTypeConverterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTypeConverterArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]] entries: Objects containing the information about the fields to change the type of. You must include at least one entry, and five at most. See `type_converter` `entry` below for details.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]:
        """
        Objects containing the information about the fields to change the type of. You must include at least one entry, and five at most. See `type_converter` `entry` below for details.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigTypeConverterEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key with the value that will be converted to a different type.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type to convert the field value to. Allowed values are: `integer`, `double`, `string` and `boolean`.
        """
elif False:
    LogTransformerTransformerConfigTypeConverterEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTypeConverterEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key with the value that will be converted to a different type.
        :param pulumi.Input[_builtins.str] type: Specifies the type to convert the field value to. Allowed values are: `integer`, `double`, `string` and `boolean`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key with the value that will be converted to a different type.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type to convert the field value to. Allowed values are: `integer`, `double`, `string` and `boolean`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogTransformerTransformerConfigUpperCaseStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the keys of the fields to convert to uppercase.
        """
elif False:
    LogTransformerTransformerConfigUpperCaseStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigUpperCaseStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] with_keys: Specifies the keys of the fields to convert to uppercase.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the keys of the fields to convert to uppercase.
        """
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class MetricAlarmMetricQueryArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the account where the metrics are located, if this is a cross-account alarm.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Metrics Insights query or a metric math expression to be evaluated on the returned data.
        For details about Metrics Insights queries, see [Metrics Insights query components and syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-metrics-insights-querylanguage) in the AWS documentation.
        For details about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the AWS documentation.
        """
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
        """
        metric: NotRequired[pulumi.Input['MetricAlarmMetricQueryMetricArgsDict']]
        """
        The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Granularity in seconds of returned data points.
        For metrics with regular resolution, valid values are any multiple of `60`.
        For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        """
        return_data: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specify exactly one `metric_query` to be `true` to use that `metric_query` result as the alarm.

        > **NOTE:**  You must specify either `metric` or `expression`. Not both.
        """
elif False:
    MetricAlarmMetricQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlarmMetricQueryArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 return_data: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] id: A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        :param pulumi.Input[_builtins.str] account_id: The ID of the account where the metrics are located, if this is a cross-account alarm.
        :param pulumi.Input[_builtins.str] expression: A Metrics Insights query or a metric math expression to be evaluated on the returned data.
               For details about Metrics Insights queries, see [Metrics Insights query components and syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-metrics-insights-querylanguage) in the AWS documentation.
               For details about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the AWS documentation.
        :param pulumi.Input[_builtins.str] label: A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
        :param pulumi.Input['MetricAlarmMetricQueryMetricArgs'] metric: The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
        :param pulumi.Input[_builtins.int] period: Granularity in seconds of returned data points.
               For metrics with regular resolution, valid values are any multiple of `60`.
               For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        :param pulumi.Input[_builtins.bool] return_data: Specify exactly one `metric_query` to be `true` to use that `metric_query` result as the alarm.
               
               > **NOTE:**  You must specify either `metric` or `expression`. Not both.
        """
        pulumi.set(__self__, "id", id)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        A short name used to tie this object to the results in the response. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the account where the metrics are located, if this is a cross-account alarm.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Metrics Insights query or a metric math expression to be evaluated on the returned data.
        For details about Metrics Insights queries, see [Metrics Insights query components and syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-metrics-insights-querylanguage) in the AWS documentation.
        For details about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the AWS documentation.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']]:
        """
        The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Granularity in seconds of returned data points.
        For metrics with regular resolution, valid values are any multiple of `60`.
        For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specify exactly one `metric_query` to be `true` to use that `metric_query` result as the alarm.

        > **NOTE:**  You must specify either `metric` or `expression`. Not both.
        """
        return pulumi.get(self, "return_data")

    @return_data.setter
    def return_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_data", value)


if not MYPY:
    class MetricAlarmMetricQueryMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        """
        The name for this metric.
        See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        period: pulumi.Input[_builtins.int]
        """
        Granularity in seconds of returned data points.
        For metrics with regular resolution, valid values are any multiple of `60`.
        For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        """
        stat: pulumi.Input[_builtins.str]
        """
        The statistic to apply to this metric.
        See docs for [supported statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
        See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unit for this metric.
        """
elif False:
    MetricAlarmMetricQueryMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlarmMetricQueryMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.int],
                 stat: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_name: The name for this metric.
               See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        :param pulumi.Input[_builtins.int] period: Granularity in seconds of returned data points.
               For metrics with regular resolution, valid values are any multiple of `60`.
               For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        :param pulumi.Input[_builtins.str] stat: The statistic to apply to this metric.
               See docs for [supported statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] dimensions: The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        :param pulumi.Input[_builtins.str] namespace: The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
               See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        :param pulumi.Input[_builtins.str] unit: The unit for this metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "stat", stat)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name for this metric.
        See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Granularity in seconds of returned data points.
        For metrics with regular resolution, valid values are any multiple of `60`.
        For high-resolution metrics, valid values are `1`, `5`, `10`, `20`, `30`, or any multiple of `60`.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def stat(self) -> pulumi.Input[_builtins.str]:
        """
        The statistic to apply to this metric.
        See docs for [supported statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stat", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
        See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unit for this metric.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class MetricStreamExcludeFilterArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Name of the metric namespace in the filter.
        """
        metric_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array that defines the metrics you want to exclude for this metric namespace
        """
elif False:
    MetricStreamExcludeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamExcludeFilterArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 metric_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Name of the metric namespace in the filter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metric_names: An array that defines the metrics you want to exclude for this metric namespace
        """
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the metric namespace in the filter.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array that defines the metrics you want to exclude for this metric namespace
        """
        return pulumi.get(self, "metric_names")

    @metric_names.setter
    def metric_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_names", value)


if not MYPY:
    class MetricStreamIncludeFilterArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Name of the metric namespace in the filter.
        """
        metric_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array that defines the metrics you want to include for this metric namespace
        """
elif False:
    MetricStreamIncludeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamIncludeFilterArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 metric_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Name of the metric namespace in the filter.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metric_names: An array that defines the metrics you want to include for this metric namespace
        """
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the metric namespace in the filter.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array that defines the metrics you want to include for this metric namespace
        """
        return pulumi.get(self, "metric_names")

    @metric_names.setter
    def metric_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_names", value)


if not MYPY:
    class MetricStreamStatisticsConfigurationArgsDict(TypedDict):
        additional_statistics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The additional statistics to stream for the metrics listed in `include_metrics`.
        """
        include_metrics: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgsDict']]]
        """
        An array that defines the metrics that are to have additional statistics streamed. See details below.
        """
elif False:
    MetricStreamStatisticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamStatisticsConfigurationArgs:
    def __init__(__self__, *,
                 additional_statistics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 include_metrics: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] additional_statistics: The additional statistics to stream for the metrics listed in `include_metrics`.
        :param pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]] include_metrics: An array that defines the metrics that are to have additional statistics streamed. See details below.
        """
        pulumi.set(__self__, "additional_statistics", additional_statistics)
        pulumi.set(__self__, "include_metrics", include_metrics)

    @_builtins.property
    @pulumi.getter(name="additionalStatistics")
    def additional_statistics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The additional statistics to stream for the metrics listed in `include_metrics`.
        """
        return pulumi.get(self, "additional_statistics")

    @additional_statistics.setter
    def additional_statistics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "additional_statistics", value)

    @_builtins.property
    @pulumi.getter(name="includeMetrics")
    def include_metrics(self) -> pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]:
        """
        An array that defines the metrics that are to have additional statistics streamed. See details below.
        """
        return pulumi.get(self, "include_metrics")

    @include_metrics.setter
    def include_metrics(self, value: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]):
        pulumi.set(self, "include_metrics", value)


if not MYPY:
    class MetricStreamStatisticsConfigurationIncludeMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        """
        The name of the metric.
        """
        namespace: pulumi.Input[_builtins.str]
elif False:
    MetricStreamStatisticsConfigurationIncludeMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamStatisticsConfigurationIncludeMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metric_name: The name of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PolicyDocumentArgsDict(TypedDict):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgsDict']]]
        version: pulumi.Input['iam.PolicyDocumentVersion']
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PolicyDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDocumentArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]],
                 version: pulumi.Input['iam.PolicyDocumentVersion'],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="Statement")
    def statement(self) -> pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter(name="Version")
    def version(self) -> pulumi.Input['iam.PolicyDocumentVersion']:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input['iam.PolicyDocumentVersion']):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentConfigurationArgsDict(TypedDict):
        custom_data_identifiers: NotRequired[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict']]
        """
        Configures custom regular expressions to detect sensitive data. Read more in [Custom data identifiers](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL-custom-data-identifiers.html).
        """
elif False:
    GetLogDataProtectionPolicyDocumentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentConfigurationArgs:
    def __init__(__self__, *,
                 custom_data_identifiers: Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']] = None):
        """
        :param Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs'] custom_data_identifiers: Configures custom regular expressions to detect sensitive data. Read more in [Custom data identifiers](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL-custom-data-identifiers.html).
        """
        if custom_data_identifiers is not None:
            pulumi.set(__self__, "custom_data_identifiers", custom_data_identifiers)

    @_builtins.property
    @pulumi.getter(name="customDataIdentifiers")
    def custom_data_identifiers(self) -> Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']]:
        """
        Configures custom regular expressions to detect sensitive data. Read more in [Custom data identifiers](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL-custom-data-identifiers.html).
        """
        return pulumi.get(self, "custom_data_identifiers")

    @custom_data_identifiers.setter
    def custom_data_identifiers(self, value: Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']]):
        pulumi.set(self, "custom_data_identifiers", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the custom data idenfitier
        """
        regex: _builtins.str
        """
        Regular expression to match sensitive data
        """
elif False:
    GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str name: Name of the custom data idenfitier
        :param _builtins.str regex: Regular expression to match sensitive data
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the custom data idenfitier
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Regular expression to match sensitive data
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: _builtins.str):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementArgsDict(TypedDict):
        data_identifiers: Sequence[_builtins.str]
        """
        Set of at least 1 sensitive data identifiers that you want to mask. Read more in [Types of data that you can protect](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/protect-sensitive-log-data-types.html).
        """
        operation: 'GetLogDataProtectionPolicyDocumentStatementOperationArgsDict'
        """
        Configures the data protection operation applied by this statement.
        """
        sid: NotRequired[_builtins.str]
        """
        Name of this statement.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementArgs:
    def __init__(__self__, *,
                 data_identifiers: Sequence[_builtins.str],
                 operation: 'GetLogDataProtectionPolicyDocumentStatementOperationArgs',
                 sid: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] data_identifiers: Set of at least 1 sensitive data identifiers that you want to mask. Read more in [Types of data that you can protect](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/protect-sensitive-log-data-types.html).
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationArgs' operation: Configures the data protection operation applied by this statement.
        :param _builtins.str sid: Name of this statement.
        """
        pulumi.set(__self__, "data_identifiers", data_identifiers)
        pulumi.set(__self__, "operation", operation)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)

    @_builtins.property
    @pulumi.getter(name="dataIdentifiers")
    def data_identifiers(self) -> Sequence[_builtins.str]:
        """
        Set of at least 1 sensitive data identifiers that you want to mask. Read more in [Types of data that you can protect](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/protect-sensitive-log-data-types.html).
        """
        return pulumi.get(self, "data_identifiers")

    @data_identifiers.setter
    def data_identifiers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "data_identifiers", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationArgs':
        """
        Configures the data protection operation applied by this statement.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationArgs'):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[_builtins.str]:
        """
        Name of this statement.
        """
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sid", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationArgsDict(TypedDict):
        audit: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict']
        """
        Configures the detection of sensitive data.
        """
        deidentify: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict']
        """
        Configures the masking of sensitive data.

        > Every policy statement must specify exactly one operation.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationArgs:
    def __init__(__self__, *,
                 audit: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs'] = None,
                 deidentify: Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs'] = None):
        """
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs' audit: Configures the detection of sensitive data.
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs' deidentify: Configures the masking of sensitive data.
               
               > Every policy statement must specify exactly one operation.
        """
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if deidentify is not None:
            pulumi.set(__self__, "deidentify", deidentify)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs']:
        """
        Configures the detection of sensitive data.
        """
        return pulumi.get(self, "audit")

    @audit.setter
    def audit(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs']):
        pulumi.set(self, "audit", value)

    @_builtins.property
    @pulumi.getter
    def deidentify(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs']:
        """
        Configures the masking of sensitive data.

        > Every policy statement must specify exactly one operation.
        """
        return pulumi.get(self, "deidentify")

    @deidentify.setter
    def deidentify(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs']):
        pulumi.set(self, "deidentify", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict(TypedDict):
        findings_destination: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict'
        """
        Configures destinations to send audit findings to.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs:
    def __init__(__self__, *,
                 findings_destination: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs'):
        """
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs' findings_destination: Configures destinations to send audit findings to.
        """
        pulumi.set(__self__, "findings_destination", findings_destination)

    @_builtins.property
    @pulumi.getter(name="findingsDestination")
    def findings_destination(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs':
        """
        Configures destinations to send audit findings to.
        """
        return pulumi.get(self, "findings_destination")

    @findings_destination.setter
    def findings_destination(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs'):
        pulumi.set(self, "findings_destination", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict(TypedDict):
        cloudwatch_logs: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict']
        """
        Configures CloudWatch Logs as a findings destination.
        """
        firehose: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict']
        """
        Configures Kinesis Firehose as a findings destination.
        """
        s3: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict']
        """
        Configures S3 as a findings destination.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs'] = None,
                 firehose: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs'] = None,
                 s3: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args'] = None):
        """
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs' cloudwatch_logs: Configures CloudWatch Logs as a findings destination.
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs' firehose: Configures Kinesis Firehose as a findings destination.
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args' s3: Configures S3 as a findings destination.
        """
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs']:
        """
        Configures CloudWatch Logs as a findings destination.
        """
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs']):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs']:
        """
        Configures Kinesis Firehose as a findings destination.
        """
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs']):
        pulumi.set(self, "firehose", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args']:
        """
        Configures S3 as a findings destination.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict(TypedDict):
        log_group: _builtins.str
        """
        Name of the CloudWatch Log Group to send findings to.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group: _builtins.str):
        """
        :param _builtins.str log_group: Name of the CloudWatch Log Group to send findings to.
        """
        pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> _builtins.str:
        """
        Name of the CloudWatch Log Group to send findings to.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: _builtins.str):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict(TypedDict):
        delivery_stream: _builtins.str
        """
        Name of the Kinesis Firehose Delivery Stream to send findings to.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream: _builtins.str):
        """
        :param _builtins.str delivery_stream: Name of the Kinesis Firehose Delivery Stream to send findings to.
        """
        pulumi.set(__self__, "delivery_stream", delivery_stream)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> _builtins.str:
        """
        Name of the Kinesis Firehose Delivery Stream to send findings to.
        """
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: _builtins.str):
        pulumi.set(self, "delivery_stream", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict(TypedDict):
        bucket: _builtins.str
        """
        Name of the S3 Bucket to send findings to.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args:
    def __init__(__self__, *,
                 bucket: _builtins.str):
        """
        :param _builtins.str bucket: Name of the S3 Bucket to send findings to.
        """
        pulumi.set(__self__, "bucket", bucket)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the S3 Bucket to send findings to.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: _builtins.str):
        pulumi.set(self, "bucket", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict(TypedDict):
        mask_config: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict'
        """
        An empty object that configures masking.
        """
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs:
    def __init__(__self__, *,
                 mask_config: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs'):
        """
        :param 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs' mask_config: An empty object that configures masking.
        """
        pulumi.set(__self__, "mask_config", mask_config)

    @_builtins.property
    @pulumi.getter(name="maskConfig")
    def mask_config(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs':
        """
        An empty object that configures masking.
        """
        return pulumi.get(self, "mask_config")

    @mask_config.setter
    def mask_config(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs'):
        pulumi.set(self, "mask_config", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict(TypedDict):
        pass
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs:
    def __init__(__self__):
        pass


