# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from .. import iam
from .. import iam as _iam

__all__ = [
    'CompositeAlarmActionsSuppressorArgs',
    'CompositeAlarmActionsSuppressorArgsDict',
    'EventBusDeadLetterConfigArgs',
    'EventBusDeadLetterConfigArgsDict',
    'EventBusLogConfigArgs',
    'EventBusLogConfigArgsDict',
    'EventConnectionAuthParametersArgs',
    'EventConnectionAuthParametersArgsDict',
    'EventConnectionAuthParametersApiKeyArgs',
    'EventConnectionAuthParametersApiKeyArgsDict',
    'EventConnectionAuthParametersBasicArgs',
    'EventConnectionAuthParametersBasicArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersArgs',
    'EventConnectionAuthParametersInvocationHttpParametersArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersBodyArgs',
    'EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersHeaderArgs',
    'EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict',
    'EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs',
    'EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict',
    'EventConnectionAuthParametersOauthArgs',
    'EventConnectionAuthParametersOauthArgsDict',
    'EventConnectionAuthParametersOauthClientParametersArgs',
    'EventConnectionAuthParametersOauthClientParametersArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict',
    'EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs',
    'EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict',
    'EventConnectionInvocationConnectivityParametersArgs',
    'EventConnectionInvocationConnectivityParametersArgsDict',
    'EventConnectionInvocationConnectivityParametersResourceParametersArgs',
    'EventConnectionInvocationConnectivityParametersResourceParametersArgsDict',
    'EventEndpointEventBusArgs',
    'EventEndpointEventBusArgsDict',
    'EventEndpointReplicationConfigArgs',
    'EventEndpointReplicationConfigArgsDict',
    'EventEndpointRoutingConfigArgs',
    'EventEndpointRoutingConfigArgsDict',
    'EventEndpointRoutingConfigFailoverConfigArgs',
    'EventEndpointRoutingConfigFailoverConfigArgsDict',
    'EventEndpointRoutingConfigFailoverConfigPrimaryArgs',
    'EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict',
    'EventEndpointRoutingConfigFailoverConfigSecondaryArgs',
    'EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict',
    'EventPermissionConditionArgs',
    'EventPermissionConditionArgsDict',
    'EventTargetAppsyncTargetArgs',
    'EventTargetAppsyncTargetArgsDict',
    'EventTargetBatchTargetArgs',
    'EventTargetBatchTargetArgsDict',
    'EventTargetDeadLetterConfigArgs',
    'EventTargetDeadLetterConfigArgsDict',
    'EventTargetEcsTargetArgs',
    'EventTargetEcsTargetArgsDict',
    'EventTargetEcsTargetCapacityProviderStrategyArgs',
    'EventTargetEcsTargetCapacityProviderStrategyArgsDict',
    'EventTargetEcsTargetNetworkConfigurationArgs',
    'EventTargetEcsTargetNetworkConfigurationArgsDict',
    'EventTargetEcsTargetOrderedPlacementStrategyArgs',
    'EventTargetEcsTargetOrderedPlacementStrategyArgsDict',
    'EventTargetEcsTargetPlacementConstraintArgs',
    'EventTargetEcsTargetPlacementConstraintArgsDict',
    'EventTargetHttpTargetArgs',
    'EventTargetHttpTargetArgsDict',
    'EventTargetInputTransformerArgs',
    'EventTargetInputTransformerArgsDict',
    'EventTargetKinesisTargetArgs',
    'EventTargetKinesisTargetArgsDict',
    'EventTargetRedshiftTargetArgs',
    'EventTargetRedshiftTargetArgsDict',
    'EventTargetRetryPolicyArgs',
    'EventTargetRetryPolicyArgsDict',
    'EventTargetRunCommandTargetArgs',
    'EventTargetRunCommandTargetArgsDict',
    'EventTargetSagemakerPipelineTargetArgs',
    'EventTargetSagemakerPipelineTargetArgsDict',
    'EventTargetSagemakerPipelineTargetPipelineParameterListArgs',
    'EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict',
    'EventTargetSqsTargetArgs',
    'EventTargetSqsTargetArgsDict',
    'InternetMonitorHealthEventsConfigArgs',
    'InternetMonitorHealthEventsConfigArgsDict',
    'InternetMonitorInternetMeasurementsLogDeliveryArgs',
    'InternetMonitorInternetMeasurementsLogDeliveryArgsDict',
    'InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs',
    'InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict',
    'LogDeliveryDestinationDeliveryDestinationConfigurationArgs',
    'LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict',
    'LogDeliveryS3DeliveryConfigurationArgs',
    'LogDeliveryS3DeliveryConfigurationArgsDict',
    'LogMetricFilterMetricTransformationArgs',
    'LogMetricFilterMetricTransformationArgsDict',
    'LogTransformerTransformerConfigArgs',
    'LogTransformerTransformerConfigArgsDict',
    'LogTransformerTransformerConfigAddKeysArgs',
    'LogTransformerTransformerConfigAddKeysArgsDict',
    'LogTransformerTransformerConfigAddKeysEntryArgs',
    'LogTransformerTransformerConfigAddKeysEntryArgsDict',
    'LogTransformerTransformerConfigCopyValueArgs',
    'LogTransformerTransformerConfigCopyValueArgsDict',
    'LogTransformerTransformerConfigCopyValueEntryArgs',
    'LogTransformerTransformerConfigCopyValueEntryArgsDict',
    'LogTransformerTransformerConfigCsvArgs',
    'LogTransformerTransformerConfigCsvArgsDict',
    'LogTransformerTransformerConfigDateTimeConverterArgs',
    'LogTransformerTransformerConfigDateTimeConverterArgsDict',
    'LogTransformerTransformerConfigDeleteKeyArgs',
    'LogTransformerTransformerConfigDeleteKeyArgsDict',
    'LogTransformerTransformerConfigGrokArgs',
    'LogTransformerTransformerConfigGrokArgsDict',
    'LogTransformerTransformerConfigListToMapArgs',
    'LogTransformerTransformerConfigListToMapArgsDict',
    'LogTransformerTransformerConfigLowerCaseStringArgs',
    'LogTransformerTransformerConfigLowerCaseStringArgsDict',
    'LogTransformerTransformerConfigMoveKeyArgs',
    'LogTransformerTransformerConfigMoveKeyArgsDict',
    'LogTransformerTransformerConfigMoveKeyEntryArgs',
    'LogTransformerTransformerConfigMoveKeyEntryArgsDict',
    'LogTransformerTransformerConfigParseCloudfrontArgs',
    'LogTransformerTransformerConfigParseCloudfrontArgsDict',
    'LogTransformerTransformerConfigParseJsonArgs',
    'LogTransformerTransformerConfigParseJsonArgsDict',
    'LogTransformerTransformerConfigParseKeyValueArgs',
    'LogTransformerTransformerConfigParseKeyValueArgsDict',
    'LogTransformerTransformerConfigParsePostgresArgs',
    'LogTransformerTransformerConfigParsePostgresArgsDict',
    'LogTransformerTransformerConfigParseRoute53Args',
    'LogTransformerTransformerConfigParseRoute53ArgsDict',
    'LogTransformerTransformerConfigParseToOcsfArgs',
    'LogTransformerTransformerConfigParseToOcsfArgsDict',
    'LogTransformerTransformerConfigParseVpcArgs',
    'LogTransformerTransformerConfigParseVpcArgsDict',
    'LogTransformerTransformerConfigParseWafArgs',
    'LogTransformerTransformerConfigParseWafArgsDict',
    'LogTransformerTransformerConfigRenameKeyArgs',
    'LogTransformerTransformerConfigRenameKeyArgsDict',
    'LogTransformerTransformerConfigRenameKeyEntryArgs',
    'LogTransformerTransformerConfigRenameKeyEntryArgsDict',
    'LogTransformerTransformerConfigSplitStringArgs',
    'LogTransformerTransformerConfigSplitStringArgsDict',
    'LogTransformerTransformerConfigSplitStringEntryArgs',
    'LogTransformerTransformerConfigSplitStringEntryArgsDict',
    'LogTransformerTransformerConfigSubstituteStringArgs',
    'LogTransformerTransformerConfigSubstituteStringArgsDict',
    'LogTransformerTransformerConfigSubstituteStringEntryArgs',
    'LogTransformerTransformerConfigSubstituteStringEntryArgsDict',
    'LogTransformerTransformerConfigTrimStringArgs',
    'LogTransformerTransformerConfigTrimStringArgsDict',
    'LogTransformerTransformerConfigTypeConverterArgs',
    'LogTransformerTransformerConfigTypeConverterArgsDict',
    'LogTransformerTransformerConfigTypeConverterEntryArgs',
    'LogTransformerTransformerConfigTypeConverterEntryArgsDict',
    'LogTransformerTransformerConfigUpperCaseStringArgs',
    'LogTransformerTransformerConfigUpperCaseStringArgsDict',
    'MetricAlarmMetricQueryArgs',
    'MetricAlarmMetricQueryArgsDict',
    'MetricAlarmMetricQueryMetricArgs',
    'MetricAlarmMetricQueryMetricArgsDict',
    'MetricStreamExcludeFilterArgs',
    'MetricStreamExcludeFilterArgsDict',
    'MetricStreamIncludeFilterArgs',
    'MetricStreamIncludeFilterArgsDict',
    'MetricStreamStatisticsConfigurationArgs',
    'MetricStreamStatisticsConfigurationArgsDict',
    'MetricStreamStatisticsConfigurationIncludeMetricArgs',
    'MetricStreamStatisticsConfigurationIncludeMetricArgsDict',
    'PolicyDocumentArgs',
    'PolicyDocumentArgsDict',
    'GetLogDataProtectionPolicyDocumentConfigurationArgs',
    'GetLogDataProtectionPolicyDocumentConfigurationArgsDict',
    'GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs',
    'GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementArgs',
    'GetLogDataProtectionPolicyDocumentStatementArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args',
    'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs',
    'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict',
]

MYPY = False

if not MYPY:
    class CompositeAlarmActionsSuppressorArgsDict(TypedDict):
        alarm: pulumi.Input[_builtins.str]
        extension_period: pulumi.Input[_builtins.int]
        wait_period: pulumi.Input[_builtins.int]
elif False:
    CompositeAlarmActionsSuppressorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompositeAlarmActionsSuppressorArgs:
    def __init__(__self__, *,
                 alarm: pulumi.Input[_builtins.str],
                 extension_period: pulumi.Input[_builtins.int],
                 wait_period: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "alarm", alarm)
        pulumi.set(__self__, "extension_period", extension_period)
        pulumi.set(__self__, "wait_period", wait_period)

    @_builtins.property
    @pulumi.getter
    def alarm(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "alarm")

    @alarm.setter
    def alarm(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm", value)

    @_builtins.property
    @pulumi.getter(name="extensionPeriod")
    def extension_period(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "extension_period")

    @extension_period.setter
    def extension_period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "extension_period", value)

    @_builtins.property
    @pulumi.getter(name="waitPeriod")
    def wait_period(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "wait_period")

    @wait_period.setter
    def wait_period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "wait_period", value)


if not MYPY:
    class EventBusDeadLetterConfigArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventBusDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventBusDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class EventBusLogConfigArgsDict(TypedDict):
        include_detail: NotRequired[pulumi.Input[_builtins.str]]
        level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventBusLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventBusLogConfigArgs:
    def __init__(__self__, *,
                 include_detail: Optional[pulumi.Input[_builtins.str]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        if include_detail is not None:
            pulumi.set(__self__, "include_detail", include_detail)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="includeDetail")
    def include_detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_detail")

    @include_detail.setter
    def include_detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_detail", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class EventConnectionAuthParametersArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['EventConnectionAuthParametersApiKeyArgsDict']]
        basic: NotRequired[pulumi.Input['EventConnectionAuthParametersBasicArgsDict']]
        invocation_http_parameters: NotRequired[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgsDict']]
        oauth: NotRequired[pulumi.Input['EventConnectionAuthParametersOauthArgsDict']]
elif False:
    EventConnectionAuthParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']] = None,
                 invocation_http_parameters: Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']] = None,
                 oauth: Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if invocation_http_parameters is not None:
            pulumi.set(__self__, "invocation_http_parameters", invocation_http_parameters)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['EventConnectionAuthParametersApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']]:
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['EventConnectionAuthParametersBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="invocationHttpParameters")
    def invocation_http_parameters(self) -> Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']]:
        return pulumi.get(self, "invocation_http_parameters")

    @invocation_http_parameters.setter
    def invocation_http_parameters(self, value: Optional[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersArgs']]):
        pulumi.set(self, "invocation_http_parameters", value)

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']]:
        return pulumi.get(self, "oauth")

    @oauth.setter
    def oauth(self, value: Optional[pulumi.Input['EventConnectionAuthParametersOauthArgs']]):
        pulumi.set(self, "oauth", value)


if not MYPY:
    class EventConnectionAuthParametersApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    EventConnectionAuthParametersApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        username: pulumi.Input[_builtins.str]
elif False:
    EventConnectionAuthParametersBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersArgsDict(TypedDict):
        bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict']]]]
        query_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict']]]]
elif False:
    EventConnectionAuthParametersInvocationHttpParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersArgs:
    def __init__(__self__, *,
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]] = None,
                 query_strings: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]]:
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]]:
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs']]]]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersInvocationHttpParametersBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersBodyArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersInvocationHttpParametersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersHeaderArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersInvocationHttpParametersQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersInvocationHttpParametersQueryStringArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthArgsDict(TypedDict):
        authorization_endpoint: pulumi.Input[_builtins.str]
        http_method: pulumi.Input[_builtins.str]
        oauth_http_parameters: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgsDict']
        client_parameters: NotRequired[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgsDict']]
elif False:
    EventConnectionAuthParametersOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthArgs:
    def __init__(__self__, *,
                 authorization_endpoint: pulumi.Input[_builtins.str],
                 http_method: pulumi.Input[_builtins.str],
                 oauth_http_parameters: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs'],
                 client_parameters: Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']] = None):
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "oauth_http_parameters", oauth_http_parameters)
        if client_parameters is not None:
            pulumi.set(__self__, "client_parameters", client_parameters)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="oauthHttpParameters")
    def oauth_http_parameters(self) -> pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs']:
        return pulumi.get(self, "oauth_http_parameters")

    @oauth_http_parameters.setter
    def oauth_http_parameters(self, value: pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersArgs']):
        pulumi.set(self, "oauth_http_parameters", value)

    @_builtins.property
    @pulumi.getter(name="clientParameters")
    def client_parameters(self) -> Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']]:
        return pulumi.get(self, "client_parameters")

    @client_parameters.setter
    def client_parameters(self, value: Optional[pulumi.Input['EventConnectionAuthParametersOauthClientParametersArgs']]):
        pulumi.set(self, "client_parameters", value)


if not MYPY:
    class EventConnectionAuthParametersOauthClientParametersArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        client_secret: pulumi.Input[_builtins.str]
elif False:
    EventConnectionAuthParametersOauthClientParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthClientParametersArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersArgsDict(TypedDict):
        bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict']]]]
        query_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict']]]]
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersArgs:
    def __init__(__self__, *,
                 bodies: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]] = None,
                 query_strings: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]] = None):
        if bodies is not None:
            pulumi.set(__self__, "bodies", bodies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)

    @_builtins.property
    @pulumi.getter
    def bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]]:
        return pulumi.get(self, "bodies")

    @bodies.setter
    def bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs']]]]):
        pulumi.set(self, "bodies", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]]:
        return pulumi.get(self, "query_strings")

    @query_strings.setter
    def query_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs']]]]):
        pulumi.set(self, "query_strings", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersBodyArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersHeaderArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict(TypedDict):
        is_value_secret: NotRequired[pulumi.Input[_builtins.bool]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionAuthParametersOauthOauthHttpParametersQueryStringArgs:
    def __init__(__self__, *,
                 is_value_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if is_value_secret is not None:
            pulumi.set(__self__, "is_value_secret", is_value_secret)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="isValueSecret")
    def is_value_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_value_secret")

    @is_value_secret.setter
    def is_value_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_value_secret", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventConnectionInvocationConnectivityParametersArgsDict(TypedDict):
        resource_parameters: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgsDict']
elif False:
    EventConnectionInvocationConnectivityParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionInvocationConnectivityParametersArgs:
    def __init__(__self__, *,
                 resource_parameters: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']):
        pulumi.set(__self__, "resource_parameters", resource_parameters)

    @_builtins.property
    @pulumi.getter(name="resourceParameters")
    def resource_parameters(self) -> pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']:
        return pulumi.get(self, "resource_parameters")

    @resource_parameters.setter
    def resource_parameters(self, value: pulumi.Input['EventConnectionInvocationConnectivityParametersResourceParametersArgs']):
        pulumi.set(self, "resource_parameters", value)


if not MYPY:
    class EventConnectionInvocationConnectivityParametersResourceParametersArgsDict(TypedDict):
        resource_configuration_arn: pulumi.Input[_builtins.str]
        resource_association_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventConnectionInvocationConnectivityParametersResourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventConnectionInvocationConnectivityParametersResourceParametersArgs:
    def __init__(__self__, *,
                 resource_configuration_arn: pulumi.Input[_builtins.str],
                 resource_association_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "resource_configuration_arn", resource_configuration_arn)
        if resource_association_arn is not None:
            pulumi.set(__self__, "resource_association_arn", resource_association_arn)

    @_builtins.property
    @pulumi.getter(name="resourceConfigurationArn")
    def resource_configuration_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_configuration_arn")

    @resource_configuration_arn.setter
    def resource_configuration_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_configuration_arn", value)

    @_builtins.property
    @pulumi.getter(name="resourceAssociationArn")
    def resource_association_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_association_arn")

    @resource_association_arn.setter
    def resource_association_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_association_arn", value)


if not MYPY:
    class EventEndpointEventBusArgsDict(TypedDict):
        event_bus_arn: pulumi.Input[_builtins.str]
elif False:
    EventEndpointEventBusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointEventBusArgs:
    def __init__(__self__, *,
                 event_bus_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "event_bus_arn", event_bus_arn)

    @_builtins.property
    @pulumi.getter(name="eventBusArn")
    def event_bus_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_bus_arn")

    @event_bus_arn.setter
    def event_bus_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_bus_arn", value)


if not MYPY:
    class EventEndpointReplicationConfigArgsDict(TypedDict):
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventEndpointReplicationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointReplicationConfigArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class EventEndpointRoutingConfigArgsDict(TypedDict):
        failover_config: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgsDict']
elif False:
    EventEndpointRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigArgs:
    def __init__(__self__, *,
                 failover_config: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']):
        pulumi.set(__self__, "failover_config", failover_config)

    @_builtins.property
    @pulumi.getter(name="failoverConfig")
    def failover_config(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']:
        return pulumi.get(self, "failover_config")

    @failover_config.setter
    def failover_config(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigArgs']):
        pulumi.set(self, "failover_config", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigArgsDict(TypedDict):
        primary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict']
        secondary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict']
elif False:
    EventEndpointRoutingConfigFailoverConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs'],
                 secondary: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']):
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "secondary", secondary)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs']:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigPrimaryArgs']):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: pulumi.Input['EventEndpointRoutingConfigFailoverConfigSecondaryArgs']):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict(TypedDict):
        health_check: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventEndpointRoutingConfigFailoverConfigPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigPrimaryArgs:
    def __init__(__self__, *,
                 health_check: Optional[pulumi.Input[_builtins.str]] = None):
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "health_check", value)


if not MYPY:
    class EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict(TypedDict):
        route: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventEndpointRoutingConfigFailoverConfigSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventEndpointRoutingConfigFailoverConfigSecondaryArgs:
    def __init__(__self__, *,
                 route: Optional[pulumi.Input[_builtins.str]] = None):
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route", value)


if not MYPY:
    class EventPermissionConditionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    EventPermissionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventPermissionConditionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventTargetAppsyncTargetArgsDict(TypedDict):
        graphql_operation: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetAppsyncTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetAppsyncTargetArgs:
    def __init__(__self__, *,
                 graphql_operation: Optional[pulumi.Input[_builtins.str]] = None):
        if graphql_operation is not None:
            pulumi.set(__self__, "graphql_operation", graphql_operation)

    @_builtins.property
    @pulumi.getter(name="graphqlOperation")
    def graphql_operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "graphql_operation")

    @graphql_operation.setter
    def graphql_operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "graphql_operation", value)


if not MYPY:
    class EventTargetBatchTargetArgsDict(TypedDict):
        job_definition: pulumi.Input[_builtins.str]
        job_name: pulumi.Input[_builtins.str]
        array_size: NotRequired[pulumi.Input[_builtins.int]]
        job_attempts: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    EventTargetBatchTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetBatchTargetArgs:
    def __init__(__self__, *,
                 job_definition: pulumi.Input[_builtins.str],
                 job_name: pulumi.Input[_builtins.str],
                 array_size: Optional[pulumi.Input[_builtins.int]] = None,
                 job_attempts: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "job_definition", job_definition)
        pulumi.set(__self__, "job_name", job_name)
        if array_size is not None:
            pulumi.set(__self__, "array_size", array_size)
        if job_attempts is not None:
            pulumi.set(__self__, "job_attempts", job_attempts)

    @_builtins.property
    @pulumi.getter(name="jobDefinition")
    def job_definition(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "job_definition")

    @job_definition.setter
    def job_definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_definition", value)

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "job_name", value)

    @_builtins.property
    @pulumi.getter(name="arraySize")
    def array_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "array_size")

    @array_size.setter
    def array_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "array_size", value)

    @_builtins.property
    @pulumi.getter(name="jobAttempts")
    def job_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "job_attempts")

    @job_attempts.setter
    def job_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "job_attempts", value)


if not MYPY:
    class EventTargetDeadLetterConfigArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetDeadLetterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetDeadLetterConfigArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class EventTargetEcsTargetArgsDict(TypedDict):
        task_definition_arn: pulumi.Input[_builtins.str]
        capacity_provider_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgsDict']]]]
        enable_ecs_managed_tags: NotRequired[pulumi.Input[_builtins.bool]]
        enable_execute_command: NotRequired[pulumi.Input[_builtins.bool]]
        group: NotRequired[pulumi.Input[_builtins.str]]
        launch_type: NotRequired[pulumi.Input[_builtins.str]]
        network_configuration: NotRequired[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgsDict']]
        ordered_placement_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgsDict']]]]
        placement_constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgsDict']]]]
        platform_version: NotRequired[pulumi.Input[_builtins.str]]
        propagate_tags: NotRequired[pulumi.Input[_builtins.str]]
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        task_count: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    EventTargetEcsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetArgs:
    def __init__(__self__, *,
                 task_definition_arn: pulumi.Input[_builtins.str],
                 capacity_provider_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]] = None,
                 enable_ecs_managed_tags: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_execute_command: Optional[pulumi.Input[_builtins.bool]] = None,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 launch_type: Optional[pulumi.Input[_builtins.str]] = None,
                 network_configuration: Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']] = None,
                 ordered_placement_strategies: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]] = None,
                 placement_constraints: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]] = None,
                 platform_version: Optional[pulumi.Input[_builtins.str]] = None,
                 propagate_tags: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 task_count: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "task_definition_arn", task_definition_arn)
        if capacity_provider_strategies is not None:
            pulumi.set(__self__, "capacity_provider_strategies", capacity_provider_strategies)
        if enable_ecs_managed_tags is not None:
            pulumi.set(__self__, "enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            pulumi.set(__self__, "enable_execute_command", enable_execute_command)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if launch_type is not None:
            pulumi.set(__self__, "launch_type", launch_type)
        if network_configuration is not None:
            pulumi.set(__self__, "network_configuration", network_configuration)
        if ordered_placement_strategies is not None:
            pulumi.set(__self__, "ordered_placement_strategies", ordered_placement_strategies)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @_builtins.property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "task_definition_arn")

    @task_definition_arn.setter
    def task_definition_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "task_definition_arn", value)

    @_builtins.property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]]:
        return pulumi.get(self, "capacity_provider_strategies")

    @capacity_provider_strategies.setter
    def capacity_provider_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetCapacityProviderStrategyArgs']]]]):
        pulumi.set(self, "capacity_provider_strategies", value)

    @_builtins.property
    @pulumi.getter(name="enableEcsManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_ecs_managed_tags")

    @enable_ecs_managed_tags.setter
    def enable_ecs_managed_tags(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_ecs_managed_tags", value)

    @_builtins.property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_execute_command")

    @enable_execute_command.setter
    def enable_execute_command(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_execute_command", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "launch_type")

    @launch_type.setter
    def launch_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_type", value)

    @_builtins.property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']]:
        return pulumi.get(self, "network_configuration")

    @network_configuration.setter
    def network_configuration(self, value: Optional[pulumi.Input['EventTargetEcsTargetNetworkConfigurationArgs']]):
        pulumi.set(self, "network_configuration", value)

    @_builtins.property
    @pulumi.getter(name="orderedPlacementStrategies")
    def ordered_placement_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]]:
        return pulumi.get(self, "ordered_placement_strategies")

    @ordered_placement_strategies.setter
    def ordered_placement_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetOrderedPlacementStrategyArgs']]]]):
        pulumi.set(self, "ordered_placement_strategies", value)

    @_builtins.property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]]:
        return pulumi.get(self, "placement_constraints")

    @placement_constraints.setter
    def placement_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetEcsTargetPlacementConstraintArgs']]]]):
        pulumi.set(self, "placement_constraints", value)

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform_version", value)

    @_builtins.property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "propagate_tags")

    @propagate_tags.setter
    def propagate_tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "propagate_tags", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_count", value)


if not MYPY:
    class EventTargetEcsTargetCapacityProviderStrategyArgsDict(TypedDict):
        capacity_provider: pulumi.Input[_builtins.str]
        base: NotRequired[pulumi.Input[_builtins.int]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    EventTargetEcsTargetCapacityProviderStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetCapacityProviderStrategyArgs:
    def __init__(__self__, *,
                 capacity_provider: pulumi.Input[_builtins.str],
                 base: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "capacity_provider")

    @capacity_provider.setter
    def capacity_provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity_provider", value)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class EventTargetEcsTargetNetworkConfigurationArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        assign_public_ip: NotRequired[pulumi.Input[_builtins.bool]]
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    EventTargetEcsTargetNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 assign_public_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "subnets", subnets)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class EventTargetEcsTargetOrderedPlacementStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        field: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetEcsTargetOrderedPlacementStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetOrderedPlacementStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 field: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class EventTargetEcsTargetPlacementConstraintArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        expression: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetEcsTargetPlacementConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetEcsTargetPlacementConstraintArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventTargetHttpTargetArgsDict(TypedDict):
        header_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        path_parameter_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        query_string_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    EventTargetHttpTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetHttpTargetArgs:
    def __init__(__self__, *,
                 header_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path_parameter_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 query_string_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if header_parameters is not None:
            pulumi.set(__self__, "header_parameters", header_parameters)
        if path_parameter_values is not None:
            pulumi.set(__self__, "path_parameter_values", path_parameter_values)
        if query_string_parameters is not None:
            pulumi.set(__self__, "query_string_parameters", query_string_parameters)

    @_builtins.property
    @pulumi.getter(name="headerParameters")
    def header_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header_parameters")

    @header_parameters.setter
    def header_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header_parameters", value)

    @_builtins.property
    @pulumi.getter(name="pathParameterValues")
    def path_parameter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_parameter_values")

    @path_parameter_values.setter
    def path_parameter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_parameter_values", value)

    @_builtins.property
    @pulumi.getter(name="queryStringParameters")
    def query_string_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "query_string_parameters")

    @query_string_parameters.setter
    def query_string_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_string_parameters", value)


if not MYPY:
    class EventTargetInputTransformerArgsDict(TypedDict):
        input_template: pulumi.Input[_builtins.str]
        input_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    EventTargetInputTransformerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetInputTransformerArgs:
    def __init__(__self__, *,
                 input_template: pulumi.Input[_builtins.str],
                 input_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "input_template", input_template)
        if input_paths is not None:
            pulumi.set(__self__, "input_paths", input_paths)

    @_builtins.property
    @pulumi.getter(name="inputTemplate")
    def input_template(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "input_template")

    @input_template.setter
    def input_template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_template", value)

    @_builtins.property
    @pulumi.getter(name="inputPaths")
    def input_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "input_paths")

    @input_paths.setter
    def input_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_paths", value)


if not MYPY:
    class EventTargetKinesisTargetArgsDict(TypedDict):
        partition_key_path: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetKinesisTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetKinesisTargetArgs:
    def __init__(__self__, *,
                 partition_key_path: Optional[pulumi.Input[_builtins.str]] = None):
        if partition_key_path is not None:
            pulumi.set(__self__, "partition_key_path", partition_key_path)

    @_builtins.property
    @pulumi.getter(name="partitionKeyPath")
    def partition_key_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "partition_key_path")

    @partition_key_path.setter
    def partition_key_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition_key_path", value)


if not MYPY:
    class EventTargetRedshiftTargetArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        db_user: NotRequired[pulumi.Input[_builtins.str]]
        secrets_manager_arn: NotRequired[pulumi.Input[_builtins.str]]
        sql: NotRequired[pulumi.Input[_builtins.str]]
        statement_name: NotRequired[pulumi.Input[_builtins.str]]
        with_event: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    EventTargetRedshiftTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRedshiftTargetArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 db_user: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets_manager_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 sql: Optional[pulumi.Input[_builtins.str]] = None,
                 statement_name: Optional[pulumi.Input[_builtins.str]] = None,
                 with_event: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "database", database)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if secrets_manager_arn is not None:
            pulumi.set(__self__, "secrets_manager_arn", secrets_manager_arn)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if statement_name is not None:
            pulumi.set(__self__, "statement_name", statement_name)
        if with_event is not None:
            pulumi.set(__self__, "with_event", with_event)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_user", value)

    @_builtins.property
    @pulumi.getter(name="secretsManagerArn")
    def secrets_manager_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secrets_manager_arn")

    @secrets_manager_arn.setter
    def secrets_manager_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secrets_manager_arn", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sql", value)

    @_builtins.property
    @pulumi.getter(name="statementName")
    def statement_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "statement_name")

    @statement_name.setter
    def statement_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "statement_name", value)

    @_builtins.property
    @pulumi.getter(name="withEvent")
    def with_event(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "with_event")

    @with_event.setter
    def with_event(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "with_event", value)


if not MYPY:
    class EventTargetRetryPolicyArgsDict(TypedDict):
        maximum_event_age_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        maximum_retry_attempts: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    EventTargetRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRetryPolicyArgs:
    def __init__(__self__, *,
                 maximum_event_age_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum_retry_attempts: Optional[pulumi.Input[_builtins.int]] = None):
        if maximum_event_age_in_seconds is not None:
            pulumi.set(__self__, "maximum_event_age_in_seconds", maximum_event_age_in_seconds)
        if maximum_retry_attempts is not None:
            pulumi.set(__self__, "maximum_retry_attempts", maximum_retry_attempts)

    @_builtins.property
    @pulumi.getter(name="maximumEventAgeInSeconds")
    def maximum_event_age_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_event_age_in_seconds")

    @maximum_event_age_in_seconds.setter
    def maximum_event_age_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_event_age_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maximumRetryAttempts")
    def maximum_retry_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "maximum_retry_attempts")

    @maximum_retry_attempts.setter
    def maximum_retry_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum_retry_attempts", value)


if not MYPY:
    class EventTargetRunCommandTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    EventTargetRunCommandTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetRunCommandTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EventTargetSagemakerPipelineTargetArgsDict(TypedDict):
        pipeline_parameter_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict']]]]
elif False:
    EventTargetSagemakerPipelineTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSagemakerPipelineTargetArgs:
    def __init__(__self__, *,
                 pipeline_parameter_lists: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]] = None):
        if pipeline_parameter_lists is not None:
            pulumi.set(__self__, "pipeline_parameter_lists", pipeline_parameter_lists)

    @_builtins.property
    @pulumi.getter(name="pipelineParameterLists")
    def pipeline_parameter_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]]:
        return pulumi.get(self, "pipeline_parameter_lists")

    @pipeline_parameter_lists.setter
    def pipeline_parameter_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventTargetSagemakerPipelineTargetPipelineParameterListArgs']]]]):
        pulumi.set(self, "pipeline_parameter_lists", value)


if not MYPY:
    class EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    EventTargetSagemakerPipelineTargetPipelineParameterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSagemakerPipelineTargetPipelineParameterListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventTargetSqsTargetArgsDict(TypedDict):
        message_group_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EventTargetSqsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTargetSqsTargetArgs:
    def __init__(__self__, *,
                 message_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        if message_group_id is not None:
            pulumi.set(__self__, "message_group_id", message_group_id)

    @_builtins.property
    @pulumi.getter(name="messageGroupId")
    def message_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_group_id")

    @message_group_id.setter
    def message_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_group_id", value)


if not MYPY:
    class InternetMonitorHealthEventsConfigArgsDict(TypedDict):
        availability_score_threshold: NotRequired[pulumi.Input[_builtins.float]]
        performance_score_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    InternetMonitorHealthEventsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorHealthEventsConfigArgs:
    def __init__(__self__, *,
                 availability_score_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 performance_score_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if availability_score_threshold is not None:
            pulumi.set(__self__, "availability_score_threshold", availability_score_threshold)
        if performance_score_threshold is not None:
            pulumi.set(__self__, "performance_score_threshold", performance_score_threshold)

    @_builtins.property
    @pulumi.getter(name="availabilityScoreThreshold")
    def availability_score_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "availability_score_threshold")

    @availability_score_threshold.setter
    def availability_score_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "availability_score_threshold", value)

    @_builtins.property
    @pulumi.getter(name="performanceScoreThreshold")
    def performance_score_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "performance_score_threshold")

    @performance_score_threshold.setter
    def performance_score_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "performance_score_threshold", value)


if not MYPY:
    class InternetMonitorInternetMeasurementsLogDeliveryArgsDict(TypedDict):
        s3_config: NotRequired[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict']]
elif False:
    InternetMonitorInternetMeasurementsLogDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorInternetMeasurementsLogDeliveryArgs:
    def __init__(__self__, *,
                 s3_config: Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']] = None):
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)

    @_builtins.property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']]:
        return pulumi.get(self, "s3_config")

    @s3_config.setter
    def s3_config(self, value: Optional[pulumi.Input['InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs']]):
        pulumi.set(self, "s3_config", value)


if not MYPY:
    class InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        log_delivery_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternetMonitorInternetMeasurementsLogDeliveryS3ConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_delivery_status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if log_delivery_status is not None:
            pulumi.set(__self__, "log_delivery_status", log_delivery_status)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logDeliveryStatus")
    def log_delivery_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_delivery_status")

    @log_delivery_status.setter
    def log_delivery_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_delivery_status", value)


if not MYPY:
    class LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict(TypedDict):
        destination_resource_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogDeliveryDestinationDeliveryDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogDeliveryDestinationDeliveryDestinationConfigurationArgs:
    def __init__(__self__, *,
                 destination_resource_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if destination_resource_arn is not None:
            pulumi.set(__self__, "destination_resource_arn", destination_resource_arn)

    @_builtins.property
    @pulumi.getter(name="destinationResourceArn")
    def destination_resource_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination_resource_arn")

    @destination_resource_arn.setter
    def destination_resource_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_resource_arn", value)


if not MYPY:
    class LogDeliveryS3DeliveryConfigurationArgsDict(TypedDict):
        enable_hive_compatible_path: pulumi.Input[_builtins.bool]
        suffix_path: pulumi.Input[_builtins.str]
elif False:
    LogDeliveryS3DeliveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogDeliveryS3DeliveryConfigurationArgs:
    def __init__(__self__, *,
                 enable_hive_compatible_path: pulumi.Input[_builtins.bool],
                 suffix_path: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "enable_hive_compatible_path", enable_hive_compatible_path)
        pulumi.set(__self__, "suffix_path", suffix_path)

    @_builtins.property
    @pulumi.getter(name="enableHiveCompatiblePath")
    def enable_hive_compatible_path(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enable_hive_compatible_path")

    @enable_hive_compatible_path.setter
    def enable_hive_compatible_path(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_hive_compatible_path", value)

    @_builtins.property
    @pulumi.getter(name="suffixPath")
    def suffix_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "suffix_path")

    @suffix_path.setter
    def suffix_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix_path", value)


if not MYPY:
    class LogMetricFilterMetricTransformationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        namespace: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        unit: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogMetricFilterMetricTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogMetricFilterMetricTransformationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "value", value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class LogTransformerTransformerConfigArgsDict(TypedDict):
        add_keys: NotRequired[pulumi.Input['LogTransformerTransformerConfigAddKeysArgsDict']]
        copy_value: NotRequired[pulumi.Input['LogTransformerTransformerConfigCopyValueArgsDict']]
        csvs: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgsDict']]]]
        date_time_converters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgsDict']]]]
        delete_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgsDict']]]]
        grok: NotRequired[pulumi.Input['LogTransformerTransformerConfigGrokArgsDict']]
        list_to_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgsDict']]]]
        lower_case_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgsDict']]]]
        move_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgsDict']]]]
        parse_cloudfront: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgsDict']]
        parse_jsons: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgsDict']]]]
        parse_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgsDict']]]]
        parse_postgres: NotRequired[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgsDict']]
        parse_route53: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseRoute53ArgsDict']]
        parse_to_ocsf: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgsDict']]
        parse_vpc: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseVpcArgsDict']]
        parse_waf: NotRequired[pulumi.Input['LogTransformerTransformerConfigParseWafArgsDict']]
        rename_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgsDict']]]]
        split_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgsDict']]]]
        substitute_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgsDict']]]]
        trim_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgsDict']]]]
        type_converters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgsDict']]]]
        upper_case_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgsDict']]]]
elif False:
    LogTransformerTransformerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigArgs:
    def __init__(__self__, *,
                 add_keys: Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']] = None,
                 copy_value: Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']] = None,
                 csvs: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]] = None,
                 date_time_converters: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]] = None,
                 delete_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]] = None,
                 grok: Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']] = None,
                 list_to_maps: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]] = None,
                 lower_case_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]] = None,
                 move_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]] = None,
                 parse_cloudfront: Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']] = None,
                 parse_jsons: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]] = None,
                 parse_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]] = None,
                 parse_postgres: Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']] = None,
                 parse_route53: Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']] = None,
                 parse_to_ocsf: Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']] = None,
                 parse_vpc: Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']] = None,
                 parse_waf: Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']] = None,
                 rename_keys: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]] = None,
                 split_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]] = None,
                 substitute_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]] = None,
                 trim_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]] = None,
                 type_converters: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]] = None,
                 upper_case_strings: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]] = None):
        if add_keys is not None:
            pulumi.set(__self__, "add_keys", add_keys)
        if copy_value is not None:
            pulumi.set(__self__, "copy_value", copy_value)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if date_time_converters is not None:
            pulumi.set(__self__, "date_time_converters", date_time_converters)
        if delete_keys is not None:
            pulumi.set(__self__, "delete_keys", delete_keys)
        if grok is not None:
            pulumi.set(__self__, "grok", grok)
        if list_to_maps is not None:
            pulumi.set(__self__, "list_to_maps", list_to_maps)
        if lower_case_strings is not None:
            pulumi.set(__self__, "lower_case_strings", lower_case_strings)
        if move_keys is not None:
            pulumi.set(__self__, "move_keys", move_keys)
        if parse_cloudfront is not None:
            pulumi.set(__self__, "parse_cloudfront", parse_cloudfront)
        if parse_jsons is not None:
            pulumi.set(__self__, "parse_jsons", parse_jsons)
        if parse_key_values is not None:
            pulumi.set(__self__, "parse_key_values", parse_key_values)
        if parse_postgres is not None:
            pulumi.set(__self__, "parse_postgres", parse_postgres)
        if parse_route53 is not None:
            pulumi.set(__self__, "parse_route53", parse_route53)
        if parse_to_ocsf is not None:
            pulumi.set(__self__, "parse_to_ocsf", parse_to_ocsf)
        if parse_vpc is not None:
            pulumi.set(__self__, "parse_vpc", parse_vpc)
        if parse_waf is not None:
            pulumi.set(__self__, "parse_waf", parse_waf)
        if rename_keys is not None:
            pulumi.set(__self__, "rename_keys", rename_keys)
        if split_strings is not None:
            pulumi.set(__self__, "split_strings", split_strings)
        if substitute_strings is not None:
            pulumi.set(__self__, "substitute_strings", substitute_strings)
        if trim_strings is not None:
            pulumi.set(__self__, "trim_strings", trim_strings)
        if type_converters is not None:
            pulumi.set(__self__, "type_converters", type_converters)
        if upper_case_strings is not None:
            pulumi.set(__self__, "upper_case_strings", upper_case_strings)

    @_builtins.property
    @pulumi.getter(name="addKeys")
    def add_keys(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']]:
        return pulumi.get(self, "add_keys")

    @add_keys.setter
    def add_keys(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigAddKeysArgs']]):
        pulumi.set(self, "add_keys", value)

    @_builtins.property
    @pulumi.getter(name="copyValue")
    def copy_value(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']]:
        return pulumi.get(self, "copy_value")

    @copy_value.setter
    def copy_value(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigCopyValueArgs']]):
        pulumi.set(self, "copy_value", value)

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]]:
        return pulumi.get(self, "csvs")

    @csvs.setter
    def csvs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCsvArgs']]]]):
        pulumi.set(self, "csvs", value)

    @_builtins.property
    @pulumi.getter(name="dateTimeConverters")
    def date_time_converters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]]:
        return pulumi.get(self, "date_time_converters")

    @date_time_converters.setter
    def date_time_converters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDateTimeConverterArgs']]]]):
        pulumi.set(self, "date_time_converters", value)

    @_builtins.property
    @pulumi.getter(name="deleteKeys")
    def delete_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]]:
        return pulumi.get(self, "delete_keys")

    @delete_keys.setter
    def delete_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigDeleteKeyArgs']]]]):
        pulumi.set(self, "delete_keys", value)

    @_builtins.property
    @pulumi.getter
    def grok(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']]:
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigGrokArgs']]):
        pulumi.set(self, "grok", value)

    @_builtins.property
    @pulumi.getter(name="listToMaps")
    def list_to_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]]:
        return pulumi.get(self, "list_to_maps")

    @list_to_maps.setter
    def list_to_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigListToMapArgs']]]]):
        pulumi.set(self, "list_to_maps", value)

    @_builtins.property
    @pulumi.getter(name="lowerCaseStrings")
    def lower_case_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]]:
        return pulumi.get(self, "lower_case_strings")

    @lower_case_strings.setter
    def lower_case_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigLowerCaseStringArgs']]]]):
        pulumi.set(self, "lower_case_strings", value)

    @_builtins.property
    @pulumi.getter(name="moveKeys")
    def move_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]]:
        return pulumi.get(self, "move_keys")

    @move_keys.setter
    def move_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyArgs']]]]):
        pulumi.set(self, "move_keys", value)

    @_builtins.property
    @pulumi.getter(name="parseCloudfront")
    def parse_cloudfront(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']]:
        return pulumi.get(self, "parse_cloudfront")

    @parse_cloudfront.setter
    def parse_cloudfront(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseCloudfrontArgs']]):
        pulumi.set(self, "parse_cloudfront", value)

    @_builtins.property
    @pulumi.getter(name="parseJsons")
    def parse_jsons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]]:
        return pulumi.get(self, "parse_jsons")

    @parse_jsons.setter
    def parse_jsons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseJsonArgs']]]]):
        pulumi.set(self, "parse_jsons", value)

    @_builtins.property
    @pulumi.getter(name="parseKeyValues")
    def parse_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]]:
        return pulumi.get(self, "parse_key_values")

    @parse_key_values.setter
    def parse_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigParseKeyValueArgs']]]]):
        pulumi.set(self, "parse_key_values", value)

    @_builtins.property
    @pulumi.getter(name="parsePostgres")
    def parse_postgres(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']]:
        return pulumi.get(self, "parse_postgres")

    @parse_postgres.setter
    def parse_postgres(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParsePostgresArgs']]):
        pulumi.set(self, "parse_postgres", value)

    @_builtins.property
    @pulumi.getter(name="parseRoute53")
    def parse_route53(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']]:
        return pulumi.get(self, "parse_route53")

    @parse_route53.setter
    def parse_route53(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseRoute53Args']]):
        pulumi.set(self, "parse_route53", value)

    @_builtins.property
    @pulumi.getter(name="parseToOcsf")
    def parse_to_ocsf(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']]:
        return pulumi.get(self, "parse_to_ocsf")

    @parse_to_ocsf.setter
    def parse_to_ocsf(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseToOcsfArgs']]):
        pulumi.set(self, "parse_to_ocsf", value)

    @_builtins.property
    @pulumi.getter(name="parseVpc")
    def parse_vpc(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']]:
        return pulumi.get(self, "parse_vpc")

    @parse_vpc.setter
    def parse_vpc(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseVpcArgs']]):
        pulumi.set(self, "parse_vpc", value)

    @_builtins.property
    @pulumi.getter(name="parseWaf")
    def parse_waf(self) -> Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']]:
        return pulumi.get(self, "parse_waf")

    @parse_waf.setter
    def parse_waf(self, value: Optional[pulumi.Input['LogTransformerTransformerConfigParseWafArgs']]):
        pulumi.set(self, "parse_waf", value)

    @_builtins.property
    @pulumi.getter(name="renameKeys")
    def rename_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]]:
        return pulumi.get(self, "rename_keys")

    @rename_keys.setter
    def rename_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyArgs']]]]):
        pulumi.set(self, "rename_keys", value)

    @_builtins.property
    @pulumi.getter(name="splitStrings")
    def split_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]]:
        return pulumi.get(self, "split_strings")

    @split_strings.setter
    def split_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringArgs']]]]):
        pulumi.set(self, "split_strings", value)

    @_builtins.property
    @pulumi.getter(name="substituteStrings")
    def substitute_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]]:
        return pulumi.get(self, "substitute_strings")

    @substitute_strings.setter
    def substitute_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringArgs']]]]):
        pulumi.set(self, "substitute_strings", value)

    @_builtins.property
    @pulumi.getter(name="trimStrings")
    def trim_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]]:
        return pulumi.get(self, "trim_strings")

    @trim_strings.setter
    def trim_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTrimStringArgs']]]]):
        pulumi.set(self, "trim_strings", value)

    @_builtins.property
    @pulumi.getter(name="typeConverters")
    def type_converters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]]:
        return pulumi.get(self, "type_converters")

    @type_converters.setter
    def type_converters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterArgs']]]]):
        pulumi.set(self, "type_converters", value)

    @_builtins.property
    @pulumi.getter(name="upperCaseStrings")
    def upper_case_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]]:
        return pulumi.get(self, "upper_case_strings")

    @upper_case_strings.setter
    def upper_case_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigUpperCaseStringArgs']]]]):
        pulumi.set(self, "upper_case_strings", value)


if not MYPY:
    class LogTransformerTransformerConfigAddKeysArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigAddKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigAddKeysArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigAddKeysEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigAddKeysEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    LogTransformerTransformerConfigAddKeysEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigAddKeysEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigCopyValueArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigCopyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCopyValueArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigCopyValueEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigCopyValueEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    LogTransformerTransformerConfigCopyValueEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCopyValueEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigCsvArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        quote_character: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigCsvArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 quote_character: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if quote_character is not None:
            pulumi.set(__self__, "quote_character", quote_character)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="quoteCharacter")
    def quote_character(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "quote_character")

    @quote_character.setter
    def quote_character(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quote_character", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigDateTimeConverterArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        locale: NotRequired[pulumi.Input[_builtins.str]]
        source_timezone: NotRequired[pulumi.Input[_builtins.str]]
        target_format: NotRequired[pulumi.Input[_builtins.str]]
        target_timezone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigDateTimeConverterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigDateTimeConverterArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 locale: Optional[pulumi.Input[_builtins.str]] = None,
                 source_timezone: Optional[pulumi.Input[_builtins.str]] = None,
                 target_format: Optional[pulumi.Input[_builtins.str]] = None,
                 target_timezone: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if source_timezone is not None:
            pulumi.set(__self__, "source_timezone", source_timezone)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)
        if target_timezone is not None:
            pulumi.set(__self__, "target_timezone", target_timezone)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locale", value)

    @_builtins.property
    @pulumi.getter(name="sourceTimezone")
    def source_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_timezone")

    @source_timezone.setter
    def source_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_timezone", value)

    @_builtins.property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_format")

    @target_format.setter
    def target_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_format", value)

    @_builtins.property
    @pulumi.getter(name="targetTimezone")
    def target_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_timezone")

    @target_timezone.setter
    def target_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_timezone", value)


if not MYPY:
    class LogTransformerTransformerConfigDeleteKeyArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    LogTransformerTransformerConfigDeleteKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigDeleteKeyArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigGrokArgsDict(TypedDict):
        match: pulumi.Input[_builtins.str]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigGrokArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigGrokArgs:
    def __init__(__self__, *,
                 match: pulumi.Input[_builtins.str],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match", match)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigListToMapArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        flatten: NotRequired[pulumi.Input[_builtins.bool]]
        flattened_element: NotRequired[pulumi.Input[_builtins.str]]
        target: NotRequired[pulumi.Input[_builtins.str]]
        value_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigListToMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigListToMapArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 flatten: Optional[pulumi.Input[_builtins.bool]] = None,
                 flattened_element: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value_key: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if flatten is not None:
            pulumi.set(__self__, "flatten", flatten)
        if flattened_element is not None:
            pulumi.set(__self__, "flattened_element", flattened_element)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value_key is not None:
            pulumi.set(__self__, "value_key", value_key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def flatten(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "flatten")

    @flatten.setter
    def flatten(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten", value)

    @_builtins.property
    @pulumi.getter(name="flattenedElement")
    def flattened_element(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "flattened_element")

    @flattened_element.setter
    def flattened_element(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flattened_element", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value_key")

    @value_key.setter
    def value_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_key", value)


if not MYPY:
    class LogTransformerTransformerConfigLowerCaseStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    LogTransformerTransformerConfigLowerCaseStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigLowerCaseStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigMoveKeyArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigMoveKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigMoveKeyArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigMoveKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigMoveKeyEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    LogTransformerTransformerConfigMoveKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigMoveKeyEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigParseCloudfrontArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseCloudfrontArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseJsonArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseJsonArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseKeyValueArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        key_value_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        non_match_value: NotRequired[pulumi.Input[_builtins.str]]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseKeyValueArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 key_value_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 non_match_value: Optional[pulumi.Input[_builtins.str]] = None,
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if key_value_delimiter is not None:
            pulumi.set(__self__, "key_value_delimiter", key_value_delimiter)
        if non_match_value is not None:
            pulumi.set(__self__, "non_match_value", non_match_value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="keyValueDelimiter")
    def key_value_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_value_delimiter")

    @key_value_delimiter.setter
    def key_value_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_value_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="nonMatchValue")
    def non_match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "non_match_value")

    @non_match_value.setter
    def non_match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "non_match_value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParsePostgresArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParsePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParsePostgresArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseRoute53ArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseRoute53Args:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseToOcsfArgsDict(TypedDict):
        event_source: pulumi.Input[_builtins.str]
        ocsf_version: pulumi.Input[_builtins.str]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseToOcsfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseToOcsfArgs:
    def __init__(__self__, *,
                 event_source: pulumi.Input[_builtins.str],
                 ocsf_version: pulumi.Input[_builtins.str],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "ocsf_version", ocsf_version)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="ocsfVersion")
    def ocsf_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ocsf_version")

    @ocsf_version.setter
    def ocsf_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ocsf_version", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseVpcArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseVpcArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigParseWafArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LogTransformerTransformerConfigParseWafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigParseWafArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigRenameKeyArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigRenameKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigRenameKeyArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigRenameKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigRenameKeyEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        rename_to: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    LogTransformerTransformerConfigRenameKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigRenameKeyEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 rename_to: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "rename_to", rename_to)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="renameTo")
    def rename_to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "rename_to")

    @rename_to.setter
    def rename_to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rename_to", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class LogTransformerTransformerConfigSplitStringArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigSplitStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSplitStringArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSplitStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigSplitStringEntryArgsDict(TypedDict):
        delimiter: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
elif False:
    LogTransformerTransformerConfigSplitStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSplitStringEntryArgs:
    def __init__(__self__, *,
                 delimiter: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class LogTransformerTransformerConfigSubstituteStringArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigSubstituteStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSubstituteStringArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigSubstituteStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigSubstituteStringEntryArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        to: pulumi.Input[_builtins.str]
elif False:
    LogTransformerTransformerConfigSubstituteStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigSubstituteStringEntryArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class LogTransformerTransformerConfigTrimStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    LogTransformerTransformerConfigTrimStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTrimStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class LogTransformerTransformerConfigTypeConverterArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgsDict']]]
elif False:
    LogTransformerTransformerConfigTypeConverterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTypeConverterArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]):
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['LogTransformerTransformerConfigTypeConverterEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class LogTransformerTransformerConfigTypeConverterEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    LogTransformerTransformerConfigTypeConverterEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigTypeConverterEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogTransformerTransformerConfigUpperCaseStringArgsDict(TypedDict):
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    LogTransformerTransformerConfigUpperCaseStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogTransformerTransformerConfigUpperCaseStringArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class MetricAlarmMetricQueryArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        expression: NotRequired[pulumi.Input[_builtins.str]]
        label: NotRequired[pulumi.Input[_builtins.str]]
        metric: NotRequired[pulumi.Input['MetricAlarmMetricQueryMetricArgsDict']]
        period: NotRequired[pulumi.Input[_builtins.int]]
        return_data: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    MetricAlarmMetricQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlarmMetricQueryArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 metric: Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 return_data: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "id", id)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['MetricAlarmMetricQueryMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "return_data")

    @return_data.setter
    def return_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_data", value)


if not MYPY:
    class MetricAlarmMetricQueryMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        period: pulumi.Input[_builtins.int]
        stat: pulumi.Input[_builtins.str]
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        unit: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MetricAlarmMetricQueryMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricAlarmMetricQueryMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.int],
                 stat: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "stat", stat)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def stat(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stat", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class MetricStreamExcludeFilterArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        metric_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MetricStreamExcludeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamExcludeFilterArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 metric_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "metric_names")

    @metric_names.setter
    def metric_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_names", value)


if not MYPY:
    class MetricStreamIncludeFilterArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        metric_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    MetricStreamIncludeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamIncludeFilterArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 metric_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "namespace", namespace)
        if metric_names is not None:
            pulumi.set(__self__, "metric_names", metric_names)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricNames")
    def metric_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "metric_names")

    @metric_names.setter
    def metric_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_names", value)


if not MYPY:
    class MetricStreamStatisticsConfigurationArgsDict(TypedDict):
        additional_statistics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        include_metrics: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgsDict']]]
elif False:
    MetricStreamStatisticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamStatisticsConfigurationArgs:
    def __init__(__self__, *,
                 additional_statistics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 include_metrics: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]):
        pulumi.set(__self__, "additional_statistics", additional_statistics)
        pulumi.set(__self__, "include_metrics", include_metrics)

    @_builtins.property
    @pulumi.getter(name="additionalStatistics")
    def additional_statistics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "additional_statistics")

    @additional_statistics.setter
    def additional_statistics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "additional_statistics", value)

    @_builtins.property
    @pulumi.getter(name="includeMetrics")
    def include_metrics(self) -> pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]:
        return pulumi.get(self, "include_metrics")

    @include_metrics.setter
    def include_metrics(self, value: pulumi.Input[Sequence[pulumi.Input['MetricStreamStatisticsConfigurationIncludeMetricArgs']]]):
        pulumi.set(self, "include_metrics", value)


if not MYPY:
    class MetricStreamStatisticsConfigurationIncludeMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        namespace: pulumi.Input[_builtins.str]
elif False:
    MetricStreamStatisticsConfigurationIncludeMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricStreamStatisticsConfigurationIncludeMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PolicyDocumentArgsDict(TypedDict):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgsDict']]]
        version: pulumi.Input['iam.PolicyDocumentVersion']
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PolicyDocumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDocumentArgs:
    def __init__(__self__, *,
                 statement: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]],
                 version: pulumi.Input['iam.PolicyDocumentVersion'],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Represents an AWS IAM policy document that defines permissions for AWS resources and actions.
        """
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="Statement")
    def statement(self) -> pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input[Sequence[pulumi.Input['_iam.PolicyStatementArgs']]]):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter(name="Version")
    def version(self) -> pulumi.Input['iam.PolicyDocumentVersion']:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input['iam.PolicyDocumentVersion']):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentConfigurationArgsDict(TypedDict):
        custom_data_identifiers: NotRequired[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict']]
elif False:
    GetLogDataProtectionPolicyDocumentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentConfigurationArgs:
    def __init__(__self__, *,
                 custom_data_identifiers: Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']] = None):
        if custom_data_identifiers is not None:
            pulumi.set(__self__, "custom_data_identifiers", custom_data_identifiers)

    @_builtins.property
    @pulumi.getter(name="customDataIdentifiers")
    def custom_data_identifiers(self) -> Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']]:
        return pulumi.get(self, "custom_data_identifiers")

    @custom_data_identifiers.setter
    def custom_data_identifiers(self, value: Optional[Sequence['GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs']]):
        pulumi.set(self, "custom_data_identifiers", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict(TypedDict):
        name: _builtins.str
        regex: _builtins.str
elif False:
    GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentConfigurationCustomDataIdentifierArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 regex: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: _builtins.str):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementArgsDict(TypedDict):
        data_identifiers: Sequence[_builtins.str]
        operation: 'GetLogDataProtectionPolicyDocumentStatementOperationArgsDict'
        sid: NotRequired[_builtins.str]
elif False:
    GetLogDataProtectionPolicyDocumentStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementArgs:
    def __init__(__self__, *,
                 data_identifiers: Sequence[_builtins.str],
                 operation: 'GetLogDataProtectionPolicyDocumentStatementOperationArgs',
                 sid: Optional[_builtins.str] = None):
        pulumi.set(__self__, "data_identifiers", data_identifiers)
        pulumi.set(__self__, "operation", operation)
        if sid is not None:
            pulumi.set(__self__, "sid", sid)

    @_builtins.property
    @pulumi.getter(name="dataIdentifiers")
    def data_identifiers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "data_identifiers")

    @data_identifiers.setter
    def data_identifiers(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "data_identifiers", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationArgs':
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationArgs'):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def sid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sid", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationArgsDict(TypedDict):
        audit: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict']
        deidentify: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict']
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationArgs:
    def __init__(__self__, *,
                 audit: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs'] = None,
                 deidentify: Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs'] = None):
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if deidentify is not None:
            pulumi.set(__self__, "deidentify", deidentify)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs']:
        return pulumi.get(self, "audit")

    @audit.setter
    def audit(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs']):
        pulumi.set(self, "audit", value)

    @_builtins.property
    @pulumi.getter
    def deidentify(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs']:
        return pulumi.get(self, "deidentify")

    @deidentify.setter
    def deidentify(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs']):
        pulumi.set(self, "deidentify", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict(TypedDict):
        findings_destination: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict'
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditArgs:
    def __init__(__self__, *,
                 findings_destination: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs'):
        pulumi.set(__self__, "findings_destination", findings_destination)

    @_builtins.property
    @pulumi.getter(name="findingsDestination")
    def findings_destination(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs':
        return pulumi.get(self, "findings_destination")

    @findings_destination.setter
    def findings_destination(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs'):
        pulumi.set(self, "findings_destination", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict(TypedDict):
        cloudwatch_logs: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict']
        firehose: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict']
        s3: NotRequired['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict']
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs'] = None,
                 firehose: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs'] = None,
                 s3: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args'] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs']:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs']):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter
    def firehose(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs']:
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs']):
        pulumi.set(self, "firehose", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict(TypedDict):
        log_group: _builtins.str
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group: _builtins.str):
        pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> _builtins.str:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: _builtins.str):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict(TypedDict):
        delivery_stream: _builtins.str
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationFirehoseArgs:
    def __init__(__self__, *,
                 delivery_stream: _builtins.str):
        pulumi.set(__self__, "delivery_stream", delivery_stream)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> _builtins.str:
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: _builtins.str):
        pulumi.set(self, "delivery_stream", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict(TypedDict):
        bucket: _builtins.str
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationAuditFindingsDestinationS3Args:
    def __init__(__self__, *,
                 bucket: _builtins.str):
        pulumi.set(__self__, "bucket", bucket)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: _builtins.str):
        pulumi.set(self, "bucket", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict(TypedDict):
        mask_config: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict'
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyArgs:
    def __init__(__self__, *,
                 mask_config: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs'):
        pulumi.set(__self__, "mask_config", mask_config)

    @_builtins.property
    @pulumi.getter(name="maskConfig")
    def mask_config(self) -> 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs':
        return pulumi.get(self, "mask_config")

    @mask_config.setter
    def mask_config(self, value: 'GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs'):
        pulumi.set(self, "mask_config", value)


if not MYPY:
    class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict(TypedDict):
        pass
elif False:
    GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLogDataProtectionPolicyDocumentStatementOperationDeidentifyMaskConfigArgs:
    def __init__(__self__):
        pass


