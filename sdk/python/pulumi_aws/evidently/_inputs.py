# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FeatureEvaluationRuleArgs',
    'FeatureEvaluationRuleArgsDict',
    'FeatureVariationArgs',
    'FeatureVariationArgsDict',
    'FeatureVariationValueArgs',
    'FeatureVariationValueArgsDict',
    'LaunchExecutionArgs',
    'LaunchExecutionArgsDict',
    'LaunchGroupArgs',
    'LaunchGroupArgsDict',
    'LaunchMetricMonitorArgs',
    'LaunchMetricMonitorArgsDict',
    'LaunchMetricMonitorMetricDefinitionArgs',
    'LaunchMetricMonitorMetricDefinitionArgsDict',
    'LaunchScheduledSplitsConfigArgs',
    'LaunchScheduledSplitsConfigArgsDict',
    'LaunchScheduledSplitsConfigStepArgs',
    'LaunchScheduledSplitsConfigStepArgsDict',
    'LaunchScheduledSplitsConfigStepSegmentOverrideArgs',
    'LaunchScheduledSplitsConfigStepSegmentOverrideArgsDict',
    'ProjectDataDeliveryArgs',
    'ProjectDataDeliveryArgsDict',
    'ProjectDataDeliveryCloudwatchLogsArgs',
    'ProjectDataDeliveryCloudwatchLogsArgsDict',
    'ProjectDataDeliveryS3DestinationArgs',
    'ProjectDataDeliveryS3DestinationArgsDict',
]

MYPY = False

if not MYPY:
    class FeatureEvaluationRuleArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FeatureEvaluationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureEvaluationRuleArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FeatureVariationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input['FeatureVariationValueArgsDict']
elif False:
    FeatureVariationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureVariationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input['FeatureVariationValueArgs']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input['FeatureVariationValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['FeatureVariationValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class FeatureVariationValueArgsDict(TypedDict):
        bool_value: NotRequired[pulumi.Input[_builtins.str]]
        double_value: NotRequired[pulumi.Input[_builtins.str]]
        long_value: NotRequired[pulumi.Input[_builtins.str]]
        string_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FeatureVariationValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureVariationValueArgs:
    def __init__(__self__, *,
                 bool_value: Optional[pulumi.Input[_builtins.str]] = None,
                 double_value: Optional[pulumi.Input[_builtins.str]] = None,
                 long_value: Optional[pulumi.Input[_builtins.str]] = None,
                 string_value: Optional[pulumi.Input[_builtins.str]] = None):
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if long_value is not None:
            pulumi.set(__self__, "long_value", long_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bool_value")

    @bool_value.setter
    def bool_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bool_value", value)

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "double_value", value)

    @_builtins.property
    @pulumi.getter(name="longValue")
    def long_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "long_value")

    @long_value.setter
    def long_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "long_value", value)

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class LaunchExecutionArgsDict(TypedDict):
        ended_time: NotRequired[pulumi.Input[_builtins.str]]
        started_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LaunchExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchExecutionArgs:
    def __init__(__self__, *,
                 ended_time: Optional[pulumi.Input[_builtins.str]] = None,
                 started_time: Optional[pulumi.Input[_builtins.str]] = None):
        if ended_time is not None:
            pulumi.set(__self__, "ended_time", ended_time)
        if started_time is not None:
            pulumi.set(__self__, "started_time", started_time)

    @_builtins.property
    @pulumi.getter(name="endedTime")
    def ended_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ended_time")

    @ended_time.setter
    def ended_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ended_time", value)

    @_builtins.property
    @pulumi.getter(name="startedTime")
    def started_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "started_time")

    @started_time.setter
    def started_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_time", value)


if not MYPY:
    class LaunchGroupArgsDict(TypedDict):
        feature: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        variation: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LaunchGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchGroupArgs:
    def __init__(__self__, *,
                 feature: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 variation: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "feature", feature)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "variation", variation)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "feature")

    @feature.setter
    def feature(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "feature", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "variation", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LaunchMetricMonitorArgsDict(TypedDict):
        metric_definition: pulumi.Input['LaunchMetricMonitorMetricDefinitionArgsDict']
elif False:
    LaunchMetricMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchMetricMonitorArgs:
    def __init__(__self__, *,
                 metric_definition: pulumi.Input['LaunchMetricMonitorMetricDefinitionArgs']):
        pulumi.set(__self__, "metric_definition", metric_definition)

    @_builtins.property
    @pulumi.getter(name="metricDefinition")
    def metric_definition(self) -> pulumi.Input['LaunchMetricMonitorMetricDefinitionArgs']:
        return pulumi.get(self, "metric_definition")

    @metric_definition.setter
    def metric_definition(self, value: pulumi.Input['LaunchMetricMonitorMetricDefinitionArgs']):
        pulumi.set(self, "metric_definition", value)


if not MYPY:
    class LaunchMetricMonitorMetricDefinitionArgsDict(TypedDict):
        entity_id_key: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        value_key: pulumi.Input[_builtins.str]
        event_pattern: NotRequired[pulumi.Input[_builtins.str]]
        unit_label: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    LaunchMetricMonitorMetricDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchMetricMonitorMetricDefinitionArgs:
    def __init__(__self__, *,
                 entity_id_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value_key: pulumi.Input[_builtins.str],
                 event_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 unit_label: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "entity_id_key", entity_id_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_key", value_key)
        if event_pattern is not None:
            pulumi.set(__self__, "event_pattern", event_pattern)
        if unit_label is not None:
            pulumi.set(__self__, "unit_label", unit_label)

    @_builtins.property
    @pulumi.getter(name="entityIdKey")
    def entity_id_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "entity_id_key")

    @entity_id_key.setter
    def entity_id_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entity_id_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_key")

    @value_key.setter
    def value_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_key", value)

    @_builtins.property
    @pulumi.getter(name="eventPattern")
    def event_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_pattern")

    @event_pattern.setter
    def event_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_pattern", value)

    @_builtins.property
    @pulumi.getter(name="unitLabel")
    def unit_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unit_label")

    @unit_label.setter
    def unit_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit_label", value)


if not MYPY:
    class LaunchScheduledSplitsConfigArgsDict(TypedDict):
        steps: pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepArgsDict']]]
elif False:
    LaunchScheduledSplitsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchScheduledSplitsConfigArgs:
    def __init__(__self__, *,
                 steps: pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepArgs']]]):
        pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepArgs']]]:
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepArgs']]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class LaunchScheduledSplitsConfigStepArgsDict(TypedDict):
        group_weights: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]
        start_time: pulumi.Input[_builtins.str]
        segment_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepSegmentOverrideArgsDict']]]]
elif False:
    LaunchScheduledSplitsConfigStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchScheduledSplitsConfigStepArgs:
    def __init__(__self__, *,
                 group_weights: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]],
                 start_time: pulumi.Input[_builtins.str],
                 segment_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepSegmentOverrideArgs']]]] = None):
        pulumi.set(__self__, "group_weights", group_weights)
        pulumi.set(__self__, "start_time", start_time)
        if segment_overrides is not None:
            pulumi.set(__self__, "segment_overrides", segment_overrides)

    @_builtins.property
    @pulumi.getter(name="groupWeights")
    def group_weights(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "group_weights")

    @group_weights.setter
    def group_weights(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "group_weights", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="segmentOverrides")
    def segment_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepSegmentOverrideArgs']]]]:
        return pulumi.get(self, "segment_overrides")

    @segment_overrides.setter
    def segment_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchScheduledSplitsConfigStepSegmentOverrideArgs']]]]):
        pulumi.set(self, "segment_overrides", value)


if not MYPY:
    class LaunchScheduledSplitsConfigStepSegmentOverrideArgsDict(TypedDict):
        evaluation_order: pulumi.Input[_builtins.int]
        segment: pulumi.Input[_builtins.str]
        weights: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]
elif False:
    LaunchScheduledSplitsConfigStepSegmentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchScheduledSplitsConfigStepSegmentOverrideArgs:
    def __init__(__self__, *,
                 evaluation_order: pulumi.Input[_builtins.int],
                 segment: pulumi.Input[_builtins.str],
                 weights: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "evaluation_order", evaluation_order)
        pulumi.set(__self__, "segment", segment)
        pulumi.set(__self__, "weights", weights)

    @_builtins.property
    @pulumi.getter(name="evaluationOrder")
    def evaluation_order(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "evaluation_order")

    @evaluation_order.setter
    def evaluation_order(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "evaluation_order", value)

    @_builtins.property
    @pulumi.getter
    def segment(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "segment", value)

    @_builtins.property
    @pulumi.getter
    def weights(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "weights")

    @weights.setter
    def weights(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "weights", value)


if not MYPY:
    class ProjectDataDeliveryArgsDict(TypedDict):
        cloudwatch_logs: NotRequired[pulumi.Input['ProjectDataDeliveryCloudwatchLogsArgsDict']]
        s3_destination: NotRequired[pulumi.Input['ProjectDataDeliveryS3DestinationArgsDict']]
elif False:
    ProjectDataDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDataDeliveryArgs:
    def __init__(__self__, *,
                 cloudwatch_logs: Optional[pulumi.Input['ProjectDataDeliveryCloudwatchLogsArgs']] = None,
                 s3_destination: Optional[pulumi.Input['ProjectDataDeliveryS3DestinationArgs']] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if s3_destination is not None:
            pulumi.set(__self__, "s3_destination", s3_destination)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['ProjectDataDeliveryCloudwatchLogsArgs']]:
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['ProjectDataDeliveryCloudwatchLogsArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @_builtins.property
    @pulumi.getter(name="s3Destination")
    def s3_destination(self) -> Optional[pulumi.Input['ProjectDataDeliveryS3DestinationArgs']]:
        return pulumi.get(self, "s3_destination")

    @s3_destination.setter
    def s3_destination(self, value: Optional[pulumi.Input['ProjectDataDeliveryS3DestinationArgs']]):
        pulumi.set(self, "s3_destination", value)


if not MYPY:
    class ProjectDataDeliveryCloudwatchLogsArgsDict(TypedDict):
        log_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectDataDeliveryCloudwatchLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDataDeliveryCloudwatchLogsArgs:
    def __init__(__self__, *,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None):
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class ProjectDataDeliveryS3DestinationArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectDataDeliveryS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDataDeliveryS3DestinationArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


