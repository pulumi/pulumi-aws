# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'FeatureEvaluationRule',
    'FeatureVariation',
    'FeatureVariationValue',
    'LaunchExecution',
    'LaunchGroup',
    'LaunchMetricMonitor',
    'LaunchMetricMonitorMetricDefinition',
    'LaunchScheduledSplitsConfig',
    'LaunchScheduledSplitsConfigStep',
    'LaunchScheduledSplitsConfigStepSegmentOverride',
    'ProjectDataDelivery',
    'ProjectDataDeliveryCloudwatchLogs',
    'ProjectDataDeliveryS3Destination',
]

@pulumi.output_type
class FeatureEvaluationRule(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class FeatureVariation(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: 'outputs.FeatureVariationValue'):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.FeatureVariationValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class FeatureVariationValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boolValue":
            suggest = "bool_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "longValue":
            suggest = "long_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureVariationValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureVariationValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureVariationValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bool_value: Optional[_builtins.str] = None,
                 double_value: Optional[_builtins.str] = None,
                 long_value: Optional[_builtins.str] = None,
                 string_value: Optional[_builtins.str] = None):
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if long_value is not None:
            pulumi.set(__self__, "long_value", long_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bool_value")

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "double_value")

    @_builtins.property
    @pulumi.getter(name="longValue")
    def long_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "long_value")

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "string_value")


@pulumi.output_type
class LaunchExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedTime":
            suggest = "ended_time"
        elif key == "startedTime":
            suggest = "started_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_time: Optional[_builtins.str] = None,
                 started_time: Optional[_builtins.str] = None):
        if ended_time is not None:
            pulumi.set(__self__, "ended_time", ended_time)
        if started_time is not None:
            pulumi.set(__self__, "started_time", started_time)

    @_builtins.property
    @pulumi.getter(name="endedTime")
    def ended_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ended_time")

    @_builtins.property
    @pulumi.getter(name="startedTime")
    def started_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "started_time")


@pulumi.output_type
class LaunchGroup(dict):
    def __init__(__self__, *,
                 feature: _builtins.str,
                 name: _builtins.str,
                 variation: _builtins.str,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "feature", feature)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "variation", variation)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.str:
        return pulumi.get(self, "variation")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LaunchMetricMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDefinition":
            suggest = "metric_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchMetricMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchMetricMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchMetricMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_definition: 'outputs.LaunchMetricMonitorMetricDefinition'):
        pulumi.set(__self__, "metric_definition", metric_definition)

    @_builtins.property
    @pulumi.getter(name="metricDefinition")
    def metric_definition(self) -> 'outputs.LaunchMetricMonitorMetricDefinition':
        return pulumi.get(self, "metric_definition")


@pulumi.output_type
class LaunchMetricMonitorMetricDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityIdKey":
            suggest = "entity_id_key"
        elif key == "valueKey":
            suggest = "value_key"
        elif key == "eventPattern":
            suggest = "event_pattern"
        elif key == "unitLabel":
            suggest = "unit_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchMetricMonitorMetricDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchMetricMonitorMetricDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchMetricMonitorMetricDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id_key: _builtins.str,
                 name: _builtins.str,
                 value_key: _builtins.str,
                 event_pattern: Optional[_builtins.str] = None,
                 unit_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "entity_id_key", entity_id_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_key", value_key)
        if event_pattern is not None:
            pulumi.set(__self__, "event_pattern", event_pattern)
        if unit_label is not None:
            pulumi.set(__self__, "unit_label", unit_label)

    @_builtins.property
    @pulumi.getter(name="entityIdKey")
    def entity_id_key(self) -> _builtins.str:
        return pulumi.get(self, "entity_id_key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> _builtins.str:
        return pulumi.get(self, "value_key")

    @_builtins.property
    @pulumi.getter(name="eventPattern")
    def event_pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_pattern")

    @_builtins.property
    @pulumi.getter(name="unitLabel")
    def unit_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit_label")


@pulumi.output_type
class LaunchScheduledSplitsConfig(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.LaunchScheduledSplitsConfigStep']):
        pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.LaunchScheduledSplitsConfigStep']:
        return pulumi.get(self, "steps")


@pulumi.output_type
class LaunchScheduledSplitsConfigStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupWeights":
            suggest = "group_weights"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "segmentOverrides":
            suggest = "segment_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchScheduledSplitsConfigStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchScheduledSplitsConfigStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchScheduledSplitsConfigStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_weights: Mapping[str, _builtins.int],
                 start_time: _builtins.str,
                 segment_overrides: Optional[Sequence['outputs.LaunchScheduledSplitsConfigStepSegmentOverride']] = None):
        pulumi.set(__self__, "group_weights", group_weights)
        pulumi.set(__self__, "start_time", start_time)
        if segment_overrides is not None:
            pulumi.set(__self__, "segment_overrides", segment_overrides)

    @_builtins.property
    @pulumi.getter(name="groupWeights")
    def group_weights(self) -> Mapping[str, _builtins.int]:
        return pulumi.get(self, "group_weights")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="segmentOverrides")
    def segment_overrides(self) -> Optional[Sequence['outputs.LaunchScheduledSplitsConfigStepSegmentOverride']]:
        return pulumi.get(self, "segment_overrides")


@pulumi.output_type
class LaunchScheduledSplitsConfigStepSegmentOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationOrder":
            suggest = "evaluation_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchScheduledSplitsConfigStepSegmentOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchScheduledSplitsConfigStepSegmentOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchScheduledSplitsConfigStepSegmentOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_order: _builtins.int,
                 segment: _builtins.str,
                 weights: Mapping[str, _builtins.int]):
        pulumi.set(__self__, "evaluation_order", evaluation_order)
        pulumi.set(__self__, "segment", segment)
        pulumi.set(__self__, "weights", weights)

    @_builtins.property
    @pulumi.getter(name="evaluationOrder")
    def evaluation_order(self) -> _builtins.int:
        return pulumi.get(self, "evaluation_order")

    @_builtins.property
    @pulumi.getter
    def segment(self) -> _builtins.str:
        return pulumi.get(self, "segment")

    @_builtins.property
    @pulumi.getter
    def weights(self) -> Mapping[str, _builtins.int]:
        return pulumi.get(self, "weights")


@pulumi.output_type
class ProjectDataDelivery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"
        elif key == "s3Destination":
            suggest = "s3_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectDataDelivery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectDataDelivery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectDataDelivery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_logs: Optional['outputs.ProjectDataDeliveryCloudwatchLogs'] = None,
                 s3_destination: Optional['outputs.ProjectDataDeliveryS3Destination'] = None):
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if s3_destination is not None:
            pulumi.set(__self__, "s3_destination", s3_destination)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.ProjectDataDeliveryCloudwatchLogs']:
        return pulumi.get(self, "cloudwatch_logs")

    @_builtins.property
    @pulumi.getter(name="s3Destination")
    def s3_destination(self) -> Optional['outputs.ProjectDataDeliveryS3Destination']:
        return pulumi.get(self, "s3_destination")


@pulumi.output_type
class ProjectDataDeliveryCloudwatchLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectDataDeliveryCloudwatchLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectDataDeliveryCloudwatchLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectDataDeliveryCloudwatchLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group: Optional[_builtins.str] = None):
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group")


@pulumi.output_type
class ProjectDataDeliveryS3Destination(dict):
    def __init__(__self__, *,
                 bucket: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")


