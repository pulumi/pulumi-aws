# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationAutoStartConfigurationArgs',
    'ApplicationAutoStartConfigurationArgsDict',
    'ApplicationAutoStopConfigurationArgs',
    'ApplicationAutoStopConfigurationArgsDict',
    'ApplicationImageConfigurationArgs',
    'ApplicationImageConfigurationArgsDict',
    'ApplicationInitialCapacityArgs',
    'ApplicationInitialCapacityArgsDict',
    'ApplicationInitialCapacityInitialCapacityConfigArgs',
    'ApplicationInitialCapacityInitialCapacityConfigArgsDict',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict',
    'ApplicationInteractiveConfigurationArgs',
    'ApplicationInteractiveConfigurationArgsDict',
    'ApplicationMaximumCapacityArgs',
    'ApplicationMaximumCapacityArgsDict',
    'ApplicationMonitoringConfigurationArgs',
    'ApplicationMonitoringConfigurationArgsDict',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgsDict',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgsDict',
    'ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs',
    'ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgsDict',
    'ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs',
    'ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgsDict',
    'ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs',
    'ApplicationMonitoringConfigurationS3MonitoringConfigurationArgsDict',
    'ApplicationNetworkConfigurationArgs',
    'ApplicationNetworkConfigurationArgsDict',
    'ApplicationRuntimeConfigurationArgs',
    'ApplicationRuntimeConfigurationArgsDict',
    'ApplicationSchedulerConfigurationArgs',
    'ApplicationSchedulerConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationAutoStartConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ApplicationAutoStartConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStartConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplicationAutoStopConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        idle_timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ApplicationAutoStopConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStopConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 idle_timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "idle_timeout_minutes")

    @idle_timeout_minutes.setter
    def idle_timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout_minutes", value)


if not MYPY:
    class ApplicationImageConfigurationArgsDict(TypedDict):
        image_uri: pulumi.Input[_builtins.str]
elif False:
    ApplicationImageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationImageConfigurationArgs:
    def __init__(__self__, *,
                 image_uri: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "image_uri", image_uri)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_uri", value)


if not MYPY:
    class ApplicationInitialCapacityArgsDict(TypedDict):
        initial_capacity_type: pulumi.Input[_builtins.str]
        initial_capacity_config: NotRequired[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgsDict']]
elif False:
    ApplicationInitialCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityArgs:
    def __init__(__self__, *,
                 initial_capacity_type: pulumi.Input[_builtins.str],
                 initial_capacity_config: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']] = None):
        pulumi.set(__self__, "initial_capacity_type", initial_capacity_type)
        if initial_capacity_config is not None:
            pulumi.set(__self__, "initial_capacity_config", initial_capacity_config)

    @_builtins.property
    @pulumi.getter(name="initialCapacityType")
    def initial_capacity_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "initial_capacity_type")

    @initial_capacity_type.setter
    def initial_capacity_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "initial_capacity_type", value)

    @_builtins.property
    @pulumi.getter(name="initialCapacityConfig")
    def initial_capacity_config(self) -> Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']]:
        return pulumi.get(self, "initial_capacity_config")

    @initial_capacity_config.setter
    def initial_capacity_config(self, value: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']]):
        pulumi.set(self, "initial_capacity_config", value)


if not MYPY:
    class ApplicationInitialCapacityInitialCapacityConfigArgsDict(TypedDict):
        worker_count: pulumi.Input[_builtins.int]
        worker_configuration: NotRequired[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict']]
elif False:
    ApplicationInitialCapacityInitialCapacityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityInitialCapacityConfigArgs:
    def __init__(__self__, *,
                 worker_count: pulumi.Input[_builtins.int],
                 worker_configuration: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']] = None):
        pulumi.set(__self__, "worker_count", worker_count)
        if worker_configuration is not None:
            pulumi.set(__self__, "worker_configuration", worker_configuration)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "worker_count", value)

    @_builtins.property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']]:
        return pulumi.get(self, "worker_configuration")

    @worker_configuration.setter
    def worker_configuration(self, value: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']]):
        pulumi.set(self, "worker_configuration", value)


if not MYPY:
    class ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.str]
        memory: pulumi.Input[_builtins.str]
        disk: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str],
                 disk: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk", value)


if not MYPY:
    class ApplicationInteractiveConfigurationArgsDict(TypedDict):
        livy_endpoint_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        studio_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ApplicationInteractiveConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInteractiveConfigurationArgs:
    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 studio_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @_builtins.property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "livy_endpoint_enabled")

    @livy_endpoint_enabled.setter
    def livy_endpoint_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "livy_endpoint_enabled", value)

    @_builtins.property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "studio_enabled")

    @studio_enabled.setter
    def studio_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "studio_enabled", value)


if not MYPY:
    class ApplicationMaximumCapacityArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.str]
        memory: pulumi.Input[_builtins.str]
        disk: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationMaximumCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMaximumCapacityArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str],
                 disk: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk", value)


if not MYPY:
    class ApplicationMonitoringConfigurationArgsDict(TypedDict):
        cloudwatch_logging_configuration: NotRequired[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgsDict']]
        managed_persistence_monitoring_configuration: NotRequired[pulumi.Input['ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgsDict']]
        prometheus_monitoring_configuration: NotRequired[pulumi.Input['ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgsDict']]
        s3_monitoring_configuration: NotRequired[pulumi.Input['ApplicationMonitoringConfigurationS3MonitoringConfigurationArgsDict']]
elif False:
    ApplicationMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 cloudwatch_logging_configuration: Optional[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs']] = None,
                 managed_persistence_monitoring_configuration: Optional[pulumi.Input['ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs']] = None,
                 prometheus_monitoring_configuration: Optional[pulumi.Input['ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs']] = None,
                 s3_monitoring_configuration: Optional[pulumi.Input['ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs']] = None):
        if cloudwatch_logging_configuration is not None:
            pulumi.set(__self__, "cloudwatch_logging_configuration", cloudwatch_logging_configuration)
        if managed_persistence_monitoring_configuration is not None:
            pulumi.set(__self__, "managed_persistence_monitoring_configuration", managed_persistence_monitoring_configuration)
        if prometheus_monitoring_configuration is not None:
            pulumi.set(__self__, "prometheus_monitoring_configuration", prometheus_monitoring_configuration)
        if s3_monitoring_configuration is not None:
            pulumi.set(__self__, "s3_monitoring_configuration", s3_monitoring_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLoggingConfiguration")
    def cloudwatch_logging_configuration(self) -> Optional[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs']]:
        return pulumi.get(self, "cloudwatch_logging_configuration")

    @cloudwatch_logging_configuration.setter
    def cloudwatch_logging_configuration(self, value: Optional[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs']]):
        pulumi.set(self, "cloudwatch_logging_configuration", value)

    @_builtins.property
    @pulumi.getter(name="managedPersistenceMonitoringConfiguration")
    def managed_persistence_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs']]:
        return pulumi.get(self, "managed_persistence_monitoring_configuration")

    @managed_persistence_monitoring_configuration.setter
    def managed_persistence_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs']]):
        pulumi.set(self, "managed_persistence_monitoring_configuration", value)

    @_builtins.property
    @pulumi.getter(name="prometheusMonitoringConfiguration")
    def prometheus_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs']]:
        return pulumi.get(self, "prometheus_monitoring_configuration")

    @prometheus_monitoring_configuration.setter
    def prometheus_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs']]):
        pulumi.set(self, "prometheus_monitoring_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3MonitoringConfiguration")
    def s3_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs']]:
        return pulumi.get(self, "s3_monitoring_configuration")

    @s3_monitoring_configuration.setter
    def s3_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs']]):
        pulumi.set(self, "s3_monitoring_configuration", value)


if not MYPY:
    class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        log_stream_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        log_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgsDict']]]]
elif False:
    ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_name_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_types: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs']]]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_stream_name_prefix")

    @log_stream_name_prefix.setter
    def log_stream_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs']]]]:
        return pulumi.get(self, "log_types")

    @log_types.setter
    def log_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs']]]]):
        pulumi.set(self, "log_types", value)


if not MYPY:
    class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)


if not MYPY:
    class ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgsDict(TypedDict):
        remote_write_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 remote_write_url: Optional[pulumi.Input[_builtins.str]] = None):
        if remote_write_url is not None:
            pulumi.set(__self__, "remote_write_url", remote_write_url)

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_write_url")

    @remote_write_url.setter
    def remote_write_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_write_url", value)


if not MYPY:
    class ApplicationMonitoringConfigurationS3MonitoringConfigurationArgsDict(TypedDict):
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        log_uri: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationMonitoringConfigurationS3MonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs:
    def __init__(__self__, *,
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 log_uri: Optional[pulumi.Input[_builtins.str]] = None):
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_uri")

    @log_uri.setter
    def log_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_uri", value)


if not MYPY:
    class ApplicationNetworkConfigurationArgsDict(TypedDict):
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ApplicationNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationNetworkConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class ApplicationRuntimeConfigurationArgsDict(TypedDict):
        classification: pulumi.Input[_builtins.str]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ApplicationRuntimeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRuntimeConfigurationArgs:
    def __init__(__self__, *,
                 classification: pulumi.Input[_builtins.str],
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class ApplicationSchedulerConfigurationArgsDict(TypedDict):
        max_concurrent_runs: NotRequired[pulumi.Input[_builtins.int]]
        queue_timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ApplicationSchedulerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSchedulerConfigurationArgs:
    def __init__(__self__, *,
                 max_concurrent_runs: Optional[pulumi.Input[_builtins.int]] = None,
                 queue_timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if queue_timeout_minutes is not None:
            pulumi.set(__self__, "queue_timeout_minutes", queue_timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_concurrent_runs")

    @max_concurrent_runs.setter
    def max_concurrent_runs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrent_runs", value)

    @_builtins.property
    @pulumi.getter(name="queueTimeoutMinutes")
    def queue_timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "queue_timeout_minutes")

    @queue_timeout_minutes.setter
    def queue_timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_timeout_minutes", value)


