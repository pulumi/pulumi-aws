# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationAutoStartConfigurationArgs',
    'ApplicationAutoStartConfigurationArgsDict',
    'ApplicationAutoStopConfigurationArgs',
    'ApplicationAutoStopConfigurationArgsDict',
    'ApplicationImageConfigurationArgs',
    'ApplicationImageConfigurationArgsDict',
    'ApplicationInitialCapacityArgs',
    'ApplicationInitialCapacityArgsDict',
    'ApplicationInitialCapacityInitialCapacityConfigArgs',
    'ApplicationInitialCapacityInitialCapacityConfigArgsDict',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict',
    'ApplicationInteractiveConfigurationArgs',
    'ApplicationInteractiveConfigurationArgsDict',
    'ApplicationMaximumCapacityArgs',
    'ApplicationMaximumCapacityArgsDict',
    'ApplicationNetworkConfigurationArgs',
    'ApplicationNetworkConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationAutoStartConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the application to automatically start on job submission. Defaults to `true`.
        """
elif False:
    ApplicationAutoStartConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStartConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enables the application to automatically start on job submission. Defaults to `true`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the application to automatically start on job submission. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplicationAutoStopConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
        """
        idle_timeout_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
        """
elif False:
    ApplicationAutoStopConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStopConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idle_timeout_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
        :param pulumi.Input[builtins.int] idle_timeout_minutes: The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
        """
        return pulumi.get(self, "idle_timeout_minutes")

    @idle_timeout_minutes.setter
    def idle_timeout_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_timeout_minutes", value)


if not MYPY:
    class ApplicationImageConfigurationArgsDict(TypedDict):
        image_uri: pulumi.Input[builtins.str]
        """
        The image URI.
        """
elif False:
    ApplicationImageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationImageConfigurationArgs:
    def __init__(__self__, *,
                 image_uri: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] image_uri: The image URI.
        """
        pulumi.set(__self__, "image_uri", image_uri)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[builtins.str]:
        """
        The image URI.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "image_uri", value)


if not MYPY:
    class ApplicationInitialCapacityArgsDict(TypedDict):
        initial_capacity_type: pulumi.Input[builtins.str]
        """
        The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
        """
        initial_capacity_config: NotRequired[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgsDict']]
        """
        The initial capacity configuration per worker.
        """
elif False:
    ApplicationInitialCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityArgs:
    def __init__(__self__, *,
                 initial_capacity_type: pulumi.Input[builtins.str],
                 initial_capacity_config: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']] = None):
        """
        :param pulumi.Input[builtins.str] initial_capacity_type: The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
        :param pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs'] initial_capacity_config: The initial capacity configuration per worker.
        """
        pulumi.set(__self__, "initial_capacity_type", initial_capacity_type)
        if initial_capacity_config is not None:
            pulumi.set(__self__, "initial_capacity_config", initial_capacity_config)

    @property
    @pulumi.getter(name="initialCapacityType")
    def initial_capacity_type(self) -> pulumi.Input[builtins.str]:
        """
        The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
        """
        return pulumi.get(self, "initial_capacity_type")

    @initial_capacity_type.setter
    def initial_capacity_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "initial_capacity_type", value)

    @property
    @pulumi.getter(name="initialCapacityConfig")
    def initial_capacity_config(self) -> Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']]:
        """
        The initial capacity configuration per worker.
        """
        return pulumi.get(self, "initial_capacity_config")

    @initial_capacity_config.setter
    def initial_capacity_config(self, value: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigArgs']]):
        pulumi.set(self, "initial_capacity_config", value)


if not MYPY:
    class ApplicationInitialCapacityInitialCapacityConfigArgsDict(TypedDict):
        worker_count: pulumi.Input[builtins.int]
        """
        The number of workers in the initial capacity configuration.
        """
        worker_configuration: NotRequired[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict']]
        """
        The resource configuration of the initial capacity configuration.
        """
elif False:
    ApplicationInitialCapacityInitialCapacityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityInitialCapacityConfigArgs:
    def __init__(__self__, *,
                 worker_count: pulumi.Input[builtins.int],
                 worker_configuration: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']] = None):
        """
        :param pulumi.Input[builtins.int] worker_count: The number of workers in the initial capacity configuration.
        :param pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs'] worker_configuration: The resource configuration of the initial capacity configuration.
        """
        pulumi.set(__self__, "worker_count", worker_count)
        if worker_configuration is not None:
            pulumi.set(__self__, "worker_configuration", worker_configuration)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> pulumi.Input[builtins.int]:
        """
        The number of workers in the initial capacity configuration.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "worker_count", value)

    @property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']]:
        """
        The resource configuration of the initial capacity configuration.
        """
        return pulumi.get(self, "worker_configuration")

    @worker_configuration.setter
    def worker_configuration(self, value: Optional[pulumi.Input['ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs']]):
        pulumi.set(self, "worker_configuration", value)


if not MYPY:
    class ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict(TypedDict):
        cpu: pulumi.Input[builtins.str]
        """
        The CPU requirements for every worker instance of the worker type.
        """
        memory: pulumi.Input[builtins.str]
        """
        The memory requirements for every worker instance of the worker type.
        """
        disk: NotRequired[pulumi.Input[builtins.str]]
        """
        The disk requirements for every worker instance of the worker type.
        """
elif False:
    ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[builtins.str],
                 memory: pulumi.Input[builtins.str],
                 disk: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: The CPU requirements for every worker instance of the worker type.
        :param pulumi.Input[builtins.str] memory: The memory requirements for every worker instance of the worker type.
        :param pulumi.Input[builtins.str] disk: The disk requirements for every worker instance of the worker type.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[builtins.str]:
        """
        The CPU requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[builtins.str]:
        """
        The memory requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The disk requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk", value)


if not MYPY:
    class ApplicationInteractiveConfigurationArgsDict(TypedDict):
        livy_endpoint_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs.
        """
        studio_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables you to connect an application to Amazon EMR Studio to run interactive workloads in a notebook.
        """
elif False:
    ApplicationInteractiveConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInteractiveConfigurationArgs:
    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 studio_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] livy_endpoint_enabled: Enables an Apache Livy endpoint that you can connect to and run interactive jobs.
        :param pulumi.Input[builtins.bool] studio_enabled: Enables you to connect an application to Amazon EMR Studio to run interactive workloads in a notebook.
        """
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs.
        """
        return pulumi.get(self, "livy_endpoint_enabled")

    @livy_endpoint_enabled.setter
    def livy_endpoint_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "livy_endpoint_enabled", value)

    @property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables you to connect an application to Amazon EMR Studio to run interactive workloads in a notebook.
        """
        return pulumi.get(self, "studio_enabled")

    @studio_enabled.setter
    def studio_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "studio_enabled", value)


if not MYPY:
    class ApplicationMaximumCapacityArgsDict(TypedDict):
        cpu: pulumi.Input[builtins.str]
        """
        The maximum allowed CPU for an application.
        """
        memory: pulumi.Input[builtins.str]
        """
        The maximum allowed resources for an application.
        """
        disk: NotRequired[pulumi.Input[builtins.str]]
        """
        The maximum allowed disk for an application.
        """
elif False:
    ApplicationMaximumCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMaximumCapacityArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[builtins.str],
                 memory: pulumi.Input[builtins.str],
                 disk: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cpu: The maximum allowed CPU for an application.
        :param pulumi.Input[builtins.str] memory: The maximum allowed resources for an application.
        :param pulumi.Input[builtins.str] disk: The maximum allowed disk for an application.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[builtins.str]:
        """
        The maximum allowed CPU for an application.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[builtins.str]:
        """
        The maximum allowed resources for an application.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The maximum allowed disk for an application.
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk", value)


if not MYPY:
    class ApplicationNetworkConfigurationArgsDict(TypedDict):
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The array of security group Ids for customer VPC connectivity.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The array of subnet Ids for customer VPC connectivity.
        """
elif False:
    ApplicationNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationNetworkConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: The array of security group Ids for customer VPC connectivity.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnet_ids: The array of subnet Ids for customer VPC connectivity.
        """
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The array of security group Ids for customer VPC connectivity.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The array of subnet Ids for customer VPC connectivity.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


