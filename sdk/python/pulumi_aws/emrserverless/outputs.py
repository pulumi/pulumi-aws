# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationAutoStartConfiguration',
    'ApplicationAutoStopConfiguration',
    'ApplicationImageConfiguration',
    'ApplicationInitialCapacity',
    'ApplicationInitialCapacityInitialCapacityConfig',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration',
    'ApplicationInteractiveConfiguration',
    'ApplicationMaximumCapacity',
    'ApplicationMonitoringConfiguration',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType',
    'ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration',
    'ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration',
    'ApplicationMonitoringConfigurationS3MonitoringConfiguration',
    'ApplicationNetworkConfiguration',
    'ApplicationRuntimeConfiguration',
    'ApplicationSchedulerConfiguration',
]

@pulumi.output_type
class ApplicationAutoStartConfiguration(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplicationAutoStopConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeoutMinutes":
            suggest = "idle_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAutoStopConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout_minutes: Optional[_builtins.int] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "idle_timeout_minutes")


@pulumi.output_type
class ApplicationImageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationImageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationImageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationImageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: _builtins.str):
        pulumi.set(__self__, "image_uri", image_uri)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> _builtins.str:
        return pulumi.get(self, "image_uri")


@pulumi.output_type
class ApplicationInitialCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialCapacityType":
            suggest = "initial_capacity_type"
        elif key == "initialCapacityConfig":
            suggest = "initial_capacity_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInitialCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInitialCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInitialCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_capacity_type: _builtins.str,
                 initial_capacity_config: Optional['outputs.ApplicationInitialCapacityInitialCapacityConfig'] = None):
        pulumi.set(__self__, "initial_capacity_type", initial_capacity_type)
        if initial_capacity_config is not None:
            pulumi.set(__self__, "initial_capacity_config", initial_capacity_config)

    @_builtins.property
    @pulumi.getter(name="initialCapacityType")
    def initial_capacity_type(self) -> _builtins.str:
        return pulumi.get(self, "initial_capacity_type")

    @_builtins.property
    @pulumi.getter(name="initialCapacityConfig")
    def initial_capacity_config(self) -> Optional['outputs.ApplicationInitialCapacityInitialCapacityConfig']:
        return pulumi.get(self, "initial_capacity_config")


@pulumi.output_type
class ApplicationInitialCapacityInitialCapacityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workerCount":
            suggest = "worker_count"
        elif key == "workerConfiguration":
            suggest = "worker_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInitialCapacityInitialCapacityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInitialCapacityInitialCapacityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInitialCapacityInitialCapacityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 worker_count: _builtins.int,
                 worker_configuration: Optional['outputs.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration'] = None):
        pulumi.set(__self__, "worker_count", worker_count)
        if worker_configuration is not None:
            pulumi.set(__self__, "worker_configuration", worker_configuration)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> _builtins.int:
        return pulumi.get(self, "worker_count")

    @_builtins.property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> Optional['outputs.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration']:
        return pulumi.get(self, "worker_configuration")


@pulumi.output_type
class ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disk")


@pulumi.output_type
class ApplicationInteractiveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livyEndpointEnabled":
            suggest = "livy_endpoint_enabled"
        elif key == "studioEnabled":
            suggest = "studio_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInteractiveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[_builtins.bool] = None,
                 studio_enabled: Optional[_builtins.bool] = None):
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @_builtins.property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "livy_endpoint_enabled")

    @_builtins.property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "studio_enabled")


@pulumi.output_type
class ApplicationMaximumCapacity(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disk")


@pulumi.output_type
class ApplicationMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLoggingConfiguration":
            suggest = "cloudwatch_logging_configuration"
        elif key == "managedPersistenceMonitoringConfiguration":
            suggest = "managed_persistence_monitoring_configuration"
        elif key == "prometheusMonitoringConfiguration":
            suggest = "prometheus_monitoring_configuration"
        elif key == "s3MonitoringConfiguration":
            suggest = "s3_monitoring_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_logging_configuration: Optional['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration'] = None,
                 managed_persistence_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration'] = None,
                 prometheus_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration'] = None,
                 s3_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationS3MonitoringConfiguration'] = None):
        if cloudwatch_logging_configuration is not None:
            pulumi.set(__self__, "cloudwatch_logging_configuration", cloudwatch_logging_configuration)
        if managed_persistence_monitoring_configuration is not None:
            pulumi.set(__self__, "managed_persistence_monitoring_configuration", managed_persistence_monitoring_configuration)
        if prometheus_monitoring_configuration is not None:
            pulumi.set(__self__, "prometheus_monitoring_configuration", prometheus_monitoring_configuration)
        if s3_monitoring_configuration is not None:
            pulumi.set(__self__, "s3_monitoring_configuration", s3_monitoring_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLoggingConfiguration")
    def cloudwatch_logging_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration']:
        return pulumi.get(self, "cloudwatch_logging_configuration")

    @_builtins.property
    @pulumi.getter(name="managedPersistenceMonitoringConfiguration")
    def managed_persistence_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration']:
        return pulumi.get(self, "managed_persistence_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="prometheusMonitoringConfiguration")
    def prometheus_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration']:
        return pulumi.get(self, "prometheus_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="s3MonitoringConfiguration")
    def s3_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationS3MonitoringConfiguration']:
        return pulumi.get(self, "s3_monitoring_configuration")


@pulumi.output_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamNamePrefix":
            suggest = "log_stream_name_prefix"
        elif key == "logTypes":
            suggest = "log_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_group_name: Optional[_builtins.str] = None,
                 log_stream_name_prefix: Optional[_builtins.str] = None,
                 log_types: Optional[Sequence['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_stream_name_prefix")

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[Sequence['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType']]:
        return pulumi.get(self, "log_types")


@pulumi.output_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 encryption_key_arn: Optional[_builtins.str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_key_arn")


@pulumi.output_type
class ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteWriteUrl":
            suggest = "remote_write_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_write_url: Optional[_builtins.str] = None):
        if remote_write_url is not None:
            pulumi.set(__self__, "remote_write_url", remote_write_url)

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_write_url")


@pulumi.output_type
class ApplicationMonitoringConfigurationS3MonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logUri":
            suggest = "log_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationS3MonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationS3MonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationS3MonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_uri: Optional[_builtins.str] = None):
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_uri")


@pulumi.output_type
class ApplicationNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ApplicationRuntimeConfiguration(dict):
    def __init__(__self__, *,
                 classification: _builtins.str,
                 properties: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "properties")


@pulumi.output_type
class ApplicationSchedulerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"
        elif key == "queueTimeoutMinutes":
            suggest = "queue_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSchedulerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[_builtins.int] = None,
                 queue_timeout_minutes: Optional[_builtins.int] = None):
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if queue_timeout_minutes is not None:
            pulumi.set(__self__, "queue_timeout_minutes", queue_timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_concurrent_runs")

    @_builtins.property
    @pulumi.getter(name="queueTimeoutMinutes")
    def queue_timeout_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "queue_timeout_minutes")


