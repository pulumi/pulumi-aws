# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationAutoStartConfiguration',
    'ApplicationAutoStopConfiguration',
    'ApplicationImageConfiguration',
    'ApplicationInitialCapacity',
    'ApplicationInitialCapacityInitialCapacityConfig',
    'ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration',
    'ApplicationInteractiveConfiguration',
    'ApplicationMaximumCapacity',
    'ApplicationMonitoringConfiguration',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration',
    'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType',
    'ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration',
    'ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration',
    'ApplicationMonitoringConfigurationS3MonitoringConfiguration',
    'ApplicationNetworkConfiguration',
    'ApplicationRuntimeConfiguration',
    'ApplicationSchedulerConfiguration',
]

@pulumi.output_type
class ApplicationAutoStartConfiguration(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables the application to automatically start on job submission. Defaults to `true`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables the application to automatically start on job submission. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplicationAutoStopConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeoutMinutes":
            suggest = "idle_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAutoStopConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
        :param _builtins.int idle_timeout_minutes: The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables the application to automatically stop after a certain amount of time being idle. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of idle time in minutes after which your application will automatically stop. Defaults to `15` minutes.
        """
        return pulumi.get(self, "idle_timeout_minutes")


@pulumi.output_type
class ApplicationImageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationImageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationImageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationImageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: _builtins.str):
        """
        :param _builtins.str image_uri: The image URI.
        """
        pulumi.set(__self__, "image_uri", image_uri)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> _builtins.str:
        """
        The image URI.
        """
        return pulumi.get(self, "image_uri")


@pulumi.output_type
class ApplicationInitialCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialCapacityType":
            suggest = "initial_capacity_type"
        elif key == "initialCapacityConfig":
            suggest = "initial_capacity_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInitialCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInitialCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInitialCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_capacity_type: _builtins.str,
                 initial_capacity_config: Optional['outputs.ApplicationInitialCapacityInitialCapacityConfig'] = None):
        """
        :param _builtins.str initial_capacity_type: The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
        :param 'ApplicationInitialCapacityInitialCapacityConfigArgs' initial_capacity_config: The initial capacity configuration per worker.
        """
        pulumi.set(__self__, "initial_capacity_type", initial_capacity_type)
        if initial_capacity_config is not None:
            pulumi.set(__self__, "initial_capacity_config", initial_capacity_config)

    @_builtins.property
    @pulumi.getter(name="initialCapacityType")
    def initial_capacity_type(self) -> _builtins.str:
        """
        The worker type for an analytics framework. For Spark applications, the key can either be set to `Driver` or `Executor`. For Hive applications, it can be set to `HiveDriver` or `TezTask`.
        """
        return pulumi.get(self, "initial_capacity_type")

    @_builtins.property
    @pulumi.getter(name="initialCapacityConfig")
    def initial_capacity_config(self) -> Optional['outputs.ApplicationInitialCapacityInitialCapacityConfig']:
        """
        The initial capacity configuration per worker.
        """
        return pulumi.get(self, "initial_capacity_config")


@pulumi.output_type
class ApplicationInitialCapacityInitialCapacityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workerCount":
            suggest = "worker_count"
        elif key == "workerConfiguration":
            suggest = "worker_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInitialCapacityInitialCapacityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInitialCapacityInitialCapacityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInitialCapacityInitialCapacityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 worker_count: _builtins.int,
                 worker_configuration: Optional['outputs.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration'] = None):
        """
        :param _builtins.int worker_count: The number of workers in the initial capacity configuration.
        :param 'ApplicationInitialCapacityInitialCapacityConfigWorkerConfigurationArgs' worker_configuration: The resource configuration of the initial capacity configuration.
        """
        pulumi.set(__self__, "worker_count", worker_count)
        if worker_configuration is not None:
            pulumi.set(__self__, "worker_configuration", worker_configuration)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> _builtins.int:
        """
        The number of workers in the initial capacity configuration.
        """
        return pulumi.get(self, "worker_count")

    @_builtins.property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> Optional['outputs.ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration']:
        """
        The resource configuration of the initial capacity configuration.
        """
        return pulumi.get(self, "worker_configuration")


@pulumi.output_type
class ApplicationInitialCapacityInitialCapacityConfigWorkerConfiguration(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu: The CPU requirements for every worker instance of the worker type.
        :param _builtins.str memory: The memory requirements for every worker instance of the worker type.
        :param _builtins.str disk: The disk requirements for every worker instance of the worker type.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        The CPU requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        The memory requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        """
        The disk requirements for every worker instance of the worker type.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class ApplicationInteractiveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livyEndpointEnabled":
            suggest = "livy_endpoint_enabled"
        elif key == "studioEnabled":
            suggest = "studio_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInteractiveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[_builtins.bool] = None,
                 studio_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool livy_endpoint_enabled: Enables an Apache Livy endpoint that you can connect to and run interactive jobs.
        :param _builtins.bool studio_enabled: Enables you to connect an application to Amazon EMR Studio to run interactive workloads in a notebook.
        """
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @_builtins.property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs.
        """
        return pulumi.get(self, "livy_endpoint_enabled")

    @_builtins.property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables you to connect an application to Amazon EMR Studio to run interactive workloads in a notebook.
        """
        return pulumi.get(self, "studio_enabled")


@pulumi.output_type
class ApplicationMaximumCapacity(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu: The maximum allowed CPU for an application.
        :param _builtins.str memory: The maximum allowed resources for an application.
        :param _builtins.str disk: The maximum allowed disk for an application.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        The maximum allowed CPU for an application.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        The maximum allowed resources for an application.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        """
        The maximum allowed disk for an application.
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class ApplicationMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLoggingConfiguration":
            suggest = "cloudwatch_logging_configuration"
        elif key == "managedPersistenceMonitoringConfiguration":
            suggest = "managed_persistence_monitoring_configuration"
        elif key == "prometheusMonitoringConfiguration":
            suggest = "prometheus_monitoring_configuration"
        elif key == "s3MonitoringConfiguration":
            suggest = "s3_monitoring_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_logging_configuration: Optional['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration'] = None,
                 managed_persistence_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration'] = None,
                 prometheus_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration'] = None,
                 s3_monitoring_configuration: Optional['outputs.ApplicationMonitoringConfigurationS3MonitoringConfiguration'] = None):
        """
        :param 'ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationArgs' cloudwatch_logging_configuration: The Amazon CloudWatch configuration for monitoring logs.
        :param 'ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfigurationArgs' managed_persistence_monitoring_configuration: The managed log persistence configuration for monitoring logs.
        :param 'ApplicationMonitoringConfigurationPrometheusMonitoringConfigurationArgs' prometheus_monitoring_configuration: The Prometheus configuration for monitoring metrics.
        :param 'ApplicationMonitoringConfigurationS3MonitoringConfigurationArgs' s3_monitoring_configuration: The Amazon S3 configuration for monitoring log publishing.
        """
        if cloudwatch_logging_configuration is not None:
            pulumi.set(__self__, "cloudwatch_logging_configuration", cloudwatch_logging_configuration)
        if managed_persistence_monitoring_configuration is not None:
            pulumi.set(__self__, "managed_persistence_monitoring_configuration", managed_persistence_monitoring_configuration)
        if prometheus_monitoring_configuration is not None:
            pulumi.set(__self__, "prometheus_monitoring_configuration", prometheus_monitoring_configuration)
        if s3_monitoring_configuration is not None:
            pulumi.set(__self__, "s3_monitoring_configuration", s3_monitoring_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLoggingConfiguration")
    def cloudwatch_logging_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration']:
        """
        The Amazon CloudWatch configuration for monitoring logs.
        """
        return pulumi.get(self, "cloudwatch_logging_configuration")

    @_builtins.property
    @pulumi.getter(name="managedPersistenceMonitoringConfiguration")
    def managed_persistence_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration']:
        """
        The managed log persistence configuration for monitoring logs.
        """
        return pulumi.get(self, "managed_persistence_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="prometheusMonitoringConfiguration")
    def prometheus_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration']:
        """
        The Prometheus configuration for monitoring metrics.
        """
        return pulumi.get(self, "prometheus_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="s3MonitoringConfiguration")
    def s3_monitoring_configuration(self) -> Optional['outputs.ApplicationMonitoringConfigurationS3MonitoringConfiguration']:
        """
        The Amazon S3 configuration for monitoring log publishing.
        """
        return pulumi.get(self, "s3_monitoring_configuration")


@pulumi.output_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamNamePrefix":
            suggest = "log_stream_name_prefix"
        elif key == "logTypes":
            suggest = "log_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationCloudwatchLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_group_name: Optional[_builtins.str] = None,
                 log_stream_name_prefix: Optional[_builtins.str] = None,
                 log_types: Optional[Sequence['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType']] = None):
        """
        :param _builtins.bool enabled: Enables CloudWatch logging.
        :param _builtins.str encryption_key_arn: The AWS Key Management Service (KMS) key ARN to encrypt the logs that you store in CloudWatch Logs.
        :param _builtins.str log_group_name: The name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        :param _builtins.str log_stream_name_prefix: Prefix for the CloudWatch log stream name.
        :param Sequence['ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogTypeArgs'] log_types: The types of logs that you want to publish to CloudWatch. If you don't specify any log types, driver STDOUT and STDERR logs will be published to CloudWatch Logs by default. See log_types for more details.
        """
        pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables CloudWatch logging.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        The AWS Key Management Service (KMS) key ARN to encrypt the logs that you store in CloudWatch Logs.
        """
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[_builtins.str]:
        """
        Prefix for the CloudWatch log stream name.
        """
        return pulumi.get(self, "log_stream_name_prefix")

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[Sequence['outputs.ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType']]:
        """
        The types of logs that you want to publish to CloudWatch. If you don't specify any log types, driver STDOUT and STDERR logs will be published to CloudWatch Logs by default. See log_types for more details.
        """
        return pulumi.get(self, "log_types")


@pulumi.output_type
class ApplicationMonitoringConfigurationCloudwatchLoggingConfigurationLogType(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The worker type. Valid values are `SPARK_DRIVER`, `SPARK_EXECUTOR`, `HIVE_DRIVER`, and `TEZ_TASK`.
        :param Sequence[_builtins.str] values: The list of log types to publish. Valid values are `STDOUT`, `STDERR`, `HIVE_LOG`, `TEZ_AM`, and `SYSTEM_LOGS`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The worker type. Valid values are `SPARK_DRIVER`, `SPARK_EXECUTOR`, `HIVE_DRIVER`, and `TEZ_TASK`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of log types to publish. Valid values are `STDOUT`, `STDERR`, `HIVE_LOG`, `TEZ_AM`, and `SYSTEM_LOGS`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 encryption_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Enables managed log persistence for monitoring logs.
        :param _builtins.str encryption_key_arn: The KMS key ARN to encrypt the logs stored in managed persistence.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables managed log persistence for monitoring logs.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        The KMS key ARN to encrypt the logs stored in managed persistence.
        """
        return pulumi.get(self, "encryption_key_arn")


@pulumi.output_type
class ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteWriteUrl":
            suggest = "remote_write_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_write_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str remote_write_url: The Prometheus remote write URL for sending metrics. Only supported in EMR 7.1.0 and later versions.
        """
        if remote_write_url is not None:
            pulumi.set(__self__, "remote_write_url", remote_write_url)

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> Optional[_builtins.str]:
        """
        The Prometheus remote write URL for sending metrics. Only supported in EMR 7.1.0 and later versions.
        """
        return pulumi.get(self, "remote_write_url")


@pulumi.output_type
class ApplicationMonitoringConfigurationS3MonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logUri":
            suggest = "log_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfigurationS3MonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfigurationS3MonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfigurationS3MonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str encryption_key_arn: The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        :param _builtins.str log_uri: The Amazon S3 destination URI for log publishing.
        """
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        """
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[_builtins.str]:
        """
        The Amazon S3 destination URI for log publishing.
        """
        return pulumi.get(self, "log_uri")


@pulumi.output_type
class ApplicationNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] security_group_ids: The array of security group Ids for customer VPC connectivity.
        :param Sequence[_builtins.str] subnet_ids: The array of subnet Ids for customer VPC connectivity.
        """
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The array of security group Ids for customer VPC connectivity.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The array of subnet Ids for customer VPC connectivity.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ApplicationRuntimeConfiguration(dict):
    def __init__(__self__, *,
                 classification: _builtins.str,
                 properties: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str classification: The classification within a configuration.
        :param Mapping[str, _builtins.str] properties: A set of properties specified within a configuration classification.
        """
        pulumi.set(__self__, "classification", classification)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        """
        The classification within a configuration.
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of properties specified within a configuration classification.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class ApplicationSchedulerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"
        elif key == "queueTimeoutMinutes":
            suggest = "queue_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSchedulerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[_builtins.int] = None,
                 queue_timeout_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_runs: Maximum concurrent job runs on this application. Valid range is `1` to `1000`. Defaults to `15`.
        :param _builtins.int queue_timeout_minutes: Maximum duration in minutes for the job in QUEUED state. Valid range is from `15` to `720`. Defaults to `360`.
        """
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if queue_timeout_minutes is not None:
            pulumi.set(__self__, "queue_timeout_minutes", queue_timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[_builtins.int]:
        """
        Maximum concurrent job runs on this application. Valid range is `1` to `1000`. Defaults to `15`.
        """
        return pulumi.get(self, "max_concurrent_runs")

    @_builtins.property
    @pulumi.getter(name="queueTimeoutMinutes")
    def queue_timeout_minutes(self) -> Optional[_builtins.int]:
        """
        Maximum duration in minutes for the job in QUEUED state. Valid range is from `15` to `720`. Defaults to `360`.
        """
        return pulumi.get(self, "queue_timeout_minutes")


