# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AliasRoutingStrategy',
    'BuildStorageLocation',
    'FleetCertificateConfiguration',
    'FleetEc2InboundPermission',
    'FleetResourceCreationLimitPolicy',
    'FleetRuntimeConfiguration',
    'FleetRuntimeConfigurationServerProcess',
    'GameServerGroupAutoScalingPolicy',
    'GameServerGroupAutoScalingPolicyTargetTrackingConfiguration',
    'GameServerGroupInstanceDefinition',
    'GameServerGroupLaunchTemplate',
    'GameSessionQueuePlayerLatencyPolicy',
    'MatchmakingConfigurationGameProperty',
    'ScriptStorageLocation',
]

@pulumi.output_type
class AliasRoutingStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fleetId":
            suggest = "fleet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasRoutingStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasRoutingStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasRoutingStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fleet_id: Optional[str] = None,
                 message: Optional[str] = None):
        """
        :param str type: Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
        :param str fleet_id: ID of the GameLift Fleet to point the alias to.
        :param str message: Message text to be used with the `TERMINAL` routing strategy.
        """
        AliasRoutingStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            fleet_id=fleet_id,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             fleet_id: Optional[str] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if fleet_id is None and 'fleetId' in kwargs:
            fleet_id = kwargs['fleetId']

        _setter("type", type)
        if fleet_id is not None:
            _setter("fleet_id", fleet_id)
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of routing strategyE.g., `SIMPLE` or `TERMINAL`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fleetId")
    def fleet_id(self) -> Optional[str]:
        """
        ID of the GameLift Fleet to point the alias to.
        """
        return pulumi.get(self, "fleet_id")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message text to be used with the `TERMINAL` routing strategy.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class BuildStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "objectVersion":
            suggest = "object_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 key: str,
                 role_arn: str,
                 object_version: Optional[str] = None):
        """
        :param str bucket: Name of your S3 bucket.
        :param str key: Name of the zip file containing your build files.
        :param str role_arn: ARN of the access role that allows Amazon GameLift to access your S3 bucket.
        :param str object_version: A specific version of the file. If not set, the latest version of the file is retrieved.
        """
        BuildStorageLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
            role_arn=role_arn,
            object_version=object_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[str] = None,
             key: Optional[str] = None,
             role_arn: Optional[str] = None,
             object_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if object_version is None and 'objectVersion' in kwargs:
            object_version = kwargs['objectVersion']

        _setter("bucket", bucket)
        _setter("key", key)
        _setter("role_arn", role_arn)
        if object_version is not None:
            _setter("object_version", object_version)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name of the zip file containing your build files.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the access role that allows Amazon GameLift to access your S3 bucket.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="objectVersion")
    def object_version(self) -> Optional[str]:
        """
        A specific version of the file. If not set, the latest version of the file is retrieved.
        """
        return pulumi.get(self, "object_version")


@pulumi.output_type
class FleetCertificateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetCertificateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetCertificateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetCertificateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: Optional[str] = None):
        """
        :param str certificate_type: Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
        """
        FleetCertificateConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_type=certificate_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_type is None and 'certificateType' in kwargs:
            certificate_type = kwargs['certificateType']

        if certificate_type is not None:
            _setter("certificate_type", certificate_type)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[str]:
        """
        Indicates whether a TLS/SSL certificate is generated for a fleet. Valid values are `DISABLED` and `GENERATED`. Default value is `DISABLED`.
        """
        return pulumi.get(self, "certificate_type")


@pulumi.output_type
class FleetEc2InboundPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ipRange":
            suggest = "ip_range"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetEc2InboundPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetEc2InboundPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetEc2InboundPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 ip_range: str,
                 protocol: str,
                 to_port: int):
        """
        :param int from_port: Starting value for a range of allowed port numbers.
        :param str ip_range: Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
        :param str protocol: Network communication protocol used by the fleetE.g., `TCP` or `UDP`
        :param int to_port: Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `from_port`.
        """
        FleetEc2InboundPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_port=from_port,
            ip_range=ip_range,
            protocol=protocol,
            to_port=to_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_port: Optional[int] = None,
             ip_range: Optional[str] = None,
             protocol: Optional[str] = None,
             to_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_port is None and 'fromPort' in kwargs:
            from_port = kwargs['fromPort']
        if from_port is None:
            raise TypeError("Missing 'from_port' argument")
        if ip_range is None and 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if ip_range is None:
            raise TypeError("Missing 'ip_range' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if to_port is None and 'toPort' in kwargs:
            to_port = kwargs['toPort']
        if to_port is None:
            raise TypeError("Missing 'to_port' argument")

        _setter("from_port", from_port)
        _setter("ip_range", ip_range)
        _setter("protocol", protocol)
        _setter("to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        """
        Starting value for a range of allowed port numbers.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        Range of allowed IP addresses expressed in CIDR notationE.g., `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network communication protocol used by the fleetE.g., `TCP` or `UDP`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        """
        Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `from_port`.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class FleetResourceCreationLimitPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newGameSessionsPerCreator":
            suggest = "new_game_sessions_per_creator"
        elif key == "policyPeriodInMinutes":
            suggest = "policy_period_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetResourceCreationLimitPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetResourceCreationLimitPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetResourceCreationLimitPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 new_game_sessions_per_creator: Optional[int] = None,
                 policy_period_in_minutes: Optional[int] = None):
        """
        :param int new_game_sessions_per_creator: Maximum number of game sessions that an individual can create during the policy period.
        :param int policy_period_in_minutes: Time span used in evaluating the resource creation limit policy.
        """
        FleetResourceCreationLimitPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            new_game_sessions_per_creator=new_game_sessions_per_creator,
            policy_period_in_minutes=policy_period_in_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             new_game_sessions_per_creator: Optional[int] = None,
             policy_period_in_minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if new_game_sessions_per_creator is None and 'newGameSessionsPerCreator' in kwargs:
            new_game_sessions_per_creator = kwargs['newGameSessionsPerCreator']
        if policy_period_in_minutes is None and 'policyPeriodInMinutes' in kwargs:
            policy_period_in_minutes = kwargs['policyPeriodInMinutes']

        if new_game_sessions_per_creator is not None:
            _setter("new_game_sessions_per_creator", new_game_sessions_per_creator)
        if policy_period_in_minutes is not None:
            _setter("policy_period_in_minutes", policy_period_in_minutes)

    @property
    @pulumi.getter(name="newGameSessionsPerCreator")
    def new_game_sessions_per_creator(self) -> Optional[int]:
        """
        Maximum number of game sessions that an individual can create during the policy period.
        """
        return pulumi.get(self, "new_game_sessions_per_creator")

    @property
    @pulumi.getter(name="policyPeriodInMinutes")
    def policy_period_in_minutes(self) -> Optional[int]:
        """
        Time span used in evaluating the resource creation limit policy.
        """
        return pulumi.get(self, "policy_period_in_minutes")


@pulumi.output_type
class FleetRuntimeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gameSessionActivationTimeoutSeconds":
            suggest = "game_session_activation_timeout_seconds"
        elif key == "maxConcurrentGameSessionActivations":
            suggest = "max_concurrent_game_session_activations"
        elif key == "serverProcesses":
            suggest = "server_processes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetRuntimeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetRuntimeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetRuntimeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 game_session_activation_timeout_seconds: Optional[int] = None,
                 max_concurrent_game_session_activations: Optional[int] = None,
                 server_processes: Optional[Sequence['outputs.FleetRuntimeConfigurationServerProcess']] = None):
        """
        :param int game_session_activation_timeout_seconds: Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
        :param int max_concurrent_game_session_activations: Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
        :param Sequence['FleetRuntimeConfigurationServerProcessArgs'] server_processes: Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
        """
        FleetRuntimeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            game_session_activation_timeout_seconds=game_session_activation_timeout_seconds,
            max_concurrent_game_session_activations=max_concurrent_game_session_activations,
            server_processes=server_processes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             game_session_activation_timeout_seconds: Optional[int] = None,
             max_concurrent_game_session_activations: Optional[int] = None,
             server_processes: Optional[Sequence['outputs.FleetRuntimeConfigurationServerProcess']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if game_session_activation_timeout_seconds is None and 'gameSessionActivationTimeoutSeconds' in kwargs:
            game_session_activation_timeout_seconds = kwargs['gameSessionActivationTimeoutSeconds']
        if max_concurrent_game_session_activations is None and 'maxConcurrentGameSessionActivations' in kwargs:
            max_concurrent_game_session_activations = kwargs['maxConcurrentGameSessionActivations']
        if server_processes is None and 'serverProcesses' in kwargs:
            server_processes = kwargs['serverProcesses']

        if game_session_activation_timeout_seconds is not None:
            _setter("game_session_activation_timeout_seconds", game_session_activation_timeout_seconds)
        if max_concurrent_game_session_activations is not None:
            _setter("max_concurrent_game_session_activations", max_concurrent_game_session_activations)
        if server_processes is not None:
            _setter("server_processes", server_processes)

    @property
    @pulumi.getter(name="gameSessionActivationTimeoutSeconds")
    def game_session_activation_timeout_seconds(self) -> Optional[int]:
        """
        Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
        """
        return pulumi.get(self, "game_session_activation_timeout_seconds")

    @property
    @pulumi.getter(name="maxConcurrentGameSessionActivations")
    def max_concurrent_game_session_activations(self) -> Optional[int]:
        """
        Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
        """
        return pulumi.get(self, "max_concurrent_game_session_activations")

    @property
    @pulumi.getter(name="serverProcesses")
    def server_processes(self) -> Optional[Sequence['outputs.FleetRuntimeConfigurationServerProcess']]:
        """
        Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
        """
        return pulumi.get(self, "server_processes")


@pulumi.output_type
class FleetRuntimeConfigurationServerProcess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "concurrentExecutions":
            suggest = "concurrent_executions"
        elif key == "launchPath":
            suggest = "launch_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetRuntimeConfigurationServerProcess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetRuntimeConfigurationServerProcess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetRuntimeConfigurationServerProcess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 concurrent_executions: int,
                 launch_path: str,
                 parameters: Optional[str] = None):
        """
        :param int concurrent_executions: Number of server processes using this configuration to run concurrently on an instance.
        :param str launch_path: Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\\game`, and for Linux instances `/local/game`.
        :param str parameters: Optional list of parameters to pass to the server executable on launch.
        """
        FleetRuntimeConfigurationServerProcess._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            concurrent_executions=concurrent_executions,
            launch_path=launch_path,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             concurrent_executions: Optional[int] = None,
             launch_path: Optional[str] = None,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if concurrent_executions is None and 'concurrentExecutions' in kwargs:
            concurrent_executions = kwargs['concurrentExecutions']
        if concurrent_executions is None:
            raise TypeError("Missing 'concurrent_executions' argument")
        if launch_path is None and 'launchPath' in kwargs:
            launch_path = kwargs['launchPath']
        if launch_path is None:
            raise TypeError("Missing 'launch_path' argument")

        _setter("concurrent_executions", concurrent_executions)
        _setter("launch_path", launch_path)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="concurrentExecutions")
    def concurrent_executions(self) -> int:
        """
        Number of server processes using this configuration to run concurrently on an instance.
        """
        return pulumi.get(self, "concurrent_executions")

    @property
    @pulumi.getter(name="launchPath")
    def launch_path(self) -> str:
        """
        Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\\game`, and for Linux instances `/local/game`.
        """
        return pulumi.get(self, "launch_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Optional list of parameters to pass to the server executable on launch.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GameServerGroupAutoScalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetTrackingConfiguration":
            suggest = "target_tracking_configuration"
        elif key == "estimatedInstanceWarmup":
            suggest = "estimated_instance_warmup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GameServerGroupAutoScalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GameServerGroupAutoScalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GameServerGroupAutoScalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_tracking_configuration: 'outputs.GameServerGroupAutoScalingPolicyTargetTrackingConfiguration',
                 estimated_instance_warmup: Optional[int] = None):
        """
        :param int estimated_instance_warmup: Length of time, in seconds, it takes for a new instance to start
               new game server processes and register with GameLift FleetIQ.
               Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
               because it avoids prematurely starting new instances. Defaults to `60`.
        """
        GameServerGroupAutoScalingPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_tracking_configuration=target_tracking_configuration,
            estimated_instance_warmup=estimated_instance_warmup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_tracking_configuration: Optional['outputs.GameServerGroupAutoScalingPolicyTargetTrackingConfiguration'] = None,
             estimated_instance_warmup: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_tracking_configuration is None and 'targetTrackingConfiguration' in kwargs:
            target_tracking_configuration = kwargs['targetTrackingConfiguration']
        if target_tracking_configuration is None:
            raise TypeError("Missing 'target_tracking_configuration' argument")
        if estimated_instance_warmup is None and 'estimatedInstanceWarmup' in kwargs:
            estimated_instance_warmup = kwargs['estimatedInstanceWarmup']

        _setter("target_tracking_configuration", target_tracking_configuration)
        if estimated_instance_warmup is not None:
            _setter("estimated_instance_warmup", estimated_instance_warmup)

    @property
    @pulumi.getter(name="targetTrackingConfiguration")
    def target_tracking_configuration(self) -> 'outputs.GameServerGroupAutoScalingPolicyTargetTrackingConfiguration':
        return pulumi.get(self, "target_tracking_configuration")

    @property
    @pulumi.getter(name="estimatedInstanceWarmup")
    def estimated_instance_warmup(self) -> Optional[int]:
        """
        Length of time, in seconds, it takes for a new instance to start
        new game server processes and register with GameLift FleetIQ.
        Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up,
        because it avoids prematurely starting new instances. Defaults to `60`.
        """
        return pulumi.get(self, "estimated_instance_warmup")


@pulumi.output_type
class GameServerGroupAutoScalingPolicyTargetTrackingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GameServerGroupAutoScalingPolicyTargetTrackingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GameServerGroupAutoScalingPolicyTargetTrackingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GameServerGroupAutoScalingPolicyTargetTrackingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float):
        """
        :param float target_value: Desired value to use with a game server group target-based scaling policy.
        """
        GameServerGroupAutoScalingPolicyTargetTrackingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_value=target_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_value: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_value is None and 'targetValue' in kwargs:
            target_value = kwargs['targetValue']
        if target_value is None:
            raise TypeError("Missing 'target_value' argument")

        _setter("target_value", target_value)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        """
        Desired value to use with a game server group target-based scaling policy.
        """
        return pulumi.get(self, "target_value")


@pulumi.output_type
class GameServerGroupInstanceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GameServerGroupInstanceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GameServerGroupInstanceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GameServerGroupInstanceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: str,
                 weighted_capacity: Optional[str] = None):
        """
        :param str instance_type: An EC2 instance type.
        :param str weighted_capacity: Instance weighting that indicates how much this instance type contributes
               to the total capacity of a game server group.
               Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
               the most cost-effective options.
        """
        GameServerGroupInstanceDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: Optional[str] = None,
             weighted_capacity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")
        if weighted_capacity is None and 'weightedCapacity' in kwargs:
            weighted_capacity = kwargs['weightedCapacity']

        _setter("instance_type", instance_type)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        An EC2 instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[str]:
        """
        Instance weighting that indicates how much this instance type contributes
        to the total capacity of a game server group.
        Instance weights are used by GameLift FleetIQ to calculate the instance type's cost per unit hour and better identify
        the most cost-effective options.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class GameServerGroupLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: A unique identifier for an existing EC2 launch template.
        :param str name: A readable identifier for an existing EC2 launch template.
        :param str version: The version of the EC2 launch template to use. If none is set, the default is the first version created.
        """
        GameServerGroupLaunchTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique identifier for an existing EC2 launch template.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A readable identifier for an existing EC2 launch template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the EC2 launch template to use. If none is set, the default is the first version created.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GameSessionQueuePlayerLatencyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumIndividualPlayerLatencyMilliseconds":
            suggest = "maximum_individual_player_latency_milliseconds"
        elif key == "policyDurationSeconds":
            suggest = "policy_duration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GameSessionQueuePlayerLatencyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GameSessionQueuePlayerLatencyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GameSessionQueuePlayerLatencyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_individual_player_latency_milliseconds: int,
                 policy_duration_seconds: Optional[int] = None):
        """
        :param int maximum_individual_player_latency_milliseconds: Maximum latency value that is allowed for any player.
        :param int policy_duration_seconds: Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
        """
        GameSessionQueuePlayerLatencyPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_individual_player_latency_milliseconds=maximum_individual_player_latency_milliseconds,
            policy_duration_seconds=policy_duration_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_individual_player_latency_milliseconds: Optional[int] = None,
             policy_duration_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if maximum_individual_player_latency_milliseconds is None and 'maximumIndividualPlayerLatencyMilliseconds' in kwargs:
            maximum_individual_player_latency_milliseconds = kwargs['maximumIndividualPlayerLatencyMilliseconds']
        if maximum_individual_player_latency_milliseconds is None:
            raise TypeError("Missing 'maximum_individual_player_latency_milliseconds' argument")
        if policy_duration_seconds is None and 'policyDurationSeconds' in kwargs:
            policy_duration_seconds = kwargs['policyDurationSeconds']

        _setter("maximum_individual_player_latency_milliseconds", maximum_individual_player_latency_milliseconds)
        if policy_duration_seconds is not None:
            _setter("policy_duration_seconds", policy_duration_seconds)

    @property
    @pulumi.getter(name="maximumIndividualPlayerLatencyMilliseconds")
    def maximum_individual_player_latency_milliseconds(self) -> int:
        """
        Maximum latency value that is allowed for any player.
        """
        return pulumi.get(self, "maximum_individual_player_latency_milliseconds")

    @property
    @pulumi.getter(name="policyDurationSeconds")
    def policy_duration_seconds(self) -> Optional[int]:
        """
        Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
        """
        return pulumi.get(self, "policy_duration_seconds")


@pulumi.output_type
class MatchmakingConfigurationGameProperty(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: A game property key
        :param str value: A game property value.
        """
        MatchmakingConfigurationGameProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A game property key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A game property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScriptStorageLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "objectVersion":
            suggest = "object_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 key: str,
                 role_arn: str,
                 object_version: Optional[str] = None):
        """
        :param str bucket: Name of your S3 bucket.
        :param str key: Name of the zip file containing your script files.
        :param str role_arn: ARN of the access role that allows Amazon GameLift to access your S3 bucket.
        :param str object_version: A specific version of the file. If not set, the latest version of the file is retrieved.
        """
        ScriptStorageLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
            role_arn=role_arn,
            object_version=object_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[str] = None,
             key: Optional[str] = None,
             role_arn: Optional[str] = None,
             object_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")
        if object_version is None and 'objectVersion' in kwargs:
            object_version = kwargs['objectVersion']

        _setter("bucket", bucket)
        _setter("key", key)
        _setter("role_arn", role_arn)
        if object_version is not None:
            _setter("object_version", object_version)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name of the zip file containing your script files.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the access role that allows Amazon GameLift to access your S3 bucket.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="objectVersion")
    def object_version(self) -> Optional[str]:
        """
        A specific version of the file. If not set, the latest version of the file is retrieved.
        """
        return pulumi.get(self, "object_version")


