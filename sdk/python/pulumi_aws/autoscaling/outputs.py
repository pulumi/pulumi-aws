# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GroupAvailabilityZoneDistribution',
    'GroupCapacityReservationSpecification',
    'GroupCapacityReservationSpecificationCapacityReservationTarget',
    'GroupInitialLifecycleHook',
    'GroupInstanceMaintenancePolicy',
    'GroupInstanceRefresh',
    'GroupInstanceRefreshPreferences',
    'GroupInstanceRefreshPreferencesAlarmSpecification',
    'GroupLaunchTemplate',
    'GroupMixedInstancesPolicy',
    'GroupMixedInstancesPolicyInstancesDistribution',
    'GroupMixedInstancesPolicyLaunchTemplate',
    'GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification',
    'GroupMixedInstancesPolicyLaunchTemplateOverride',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount',
    'GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification',
    'GroupTag',
    'GroupTrafficSource',
    'GroupWarmPool',
    'GroupWarmPoolInstanceReusePolicy',
    'PolicyPredictiveScalingConfiguration',
    'PolicyPredictiveScalingConfigurationMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric',
    'PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification',
    'PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification',
    'PolicyStepAdjustment',
    'PolicyTargetTrackingConfiguration',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecification',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric',
    'PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension',
    'PolicyTargetTrackingConfigurationPredefinedMetricSpecification',
    'TagTag',
    'TrafficSourceAttachmentTrafficSource',
    'GetAmiIdsFilterResult',
    'GetGroupInstanceMaintenancePolicyResult',
    'GetGroupLaunchTemplateResult',
    'GetGroupMixedInstancesPolicyResult',
    'GetGroupMixedInstancesPolicyInstancesDistributionResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult',
    'GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult',
    'GetGroupTagResult',
    'GetGroupTrafficSourceResult',
    'GetGroupWarmPoolResult',
    'GetGroupWarmPoolInstanceReusePolicyResult',
]

@pulumi.output_type
class GroupAvailabilityZoneDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityDistributionStrategy":
            suggest = "capacity_distribution_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupAvailabilityZoneDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupAvailabilityZoneDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupAvailabilityZoneDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_distribution_strategy: Optional[_builtins.str] = None):
        if capacity_distribution_strategy is not None:
            pulumi.set(__self__, "capacity_distribution_strategy", capacity_distribution_strategy)

    @_builtins.property
    @pulumi.getter(name="capacityDistributionStrategy")
    def capacity_distribution_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_distribution_strategy")


@pulumi.output_type
class GroupCapacityReservationSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.GroupCapacityReservationSpecificationCapacityReservationTarget'] = None):
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.GroupCapacityReservationSpecificationCapacityReservationTarget']:
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class GroupCapacityReservationSpecificationCapacityReservationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationIds":
            suggest = "capacity_reservation_ids"
        elif key == "capacityReservationResourceGroupArns":
            suggest = "capacity_reservation_resource_group_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupCapacityReservationSpecificationCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupCapacityReservationSpecificationCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_ids: Optional[Sequence[_builtins.str]] = None,
                 capacity_reservation_resource_group_arns: Optional[Sequence[_builtins.str]] = None):
        if capacity_reservation_ids is not None:
            pulumi.set(__self__, "capacity_reservation_ids", capacity_reservation_ids)
        if capacity_reservation_resource_group_arns is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arns", capacity_reservation_resource_group_arns)

    @_builtins.property
    @pulumi.getter(name="capacityReservationIds")
    def capacity_reservation_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "capacity_reservation_ids")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArns")
    def capacity_reservation_resource_group_arns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "capacity_reservation_resource_group_arns")


@pulumi.output_type
class GroupInitialLifecycleHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecycleTransition":
            suggest = "lifecycle_transition"
        elif key == "defaultResult":
            suggest = "default_result"
        elif key == "heartbeatTimeout":
            suggest = "heartbeat_timeout"
        elif key == "notificationMetadata":
            suggest = "notification_metadata"
        elif key == "notificationTargetArn":
            suggest = "notification_target_arn"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInitialLifecycleHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInitialLifecycleHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInitialLifecycleHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_transition: _builtins.str,
                 name: _builtins.str,
                 default_result: Optional[_builtins.str] = None,
                 heartbeat_timeout: Optional[_builtins.int] = None,
                 notification_metadata: Optional[_builtins.str] = None,
                 notification_target_arn: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "lifecycle_transition", lifecycle_transition)
        pulumi.set(__self__, "name", name)
        if default_result is not None:
            pulumi.set(__self__, "default_result", default_result)
        if heartbeat_timeout is not None:
            pulumi.set(__self__, "heartbeat_timeout", heartbeat_timeout)
        if notification_metadata is not None:
            pulumi.set(__self__, "notification_metadata", notification_metadata)
        if notification_target_arn is not None:
            pulumi.set(__self__, "notification_target_arn", notification_target_arn)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="lifecycleTransition")
    def lifecycle_transition(self) -> _builtins.str:
        return pulumi.get(self, "lifecycle_transition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_result")

    @_builtins.property
    @pulumi.getter(name="heartbeatTimeout")
    def heartbeat_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "heartbeat_timeout")

    @_builtins.property
    @pulumi.getter(name="notificationMetadata")
    def notification_metadata(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "notification_metadata")

    @_builtins.property
    @pulumi.getter(name="notificationTargetArn")
    def notification_target_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "notification_target_arn")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GroupInstanceMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHealthyPercentage":
            suggest = "max_healthy_percentage"
        elif key == "minHealthyPercentage":
            suggest = "min_healthy_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInstanceMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInstanceMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInstanceMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_healthy_percentage: _builtins.int,
                 min_healthy_percentage: _builtins.int):
        pulumi.set(__self__, "max_healthy_percentage", max_healthy_percentage)
        pulumi.set(__self__, "min_healthy_percentage", min_healthy_percentage)

    @_builtins.property
    @pulumi.getter(name="maxHealthyPercentage")
    def max_healthy_percentage(self) -> _builtins.int:
        return pulumi.get(self, "max_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> _builtins.int:
        return pulumi.get(self, "min_healthy_percentage")


@pulumi.output_type
class GroupInstanceRefresh(dict):
    def __init__(__self__, *,
                 strategy: _builtins.str,
                 preferences: Optional['outputs.GroupInstanceRefreshPreferences'] = None,
                 triggers: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "strategy", strategy)
        if preferences is not None:
            pulumi.set(__self__, "preferences", preferences)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> _builtins.str:
        return pulumi.get(self, "strategy")

    @_builtins.property
    @pulumi.getter
    def preferences(self) -> Optional['outputs.GroupInstanceRefreshPreferences']:
        return pulumi.get(self, "preferences")

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "triggers")


@pulumi.output_type
class GroupInstanceRefreshPreferences(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmSpecification":
            suggest = "alarm_specification"
        elif key == "autoRollback":
            suggest = "auto_rollback"
        elif key == "checkpointDelay":
            suggest = "checkpoint_delay"
        elif key == "checkpointPercentages":
            suggest = "checkpoint_percentages"
        elif key == "instanceWarmup":
            suggest = "instance_warmup"
        elif key == "maxHealthyPercentage":
            suggest = "max_healthy_percentage"
        elif key == "minHealthyPercentage":
            suggest = "min_healthy_percentage"
        elif key == "scaleInProtectedInstances":
            suggest = "scale_in_protected_instances"
        elif key == "skipMatching":
            suggest = "skip_matching"
        elif key == "standbyInstances":
            suggest = "standby_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInstanceRefreshPreferences. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInstanceRefreshPreferences.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInstanceRefreshPreferences.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_specification: Optional['outputs.GroupInstanceRefreshPreferencesAlarmSpecification'] = None,
                 auto_rollback: Optional[_builtins.bool] = None,
                 checkpoint_delay: Optional[_builtins.str] = None,
                 checkpoint_percentages: Optional[Sequence[_builtins.int]] = None,
                 instance_warmup: Optional[_builtins.str] = None,
                 max_healthy_percentage: Optional[_builtins.int] = None,
                 min_healthy_percentage: Optional[_builtins.int] = None,
                 scale_in_protected_instances: Optional[_builtins.str] = None,
                 skip_matching: Optional[_builtins.bool] = None,
                 standby_instances: Optional[_builtins.str] = None):
        if alarm_specification is not None:
            pulumi.set(__self__, "alarm_specification", alarm_specification)
        if auto_rollback is not None:
            pulumi.set(__self__, "auto_rollback", auto_rollback)
        if checkpoint_delay is not None:
            pulumi.set(__self__, "checkpoint_delay", checkpoint_delay)
        if checkpoint_percentages is not None:
            pulumi.set(__self__, "checkpoint_percentages", checkpoint_percentages)
        if instance_warmup is not None:
            pulumi.set(__self__, "instance_warmup", instance_warmup)
        if max_healthy_percentage is not None:
            pulumi.set(__self__, "max_healthy_percentage", max_healthy_percentage)
        if min_healthy_percentage is not None:
            pulumi.set(__self__, "min_healthy_percentage", min_healthy_percentage)
        if scale_in_protected_instances is not None:
            pulumi.set(__self__, "scale_in_protected_instances", scale_in_protected_instances)
        if skip_matching is not None:
            pulumi.set(__self__, "skip_matching", skip_matching)
        if standby_instances is not None:
            pulumi.set(__self__, "standby_instances", standby_instances)

    @_builtins.property
    @pulumi.getter(name="alarmSpecification")
    def alarm_specification(self) -> Optional['outputs.GroupInstanceRefreshPreferencesAlarmSpecification']:
        return pulumi.get(self, "alarm_specification")

    @_builtins.property
    @pulumi.getter(name="autoRollback")
    def auto_rollback(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_rollback")

    @_builtins.property
    @pulumi.getter(name="checkpointDelay")
    def checkpoint_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "checkpoint_delay")

    @_builtins.property
    @pulumi.getter(name="checkpointPercentages")
    def checkpoint_percentages(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "checkpoint_percentages")

    @_builtins.property
    @pulumi.getter(name="instanceWarmup")
    def instance_warmup(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_warmup")

    @_builtins.property
    @pulumi.getter(name="maxHealthyPercentage")
    def max_healthy_percentage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="scaleInProtectedInstances")
    def scale_in_protected_instances(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_in_protected_instances")

    @_builtins.property
    @pulumi.getter(name="skipMatching")
    def skip_matching(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "skip_matching")

    @_builtins.property
    @pulumi.getter(name="standbyInstances")
    def standby_instances(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "standby_instances")


@pulumi.output_type
class GroupInstanceRefreshPreferencesAlarmSpecification(dict):
    def __init__(__self__, *,
                 alarms: Optional[Sequence[_builtins.str]] = None):
        if alarms is not None:
            pulumi.set(__self__, "alarms", alarms)

    @_builtins.property
    @pulumi.getter
    def alarms(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "alarms")


@pulumi.output_type
class GroupLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupMixedInstancesPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplate":
            suggest = "launch_template"
        elif key == "instancesDistribution":
            suggest = "instances_distribution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template: 'outputs.GroupMixedInstancesPolicyLaunchTemplate',
                 instances_distribution: Optional['outputs.GroupMixedInstancesPolicyInstancesDistribution'] = None):
        pulumi.set(__self__, "launch_template", launch_template)
        if instances_distribution is not None:
            pulumi.set(__self__, "instances_distribution", instances_distribution)

    @_builtins.property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> 'outputs.GroupMixedInstancesPolicyLaunchTemplate':
        return pulumi.get(self, "launch_template")

    @_builtins.property
    @pulumi.getter(name="instancesDistribution")
    def instances_distribution(self) -> Optional['outputs.GroupMixedInstancesPolicyInstancesDistribution']:
        return pulumi.get(self, "instances_distribution")


@pulumi.output_type
class GroupMixedInstancesPolicyInstancesDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyInstancesDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyInstancesDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyInstancesDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_allocation_strategy: Optional[_builtins.str] = None,
                 on_demand_base_capacity: Optional[_builtins.int] = None,
                 on_demand_percentage_above_base_capacity: Optional[_builtins.int] = None,
                 spot_allocation_strategy: Optional[_builtins.str] = None,
                 spot_instance_pools: Optional[_builtins.int] = None,
                 spot_max_price: Optional[_builtins.str] = None):
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_base_capacity is not None:
            pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if spot_instance_pools is not None:
            pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)

    @_builtins.property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_base_capacity")

    @_builtins.property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @_builtins.property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_instance_pools")

    @_builtins.property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.GroupMixedInstancesPolicyLaunchTemplateOverride']] = None):
        pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification':
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.GroupMixedInstancesPolicyLaunchTemplateOverride']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "launchTemplateSpecification":
            suggest = "launch_template_specification"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_requirements: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 launch_template_specification: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification'] = None,
                 weighted_capacity: Optional[_builtins.str] = None):
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification']:
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMib":
            suggest = "accelerator_total_memory_mib"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGibPerVcpu":
            suggest = "memory_gib_per_vcpu"
        elif key == "memoryMib":
            suggest = "memory_mib"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vcpuCount":
            suggest = "vcpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mib: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gib_per_vcpu: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu'] = None,
                 memory_mib: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib'] = None,
                 network_bandwidth_gbps: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb'] = None,
                 vcpu_count: Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount'] = None):
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mib is not None:
            pulumi.set(__self__, "accelerator_total_memory_mib", accelerator_total_memory_mib)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gib_per_vcpu is not None:
            pulumi.set(__self__, "memory_gib_per_vcpu", memory_gib_per_vcpu)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if vcpu_count is not None:
            pulumi.set(__self__, "vcpu_count", vcpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount']:
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMib")
    def accelerator_total_memory_mib(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib']:
        return pulumi.get(self, "accelerator_total_memory_mib")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpu")
    def memory_gib_per_vcpu(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu']:
        return pulumi.get(self, "memory_gib_per_vcpu")

    @_builtins.property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib']:
        return pulumi.get(self, "memory_mib")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount']:
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb']:
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vcpuCount")
    def vcpu_count(self) -> Optional['outputs.GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount']:
        return pulumi.get(self, "vcpu_count")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsAcceleratorTotalMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsBaselineEbsBandwidthMbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryGibPerVcpu(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsMemoryMib(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkBandwidthGbps(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsNetworkInterfaceCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsTotalLocalStorageGb(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementsVcpuCount(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "launch_template_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GroupTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 propagate_at_launch: _builtins.bool,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> _builtins.bool:
        return pulumi.get(self, "propagate_at_launch")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupTrafficSource(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "identifier", identifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GroupWarmPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceReusePolicy":
            suggest = "instance_reuse_policy"
        elif key == "maxGroupPreparedCapacity":
            suggest = "max_group_prepared_capacity"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "poolState":
            suggest = "pool_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupWarmPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupWarmPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupWarmPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_reuse_policy: Optional['outputs.GroupWarmPoolInstanceReusePolicy'] = None,
                 max_group_prepared_capacity: Optional[_builtins.int] = None,
                 min_size: Optional[_builtins.int] = None,
                 pool_state: Optional[_builtins.str] = None):
        if instance_reuse_policy is not None:
            pulumi.set(__self__, "instance_reuse_policy", instance_reuse_policy)
        if max_group_prepared_capacity is not None:
            pulumi.set(__self__, "max_group_prepared_capacity", max_group_prepared_capacity)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if pool_state is not None:
            pulumi.set(__self__, "pool_state", pool_state)

    @_builtins.property
    @pulumi.getter(name="instanceReusePolicy")
    def instance_reuse_policy(self) -> Optional['outputs.GroupWarmPoolInstanceReusePolicy']:
        return pulumi.get(self, "instance_reuse_policy")

    @_builtins.property
    @pulumi.getter(name="maxGroupPreparedCapacity")
    def max_group_prepared_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_group_prepared_capacity")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="poolState")
    def pool_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pool_state")


@pulumi.output_type
class GroupWarmPoolInstanceReusePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reuseOnScaleIn":
            suggest = "reuse_on_scale_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupWarmPoolInstanceReusePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupWarmPoolInstanceReusePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupWarmPoolInstanceReusePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reuse_on_scale_in: Optional[_builtins.bool] = None):
        if reuse_on_scale_in is not None:
            pulumi.set(__self__, "reuse_on_scale_in", reuse_on_scale_in)

    @_builtins.property
    @pulumi.getter(name="reuseOnScaleIn")
    def reuse_on_scale_in(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "reuse_on_scale_in")


@pulumi.output_type
class PolicyPredictiveScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSpecification":
            suggest = "metric_specification"
        elif key == "maxCapacityBreachBehavior":
            suggest = "max_capacity_breach_behavior"
        elif key == "maxCapacityBuffer":
            suggest = "max_capacity_buffer"
        elif key == "schedulingBufferTime":
            suggest = "scheduling_buffer_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_specification: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecification',
                 max_capacity_breach_behavior: Optional[_builtins.str] = None,
                 max_capacity_buffer: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 scheduling_buffer_time: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric_specification", metric_specification)
        if max_capacity_breach_behavior is not None:
            pulumi.set(__self__, "max_capacity_breach_behavior", max_capacity_breach_behavior)
        if max_capacity_buffer is not None:
            pulumi.set(__self__, "max_capacity_buffer", max_capacity_buffer)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if scheduling_buffer_time is not None:
            pulumi.set(__self__, "scheduling_buffer_time", scheduling_buffer_time)

    @_builtins.property
    @pulumi.getter(name="metricSpecification")
    def metric_specification(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecification':
        return pulumi.get(self, "metric_specification")

    @_builtins.property
    @pulumi.getter(name="maxCapacityBreachBehavior")
    def max_capacity_breach_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_capacity_breach_behavior")

    @_builtins.property
    @pulumi.getter(name="maxCapacityBuffer")
    def max_capacity_buffer(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_capacity_buffer")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="schedulingBufferTime")
    def scheduling_buffer_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheduling_buffer_time")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedCapacityMetricSpecification":
            suggest = "customized_capacity_metric_specification"
        elif key == "customizedLoadMetricSpecification":
            suggest = "customized_load_metric_specification"
        elif key == "customizedScalingMetricSpecification":
            suggest = "customized_scaling_metric_specification"
        elif key == "predefinedLoadMetricSpecification":
            suggest = "predefined_load_metric_specification"
        elif key == "predefinedMetricPairSpecification":
            suggest = "predefined_metric_pair_specification"
        elif key == "predefinedScalingMetricSpecification":
            suggest = "predefined_scaling_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: _builtins.float,
                 customized_capacity_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification'] = None,
                 customized_load_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification'] = None,
                 customized_scaling_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification'] = None,
                 predefined_load_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification'] = None,
                 predefined_metric_pair_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification'] = None,
                 predefined_scaling_metric_specification: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification'] = None):
        pulumi.set(__self__, "target_value", target_value)
        if customized_capacity_metric_specification is not None:
            pulumi.set(__self__, "customized_capacity_metric_specification", customized_capacity_metric_specification)
        if customized_load_metric_specification is not None:
            pulumi.set(__self__, "customized_load_metric_specification", customized_load_metric_specification)
        if customized_scaling_metric_specification is not None:
            pulumi.set(__self__, "customized_scaling_metric_specification", customized_scaling_metric_specification)
        if predefined_load_metric_specification is not None:
            pulumi.set(__self__, "predefined_load_metric_specification", predefined_load_metric_specification)
        if predefined_metric_pair_specification is not None:
            pulumi.set(__self__, "predefined_metric_pair_specification", predefined_metric_pair_specification)
        if predefined_scaling_metric_specification is not None:
            pulumi.set(__self__, "predefined_scaling_metric_specification", predefined_scaling_metric_specification)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> _builtins.float:
        return pulumi.get(self, "target_value")

    @_builtins.property
    @pulumi.getter(name="customizedCapacityMetricSpecification")
    def customized_capacity_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification']:
        return pulumi.get(self, "customized_capacity_metric_specification")

    @_builtins.property
    @pulumi.getter(name="customizedLoadMetricSpecification")
    def customized_load_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification']:
        return pulumi.get(self, "customized_load_metric_specification")

    @_builtins.property
    @pulumi.getter(name="customizedScalingMetricSpecification")
    def customized_scaling_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification']:
        return pulumi.get(self, "customized_scaling_metric_specification")

    @_builtins.property
    @pulumi.getter(name="predefinedLoadMetricSpecification")
    def predefined_load_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification']:
        return pulumi.get(self, "predefined_load_metric_specification")

    @_builtins.property
    @pulumi.getter(name="predefinedMetricPairSpecification")
    def predefined_metric_pair_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification']:
        return pulumi.get(self, "predefined_metric_pair_specification")

    @_builtins.property
    @pulumi.getter(name="predefinedScalingMetricSpecification")
    def predefined_scaling_metric_specification(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification']:
        return pulumi.get(self, "predefined_scaling_metric_specification")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery']):
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @_builtins.property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 expression: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat']:
        return pulumi.get(self, "metric_stat")

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: _builtins.str,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric':
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def stat(self) -> _builtins.str:
        return pulumi.get(self, "stat")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedCapacityMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery']):
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @_builtins.property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 expression: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat']:
        return pulumi.get(self, "metric_stat")

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: _builtins.str,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric':
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def stat(self) -> _builtins.str:
        return pulumi.get(self, "stat")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedLoadMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery']):
        pulumi.set(__self__, "metric_data_queries", metric_data_queries)

    @_builtins.property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 expression: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 metric_stat: Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat'] = None,
                 return_data: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat']:
        return pulumi.get(self, "metric_stat")

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric',
                 stat: _builtins.str,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric':
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def stat(self) -> _builtins.str:
        return pulumi.get(self, "stat")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 dimensions: Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension']] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension']]:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationCustomizedScalingMetricSpecificationMetricDataQueryMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedLoadMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 resource_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedMetricPairSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 resource_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyPredictiveScalingConfigurationMetricSpecificationPredefinedScalingMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 resource_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class PolicyStepAdjustment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "metricIntervalLowerBound":
            suggest = "metric_interval_lower_bound"
        elif key == "metricIntervalUpperBound":
            suggest = "metric_interval_upper_bound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyStepAdjustment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyStepAdjustment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyStepAdjustment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: _builtins.int,
                 metric_interval_lower_bound: Optional[_builtins.str] = None,
                 metric_interval_upper_bound: Optional[_builtins.str] = None):
        pulumi.set(__self__, "scaling_adjustment", scaling_adjustment)
        if metric_interval_lower_bound is not None:
            pulumi.set(__self__, "metric_interval_lower_bound", metric_interval_lower_bound)
        if metric_interval_upper_bound is not None:
            pulumi.set(__self__, "metric_interval_upper_bound", metric_interval_upper_bound)

    @_builtins.property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> _builtins.int:
        return pulumi.get(self, "scaling_adjustment")

    @_builtins.property
    @pulumi.getter(name="metricIntervalLowerBound")
    def metric_interval_lower_bound(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_interval_lower_bound")

    @_builtins.property
    @pulumi.getter(name="metricIntervalUpperBound")
    def metric_interval_upper_bound(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_interval_upper_bound")


@pulumi.output_type
class PolicyTargetTrackingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedMetricSpecification":
            suggest = "customized_metric_specification"
        elif key == "disableScaleIn":
            suggest = "disable_scale_in"
        elif key == "predefinedMetricSpecification":
            suggest = "predefined_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: _builtins.float,
                 customized_metric_specification: Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecification'] = None,
                 disable_scale_in: Optional[_builtins.bool] = None,
                 predefined_metric_specification: Optional['outputs.PolicyTargetTrackingConfigurationPredefinedMetricSpecification'] = None):
        pulumi.set(__self__, "target_value", target_value)
        if customized_metric_specification is not None:
            pulumi.set(__self__, "customized_metric_specification", customized_metric_specification)
        if disable_scale_in is not None:
            pulumi.set(__self__, "disable_scale_in", disable_scale_in)
        if predefined_metric_specification is not None:
            pulumi.set(__self__, "predefined_metric_specification", predefined_metric_specification)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> _builtins.float:
        return pulumi.get(self, "target_value")

    @_builtins.property
    @pulumi.getter(name="customizedMetricSpecification")
    def customized_metric_specification(self) -> Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecification']:
        return pulumi.get(self, "customized_metric_specification")

    @_builtins.property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_scale_in")

    @_builtins.property
    @pulumi.getter(name="predefinedMetricSpecification")
    def predefined_metric_specification(self) -> Optional['outputs.PolicyTargetTrackingConfigurationPredefinedMetricSpecification']:
        return pulumi.get(self, "predefined_metric_specification")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDimensions":
            suggest = "metric_dimensions"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_dimensions: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension']] = None,
                 metric_name: Optional[_builtins.str] = None,
                 metrics: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric']] = None,
                 namespace: Optional[_builtins.str] = None,
                 period: Optional[_builtins.int] = None,
                 statistic: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        if metric_dimensions is not None:
            pulumi.set(__self__, "metric_dimensions", metric_dimensions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="metricDimensions")
    def metric_dimensions(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension']]:
        return pulumi.get(self, "metric_dimensions")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric']]:
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "statistic")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 expression: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 metric_stat: Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat'] = None,
                 return_data: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat']:
        return pulumi.get(self, "metric_stat")

    @_builtins.property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric',
                 stat: _builtins.str,
                 period: Optional[_builtins.int] = None,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "stat", stat)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> 'outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric':
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def stat(self) -> _builtins.str:
        return pulumi.get(self, "stat")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 dimensions: Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension']] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension']]:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricMetricStatMetricDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyTargetTrackingConfigurationPredefinedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyTargetTrackingConfigurationPredefinedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyTargetTrackingConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyTargetTrackingConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: _builtins.str,
                 resource_label: Optional[_builtins.str] = None):
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @_builtins.property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> _builtins.str:
        return pulumi.get(self, "predefined_metric_type")

    @_builtins.property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class TagTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 propagate_at_launch: _builtins.bool,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> _builtins.bool:
        return pulumi.get(self, "propagate_at_launch")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficSourceAttachmentTrafficSource(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAmiIdsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGroupInstanceMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 max_healthy_percentage: _builtins.int,
                 min_healthy_percentage: _builtins.int):
        pulumi.set(__self__, "max_healthy_percentage", max_healthy_percentage)
        pulumi.set(__self__, "min_healthy_percentage", min_healthy_percentage)

    @_builtins.property
    @pulumi.getter(name="maxHealthyPercentage")
    def max_healthy_percentage(self) -> _builtins.int:
        return pulumi.get(self, "max_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> _builtins.int:
        return pulumi.get(self, "min_healthy_percentage")


@pulumi.output_type
class GetGroupLaunchTemplateResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupMixedInstancesPolicyResult(dict):
    def __init__(__self__, *,
                 instances_distributions: Sequence['outputs.GetGroupMixedInstancesPolicyInstancesDistributionResult'],
                 launch_templates: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateResult']):
        pulumi.set(__self__, "instances_distributions", instances_distributions)
        pulumi.set(__self__, "launch_templates", launch_templates)

    @_builtins.property
    @pulumi.getter(name="instancesDistributions")
    def instances_distributions(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyInstancesDistributionResult']:
        return pulumi.get(self, "instances_distributions")

    @_builtins.property
    @pulumi.getter(name="launchTemplates")
    def launch_templates(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateResult']:
        return pulumi.get(self, "launch_templates")


@pulumi.output_type
class GetGroupMixedInstancesPolicyInstancesDistributionResult(dict):
    def __init__(__self__, *,
                 on_demand_allocation_strategy: _builtins.str,
                 on_demand_base_capacity: _builtins.int,
                 on_demand_percentage_above_base_capacity: _builtins.int,
                 spot_allocation_strategy: _builtins.str,
                 spot_instance_pools: _builtins.int,
                 spot_max_price: _builtins.str):
        pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        pulumi.set(__self__, "spot_max_price", spot_max_price)

    @_builtins.property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> _builtins.int:
        return pulumi.get(self, "on_demand_base_capacity")

    @_builtins.property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> _builtins.int:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @_builtins.property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "spot_allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> _builtins.int:
        return pulumi.get(self, "spot_instance_pools")

    @_builtins.property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> _builtins.str:
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateResult(dict):
    def __init__(__self__, *,
                 launch_template_specifications: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult'],
                 overrides: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult']):
        pulumi.set(__self__, "launch_template_specifications", launch_template_specifications)
        pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecifications")
    def launch_template_specifications(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult']:
        return pulumi.get(self, "launch_template_specifications")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult']:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationResult(dict):
    def __init__(__self__, *,
                 launch_template_id: _builtins.str,
                 launch_template_name: _builtins.str,
                 version: _builtins.str):
        pulumi.set(__self__, "launch_template_id", launch_template_id)
        pulumi.set(__self__, "launch_template_name", launch_template_name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> _builtins.str:
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> _builtins.str:
        return pulumi.get(self, "launch_template_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideResult(dict):
    def __init__(__self__, *,
                 instance_requirements: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult'],
                 instance_type: _builtins.str,
                 launch_template_specifications: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult'],
                 weighted_capacity: _builtins.str):
        pulumi.set(__self__, "instance_requirements", instance_requirements)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "launch_template_specifications", launch_template_specifications)
        pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult']:
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecifications")
    def launch_template_specifications(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult']:
        return pulumi.get(self, "launch_template_specifications")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> _builtins.str:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementResult(dict):
    def __init__(__self__, *,
                 accelerator_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult'],
                 accelerator_manufacturers: Sequence[_builtins.str],
                 accelerator_names: Sequence[_builtins.str],
                 accelerator_total_memory_mibs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult'],
                 accelerator_types: Sequence[_builtins.str],
                 allowed_instance_types: Sequence[_builtins.str],
                 bare_metal: _builtins.str,
                 baseline_ebs_bandwidth_mbps: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult'],
                 burstable_performance: _builtins.str,
                 cpu_manufacturers: Sequence[_builtins.str],
                 excluded_instance_types: Sequence[_builtins.str],
                 instance_generations: Sequence[_builtins.str],
                 local_storage: _builtins.str,
                 local_storage_types: Sequence[_builtins.str],
                 max_spot_price_as_percentage_of_optimal_on_demand_price: _builtins.int,
                 memory_gib_per_vcpus: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult'],
                 memory_mibs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult'],
                 network_bandwidth_gbps: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult'],
                 network_interface_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult'],
                 on_demand_max_price_percentage_over_lowest_price: _builtins.int,
                 require_hibernate_support: _builtins.bool,
                 spot_max_price_percentage_over_lowest_price: _builtins.int,
                 total_local_storage_gbs: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult'],
                 vcpu_counts: Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult']):
        pulumi.set(__self__, "accelerator_counts", accelerator_counts)
        pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        pulumi.set(__self__, "accelerator_names", accelerator_names)
        pulumi.set(__self__, "accelerator_total_memory_mibs", accelerator_total_memory_mibs)
        pulumi.set(__self__, "accelerator_types", accelerator_types)
        pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        pulumi.set(__self__, "bare_metal", bare_metal)
        pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        pulumi.set(__self__, "burstable_performance", burstable_performance)
        pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        pulumi.set(__self__, "instance_generations", instance_generations)
        pulumi.set(__self__, "local_storage", local_storage)
        pulumi.set(__self__, "local_storage_types", local_storage_types)
        pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        pulumi.set(__self__, "memory_gib_per_vcpus", memory_gib_per_vcpus)
        pulumi.set(__self__, "memory_mibs", memory_mibs)
        pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        pulumi.set(__self__, "network_interface_counts", network_interface_counts)
        pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        pulumi.set(__self__, "total_local_storage_gbs", total_local_storage_gbs)
        pulumi.set(__self__, "vcpu_counts", vcpu_counts)

    @_builtins.property
    @pulumi.getter(name="acceleratorCounts")
    def accelerator_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult']:
        return pulumi.get(self, "accelerator_counts")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMibs")
    def accelerator_total_memory_mibs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult']:
        return pulumi.get(self, "accelerator_total_memory_mibs")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> _builtins.str:
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> _builtins.str:
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> _builtins.str:
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> _builtins.int:
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGibPerVcpus")
    def memory_gib_per_vcpus(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult']:
        return pulumi.get(self, "memory_gib_per_vcpus")

    @_builtins.property
    @pulumi.getter(name="memoryMibs")
    def memory_mibs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult']:
        return pulumi.get(self, "memory_mibs")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCounts")
    def network_interface_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult']:
        return pulumi.get(self, "network_interface_counts")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> _builtins.bool:
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> _builtins.int:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGbs")
    def total_local_storage_gbs(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult']:
        return pulumi.get(self, "total_local_storage_gbs")

    @_builtins.property
    @pulumi.getter(name="vcpuCounts")
    def vcpu_counts(self) -> Sequence['outputs.GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult']:
        return pulumi.get(self, "vcpu_counts")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementAcceleratorTotalMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementBaselineEbsBandwidthMbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryGibPerVcpusResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementMemoryMibResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkBandwidthGbpResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementNetworkInterfaceCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementTotalLocalStorageGbResult(dict):
    def __init__(__self__, *,
                 max: _builtins.float,
                 min: _builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.float:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideInstanceRequirementVcpuCountResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetGroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationResult(dict):
    def __init__(__self__, *,
                 launch_template_id: _builtins.str,
                 launch_template_name: _builtins.str,
                 version: _builtins.str):
        pulumi.set(__self__, "launch_template_id", launch_template_id)
        pulumi.set(__self__, "launch_template_name", launch_template_name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> _builtins.str:
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> _builtins.str:
        return pulumi.get(self, "launch_template_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGroupTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 propagate_at_launch: _builtins.bool,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> _builtins.bool:
        return pulumi.get(self, "propagate_at_launch")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGroupTrafficSourceResult(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGroupWarmPoolResult(dict):
    def __init__(__self__, *,
                 instance_reuse_policies: Sequence['outputs.GetGroupWarmPoolInstanceReusePolicyResult'],
                 max_group_prepared_capacity: _builtins.int,
                 min_size: _builtins.int,
                 pool_state: _builtins.str):
        pulumi.set(__self__, "instance_reuse_policies", instance_reuse_policies)
        pulumi.set(__self__, "max_group_prepared_capacity", max_group_prepared_capacity)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "pool_state", pool_state)

    @_builtins.property
    @pulumi.getter(name="instanceReusePolicies")
    def instance_reuse_policies(self) -> Sequence['outputs.GetGroupWarmPoolInstanceReusePolicyResult']:
        return pulumi.get(self, "instance_reuse_policies")

    @_builtins.property
    @pulumi.getter(name="maxGroupPreparedCapacity")
    def max_group_prepared_capacity(self) -> _builtins.int:
        return pulumi.get(self, "max_group_prepared_capacity")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> _builtins.int:
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="poolState")
    def pool_state(self) -> _builtins.str:
        return pulumi.get(self, "pool_state")


@pulumi.output_type
class GetGroupWarmPoolInstanceReusePolicyResult(dict):
    def __init__(__self__, *,
                 reuse_on_scale_in: _builtins.bool):
        pulumi.set(__self__, "reuse_on_scale_in", reuse_on_scale_in)

    @_builtins.property
    @pulumi.getter(name="reuseOnScaleIn")
    def reuse_on_scale_in(self) -> _builtins.bool:
        return pulumi.get(self, "reuse_on_scale_in")


